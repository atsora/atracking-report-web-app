require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

// config - common for all apps
//require('config_pulsecomponent_default.js'); - not possible HERE !

// translation - common 
//require('translation_pulsecomponent_default.js'); - not possible HERE !

// For fast tests
require('x-clock/x-clock');

// check and login
require('x-checkcurrenttime/x-checkcurrenttime');
require('x-checkpath/x-checkpath');
require('x-checkversion/x-checkversion');
require('x-checkconfigupdate/x-checkconfigupdate');
require('x-checklogin/x-checklogin');
require('x-logindisplay/x-logindisplay');
require('x-checkserveraccess/x-checkserveraccess');

require('x-markdowntext/x-markdowntext');
require('x-message/x-message');
require('x-modificationmanager/x-modificationmanager'); // Is it useful ? -- RR 2023

require('x-machineselection/x-machineselection');
/* machineselection already includes :
require('x-grouparray/x-grouparray');
require('x-machinedisplay/x-machinedisplay');
require('x-freetext/x-freetext');
*/

// Displays
require('x-reportdatetime/x-reportdatetime');
require('x-datetimepicker/x-datetimepicker');
require('x-datepicker/x-datepicker');

},{"x-checkconfigupdate/x-checkconfigupdate":71,"x-checkcurrenttime/x-checkcurrenttime":72,"x-checklogin/x-checklogin":73,"x-checkpath/x-checkpath":74,"x-checkserveraccess/x-checkserveraccess":75,"x-checkversion/x-checkversion":76,"x-clock/x-clock":77,"x-datepicker/x-datepicker":78,"x-datetimepicker/x-datetimepicker":79,"x-logindisplay/x-logindisplay":82,"x-machineselection/x-machineselection":84,"x-markdowntext/x-markdowntext":85,"x-message/x-message":86,"x-modificationmanager/x-modificationmanager":87,"x-reportdatetime/x-reportdatetime":88}],2:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

'use strict';

/**
 * @module pulseComponent
 * @requires module:pulseConfig
 * @requires module:pulseService
 * @requires module:eventBus
 */
var pulseConfig = require('pulseConfig');
var pulseLogin = require('pulseLogin');
var pulseService = require('pulseService');
var pulseUtility = require('pulseUtility');
var state = require('state');
var eventBus = require('eventBus');

/**
 * Base class for any web component 
 */
class WebComponent { // extends HTMLElement if customElements.define is used directly
  /**
   * Constructor
   *
   * @param  {Element} element - DOM element 
   */
  constructor(element) {
    this.methods = {};
    this._element = element;
  }

  /**
   * Associated DOM element
   *
   * @return {Element} element
   */
  get element () {
    return this._element;
  }

  /**
   * Callback that is called  when the custom element is connected to the DOM document
   */
  connectedCallback () {
  }

  /**
   * Callback that is called when the custom element is disconnected from the DOM document
   * return true if DOM should be destroyed and will never come again
   */
  disconnectedCallback () {
    return true;
  }

  /**
   * attribute changed callback for x-tag or custom element
   *
   * @param {string} attr - Name of the attribute
   * @param {string} oldVal - Old attribute value
   * @param {string} newVal - New attribute value
   */
  attributeChangedCallback (attr, oldVal, newVal) {
  }
}

/**
 * This class represents a super-class of all Pulse components.
 * 
 * @extends module:pulseComponent~WebComponent
 */
class PulseComponent extends WebComponent {
  /**
   * Constructor
   *
   * @param  {...any} args 
   */
  constructor(...args) {
    const self = super(...args);
    self._connected = false;
    self._connectedOnce = false;
    return self;
  }

  /**
   * Is the associated custom element connected to the DOM document ?
   *
   * @return {boolean} connected
   */
  get connected () {
    return this._connected;
  }

  /**
   * Has the associated custom element been connected once to the DOM document ?
   *
   * @return {boolean} connectedOnce
   */
  get connectedOnce () {
    return this._connectedOnce;
  }

  /**
   * Callback that is called  when the custom element is connected to the DOM document
   */
  connectedCallback () {
    super.connectedCallback();
    this._connected = true;
    this._connectedOnce = true;
  }

  /**
   * Callback that is called when the custom element is disconnected from the DOM document
   * return true if DOM should be destroyed and will never come again
   */
  disconnectedCallback () {
    this._connected = false;
    return super.disconnectedCallback();
  }

  /**
   * attribute changed callback for x-tag or custom element
   *
   * @param {string} attr - Name of the attribute
   * @param {string} oldVal - Old attribute value
   * @param {string} newVal - New attribute value
   */
  attributeChangedCallback (attr, oldVal, newVal) {
    if (this._connectedOnce) {
      this.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
    }
  }

  /**
   * attribute changed callback for x-tag or custom element only when the component has already been connected once
   *
   * @param {string} attr - Name of the attribute
   * @param {string} oldVal - Old attribute value
   * @param {string} newVal - New attribute value
   */
  attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
  }

  /**
   * Get some information on the web component instance, including its id and class if they are defined
   *
   * @return {string} Infos on component instance
   */
  getInfo () {
    let str = 'undefined';
    if (this.element != null) {
      str = this.element.tagName;
      if (this.element.hasAttribute('id')) {
        str += `[id:${this.element.getAttribute('id')}]`;
      }
      if (this.element.hasAttribute('class')) {
        str += `[class:${this.element.getAttribute('class')}]`;
      }
    }
    else {
      str += ' this.element;'
      console.warn('component.getInfo: this.element is null. Should never happen. Excepted when removed');
    }
    return str;
  }

  /**
   * Add a css class
   *
   * @param {string} cssClass - Name of the CSS class
   */
  addClass (cssClass) {
    $(this.element).addClass(cssClass);
  }

  /**
   * Remove a css class
   *
   * @param {string} cssClass - Name of the CSS class
   */
  removeClass (cssClass) {
    $(this.element).removeClass(cssClass);
  }

  /**
   * Get translation
   *
   * @param {string} key - config Key (ex: 'tag.threshold')
   * @param {*} defaultValue - default value in case nothing in found in attribute or pulseConfig
   * @returns {*} Configuration or attribute value
   */
  getTranslation (key, defaultValue) {
    // TODO : Catch exception + log + return default
    let translation = PULSE_COMPONENT_TRANSLATION;
    if (!pulseUtility.isNotDefined(translation)) {
      let nameTag = '';
      if (!pulseUtility.isNotDefined(this.element)) {
        nameTag = this.element.tagName.toLowerCase();
        if (0 == nameTag.indexOf('x-')) {
          nameTag = nameTag.substring(2);
        }
      }
      if ((pulseUtility.isNotDefined(key)) || (key === '')) {
        translation = translation[nameTag];
      }
      else {
        let listOfKeys = key.split('.');
        //toFind = translation[nameTag][keyS];
        translation = translation[nameTag];
        if ((!pulseUtility.isNotDefined(translation)) && (translation !== '')) {
          for (let i = 0; i < listOfKeys.length; i++) {
            translation = translation[listOfKeys[i]];
            if ((pulseUtility.isNotDefined(translation)) || (translation === '')) {
              //debugger;
              break;
            }
          }
        }
        if (pulseUtility.isNotDefined(translation)) {
          // toFind = translation[keyS];
          translation = PULSE_COMPONENT_TRANSLATION;
          for (let i = 0; i < listOfKeys.length; i++) {
            translation = translation[listOfKeys[i]];
            if ((pulseUtility.isNotDefined(translation))
              || (translation === '')) {
              //debugger;
              break;
            }
          }
        }
      }
    }

    if (pulseUtility.isNotDefined(translation)) {
      // TODO alert if debug mode
      //debugger;
      return defaultValue;
    }
    else {
      return translation;
    }
  }

  /**
   * Get config or attribute (if any attribute overload config)
   *
   * @param {string} key - config Key (ex: 'tag.threshold')
   * @param {*} defaultValue - default value in case nothing in found in attribute or pulseConfig
   * @returns {*} Configuration or attribute value
   */
  getConfigOrAttribute (key, defaultValue) {
    let listOfKeys = key.split('.'); // Ex: 'ANY_tagName.realKey'

    if (listOfKeys.length < 1) {
      return defaultValue;
    }

    let lastKey = listOfKeys[listOfKeys.length - 1];

    if (!pulseUtility.isNotDefined(this.element)) { // To avoid erreur when deleted
      // 1- ATTRIBUTE : Get LAST key or ONLY 
      if (this.element.hasAttribute(lastKey)) {
        return this.element.getAttribute(lastKey);
      }

      // 2- CONFIG
      let elementShortName = this.element.tagName.toLowerCase();
      elementShortName = elementShortName.slice(2);
      // 1- Search for xtag.refreshingXXX.XXXrate (for example)
      let retVal = pulseConfig.getString(elementShortName + '.' + key, 'undefDefautValue');
      if ('undefDefautValue' != retVal)
        return retVal;

      if (listOfKeys.length >= 2 && listOfKeys[0] != elementShortName) {
        //let lastKey = listOfKeys[listOfKeys.length - 1];
        // 2- Search for xtag.XXXrate (for example)
        retVal = pulseConfig.getString(elementShortName + '.' + lastKey, 'undefDefautValue');
        if ('undefDefautValue' != retVal)
          return retVal;
      }
    }
    // 3-Search for refreshingXXX.XXXrate (for example)
    return pulseConfig.getString(key, defaultValue);
  }

  /**
   * Get config or attribute (if any attribute overload config)
   *
   * @param {string} key - config Key (ex: 'tag.threshold')
   * @param {*} defaultValue - default value in case nothing in found in attribute or pulseConfig
   * @returns {*} Configuration or attribute value
   */
  getConfigOrAttributeFreeType (key, defaultValue) {
    let listOfKeys = key.split('.'); // Ex: 'ANY_tagName.realKey'

    if (listOfKeys.length < 1) {
      return defaultValue;
    }

    let elementShortName = this.element.tagName.toLowerCase();
    elementShortName = elementShortName.slice(2);
    // 1- Search for xtag.refreshingXXX.XXXrate (for example)
    let retVal = pulseConfig.get(elementShortName + '.' + key);
    if (undefined != retVal)
      return retVal;

    if (listOfKeys.length >= 2 && listOfKeys[0] != elementShortName) {
      let lastKey = listOfKeys[listOfKeys.length - 1];
      // 2- Search for xtag.XXXrate (for example)
      retVal = pulseConfig.get(elementShortName + '.' + lastKey);
      if (undefined != retVal)
        return retVal;
    }

    // 3-Search for refreshingXXX.XXXrate (for example)
    return pulseConfig.get(key, defaultValue);
  }
}


/**
 * Pulse component that implements the state machine pattern
 *
 * @extends module:pulseComponent~PulseComponent
 */
class PulseStateComponent extends PulseComponent {
  /**
   * Constructor
   *
   * @param  {...any} args 
   */
  constructor(...args) {
    const self = super(...args);
    // By default the component will be removed from DOM only once AND die :
    self._fullDeleteWhenDisconnect = true;
    self._stateContext = null;
    self._stateKey = null;
    self._getInitializedState = function (context, key) {
      return null;
    }
    self._pendingPostAction = function () { }
    return self;
  }

  /**
   * Clear extra classes linked to states
   *
   */
  clearDynamicStateContent () {
    let classes = this.element.className;

    if (classes != undefined && classes != '') {
      let class_names = classes.split(' ');
      for (let i = 0; i < class_names.length; i++) {
        let tmp_class = class_names[i];
        if (0 == tmp_class.indexOf('pulse-component-')) {
          // -loading -not-applicable -warning -error 
          $(this.element).removeClass(tmp_class);
        }
        if (0 == tmp_class.indexOf('pulsecomponent-')) {
          // pulsecomponent-context-Initialized -ParamValidation -Loaded ... 
          // pulsecomponent-key-Loading -Validating -Error ...
          $(this.element).removeClass(tmp_class);
        }
      }
    }
  }

  /**
   * To be overridden if necessary
   * 
   * @returns {boolean} is the component visible ?
   */
  get isVisible () {
    if ($(this.element).hasClass('pulse-nodisplay')) { // 'x-check...'
      return true;
    }
    if (!this._connected) {
      return false;
    }

    if ($(this.element).is(':visible')) {
      return true;
    }

    // If x-tag is in foreignObject in svg => define as visible !
    if ($(this.element).hasClass('pulse-added-in-svg')) {
      return true;
    }

    // The following code is a little bit tricky because on Chrome:
    // - $(this.element).is(':visible') only works on block elements, else false is always returned
    // - the x-tag element is always inline
    let display = this.element.currentStyle
      ? this.element.currentStyle.display // IE
      : window.getComputedStyle(this.element, null).display;
    switch (display) {
      case 'block':
        return false;
      default:
        break;
    }
    // - Because the x-tag element is always inline on Chrome,
    //   visit all the children and try to find among them a block element
    let blockElementFound = false;
    for (let child of this.element.children) {
      let childDisplay = child.currentStyle
        ? child.currentStyle.display // IE
        : window.getComputedStyle(child, null).display;
      switch (childDisplay) {
        case 'block':
          blockElementFound = true;
          if ($(child).is(':visible')) {
            return true;
          }
          else {
            break;
          }
        default:
          break;
      }
    }
    if (blockElementFound) {
      console.log('isVisible: fallback, all the block element children are not visible, return false');
      return false;
    }
    else {
      console.log('isVisible: fallback, no block element in children, return true');
      return true;
    }
  }

  /**
   * Callback that is called  when the custom element is connected to the DOM document
   */
  connectedCallback () {
    super.connectedCallback();
  }

  /**
   * Callback that is called when the custom element is disconnected from the DOM document
   * return true if DOM should be destroyed and will never come again
   */
  disconnectedCallback () {
    return super.disconnectedCallback();
  }

  /**
   * Method to use when the component can be remove / re- append to DOM
   * (for example in setupmachine)
   */
  disableDeleteWhenDisconnect () {
    this._fullDeleteWhenDisconnect = false;
  }

  /**
   * Method to use when disableDeleteWhenDisconnect have been called
   * to restore delete (for example in setuplist for children)
   */
  restoreDeleteWhenDisconnect () {
    this._fullDeleteWhenDisconnect = true;
  }

  /**
   * @returns {!string} current state context
   */
  get stateContext () {
    if (null == this._stateContext) {
      debugger; // eslint-disable-line no-debugger
      throw 'No defined state context';
    }
    return this._stateContext;
  }

  /**
   * @returns {!string} Current state key
   */
  get stateKey () {
    if (null == this._stateKey) {
      debugger; // eslint-disable-line no-debugger
      throw 'No defined state key';
    }
    return this._stateKey;
  }

  /** 
   * Define the states
   * 
   * @param {!string} context - Context
   * @param {!string} key - Key
   * @returns {!State} Created states
   *
   * @function defineState
   */

  /**
   * Define the start context
   *
   * @returns {!string} Start context
   *
   * @function startContext
   */

  /**
   * Define for each context the start key
   * 
   * @param {!string} context - Context
   * @returns {string} Start key
   * 
   * @function getStartKey
   */

  /**
   * Define which context should be considered once a context is completed
   * 
   * @param {!string} context - Context
   * @returns {string} Next context
   * 
   * @function getNextContext
   */

  /**
   * Action callback
   * 
   * @callback actionCallback
   */

  /**
  * Method to execute when you enter a context
  * 
  * @param {!string} context - Context
  * @returns {actionCallback}
  */
  enterContext (context) {
    return (function () { });
  }

  /**
   * Method to execute when you exit a context
   * 
   * @param {!string} context - Context
   * @returns {actionCallback}
   */
  exitContext (context) {
    return (function () { });
  }

  /**
   * Has a state been already initialized to this component ?
   * 
   * @returns {boolean} 
   */
  get isStarted () {
    return (null != this._stateContext) && (null != this._stateKey);
  }

  /**
   * Get a state (initialize it if necessary)
   * 
   * @param {!string} context - context 
   * @param {!string} key - key
   * @returns {State} state
   */
  getState (context, key) {
    let initializedState = this._getInitializedState(context, key);
    if (null != initializedState) {
      return initializedState;
    }
    else { // null == initializedState
      let state = this.defineState(context, key);
      let previousGetInitializedState = this._getInitializedState;
      let newGetInitializedState = function (c, k) {
        if ((c == context) && (k == key)) {
          return state;
        }
        else {
          return previousGetInitializedState(c, k);
        }
      };
      this._getInitializedState = newGetInitializedState;
      return state;
    }
  }

  /**
   * @returns {!State} current state
   */
  get state () {
    return this.getState(this.stateContext, this.stateKey);
  }

  /** 
   * Switch to state method, where the context and the key cannot be null
   * 
   * @param {!string} c - State context
   * @param {!string} k - State key
   * @param {!actionCallback} preAction - Pre-action
   * @param {!actionCallback} postAction - Post-action
  */
  _switchToState (c, k, preAction, postAction) {
    if ((null == this._stateContext) && (null == this._stateKey)) {
      let enterContext = this.enterContext(c);
      enterContext();
      this._stateContext = c;
      this._stateKey = k;
      preAction.bind(this)();
      let newState = this.getState(c, k);
      newState.enter(null, null);
      this._pendingPostAction = postAction.bind(this);
    }
    else if ((null == this._stateContext) || (null == this._stateKey)) {
      console.error('Only one context/key defined');
      debugger; // eslint-disable-line no-debugger
      throw 'Only one context/key defined';
    }
    else if ((this.stateContext == c) && (this.stateKey == k)) {
      this._pendingPostAction.bind(this)();
      this._pendingPostAction = function () { }
      preAction.bind(this)();
      let state = this.getState(c, k);
      state.stay();
      this._pendingPostAction = postAction.bind(this);
    }
    else {
      this.state.exit(c, k);
      let oldContext = this.stateContext;
      let oldKey = this.stateKey;
      this._pendingPostAction.bind(this)();
      this._pendingPostAction = function () { }
      if (oldContext != c) {
        let exitContext = this.exitContext(oldContext);
        exitContext();
        let enterContext = this.enterContext(c);
        enterContext();
      }
      this._stateContext = c;
      this._stateKey = k;
      preAction.bind(this)();
      let newState = this.getState(c, k);
      newState.enter(oldContext, oldKey);
      this._pendingPostAction = postAction.bind(this);
    }
  }

  /** Remain in the same context, but switch to the state with the specified key
   * 
   * @param {!string} k - New state key
   * @param {!actionCallback} preAction - Pre-action
   * @param {!actionCallback} postAction - Post-action
   */
  _switchToKey (k, preAction, postAction) {
    if (null == this._stateContext) {
      this._switchToState(this.startContext, k, preAction, postAction);
    }
    else {
      this._switchToState(this.stateContext, k, preAction, postAction);
    }
  }

  /**
   * Switch to a next state
   *
   * @param {?string} context - Context of the new state or null/undefined
   * @param {?string} key - Key of the new state or null/undefined
   * @param {?actionCallback} preActionParam - Pre-action
   * @param {?actionCallback} postActionParam - Post-action
   */
  switchToState (context, key, preActionParam, postActionParam) {
    let preAction;
    if (null == preActionParam) {
      preAction = function () { }
    }
    else {
      preAction = preActionParam;
    }
    let postAction;
    if (null == postActionParam) {
      postAction = function () { }
    }
    else {
      postAction = postActionParam;
    }
    if ((null == context) && (null == key)) {
      console.error('switchToState called with no context and no key');
      debugger; // eslint-disable-line no-debugger
      throw 'switchToState with no context/key';
    }
    else if (null == key) { // && (null != context)
      let k = this.getStartKey(context);
      this._switchToState(context, k, preAction, postAction);
    }
    else if (null == context) { // && (null != key)
      this._switchToKey(key, preAction, postAction);
    }
    else { // (null != context) && (null != key)
      this._switchToState(context, key, preAction, postAction);
    }
  }

  /**
   * Switch to the specified context
   * 
   * @param {!string} context - New context to switch to
   * @param {?actionCallback} preActionParam - Pre-action
   * @param {?actionCallback} postActionParam - Post-action
   */
  switchToContext (context, preActionParam, postActionParam) {
    this.switchToState(context, null, preActionParam, postActionParam);
  }

  /**
   * Switch to the state of the specified key while remaining in the same context
   * 
   * @param {!string} key - New state key
   * @param {?actionCallback} preActionParam - Pre-action
   * @param {?actionCallback} postActionParam - Post-action
   */
  switchToKey (key, preActionParam, postActionParam) {
    this.switchToState(null, key, preActionParam, postActionParam);
  }

  /**
   * Consider the current context is completed, switch to the next one
   * 
   * @param {?actionCallback} preActionParam - Pre-action
   * @param {?actionCallback} postActionParam - Post-action
   */
  switchToNextContext (preActionParam, postActionParam) {
    let nextContext;
    if (null == this._stateContext) {
      nextContext = this.startContext;
    }
    else {
      nextContext = this.getNextContext(this.stateContext);
    }
    this.switchToContext(nextContext, preActionParam, postActionParam);
  }
}


/**
 * Abstract pulse component with an initialization phase
 *
 * Available contexts: Initialization, Reset, Initialized
 *
 * Some state flows:
 * Default flow: Initialization:Initializing -> Initialized:Standard
 * Initialization error flow: Initialization:Initializing -> Initialization:Error
 * Reset flow: Initialized:Standard -> Reset:Initializing -> Initialized:Standard
 *
 * State implementations:
 * - Initialization:Initializing - {@link module:state~InitialState}
 * - Reset:Initializing - {@link module:state~ResetState}
 * - Initialized:Standard - {@link module:state~StaticState}
 * - *:Error - {@link module:state~ErrorState}
 * 
 * @extends module:pulseComponent~PulseStateComponent
 * 
* @graph Initialized_ContextFlow
@g 
@g      Initialized component: context flow
@g 
@g         +----------------+     +-------------+
@g     ==> | Initialization | ==> | Initialized |
@g         +----------------+     +-------------+
@g                                  ^
@g                                  H
@g                                  H
@g         +----------------+       H
@g     ..> |     Reset      | ======#
@g         +----------------+
* @graph Initialization_StateFlow
@g 
@g  Initialization context: state flow
@g 
@g           +--------------+
@g       ==> | Initializing | ==>
@g           +--------------+
@g             |
@g             |
@g             v
@g           +--------------+
@g           |    Error     |
@g           +--------------+
 */
class PulseInitializedComponent extends PulseStateComponent {
  /**
   * Constructor
   * 
   * @param  {...any} args 
   */
  constructor(...args) {
    const self = super(...args);

    self._errorMessage = '';
    return self;
  }

  /**
   * @override
   */
  get startContext () {
    return 'Initialization';
  }

  /**
   * @override
   * 
   * @param {!string} context - Context
   * @return {!string} key
   */
  getStartKey (context) {
    switch (context) {
      case 'Initialization':
      case 'Reset':
        return 'Initializing';
      case 'Initialized':
        return 'Standard';
    }
  }

  /**
   * @override
   */
  getNextContext (context) {
    switch (context) {
      case 'Initialization':
      case 'Reset':
        return 'Initialized';
      case 'Initialized':
        console.log(`No next context for ${context}`);
        debugger; // eslint-disable-line no-debugger
        throw 'No next context';
    }
  }

  defineState (context, key) {
    switch (context) {
      case 'BeforeDestructionState':
        return new state.BeforeDestructionState(context, key, this);
      case 'Initialized':
        return new state.StaticState(context, key, this);
      default: {
        switch (key) {
          case 'Initializing':
            switch (context) {
              case 'Initialization':
                return new state.InitialState(context, key, this);
              case 'Reset':
                return new state.ResetState(context, key, this);
              default:
                console.error(`State not defined for context=${context} and key=${key}`);
                debugger; // eslint-disable-line no-debugger
                throw 'State not defined';
            }
          case 'Error':
            return new state.ErrorState(context, key, this);
          default:
            console.error(`State not defined for context=${context} and key=${key}`);
            debugger; // eslint-disable-line no-debugger
            throw 'State not defined';
        }
      }
    }
  }

  /**
   * Method to override by the inherited class
   *
   * @override
   */
  initialize () { // To override
    if (new.target === PulseSingleRequestComponent) throw TypeError('initialize of abstract class PulseInitializedComponent');
  }

  /**
   * Clear anything that was done during intialization, so that initialize can be called once again.
   * Remove all the dispatchers and listeners.
   * Please note that no state switch is done here
   */
  clearInitialization () {
    // Remove all the listeners 
    eventBus.EventBus.removeEventListenerByScope(this);
  }

  /**
   * Check if the component is initialized, meaning its state is defined and not 'initial' or 'init_error' - means initialize () has been called.
   *
   * @return {boolean} The component is initialized
   */
  isInitialized () {
    return this.isStarted && (this.stateContext != 'Initialization') && (this.stateContext != 'Reset');
  }

  /**
   * @override
   */
  connectedCallback () {
    super.connectedCallback();
    if (!this.isStarted) {
      this.start();
    }
  }

  /**
   * Callback that is called when the custom element is disconnected from the DOM document
   * return true if DOM should be destroyed and will never come again
   */
  disconnectedCallback () {
    if (this.isStarted) {
      let disableDeleteElements = $(this.element).hasClass('disableDeleteWhenDisconnect');
      //if (disableDeleteElements.length == 0) {
      if (!disableDeleteElements) {
        if (this._fullDeleteWhenDisconnect) {
          // BUG ON Chrome
          // could be if (!navigator.userAgent.includes('Chrome')) { // Bug on Chrome - remove
          if (this.isInitialized()) {
            this.clearInitialization(); // To reset listeners

            super.disconnectedCallback();

            this.switchToState('BeforeDestructionState', 'BeforeDestructionState');

            this._element = null; // remove reference to class to help garbage collector
            return true;
          }
        }
      }
    }
    super.disconnectedCallback();
    return false; // can come back in DOM (re-order list...)
  }

  /**
   * Add the class 'pulse-component-error' to the component.
   * Used by the error state
   */
  enterErrorState () {
    this.addClass('pulse-component-error');
  }

  /**
   * Remove the display message and remove the 'pulse-component-error' class from the component.
   * Used by the error state
   */
  exitErrorState () {
    this.removeClass('pulse-component-error');
  }

  /**
   * Reset the component itself. Set the next state at the end of the method
   */
  reset () {
    this.switchToNextContext();
  }

  /**
   * Error message that is set by the setError method
   * 
   * @return {string} error message
   */
  get errorMessage () {
    return this._errorMessage;
  }

  /**
  * Set an error on the component without displaying it
  * 
  * @param {string} message - Error message to set
  */
  setError (message) {
    this._errorMessage = message;
  }

  /**
   * Show the error that has been previously stored
   */
  showError () {
    this.displayError(this.errorMessage);
  }

  /**
   * Display the error message
   * To be overridden by the sub-class
   *
   * @param {string} message - Error message to display
   */
  displayError (message) { // To override
    if (new.target === PulseInitializedComponent) throw TypeError('displayError of abstract class PulseInitializedComponent');
  }

  /**
   * Stop displaying the error message
   * To be overridden by the sub-class
   */
  removeError () { // To override
    if (new.target === PulseInitializedComponent) throw TypeError('removeError of abstract class PulseInitializedComponent');
  }

  /**
   * (Re-)start loading the component.
   * Switch to state 'reset' or 'initial' or 'reload'
   * whether the component has already been initialized or not
   */
  start () {
    if (this.isInitialized()) { // including 'Stop' Context
      this.switchToContext('Reset');
    }
    else {
      this.switchToContext(this.startContext);
    }
  }

  /**
   * Default event callback in case a config is updated: (re-)start the component
   * 
   * @param {*} event 
   */
  onConfigChange (event) {
    // Default = do nothing
    // Example :
    //if ( event.target.config == 'myConfig')
    //  this.start();
  }
}

/**
 * Abstract pulse component for components that potentially run Ajax requests
 *
 * @extends module:pulseComponent~PulseInitializedComponent
 * 
* @graph Request_StateFlow
@g 
@g        Request (Load, Normal, Reload, NotAvailable...) context: state flow
@g 
@g 
@g           +---------------------------------------------------+
@g           |                                                   |
@g           |                                                   |
@g           |    +----------------------------------------------+-----------------+
@g           |    |                                              |                 |
@g           |    |                                              |                 |
@g           |    |    +-----------------------+                 |                 |
@g           v    v    |                       v                 |                 |
@g         +-------------+     +-------+     +-----------+     +----------------+  |
@g     ==> |             | --> |       | --> |           | --> | TransientError |  |
@g         |             |     |       |     |           |     +----------------+  |
@g         |             |     |       |     |           |       ^                 |
@g         |   Loading   | <-- | Delay | <-- | Temporary |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       | -+  |           | ------+-----------------+
@g         +-------------+     +-------+  |  +-----------+       |
@g           H                            |                      |
@g           H                            +----------------------+
@g           v
 */
class PulseRequestComponent extends PulseInitializedComponent {
  /**
   * Constructor
   * 
   * @param  {...any} args 
   */
  constructor(...args) {
    const self = super(...args);
    self.states = undefined; // Abstract
    self._timeout = undefined;
    self._defaultDelayRate = 10000; // 10s
    self._defaultTransientErrorDelay = 3 * 60 * 1000; // 3 minutes
    return self;
  }

  /**
   * Timeout for the ajax requests. Default is undefined.
   *
   * @return {number} Timeout in ms
   */
  get timeout () {
    return this._timeout;
  }
  /**
   * Set the timeout of the ajax requests
   *
   * @param {number} timeout - Timeout in ms
   */
  set timeout (timeout) {
    this._timeout = timeout;
  }

  /**
   * Delay in ms to wait in case of a delay error.
   * Default is 10s.
   *
   * @return {number} Delay rate in ms
   */
  get delayRate () {
    return this._defaultDelayRate;
  }

  /**
   * Delay in ms before switching to a transient error.
   * Default is 5 minutes.
   *
   * @return {number} Delay in ms
   */
  get transientErrorDelay () {
    return Number(this.getConfigOrAttribute('stopRefreshingRate.freezeMinutes', this._defaultTransientErrorDelay / 60 / 1000)) * 60 * 1000;
  }

  /**
   * Url to use by the Ajax request.
   * To be overridden
   *
   * @return {string} Url to use in the ajax request
   */
  get url () { // To override
    if (new.target === PulseRequestComponent) throw TypeError('url of abstract class PulseRequestComponent');
  }

  /**
   * Add the CSS class 'pulse-component-warning' in case the component enters a TransientErrorState
   */
  enterTransientErrorState () {
    this.addClass('pulse-component-warning');
  }

  /**
   * Remove the CSS class 'pulse-component-warning' and the error message in case the component exits a TransientErrorState
   */
  exitTransientErrorState () {
    this.removeClass('pulse-component-warning');
  }

  /**
   * Do nothing special in case of reload.
   * To be overridden if necessary.
   */
  beforeReload () {
    // Default: do nothing special
  }

  /**
   * Method that is called when the next context is loaded.
   * To be overridden
   *
   * @param {Object} data - Ajax request response
   */
  refresh (data) { // To override
    if (new.target === PulseRequestComponent) throw TypeError('refresh of abstract class PulseRequestComponent');
  }

  /**
   * Method that is called in case of Ajax request success.
   * 
   * @param {Object} data 
   */
  manageSuccess (data) {
    this.switchToNextContext(() => this.refresh(data));
  }

  /**
   * Method that is called in case the Ajax request returns an error.
   * The Status property of the returned answer is processed by the manageErrorStatus methods.
   *
   * @param {Object} data - Ajax error response
   */
  manageError (data) {
    if (typeof data === 'undefined') {
      console.error('manageError: data is undefined');
      this.switchToKey('Error', () => this.displayError('undefined error data'), () => this.removeError());
      return;
    }
    let status = data.Status;
    if (typeof status === 'undefined') {
      console.error('manageError: data.Status is undefined');
      this.switchToKey('Error', () => this.displayError('undefined error data status'), () => this.removeError());
      return;
    }

    // New error status
    if (this.manageErrorStatus(status, data.ErrorMessage)) {
      return;
    }

    console.error(`manageError: data status ${status} is unknown, message=${data.ErrorMessage}`);
    let errorMessage;
    if (typeof (status) != 'undefined') {
      errorMessage = `unknown status ${status}, ${data.ErrorMessage}`;
    }
    else {
      errorMessage = data.ErrorMessage;
    }
    this.switchToKey('Error', () => this.displayError(errorMessage, () => this.removeError()));
  }

  /**
   * Retry immediately the Ajax request.
   * 
   * @param {string} message - Error message
   */
  retryImmediately (message) {
    if (this.stateKey == 'TransientError') {
      this.switchToKey('TransientError', () => this.displayError(message), () => this.removeError());
    }
    else {
      this.switchToKey('Temporary', () => this.setError(message), () => this.setError(''));
    }
  }

  /**
   * Retry with a delay the Ajax request.
   * 
   * @param {string} message - Error message
   */
  retryWithDelay (message) {
    if (this.stateKey == 'TransientError') {
      this.switchToKey('TransientError', () => this.displayError(message), () => this.removeError());
    }
    else {
      this.switchToKey('Delay', () => this.setError(message), () => this.setError(''));
    }
  }

  /**
   * Default method to manage the new error status
   * To be overridden in case of a non-standard behavior of the component.
   *
   * @param {string} status - Error response status
   * @param {string} message - Error response message
   * @return {boolean} The status was processed
   */
  manageErrorStatus (status, message) {
    switch (status) {
      case 'AuthorizationError': {
        if (pulseLogin.tokenNeedRefresh()) {
          pulseLogin.refreshToken();

          // Delayed display : (should never happen excepted maybe in checklogin)
          this.retryWithDelay('Authentication Error. Please retry');
        }
        else {
          pulseConfig.setGlobal('loginError', 'Authentication Error. Please retry');
          // Clean all cookies linked to login
          pulseLogin.cleanLoginRole();

          // Goto page login with an error message to be displayed
          if (!pulseConfig.isLoginPage()) { // If not in page login
            pulseConfig.goToPageLogin();
            return true;
          }
        }
      } break;
      case 'MissingConfiguration': {
        // Send Message to display on top
        let messageInfo = {
          'id': 'WARNING_MISSING_INFO',
          'level': 'warning',
          'clickToClose': true,
          'time': 45, // seconds to display message
          'message': pulseConfig.pulseTranslate('missingconfiguration', 'Missing configuration')
            + ': ' + message + ' \r\n'
            + pulseConfig.pulseTranslate('contactsupport',
              'Please contact the support team'),
          'internalLAT': 'status:' + status + '. Full message: ' + message
            + '(' + this.element.tagName + ')'
        };
        eventBus.EventBus.dispatchToAll('showMessageSignal', messageInfo);

        this.switchToKey('Error', () => this.displayError(message), () => this.removeError());
        return true;
      }
      case 'WrongRequestParameter':
      case 'UnexpectedError': {
        // Send Message to display on top
        let messageInfo = {
          'id': 'ERROR_CALL_SUPPORT',
          'level': 'error', // or 'warning', ?
          'clickToClose': true,
          'time': 45, // seconds to display message
          'message': 'ERROR : ' + pulseConfig.pulseTranslate('contactsupport',
            'please contact the support team'),
          'internalLAT': 'status:' + status + '. Full message : ' + message
            + '(' + this.element.tagName + ')'
        };
        eventBus.EventBus.dispatchToAll('showMessageSignal', messageInfo);

        this.switchToKey('Error', () => this.displayError(message), () => this.removeError());
        return true;
      }
      case 'NotApplicable':
        this.manageNotApplicable();
        return true;
      case 'ProcessingDelay':
        this.retryWithDelay(message);
        return true;
      case 'TransientProcessError':
      case 'Stale':
        this.retryImmediately(message);
        return true;
      case 'DatabaseConnectionError': { // = database unavailable
        // Stop all refresh :
        let target = {
          //url: url,
          source: this.element.tagName,
          when: new Date()
        };
        eventBus.EventBus.dispatchToAll('databaseProbablyDisconnected', target);

        if (!this.element.tagName.toUpperCase().includes('X-CHECK') // if ((this.element.tagName != 'X-CHECKSERVERACCESS')
          && (this.element.tagName.toUpperCase() != 'X-MESSAGE')) {
          this.switchToKey('Error', () => this.displayError(message), () => this.removeError());
        }
        else {
          // DO NOT DO this !!! Next context is not available if context = stop
          //this.switchToNextContext(() => this.refresh());
          this.switchToContext('Normal'); // Do not use "start" because it could not exit loading state
        }
        return true;
      }
      case 'PulseMaintenance': { // = maintenance is started (server may be off soon)
        // Stop all refresh :
        let target = {
          //url: url,
          source: this.element.tagName,
          when: new Date()
        };

        eventBus.EventBus.dispatchToAll('pulseMaintenance', target);

        if (!this.element.tagName.toUpperCase().includes('X-CHECK') // if ((this.element.tagName != 'X-CHECKSERVERACCESS')
          && (this.element.tagName.toUpperCase() != 'X-MESSAGE')) {
          // With empty message
          this.switchToKey('Error', () => this.displayError(''), () => this.removeError());
        }
        else { // == Ignore ???
          // DO NOT DO this !!! Next context is not available if context = stop
          //this.switchToNextContext(() => this.refresh());
          //if (this.element.tagName == 'X-CHECKSERVERACCESS') {
            this.switchToContext('Normal'); // Else can stay in Loading context and never check again
          //}
        }
        return true;
      }
      default:
        return false;
    }
  }

  /**
   * Manage the case when the component data does not apply
   * Switch by default to the state 'NotApplicable' and add the class pulse-component-not-applicable
   */
  manageNotApplicable () {
    this.addClass('pulse-component-not-applicable');
    this.switchToContext('NotApplicable');
  }

  /**
   * Manage an Old NO_DATA error status.
   * By default, run the retryWithDelay method, but override this method in case one the following services is used:
   * GetListOfShiftSlotService, GetMachineStatusByIWP, GetShiftAround/After/Before, GetFieldLegendsForMachine,
   * GetMachinePerformanceDay(V2), GetModeColor, GetMachineStatus, GetReasonSlots(V3)
   * 
   * @param {string} message - Error message
   */
  manageOldNoData (message) {
    // Default: delay
    this.retryWithDelay(message);
    // But:
    // - GetListOfShiftSlotService: not applicable
    // - GetMachineStatusByIWP: not applicable
    // - GetShiftAround/After/Before: not applicable
    // - GetFieldLegendsForMachine: not applicable
    // - GetMachinePerformanceDay(V2): delay or permanent
    // - GetModeColor: delay or permanent
    // - GetMachineStatus: delay or permament
    // - GetReasonSlots(V3): delay or permanent
  }

  /**
   * Manage an Ajax failure.
   * Either retry with delay in case of a time out or switch to an 'error' state else
   *
   * @param {boolean} isTimeout - Time out
   * @param {number} xhrStatus - XMLHttpRequest.status of the Ajax request
   */
  manageFailure (isTimeout, xhrStatus) {
    if (isTimeout) {
      this.retryWithDelay('time out');
    }
    else {
      let message = pulseService.getAjaxErrorMessage(xhrStatus);
      if ((xhrStatus == '0') || (xhrStatus == '500') || (xhrStatus == '504')) {
        this.retryWithDelay(message);
      }
      else {
        this.switchToKey('Error', () => this.displayError(message), () => this.removeError());
      }
    }
  }

  /**
   * Method that is called when the 'loading' state is entered.
   * By default add the css class 'pulse-component-loading'.
   */
  startLoading () {
    this.addClass('pulse-component-loading');
  }

  /**
   * Method that is called when the 'loading' state is exited.
   * By default remove the css class 'pulse-component-loading'.
   */
  endLoading () {
    this.removeClass('pulse-component-loading');
  }

  /**
   * Default event callback in case server is off : STOP the component
   * 
   * @param {*} event 
   */
  onServerOffStopRefresh (event) {
    if (!this.element.tagName.toUpperCase().includes('X-CHECK')) {// if (this.element.tagName != 'X-CHECKSERVERACCESS') {
      //if (this.stateContext != 'Loaded') {
      this.displayError(''); // Empty to hide all texts
      this._serverIsOff = true;
      this.switchToContext('Stop');
      //}
    }
  }

  /**
   * Default event callback in case server is available: (re-)start the component
   * 
   * @param {*} event 
   */
  onServerAvailableChange (event) {
    // NOT NEEDED because of _serverIsOff 
    //if (!this.element.tagName.toUpperCase().includes('X-CHECK')) { // if (this.element.tagName != 'X-CHECKSERVERACCESS') {
    if (true == this._serverIsOff) {
      this._serverIsOff = false;
      this.start();
    }
    //}
  }

}

/**
 * Abstract class for Pulse components that run a single Ajax request during the loading phase
 *
 * Available contexts: Initialization, Reset, Load, Loaded, Reload, Stop, NotApplicable
 *
 * Available states: Initializing, Error, Loading, Standard, Temporary, Delay, TransientError, Error
 *
 * Some state flows:
 * Default flow: Initialization:Initializing -> Load:Loading -> Loaded:Standard
 * Initialization error flow: Initialization:Initializing -> Initialization:Error
 * Ajax transient error flow: Initialization:Initializing -> Load:Loading -> Load:Temporary -> ... -> Load:TransientError
 *
 * State implementations:
 * - Initialization:Initializing - {@link module:state~InitialState}
 * - Reset:Initializing - {@link module:state~ResetState}
 * - Loaded:Standard - {@link module:state~StaticState}
 * - Stop:Standard - {@link module:state~StopState}
 * - Load:Loading - {@link module:state~LoadState}
 * - Reload:Loading - {@link module:state~ReloadState}
 * - *:Temporary - {@link module:state~TemporaryState}
 * - *:Delay - {@link module:state~DelayState}
 * - *:TransientError - {@link module:state~TransientErrorState}
 * - NotApplicable:Standard - {@link module:state~NotApplicableState}
 * - *:Error - {@link module:state~ErrorState}
 * 
 * @extends module:pulseComponent~PulseRequestComponent
 * 
* @graph SingleRequest_ContextFlow
@g 
@g             Single request component: context flow
@g 
@g                                +---------------+
@g                                | NotApplicable |
@g                                +---------------+
@g                                  ^
@g                                  |
@g                                  |
@g         +----------------+     +---------------+     +--------+
@g     ==> | Initialization | ==> |     Load      | ==> | Loaded |
@g         +----------------+     +---------------+     +--------+
@g                                  ^                     ^
@g                                  H                     H
@g                                  H                     H
@g         +----------------+       H                     H
@g     ..> |     Reset      | ======#                     H
@g         +----------------+                             H
@g         +----------------+     +---------------+       H
@g     ..> |      Stop      | --> |    Reload     | ======#
@g         +----------------+     +---------------+
@g                                  ^
@g                                  :
@g                                  :
* @graph Initialization_StateFlow
@g 
@g  Initialization context: state flow
@g 
@g           +--------------+
@g       ==> | Initializing | ==>
@g           +--------------+
@g             |
@g             |
@g             v
@g           +--------------+
@g           |    Error     |
@g           +--------------+
* @graph Request_StateFlow
@g 
@g        Request (Load, Normal, Reload, NotAvailable...) context: state flow
@g 
@g 
@g           +---------------------------------------------------+
@g           |                                                   |
@g           |                                                   |
@g           |    +----------------------------------------------+-----------------+
@g           |    |                                              |                 |
@g           |    |                                              |                 |
@g           |    |    +-----------------------+                 |                 |
@g           v    v    |                       v                 |                 |
@g         +-------------+     +-------+     +-----------+     +----------------+  |
@g     ==> |             | --> |       | --> |           | --> | TransientError |  |
@g         |             |     |       |     |           |     +----------------+  |
@g         |             |     |       |     |           |       ^                 |
@g         |   Loading   | <-- | Delay | <-- | Temporary |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       | -+  |           | ------+-----------------+
@g         +-------------+     +-------+  |  +-----------+       |
@g           H                            |                      |
@g           H                            +----------------------+
@g           v
 */
class PulseSingleRequestComponent extends PulseRequestComponent {
  /**
   * Constructor
   *
   * @param  {...any} args 
   */
  constructor(...args) {
    const self = super(...args);
    return self;
  }

  /**
   * @override
   * 
   * @param {!string} context - Context
   * @return {!string} key
   */
  getStartKey (context) {
    switch (context) {
      case 'Initialization':
      case 'Reset':
        return 'Initializing';
      case 'Load':
      case 'Reload':
        return 'Loading';
      case 'Loaded':
      case 'Stop':
      case 'NotApplicable':
        return 'Standard';
    }
  }

  /**
   * @override
   */
  getNextContext (context) {
    switch (context) {
      case 'Initialization':
      case 'Reset':
        return 'Load';
      case 'Load':
      case 'Reload':
        return 'Loaded';
      case 'Loaded':
      case 'Stop':
      case 'NotApplicable':
        console.error(`No next context for ${context}`);
        debugger; // eslint-disable-line no-debugger
        throw 'No next context';
    }
  }

  defineState (context, key) {
    switch (context) {
      case 'BeforeDestructionState':
        return new state.BeforeDestructionState(context, key, this);
      case 'Loaded':
        return new state.StaticState(context, key, this);
      case 'Stop':
        return new state.StopState(context, key, this);
      case 'NotApplicable':
        return new state.NotApplicableState(context, key, this);
      default: {
        switch (key) {
          case 'Initializing':
            switch (context) {
              case 'Initialization':
                return new state.InitialState(context, key, this);
              case 'Reset':
                return new state.ResetState(context, key, this);
              default:
                console.error(`State not defined for context=${context} and key=${key}`);
                debugger; // eslint-disable-line no-debugger
                throw 'State not defined';
            }
          case 'Error':
            return new state.ErrorState(context, key, this);
          case 'Loading':
            switch (context) {
              case 'Load':
                return new state.LoadState(context, key, this);
              case 'Reload':
                return new state.ReloadState(context, key, this);
              default:
                console.error(`State not defined for context=${context} and key=${key}`);
                debugger; // eslint-disable-line no-debugger
                throw 'State not defined';
            }
          case 'Temporary':
            return new state.TemporaryState(c => 1000., context, key, this);
          case 'Delay':
            return new state.DelayState(c => c.delayRate, context, key, this);
          case 'TransientError':
            return new state.TransientErrorState(c => c.delayRate, context, key, this);
          default:
            console.error(`State not defined for context=${context} and key=${key}`);
            debugger; // eslint-disable-line no-debugger
            throw 'State not defined: ' + key;
        }
      }
    }
  }

  enterContext (context) {
    switch (context) {
      case 'Load':
      case 'Reload':
        this.startLoading();
        break;
      default:
        break;
    }
    return super.enterContext(context);
  }

  exitContext (context) {
    switch (context) {
      case 'Load':
      case 'Reload':
        this.endLoading();
        break;
      default:
        break;
    }
    return super.exitContext(context);
  }
}

/**
 * Abstract class for Pulse components that run an ajax request regularly, each time it needs to be refreshed
 *
 * Available contexts: Initialization, Reset, Load, Normal, Reload, Stop, NotAvailable, NotApplicable
 *
 * Available states: Initializing, Error, Loading, Standard, Temporary, Delay, TransientError, Error
 *
 * Some state flows:
 * Default flow: Initialization:Initializing -> Load:Loading -> Normal:Loading -> Normal:Loading -> ...
 * Initialization error flow: Initialization:Initializing -> Initialization:Error
 * Ajax transient error flow: Normal:Loading -> Normal:Temporary -> Normal:Temporary -> ... -> Normal:TransientError
 * Ajax delay error flow: Normal:Loading -> Normal:Delay -> Normal:Delay -> ... -> Normal:TransientError
 * Not available flow: Normal:Loading -> NotAvailable:Loading -> ... -> Normal:Loading
 *
 * State implementations:
 * - Initialization:Initializing - {@link module:state~InitialState}
 * - Reset:Initializing - {@link module:state~ResetState}
 * - Stop:Standard - {@link module:state~StopState}
 * - Normal:Loading - {@link module:state~NormalRequestState}
 * - NotAvailable:Loading - {@link module:state~NotAvailableState}
 * - Load:Loading - {@link module:state~LoadState}
 * - Reload:Loading - {@link module:state~ReloadState}
 * - *:Temporary - {@link module:state~TemporaryState}
 * - *:Delay - {@link module:state~DelayState}
 * - *:TransientError - {@link module:state~TransientErrorState}
 * - NotApplicable:Standard - {@link module:state~NotApplicableState}
 * - *:Error - {@link module:state~ErrorState}
 * 
 * @extends module:pulseComponent~PulseRequestComponent
 * 
* @graph Refreshing_ContextFlow
@g 
@g                                   Refreshing component: context flow
@g 
@g 
@g                                       +--------------------------------------------------+
@g                                       |                                                  |
@g                                       |                                                  |
@g                                       |              #====#         +----------+         |
@g                                       |              v    H         v          |         v
@g              +----------------+     +--------+     +--------+     +--------------+     +---------------+
@g          ==> | Initialization | ==> |        | ==> |        | --> |              | --> | NotApplicable |
@g              +----------------+     |        |     |        |     |              |     +---------------+
@g                                     |        |     |        |     |              |
@g                                     |  Load  |     | Normal | <== | NotAvailable |
@g                                     |        |     |        |     |              |
@g              +----------------+     |        |     |        |     |              |
@g          ..> |     Reset      | ==> |        |     |        |     |              |
@g              +----------------+     +--------+     +--------+     +--------------+
@g                                       |              ^              ^
@g   +-----------------------------------+              H              |
@g   |                                                  H              |
@g   |          +----------------+     +--------+       H              |
@g   |      ..> |      Stop      | --> | Reload | ======#              |
@g   |          +----------------+     +--------+                      |
@g   |                                   ^                             |
@g   |                                   :                             |
@g   |                                   :                             |
@g   |                                                                 |
@g   |                                                                 |
@g   |                                                                 |
@g   |                                                                 |
@g   +-----------------------------------------------------------------+
* @graph Initialization_StateFlow
@g 
@g  Initialization context: state flow
@g 
@g           +--------------+
@g       ==> | Initializing | ==>
@g           +--------------+
@g             |
@g             |
@g             v
@g           +--------------+
@g           |    Error     |
@g           +--------------+
* @graph Request_StateFlow
@g 
@g        Request (Load, Normal, Reload, NotAvailable...) context: state flow
@g 
@g 
@g           +---------------------------------------------------+
@g           |                                                   |
@g           |                                                   |
@g           |    +----------------------------------------------+-----------------+
@g           |    |                                              |                 |
@g           |    |                                              |                 |
@g           |    |    +-----------------------+                 |                 |
@g           v    v    |                       v                 |                 |
@g         +-------------+     +-------+     +-----------+     +----------------+  |
@g     ==> |             | --> |       | --> |           | --> | TransientError |  |
@g         |             |     |       |     |           |     +----------------+  |
@g         |             |     |       |     |           |       ^                 |
@g         |   Loading   | <-- | Delay | <-- | Temporary |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       | -+  |           | ------+-----------------+
@g         +-------------+     +-------+  |  +-----------+       |
@g           H                            |                      |
@g           H                            +----------------------+
@g           v
 */
class PulseRefreshingComponent extends PulseRequestComponent {
  /**
   * Constructor
   * 
   * @param  {...any} args 
   */
  constructor(...args) {
    const self = super(...args);
    self._refreshRate = undefined;
    return self;
  }

  /**
   * @override
   * 
   * @param {!string} context - Context
   * @return {!string} key
   */
  getStartKey (context) {
    switch (context) {
      case 'Initialization':
      case 'Reset':
        return 'Initializing';
      case 'Load':
      case 'Reload':
      case 'Normal':
      case 'NotAvailable':
        return 'Loading';
      case 'Stop':
      case 'NotApplicable':
        return 'Standard';
    }
  }

  /**
   * @override
   */
  getNextContext (context) {
    switch (context) {
      case 'Initialization':
      case 'Reset':
        return 'Load';
      case 'Load':
      case 'Reload':
      case 'Normal':
      case 'NotAvailable':
        return 'Normal';
      case 'Stop':
      case 'NotApplicable':
        console.error(`No next context for ${context}`);
        debugger; // eslint-disable-line no-debugger
        throw 'No next context';
    }
  }

  defineState (context, key) {
    switch (context) {
      case 'BeforeDestructionState':
        return new state.BeforeDestructionState(context, key, this);
      case 'Stop':
        return new state.StopState(context, key, this);
      case 'NotApplicable':
        return new state.NotApplicableState(context, key, this);
      default: {
        switch (key) {
          case 'Initializing':
            switch (context) {
              case 'Initialization':
                return new state.InitialState(context, key, this);
              case 'Reset':
                return new state.ResetState(context, key, this);
              default:
                console.error(`State not defined for context=${context} and key=${key}`);
                debugger; // eslint-disable-line no-debugger
                throw 'State not defined';
            }
          case 'Error':
            return new state.ErrorState(context, key, this);
          case 'Loading':
            switch (context) {
              case 'Load':
                return new state.LoadState(context, key, this);
              case 'Reload':
                return new state.ReloadState(context, key, this);
              case 'Normal':
                return new state.NormalRequestState(c => c.refreshRate, context, key, this);
              case 'NotAvailable':
                return new state.NotAvailableState(c => c.refreshRate, context, key, this);
              default:
                console.error(`State not defined for context=${context} and key=${key}`);
                debugger; // eslint-disable-line no-debugger
                throw 'State not defined';
            }
          case 'Temporary':
            return new state.TemporaryState(c => 1000., context, key, this);
          case 'Delay':
            return new state.DelayState(c => c.delayRate, context, key, this);
          case 'TransientError':
            return new state.TransientErrorState(c => c.delayRate, context, key, this);
          default:
            console.error(`State not defined for context=${context} and key=${key}`);
            debugger; // eslint-disable-line no-debugger
            throw 'State not defined';
        }
      }
    }
  }

  enterContext (context) {
    switch (context) {
      case 'Load':
      case 'Reload':
        this.startLoading();
        break;
      default:
        break;
    }
    return super.enterContext(context);
  }

  exitContext (context) {
    switch (context) {
      case 'Load':
      case 'Reload':
        this.endLoading();
        break;
      default:
        break;
    }
    return super.exitContext(context);
  }

  /**
   * Refresh rate in ms
   *
   * @return {number} Refresh rate in ms
   */
  get refreshRate () {
    return this._refreshRate;
  }
  /**
   * Set the refresh rate
   *
   * @param {number} refreshRate - Refresh rate in ms
   */
  set refreshRate (refreshRate) {
    this._refreshRate = refreshRate;
  }

}

/**
 * Abstract pulse component with an initialization phase and a parameter validation phase
 *
 * Available contexts: Initialization, ParamValidation, Reset, Initialized
 * Available states: Initializing, Validating, Error, Standard
 *
 * Some state flows:
 * Default flow: Initialization:Initializing -> ParamValidation:Validating -> Initialized:Standard
 * Initialization error flow: Initialization:Initializing -> Initialization:Error
 * Reset flow: Initialized:Standard -> Reset:Initializing -> ParamValidation:Validating -> Initialized:Standard
 *
 * State implementations:
 * - Initialization:Initializing - {@link module:state~InitialState}
 * - Reset:Initializing - {@link module:state~ResetState}
 * - ParamValidation:Validating - {@link module:state~ParamValidationTimeoutState}
 * - Initialized:Standard - {@link module:state~StaticState}
 * - *:Error - {@link module:state~ErrorState}
 * 
 * @extends module:pulseComponent~PulseInitializedComponent
 * 
* @graph ParamInitialized_ContextFlow
@g 
@g                  Initialized component: context flow
@g 
@g         +----------------+     +-----------------+     +-------------+
@g     ==> | Initialization | ==> | ParamValidation | ==> | Initialized |
@g         +----------------+     +-----------------+     +-------------+
@g                                  ^
@g                                  H
@g                                  H
@g         +----------------+       H
@g     ..> |     Reset      | ======#
@g         +----------------+
* @graph Initialization_StateFlow
@g 
@g  Initialization context: state flow
@g 
@g           +--------------+
@g       ==> | Initializing | ==>
@g           +--------------+
@g             |
@g             |
@g             v
@g           +--------------+
@g           |    Error     |
@g           +--------------+
* @graph ParamValidation_StateFlow
@g 
@g  ParamValidation context: state flow
@g 
@g             +------------+
@g         ==> | Validating | ==>
@g             +------------+
@g               |
@g               |
@g               v
@g             +------------+
@g             |   Error    |
@g             +------------+
 */
class PulseParamInitializedComponent extends PulseInitializedComponent {
  /**
   * Constructor
   *
   * @param  {...any} args 
   */
  constructor(...args) {
    const self = super(...args);
    return self;
  }

  /**
   * @override
   * 
   * @param {!string} context - Context
   * @return {!string} key
   */
  getStartKey (context) {
    switch (context) {
      case 'ParamValidation':
        return 'Validating';
      default:
        return super.getStartKey(context);
    }
  }

  /**
   * @override
   */
  getNextContext (context) {
    switch (context) {
      case 'Initialization':
      case 'Reset':
        return 'ParamValidation';
      case 'ParamValidation':
        return 'Initialized';
      default:
        return super.getNextContext(context);
    }
  }

  defineState (context, key) {
    switch (context) {
      case 'BeforeDestructionState':
        return new state.BeforeDestructionState(context, key, this);
      case 'ParamValidation':
        switch (key) {
          case 'Validating':
            return new state.ParamValidationTimeoutState(c => 30000., context, key, this); // timeout = 30s
          case 'Error':
            return new state.ErrorState(context, key, this);
          default:
            console.error(`State not defined for context=${context} and key=${key}`);
            debugger; // eslint-disable-line no-debugger
            throw 'State not defined';
        }
      default:
        return super.defineState(context, key);
    }
  }

  enterContext (context) {
    if ((context == 'ParamValidation') && this.startLoading) {
      this.startLoading();
    }
    return super.enterContext(context);
  }

  exitContext (context) {
    if ((context == 'ParamValidation') && this.endLoading) {
      this.endLoading();
    }
    return super.exitContext(context);
  }
}

/**
 * Abstract class for Pulse components with a (event) parameter validation phase
 * that run a single Ajax request during the loading phase
 *
 * Available contexts: Initialization, ParamValidation, Reset, Load, Loaded, Reload, Stop, NotApplicable
 *
 * Available states: Initializing, Error, Validating, Loading, Standard, Temporary, Delay, TransientError, Error
 *
 * Some state flows:
 * Default flow: Initialization:Initializing -> ParamValidation:Validating -> Load:Loading -> Loaded:Standard
 * Initialization error flow: Initialization:Initializing -> Initialization:Error
 * Ajax transient error flow: Initialization:Initializing -> Load:Loading -> Load:Temporary -> ... -> Load:TransientError
 *
 * State implementations:
 * - Initialization:Initializing - {@link module:state~InitialState}
 * - Reset:Initializing - {@link module:state~ResetState}
 * - ParamValidation:Validating - {@link module:state~ParamValidationTimeoutState}
 * - Loaded:Standard - {@link module:state~StaticState}
 * - Stop:Standard - {@link module:state~StopState}
 * - Load:Loading - {@link module:state~LoadState}
 * - Reload:Loading - {@link module:state~ReloadState}
 * - *:Temporary - {@link module:state~TemporaryState}
 * - *:Delay - {@link module:state~DelayState}
 * - *:TransientError - {@link module:state~TransientErrorState}
 * - NotApplicable:Standard - {@link module:state~NotApplicableState}
 * - *:Error - {@link module:state~ErrorState}
 * 
 * @extends module:pulseComponent~PulseSingleRequestComponent
 * 
* @graph ParamSingleRequest_ContextFlow
@g 
@g        Single request and param autoPath single request component: context flow
@g 
@g         +----------------+     +-----------------+     +---------------+     +--------+
@g     ==> | Initialization | ==> | ParamValidation | ==> |     Load      | ==> | Loaded |
@g         +----------------+     +-----------------+     +---------------+     +--------+
@g                                  ^                       |                     ^
@g                                  H                       |                     H
@g                                  H                       v                     H
@g         +----------------+       H                     +---------------+       H
@g     ..> |     Reset      | ======#                     | NotApplicable |       H
@g         +----------------+                             +---------------+       H
@g         +----------------+     +-----------------+                             H
@g     ..> |      Stop      | --> |     Reload      | ============================#
@g         +----------------+     +-----------------+
@g                                  ^
@g                                  :
@g                                  :
* @graph Initialization_StateFlow
@g 
@g  Initialization context: state flow
@g 
@g           +--------------+
@g       ==> | Initializing | ==>
@g           +--------------+
@g             |
@g             |
@g             v
@g           +--------------+
@g           |    Error     |
@g           +--------------+
* @graph ParamValidation_StateFlow
@g 
@g  ParamValidation context: state flow
@g 
@g             +------------+
@g         ==> | Validating | ==>
@g             +------------+
@g               |
@g               |
@g               v
@g             +------------+
@g             |   Error    |
@g             +------------+
* @graph Request_StateFlow
@g 
@g        Request (Load, Normal, Reload, NotAvailable...) context: state flow
@g 
@g 
@g           +---------------------------------------------------+
@g           |                                                   |
@g           |                                                   |
@g           |    +----------------------------------------------+-----------------+
@g           |    |                                              |                 |
@g           |    |                                              |                 |
@g           |    |    +-----------------------+                 |                 |
@g           v    v    |                       v                 |                 |
@g         +-------------+     +-------+     +-----------+     +----------------+  |
@g     ==> |             | --> |       | --> |           | --> | TransientError |  |
@g         |             |     |       |     |           |     +----------------+  |
@g         |             |     |       |     |           |       ^                 |
@g         |   Loading   | <-- | Delay | <-- | Temporary |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       | -+  |           | ------+-----------------+
@g         +-------------+     +-------+  |  +-----------+       |
@g           H                            |                      |
@g           H                            +----------------------+
@g           v
 */
class PulseParamSingleRequestComponent extends PulseSingleRequestComponent {
  /**
   * Constructor
   *
   * @param  {...any} args 
   */
  constructor(...args) {
    const self = super(...args);
    return self;
  }

  /**
   * @override
   * 
   * @param {!string} context - Context
   * @return {!string} key
   */
  getStartKey (context) {
    switch (context) {
      case 'ParamValidation':
        return 'Validating';
      default:
        return super.getStartKey(context);
    }
  }

  /**
   * @override
   */
  getNextContext (context) {
    switch (context) {
      case 'Initialization':
      case 'Reset':
        return 'ParamValidation';
      case 'ParamValidation':
        return 'Load';
      default:
        return super.getNextContext(context);
    }
  }

  /**
   * @override
   * 
   * @param {!string} context - Context
   * @param {!string} key - Key
   * @returns {!State} Created states
   */
  defineState (context, key) {
    switch (context) {
      case 'ParamValidation':
        switch (key) {
          case 'Validating':
            return new state.ParamValidationTimeoutState(c => 30000., context, key, this); // timeout = 30s
          case 'Error':
            return new state.ErrorState(context, key, this);
          default:
            console.error(`State not defined for context=${context} and key=${key}`);
            debugger; // eslint-disable-line no-debugger
            throw 'State not defined';
        }
      default:
        return super.defineState(context, key);
    }
  }

  enterContext (context) {
    if (context == 'ParamValidation') {
      this.startLoading();
    }
    return super.enterContext(context);
  }

  exitContext (context) {
    if ((context == 'ParamValidation') && this.endLoading) {
      this.endLoading();
    }
    return super.exitContext(context);
  }
}

/**
 * Abstract class for Pulse components with a (event) parameter validation phase + Path validation is automatic
 * that run a single Ajax request during the loading phase
 *
 * Available contexts: Initialization, ParamValidation, Reset, Load, Loaded, Reload, Stop, NotApplicable
 *
 * Available states: Initializing, Error, Validating, Loading, Standard, Temporary, Delay, TransientError, Error
 *
 * Some state flows:
 * Default flow: Initialization:Initializing -> ParamValidation:Validating -> Load:Loading -> Loaded:Standard
 * Initialization error flow: Initialization:Initializing -> Initialization:Error
 * Ajax transient error flow: Initialization:Initializing -> Load:Loading -> Load:Temporary -> ... -> Load:TransientError
 *
 * State implementations:
 * - Initialization:Initializing - {@link module:state~InitialState}
 * - Reset:Initializing - {@link module:state~ResetState}
 * - ParamValidation:Validating - {@link module:state~ParamValidationTimeoutState}
 * - Loaded:Standard - {@link module:state~StaticState}
 * - Stop:Standard - {@link module:state~StopState}
 * - Load:Loading - {@link module:state~LoadState}
 * - Reload:Loading - {@link module:state~ReloadState}
 * - *:Temporary - {@link module:state~TemporaryState}
 * - *:Delay - {@link module:state~DelayState}
 * - *:TransientError - {@link module:state~TransientErrorState}
 * - NotApplicable:Standard - {@link module:state~NotApplicableState}
 * - *:Error - {@link module:state~ErrorState}
 * 
 * @extends module:pulseComponent~PulseParamSingleRequestComponent
 * 
* @graph ParamSingleRequest_ContextFlow
@g 
@g        Single request and param autoPath single request component: context flow
@g 
@g         +----------------+     +-----------------+     +---------------+     +--------+
@g     ==> | Initialization | ==> | ParamValidation | ==> |     Load      | ==> | Loaded |
@g         +----------------+     +-----------------+     +---------------+     +--------+
@g                                  ^                       |                     ^
@g                                  H                       |                     H
@g                                  H                       v                     H
@g         +----------------+       H                     +---------------+       H
@g     ..> |     Reset      | ======#                     | NotApplicable |       H
@g         +----------------+                             +---------------+       H
@g         +----------------+     +-----------------+                             H
@g     ..> |      Stop      | --> |     Reload      | ============================#
@g         +----------------+     +-----------------+
@g                                  ^
@g                                  :
@g                                  :
* @graph Initialization_StateFlow
@g 
@g  Initialization context: state flow
@g 
@g           +--------------+
@g       ==> | Initializing | ==>
@g           +--------------+
@g             |
@g             |
@g             v
@g           +--------------+
@g           |    Error     |
@g           +--------------+
* @graph ParamValidation_StateFlow
@g 
@g  ParamValidation context: state flow
@g 
@g             +------------+
@g         ==> | Validating | ==>
@g             +------------+
@g               |
@g               |
@g               v
@g             +------------+
@g             |   Error    |
@g             +------------+
* @graph Request_StateFlow
@g 
@g        Request (Load, Normal, Reload, NotAvailable...) context: state flow
@g 
@g 
@g           +---------------------------------------------------+
@g           |                                                   |
@g           |                                                   |
@g           |    +----------------------------------------------+-----------------+
@g           |    |                                              |                 |
@g           |    |                                              |                 |
@g           |    |    +-----------------------+                 |                 |
@g           v    v    |                       v                 |                 |
@g         +-------------+     +-------+     +-----------+     +----------------+  |
@g     ==> |             | --> |       | --> |           | --> | TransientError |  |
@g         |             |     |       |     |           |     +----------------+  |
@g         |             |     |       |     |           |       ^                 |
@g         |   Loading   | <-- | Delay | <-- | Temporary |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       | -+  |           | ------+-----------------+
@g         +-------------+     +-------+  |  +-----------+       |
@g           H                            |                      |
@g           H                            +----------------------+
@g           v
 */
class PulseParamAutoPathSingleRequestComponent extends PulseParamSingleRequestComponent {
  /**
   * Constructor
   * 
   * @param  {...any} args 
   */
  constructor(...args) {
    const self = super(...args);
    self._path = '';
    return self;
  }

  /**
   * Associated path
   * 
   * @returns {!string} path
   */
  get path () {
    return this._path;
  }

  /**
   * Update the path from the configuration or the attribute
   * 
   * @returns {boolean} the path is defined (not empty and not null)
   */
  updatePathFromConfigOrAttribute () {
    this._path = this.getConfigOrAttribute('path', '');
    return (typeof (this.path) != 'undefined') && ('' != this.path);
  }

  /**
   * @override
   * 
   * @param {!string} context - Context
   * @param {!string} key - Key
   * @returns {!State} Created states
   */
  defineState (context, key) {
    switch (context) {
      case 'ParamValidation':
        switch (key) {
          case 'Validating':
            return new state.ParamAndPathValidationTimeoutState(c => 30000., context, key, this); // timeout = 30s
          default:
            return super.defineState(context, key);
        }
      case 'Initialization':
        switch (key) {
          case 'Initializing':
            return new state.AutoPathInitialState(context, key, this);
          default:
            return super.defineState(context, key);
        }
      default:
        return super.defineState(context, key);
    }
  }

  /**
   * Short Url (with the path) to use in the Ajax request.
   * To be overridden
   *
   * @return {string} Url to use in the ajax request
   */
  getShortUrl () { // To override
    if (new.target === PulseParamAutoPathSingleRequestComponent)
      throw TypeError('url of abstract class PulseParamAutoPathSingleRequestComponent');
  }

  /**
   * Url to use by the Ajax request.
   *
   * @return {!string} Url to use in the ajax request
   */
  get url () {
    console.assert((typeof (this.path) != 'undefined') && ('' != this.path));
    if ((typeof (this.path) == 'undefined') || ('' == this.path)) { // This should not happen: the path should be not empty after the param validation context
      console.error('empty path');
      debugger; // eslint-disable-line no-debugger
      throw 'empty path';
    }
    return this.path + this.getShortUrl();
  }

  /**
   * Default event callback in case a path is updated: (re-)start the component
   * (to go through the param validation state again)
   * 
   * @param {*} event 
   */
  onPathChange (event) {
    this.start();
  }

}

/**
 * Abstract class for Pulse components with a (event) parameter validation phase
 * that run an ajax request regularly, each time it needs to be refreshed
 *
 * Available contexts: Initialization, ParamValidation, Reset, Load, Normal, Reload, Stop, NotAvailable, 
 *
 * Available states: Initializing, Error, Validating, Loading, Standard, Temporary, Delay, TransientError, Error
 *
 * Some state flows:
 * Default flow: Initialization:Initializing -> ParamValidation:Validating -> Load:Loading -> Normal:Loading -> Normal:Loading -> ...
 * Initialization error flow: Initialization:Initializing -> Initialization:Error
 * Ajax transient error flow: Normal:Loading -> Normal:Temporary -> Normal:Temporary -> ... -> Normal:TransientError
 * Ajax delay error flow: Normal:Loading -> Normal:Delay -> Normal:Delay -> ... -> Normal:TransientError
 * Not available flow: Normal:Loading -> NotAvailable:Loading -> ... -> Normal:Loading
 *
 * State implementations:
 * - Initialization:Initializing - {@link module:state~InitialState}
 * - Reset:Initializing - {@link module:state~ResetState}
 * - ParamValidation:Validating - {@link module:state~ParamValidationTimeoutState}
 * - Stop:Standard - {@link module:state~StopState}
 * - Normal:Loading - {@link module:state~NormalRequestState}
 * - NotAvailable:Loading - {@link module:state~NotAvailableState}
 * - Load:Loading - {@link module:state~LoadState}
 * - Reload:Loading - {@link module:state~ReloadState}
 * - *:Temporary - {@link module:state~TemporaryState}
 * - *:Delay - {@link module:state~DelayState}
 * - *:TransientError - {@link module:state~TransientErrorState}
 * - NotApplicable:Standard - {@link module:state~NotApplicableState}
 * - *:Error - {@link module:state~ErrorState}
 *
 * @extends module:pulseComponent~PulseRefreshingComponent
 * 
* @graph ParamRefreshing_ContextFlow
@g 
@g                             Refreshing and param autoPath refreshing component: context flow
@g 
@g 
@g                                                          +------------------------------------------------+
@g                                                          |                                                |
@g                                                          |                                                |
@g                                                          |            #====#         +----------+         |
@g                                                          |            v    H         v          |         v
@g         +----------------+     +-----------------+     +------+     +--------+     +--------------+     +---------------+
@g     ==> | Initialization | ==> | ParamValidation | ==> | Load | ==> |        | --> |              | --> | NotApplicable |
@g         +----------------+     +-----------------+     +------+     |        |     |              |     +---------------+
@g                                  ^                       |          |        |     |              |
@g                                  H                       |          | Normal | <== | NotAvailable |
@g                                  H                       |          |        |     |              |
@g         +----------------+       H                       |          |        |     |              |
@g     ..> |     Reset      | ======#                       |          |        |     |              |
@g         +----------------+                               |          +--------+     +--------------+
@g                                                          |            ^              ^
@g                                                          |            H              |
@g                                                          |            H              |
@g         +----------------+     +-----------------+       |            H              |
@g     ..> |      Stop      | --> |     Reload      | ======+============#              |
@g         +----------------+     +-----------------+       |                           |
@g                                  ^                       |                           |
@g                                  :                       +---------------------------+
@g                                  :
* @graph Initialization_StateFlow
@g 
@g  Initialization context: state flow
@g 
@g           +--------------+
@g       ==> | Initializing | ==>
@g           +--------------+
@g             |
@g             |
@g             v
@g           +--------------+
@g           |    Error     |
@g           +--------------+
* @graph ParamValidation_StateFlow
@g 
@g  ParamValidation context: state flow
@g 
@g             +------------+
@g         ==> | Validating | ==>
@g             +------------+
@g               |
@g               |
@g               v
@g             +------------+
@g             |   Error    |
@g             +------------+
* @graph Request_StateFlow
@g 
@g        Request (Load, Normal, Reload, NotAvailable...) context: state flow
@g 
@g 
@g           +---------------------------------------------------+
@g           |                                                   |
@g           |                                                   |
@g           |    +----------------------------------------------+-----------------+
@g           |    |                                              |                 |
@g           |    |                                              |                 |
@g           |    |    +-----------------------+                 |                 |
@g           v    v    |                       v                 |                 |
@g         +-------------+     +-------+     +-----------+     +----------------+  |
@g     ==> |             | --> |       | --> |           | --> | TransientError |  |
@g         |             |     |       |     |           |     +----------------+  |
@g         |             |     |       |     |           |       ^                 |
@g         |   Loading   | <-- | Delay | <-- | Temporary |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       | -+  |           | ------+-----------------+
@g         +-------------+     +-------+  |  +-----------+       |
@g           H                            |                      |
@g           H                            +----------------------+
@g           v
 */
class PulseParamRefreshingComponent extends PulseRefreshingComponent {
  /**
   * Constructor
   *
   * @param  {...any} args 
   */
  constructor(...args) {
    const self = super(...args);
    return self;
  }

  /**
   * @override
   * 
   * @param {!string} context - Context
   * @return {!string} key
   */
  getStartKey (context) {
    switch (context) {
      case 'ParamValidation':
        return 'Validating';
      default:
        return super.getStartKey(context);
    }
  }

  /**
   * @override
   */
  getNextContext (context) {
    switch (context) {
      case 'Initialization':
      case 'Reset':
        return 'ParamValidation';
      case 'ParamValidation':
        return 'Load';
      default:
        return super.getNextContext(context);
    }
  }

  /**
   * @override
   * 
   * @param {!string} context - Context
   * @param {!string} key - Key
   * @returns {!State} Created states
   */
  defineState (context, key) {
    switch (context) {
      case 'ParamValidation':
        switch (key) {
          case 'Validating':
            return new state.ParamValidationTimeoutState(c => 30000., context, key, this); // timeout = 30s
          case 'Error':
            return new state.ErrorState(context, key, this);
          default:
            console.error(`State not defined for context=${context} and key=${key}`);
            debugger; // eslint-disable-line no-debugger
            throw 'State not defined';
        }
      default:
        return super.defineState(context, key);
    }
  }

  /**
   * @override
   */
  enterContext (context) {
    if (context == 'ParamValidation') {
      this.startLoading();
    }
    return super.enterContext(context);
  }

  exitContext (context) {
    if ((context == 'ParamValidation') && this.endLoading) {
      this.endLoading();
    }
    return super.exitContext(context);
  }
}


/**
 * Abstract class for Pulse components with a (event) parameter validation phase + Path validation is automatic
 * that run an ajax request regularly, each time it needs to be refreshed
 *
 * Available contexts: Initialization, ParamValidation, Reset, Load, Normal, Reload, Stop, NotAvailable, NotApplicable
 *
 * Available states: Initializing, Error, Validating, Loading, Standard, Temporary, Delay, TransientError, Error
 *
 * Some state flows:
 * Default flow: Initialization:Initializing -> ParamValidation:Validating -> Load:Loading -> Normal:Loading -> Normal:Loading -> ...
 * Initialization error flow: Initialization:Initializing -> Initialization:Error
 * Ajax transient error flow: Normal:Loading -> Normal:Temporary -> Normal:Temporary -> ... -> Normal:TransientError
 * Ajax delay error flow: Normal:Loading -> Normal:Delay -> Normal:Delay -> ... -> Normal:TransientError
 * Not available flow: Normal:Loading -> NotAvailable:Loading -> ... -> Normal:Loading
 *
 * State implementations:
 * - Initialization:Initializing - {@link module:state~InitialState}
 * - Reset:Initializing - {@link module:state~ResetState}
 * - ParamValidation:Validating - {@link module:state~ParamValidationTimeoutState}
 * - Stop:Standard - {@link module:state~StopState}
 * - Normal:Loading - {@link module:state~NormalRequestState}
 * - NotAvailable:Loading - {@link module:state~NotAvailableState}
 * - Load:Loading - {@link module:state~LoadState}
 * - Reload:Loading - {@link module:state~ReloadState}
 * - *:Temporary - {@link module:state~TemporaryState}
 * - *:Delay - {@link module:state~DelayState}
 * - *:TransientError - {@link module:state~TransientErrorState}
 * - NotApplicable:Standard - {@link module:state~NotApplicableState}
 * - *:Error - {@link module:state~ErrorState}
 *
 * @extends module:pulseComponent~PulseRefreshingComponent
 * 
* @graph ParamRefreshing_ContextFlow
@g 
@g                             Refreshing and param autoPath refreshing component: context flow
@g 
@g 
@g                                                          +------------------------------------------------+
@g                                                          |                                                |
@g                                                          |                                                |
@g                                                          |            #====#         +----------+         |
@g                                                          |            v    H         v          |         v
@g         +----------------+     +-----------------+     +------+     +--------+     +--------------+     +---------------+
@g     ==> | Initialization | ==> | ParamValidation | ==> | Load | ==> |        | --> |              | --> | NotApplicable |
@g         +----------------+     +-----------------+     +------+     |        |     |              |     +---------------+
@g                                  ^                       |          |        |     |              |
@g                                  H                       |          | Normal | <== | NotAvailable |
@g                                  H                       |          |        |     |              |
@g         +----------------+       H                       |          |        |     |              |
@g     ..> |     Reset      | ======#                       |          |        |     |              |
@g         +----------------+                               |          +--------+     +--------------+
@g                                                          |            ^              ^
@g                                                          |            H              |
@g                                                          |            H              |
@g         +----------------+     +-----------------+       |            H              |
@g     ..> |      Stop      | --> |     Reload      | ======+============#              |
@g         +----------------+     +-----------------+       |                           |
@g                                  ^                       |                           |
@g                                  :                       +---------------------------+
@g                                  :
* @graph Initialization_StateFlow
@g 
@g  Initialization context: state flow
@g 
@g           +--------------+
@g       ==> | Initializing | ==>
@g           +--------------+
@g             |
@g             |
@g             v
@g           +--------------+
@g           |    Error     |
@g           +--------------+
* @graph ParamValidation_StateFlow
@g 
@g  ParamValidation context: state flow
@g 
@g             +------------+
@g         ==> | Validating | ==>
@g             +------------+
@g               |
@g               |
@g               v
@g             +------------+
@g             |   Error    |
@g             +------------+
* @graph Request_StateFlow
@g 
@g        Request (Load, Normal, Reload, NotAvailable...) context: state flow
@g 
@g 
@g           +---------------------------------------------------+
@g           |                                                   |
@g           |                                                   |
@g           |    +----------------------------------------------+-----------------+
@g           |    |                                              |                 |
@g           |    |                                              |                 |
@g           |    |    +-----------------------+                 |                 |
@g           v    v    |                       v                 |                 |
@g         +-------------+     +-------+     +-----------+     +----------------+  |
@g     ==> |             | --> |       | --> |           | --> | TransientError |  |
@g         |             |     |       |     |           |     +----------------+  |
@g         |             |     |       |     |           |       ^                 |
@g         |   Loading   | <-- | Delay | <-- | Temporary |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       |     |           |       |                 |
@g         |             |     |       | -+  |           | ------+-----------------+
@g         +-------------+     +-------+  |  +-----------+       |
@g           H                            |                      |
@g           H                            +----------------------+
@g           v
 */
class PulseParamAutoPathRefreshingComponent extends PulseParamRefreshingComponent {
  /**
   * Constructor
   * 
   * @param  {...any} args 
   */
  constructor(...args) {
    const self = super(...args);
    self._path = '';
    return self;
  }

  /**
   * Associated path
   * 
   * @returns {!string} path
   */
  get path () {
    return this._path;
  }

  /**
   * Update the path from the configuration or the attribute
   * 
   * @returns {boolean} the path is defined (not empty and not null)
   */
  updatePathFromConfigOrAttribute () {
    this._path = this.getConfigOrAttribute('path', '');
    return (typeof (this.path) != 'undefined') && ('' != this.path);
  }

  /**
   * @override
   * 
   * @param {!string} context - Context
   * @param {!string} key - Key
   * @returns {!State} Created states
   */
  defineState (context, key) {
    switch (context) {
      case 'ParamValidation':
        switch (key) {
          case 'Validating':
            return new state.ParamAndPathValidationTimeoutState(c => 30000., context, key, this); // timeout = 30s
          default:
            return super.defineState(context, key);
        }
      case 'Initialization':
        switch (key) {
          case 'Initializing':
            return new state.AutoPathInitialState(context, key, this);
          default:
            return super.defineState(context, key);
        }
      default:
        return super.defineState(context, key);
    }
  }

  /**
   * Url to use by the Ajax request.
   * To be overridden
   *
   * @return {string} Url to use in the ajax request
   */
  getShortUrl () { // To override
    if (new.target === PulseParamAutoPathRefreshingComponent)
      throw TypeError('url of abstract class PulseParamAutoPathRefreshingComponent');
  }

  /**
   * Url to use by the Ajax request.
   *
   * @return {string} Url to use in the ajax request
   */
  get url () {
    console.assert((typeof (this.path) != 'undefined') && ('' != this.path));
    if ((typeof (this.path) == 'undefined') || ('' == this.path)) { // This should not happen: the path should be not empty after the param validation context
      console.error('empty path');
      debugger; // eslint-disable-line no-debugger
      throw 'empty path';
    }
    return this.path + this.getShortUrl();
  }

  /**
   * Default event callback in case a path is updated: (re-)start the component
   * (to go through the param validation state again)
   * 
   * @param {*} event 
   */
  onPathChange (event) {
    this.start();
  }
}

exports.PulseComponent = PulseComponent;
exports.PulseInitializedComponent = PulseInitializedComponent;
exports.PulseSingleRequestComponent = PulseSingleRequestComponent;
exports.PulseRefreshingComponent = PulseRefreshingComponent;
exports.PulseParamInitializedComponent = PulseParamInitializedComponent;
exports.PulseParamSingleRequestComponent = PulseParamSingleRequestComponent;
exports.PulseParamAutoPathSingleRequestComponent = PulseParamAutoPathSingleRequestComponent;
exports.PulseParamRefreshingComponent = PulseParamRefreshingComponent;
exports.PulseParamAutoPathRefreshingComponent = PulseParamAutoPathRefreshingComponent;

/**
 * Register a custom element
 *
 * @param {string} tagName - Element tag name
 * @param {class} componentClass - Sub-class of PulseComponent to use
 * @param {?string[]} attributes - [Optional] Observed attributes
 */
exports.registerElement = function (tagName, componentClass, attributes) {
  let attrs = (typeof attributes !== 'undefined') ? attributes : [];

  class C extends HTMLElement {
    constructor(...args) {
      const self = super();
      self._webComponent = new componentClass(self);
      let componentMethods = self._webComponent.methods;
      for (let methodKey in componentMethods) {
        if (componentMethods.hasOwnProperty(methodKey)) {
          this[methodKey] = componentMethods[methodKey].bind(self._webComponent);
        }
      }
      return self;
    }

    /**
     * Associated web component
     *
     * @return {Element} associated web component
     */
    get webComponent () {
      return this._webComponent;
    }

    connectedCallback () {
      this._webComponent.connectedCallback();
    }

    disconnectedCallback () {
      if (this._webComponent != null) {
        if (this._webComponent.disconnectedCallback()) {
          // switch to context destroy
          this._webComponent = null; // remove reference to help gargabe collector
        }
      }
    }

    attributeChangedCallback (attr, oldVal, newVal) {
      if (this._webComponent != null) {
        if (typeof this._webComponent.attributeChangedCallback === 'function') {
          this._webComponent.attributeChangedCallback(attr, oldVal, newVal);
        }
      }
    }

    static get observedAttributes () {
      return attrs;
    }
  }
  //  Note: there is a polyfill for browsers that don't support customElements.define from w3c
  customElements.define(tagName, C);
}

},{"eventBus":"eventBus","pulseConfig":"pulseConfig","pulseLogin":"pulseLogin","pulseService":"pulseService","pulseUtility":"pulseUtility","state":3}],3:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module state
 * @requires module:pulseService
 */
var pulseService = require('pulseService'); // for runAjax only -> to remove ?
var pulseConfig = require('pulseConfig'); // Verify useLogin
var eventBus = require('eventBus'); // to create path listener
var pulseLogin = require('pulseLogin');

/**
 * Base class for the states that are used by a PulseStateComponent to implement the state machine pattern
 *
 * @see module:pulseComponent~PulseStateComponent
 */
class State {
  /**
   * Constructor
   * 
   * @param {string} context - State context
   * @param {string} key - State key
   * @param {PulseStateComponent} component - Associated Pulse state component
   */
  constructor(context, key, component) {
    if (new.target === State) throw TypeError('new of abstract class State');
    this._context = context;
    this._key = key;
    this._component = component;
    this._previousStateContext = undefined;
    this._previousStateKey = undefined;
  }

  /**
   * Associated context
   * 
   * @returns {string}
   */
  get context () {
    return this._context;
  }

  /**
   * Associated key 
   * 
   * @returns {string}
   */
  get key () {
    return this._key;
  }

  /**
   * Associated pulse state component
   *
   * @return {PulseStateComponent}
   */
  get component () {
    return this._component;
  }

  /**
   * Previous state context, before this state is active (after enter() is called)
   *
   * @return {string} previous state context
   */
  get previousStateContext () {
    return this._previousStateContext;
  }

  /**
 * Previous state key, before this state is active (after enter() is called)
 *
 * @return {string} previous state key
 */
  get previousStateKey () {
    return this._previousStateKey;
  }

  /**
   * Function that is called when the component enters this state
   *
   * @param {string} previousStateContext - Previous state context
   * @param {string} previousStateKey - Previous state key
   */
  enter (previousStateContext, previousStateKey) {
    this._previousStateContext = previousStateContext;
    this._previousStateKey = previousStateKey;
    this.component.addClass('pulsecomponent-context-' + this.context);
    this.component.addClass('pulsecomponent-key-' + this.key);
  }

  /**
   * Function that is called when the component exists this state
   * 
   * @param {string} nextStateContext - Next state context
   * @param {string} nextStateKey - Next state key
   */
  exit (nextStateContext, nextStateKey) {
    this.component.removeClass('pulsecomponent-context-' + this.context);
    this.component.removeClass('pulsecomponent-key-' + this.key);
  }

  /**
   * Function that is called when the component stays in this state
   */
  stay () {
  }
}

/**
 * Class for the LAST state before destruction used by all PulseStateComponent
 */
class BeforeDestructionState extends State {
  /**
   * Constructor
   * 
   * @param {string} context - State context
   * @param {string} key - State key
   * @param {PulseStateComponent} component - Associated Pulse state component
   */
  constructor(context, key, component) {
    super(context, key, component);
    this._component = null; // No reference
  }

  enter (previousStateContext, previousStateKey) {
    this._previousStateContext = previousStateContext;
    this._previousStateKey = previousStateKey;
    // Do nothing more = no call to super
  }

  /**
   * Function that is called when the component exists this state
   * 
   * @param {string} nextStateContext - Next state context
   * @param {string} nextStateKey - Next state key
   */
  exit (nextStateContext, nextStateKey) {
    // Do nothing = no call to super
  }
}

/**
 * Initial state. The next state is either the next context or the Error state
 * 
 * When this state is entered:
 * - if {@link module:pulseComponent~PulseInitializedComponent#isInitialized} returns true, {@link module:pulseComponent~PulseInitializedComponent#clearInitialization} is called first.
 * - then {@link module:pulseComponent~PulseInitializedComponent#initialize} is called.
 *
 * @extends module:state~State
 */
class InitialState extends State {
  /**
   * Switch to the next context or to the Error  state
   * 
   * @override
   */
  enter (previousStateContext, previousStateKey) {
    this.component.clearDynamicStateContent(); // To clear state classes in case of clone

    super.enter(previousStateContext, previousStateKey);
    if (this.component.isInitialized()) {
      this.component.clearInitialization();
    }

    this.component.initialize();

    // Prepare listener to check config change - After initialize
    eventBus.EventBus.addGlobalEventListener(this.component,
      'configChangeEvent',
      this.component.onConfigChange.bind(this.component));
  }
}

/**
 * Initial state for auto path components. (create listener)
 * The next state is either the next context or the Error state
 * 
 * When this state is entered:
 * - if {@link module:pulseComponent~PulseInitializedComponent#isInitialized} returns true, {@link module:pulseComponent~PulseInitializedComponent#clearInitialization} is called first.
 * - then {@link module:pulseComponent~PulseInitializedComponent#initialize} is called.
 *
 * @extends module:state~State
 */
class AutoPathInitialState extends State { // +/- idem Initial State
  /**
   * Switch to the next context or to the Error  state
   * 
   * @override
   */
  enter (previousStateContext, previousStateKey) {
    this.component.clearDynamicStateContent(); // To clear state classes in case of clone

    super.enter(previousStateContext, previousStateKey);
    if (this.component.isInitialized()) {
      this.component.clearInitialization();
    }

    this.component.initialize();

    // Listener to check server access == AFTER initialize
    eventBus.EventBus.addGlobalEventListener(this.component,
      'serverProbablyOffStopRefresh',
      this.component.onServerOffStopRefresh.bind(this.component));
    eventBus.EventBus.addGlobalEventListener(this.component,
      'serverProbablyAvailable',
      this.component.onServerAvailableChange.bind(this.component));

    // Prepare listener to check path change
    eventBus.EventBus.addGlobalEventListener(this.component,
      'pathChangeEvent',
      this.component.onPathChange.bind(this.component));

    // Prepare listener to check config change
    eventBus.EventBus.addGlobalEventListener(this.component,
      'configChangeEvent',
      this.component.onConfigChange.bind(this.component));
  }
}

/**
 * Reset state. State when the pulse component must be reset.
 * The next state is either the next context or the Error state
 * 
 * When this state is entered {@link module:pulseComponent~PulseInitializedComponent#reset} is called.
 * 
 * @extends module:state~State
 */
class ResetState extends State {
  /**
   * Switch to the next context or to the Error state
   * 
   * @override
   */
  enter (previousStateContext, previousStateKey) {
    super.enter(previousStateContext, previousStateKey);
    this.component.reset();
  }
}

/**
 * Static state.
 * It does not switch automatically to any other state
 *
 * @extends module:state~State
 */
class StaticState extends State {
}

/**
 * No action state.
 * The next state is directly the state that is given in the argument of the constructor. Nothing else special is done.
 *
 * @extends module:state~State
 */
class NoActionState extends State { // eslint-disable-line no-unused-vars
  /**
   * Constructor
   * 
   * @param {?string} nextContext - Context of the next state
   * @param {?string} nextKey - Key of the next state
   * @param {string} context - State context
   * @param {string} key - State key
   * @param {PulseStateComponent} component - Pulse state component
   */
  constructor(nextContext, nextKey, context, key, component) {
    super(context, key, component);
    this._nextContext = nextContext;
    this._nextKey = nextKey;
  }

  /**
   * Switch to the state that was given to the argument of the constructor
   *
   * @override
   */
  enter (previousStateContext, previousStateKey) {
    super.enter(previousStateContext, previousStateKey);
    if ((null == this._nextContext) && (null == this._nextKey)) {
      this.component.switchToNextContext();
    }
    else {
      this.component.switchToState(this._nextContext, this._nextKey);
    }
  }
}

/**
 * Callback that returns a number of ms to wait
 * 
 * @callback delayCallback
 * @param {PulseStateComponent} component - Pulse state component
 * @return {number} delay in ms
 */

/**
 * Wait state.
 * Switch to the next state after a specified time
 *
 * @extends module:state~State
 */
class WaitState extends State {
  /**
   * Constructor
   * 
   * @param {?string} nextContext - Context of the next state
   * @param {?string} nextKey - Key of the next state
   * @param {?actionCallback} preAction - Pre-action
   * @param {?actionCallback} postAction - Post-action
   * @param {delayCallback} delayCallback - Callback to get the delay before switching to the specified next state
   * @param {string} context - State context
   * @param {string} key - State key
   * @param {PulseStateComponent} component - Pulse state component
   */
  constructor(nextContext, nextKey, preAction, postAction, delayCallback, context, key, component) {
    super(context, key, component);
    this._nextContext = nextContext;
    this._nextKey = nextKey;
    this._preAction = preAction;
    this._postAction = postAction;
    this.delayCallback = delayCallback; // in ms
    this._active = false;
    this._timeoutId = null;
  }

  /**
   * Is the state still active ?
   * (exit has not been called yet)
   *
   * @return {boolean} The state is active
   */
  get active () {
    return this._active;
  }

  /**
   * @override
   */
  enter (previousStateContext, previousStateKey) {
    super.enter(previousStateContext, previousStateKey);
    this._active = true;
    this._clearTimeout();
    let delay = this.delayCallback(this.component);
    this._timeoutId = setTimeout(this._switch.bind(this), delay);
  }

  /**
   * @override
   */
  exit (nextStateContext, nextStateKey) {
    super.exit(nextStateContext, nextStateKey);
    this._active = false;
    this._clearTimeout();
  }

  /**
   * @override
   */
  stay () {
    super.stay();
    this._active = true;
    this._clearTimeout();
    let delay = this.delayCallback(this.component);
    this._timeoutId = setTimeout(this._switch.bind(this), delay);
  }

  _clearTimeout () {
    if (null != this._timeoutId) {
      window.clearTimeout(this._timeoutId);
      this._timeoutId = null;
    }
  }

  /**
   * Once the time is completed, switch to the next state
   */
  _switch () {
    if (this.active) {
      if ((null == this._nextContext) && (null == this._nextKey)) {
        this.component.switchToNextContext(this._preAction, this._postAction);
      }
      else {
        this.component.switchToState(this._nextContext, this._nextKey, this._preAction, this._postAction);
      }
    }
  }
}

/**
 * (Event) Parameter validation state with a timeout.
 * The event/live parameters are checked by the ValidateParameters methods of the web component.
 * 
 * In case they are ok, switch to the next context.
 * 
 * After some time, if the parameters could not be validated,
 * the web component is automatically switched to an error state
 * 
 * If the web component does not contain any ValidateParameters method, switch to the next context at once.
 *
 * When this state is entered {@link module:pulseComponent~PulseParamInitializedComponent#validateParameters} is called.
 * 
 * @extends module:state~WaitState
 */
class ParamValidationTimeoutState extends WaitState { // eslint-disable-line no-unused-vars
  /**
   * Constructor
   * 
   * @param {delayCallback} delayCallback - Callback to get the delay before switching to the error state
   * @param {string} context - State context
   * @param {string} key - State key
   * @param {PulseStateComponent} component - Pulse state component
   */
  constructor(delayCallback, context, key, component) {
    super(null, 'Error', () => this.component.showError(), () => this.component.removeError(), delayCallback, context, key, component);
  }

  /**
   * If validateParameters is a method of the component, run it.
   * Else switch to the next context.
   * 
   * @override
   */
  enter (previousStateContext, previousStateKey) {
    super.enter(previousStateContext, previousStateKey);
    this._validate();
  }

  /**
   * @override
   */
  exit (nextStateContext, nextStateKey) {
    super.exit(nextStateContext, nextStateKey);
  }

  /**
   * @override
   */
  stay () {
    super.stay();
    this._validate();
  }

  _validate () {
    if (this.component.updatePathFromConfigOrAttribute) { // Here this is optional, to make it mandatory use state ParamAndPathValidationTimeoutState
      if (!this.component.updatePathFromConfigOrAttribute()) {
        console.log('waiting attribute path');
        this.component.setError('Waiting for path');
        return;
      }
    }
    if (this.component.validateParameters) {
      this.component.validateParameters();
    }
    else {
      console.warn(`${this.component.getInfo ? this.component.getInfo() : ''}: validateParameters is not defined, it should probably inherit from base component with no parameter validation instead`);
      this.component.switchToNextContext();
    }
  }
}

/**
 * (Event) Parameter validation state with a timeout + wait for url path
 * The event/live parameters are checked by the ValidateParameters methods of the web component.
 * 
 * In case they are ok, switch to the next context.
 * 
 * After some time, if the parameters could not be validated,
 * the web component is automatically switched to an error state
 * 
 * If the web component does not contain any ValidateParameters method, switch to the next context at once.
 *
 * When this state is entered {@link module:pulseComponent~PulseParamInitializedComponent#validateParameters} is called.
 * 
 * @extends module:state~ParamValidationTimeoutState
 */
class ParamAndPathValidationTimeoutState extends ParamValidationTimeoutState {
  /**
   * Constructor
   * 
   * @param {delayCallback} delayCallback - Callback to get the delay before switching to the error state
   * @param {string} context - State context
   * @param {string} key - State key
   * @param {PulseStateComponent} component - Pulse state component
   */
  constructor(delayCallback, context, key, component) {
    super(delayCallback, context, key, component);
  }

  _validate () {
    // Check the path is valid
    if (this.component.updatePathFromConfigOrAttribute) {
      if (!this.component.updatePathFromConfigOrAttribute()) {
        console.log('waiting attribute path');
        this.component.setError('Waiting for path');
        return;
      }
    }
    else { // !this.component.updatePathFromConfigOrAttribute
      console.error('missing method updatePathFromConfigOrAttribute in component');
      debugger; // eslint-disable-line no-debugger
      throw 'missing method updatePathFromConfigOrAttribute';
    }
    if (this.component.validateParameters) {
      this.component.validateParameters();
    }
    else {
      console.warn(`${this.component.getInfo ? this.component.getInfo() : ''}: validateParameters is not defined, it should probably inherit from base component with no parameter validation instead`);
      this.component.switchToNextContext();
    }
  }
}

/**
 * Request state
 * 
 * After a specified delay, an Ajax method is called to refresh the component.
 * The URL used by the Ajax request () is the property url of the pulse component.
 *
 * @extends module:state~State
 */
class RequestState extends State {
  /**
   * Constructor
   * 
   * @param {delayCallback} delayCallback - Callback to get the initial delay before the Ajax method is called
   * @param {string} context - State context
   * @param {string} key - State key
   * @param {PulseStateComponent} component - Pulse state component
   */
  constructor(delayCallback, context, key, component) {
    if (new.target === RequestState) throw TypeError('new of abstract class RequestState');
    super(context, key, component);
    this.delayCallback = delayCallback; // in ms
    this._token = 0;
    this._active = false;
    this._timeoutId = null;
  }

  /**
   * Token that is incremented each time the enter or stay method is called
   *
   * @return {number}
   */
  get token () {
    return this._token;
  }
  /**
   * Increment the token
   * @see token
   */
  incrementToken () {
    this._token += 1;
  }

  /**
   * Is the state still active ?
   * (exit has not been called yet)
   *
   * @return {boolean} The state is active
   */
  get active () {
    return this._active;
  }

  /**
   * Url to use by the Ajax request.
   * Default is url of the component.
   * It can be overridden by the reload_url of the component.
   *
   * @return {string} Url to use in the ajax request
   */
  get url () {
    return this.component.url;
  }

  /**
   * After an initial delay, returned by the delay callback, initiate the Ajax request
   *
   * @override
   */
  enter (previousStateContext, previousStateKey) {
    super.enter(previousStateContext, previousStateKey);
    this.incrementToken();
    this._active = true;
    this._clearTimeout();
    let delay = this.delayCallback(this.component);
    this._timeoutId = setTimeout(this._runGetData.bind(this), delay, this.token);
  }

  /**
   * @override
   */
  exit (nextStateContext, nextStateKey) {
    super.exit(nextStateContext, nextStateKey);
    this._active = false;
    this._clearTimeout();
  }

  /**
   * After an initial delay, returned by the delay callback, initiate the Ajax request
   *
   * @override
   */
  stay () {
    super.stay();
    this.incrementToken();
    this._active = true;
    this._clearTimeout();
    let delay = this.delayCallback(this.component);
    this._timeoutId = setTimeout(this._runGetData.bind(this), delay, this.token);
  }

  _clearTimeout () {
    if (null != this._timeoutId) {
      window.clearTimeout(this._timeoutId);
      this._timeoutId = null;
    }
  }

  /**
   * Once the time is completed and the component is visible, run the ajax request
   *
   * @param {number} requestToken - Token number to be returned by the ajax request
   */
  _runAjaxWhenIsVisible (requestToken) {
    // Normal behavior
    if (this.active && this._checkToken(requestToken)) {
      if (this.component.isVisible) {
        let useLogin = pulseConfig.getBool('useLogin', false);
        if (useLogin) {
          pulseLogin.refreshTokenIfNeeded();
        }

        if (this.component.postData) { // savereason for example of use
          let jsondata = this.component.postData();
          pulseService.postAjax(this.token, this.url, jsondata, this.component.timeout, this._success.bind(this), this._error.bind(this), this._fail.bind(this));
        }
        else { // Normal behavior
          pulseService.runAjax(this.token, this.url, this.component.timeout, this._success.bind(this), this._error.bind(this), this._fail.bind(this));
        }
      }
      else { // Not visible: postpone it when it is visible again
        this._clearTimeout();
        this._timeoutId = setTimeout(this._runGetData.bind(this), 200, this.token);
      }
    }
  }

  /**
   * Once the time is completed and the component is visible, get data
   * (running ajax request or component._runAlternateGetData if defined)
   *
   * @param {number} requestToken - Token number to be returned by the ajax request
   */
  _runGetData (requestToken) {
    // Special behavior to get data without using url (ex : periodmanager, periodtoolbar)
    if (typeof (this.component._runAlternateGetData) != 'undefined') {
      if (this.component._runAlternateGetData()) {
        return;
      }
    }
    // Normal behavior
    this._runAjaxWhenIsVisible(requestToken);
  }

  /**
   * Callback that is run once the Ajax request is successful.
   * The refresh method of the Pulse component is run if the token matches.
   *
   * @param {number} ajaxToken - Token that is associated to the ajax request
   * @param {Object} data - Data returned by the ajax request
   */
  _success (ajaxToken, data) {
    if (this.active && this._checkToken(ajaxToken)) {
      this.component.manageSuccess(data);
    }
    else {
      console.warn('Success but token changed, ignore it');
    }
  }

  /**
   * Callback that is run if the ajax request returns an error data.
   * The manageError method of the Pulse component is run if the token matches.
   *
   * @param {number} ajaxToken - Token that is associated to the ajax request
   * @param {Object} data - Error data that is returned by the ajax request
   */
  _error (ajaxToken, data) {
    if (this.active && this._checkToken(ajaxToken)) {
      this.component.manageError(data);
      // Stop all refresh :  databaseProbablyDisconnected -> done in manageErrorStatus
    }
    else {
      console.warn('Error but token changed, ignore it');
    }
  }

  /**
   * Callback that is run if the ajax request fails.
   * The manageFailure method of the Pulse component is run if the token matches.
   *
   * @param {number} ajaxToken - Token that is associated to the ajax request
   * @param {string} url - URL used in the ajax request
   * @param {boolean} isTimeout - The ajax request ended in time out
   * @param {number} xhrStatus - XMLHttpRequest.status of the Ajax request
   */
  _fail (ajaxToken, url, isTimeout, xhrStatus) {
    if (this.active && this._checkToken(ajaxToken)) {
      this.component.manageFailure(isTimeout, xhrStatus);
      // Stop all refresh :
      let target = {
        url: url,
        source: this.component.element.tagName,
        when: new Date()
      };

      // NO Filter == Always !
      //if (!this.component.element.tagName.toUpperCase().includes('X-CHECK') ) { // != 'X-CHECKSERVERACCESS') {
      eventBus.EventBus.dispatchToAll('serverProbablyDisconnected', target);
      //}
    }
    else {
      console.warn('Failure but token changed, ignore it');
    }
  }

  /**
   * Check the token is still valid
   *
   * @param {number} ajaxToken - Token
   * @return {boolean} The token is still valid
   */
  _checkToken (ajaxToken) {
    return ajaxToken === this.token;
  }
}

/**
 * Load state. The initial ajax request was sent, but no normal data has been loaded yet.
 * The ajax request is sent right now.
 *
 * @extends module:state~RequestState
 */
class LoadState extends RequestState {
  /**
   * @override
   *
   * @param {string} context - State context
   * @param {string} key - State key
   * @param {PulseStateComponent} component - Pulse state component
   */
  constructor(context, key, component) {
    super(c => 0., context, key, component); // TODO: adapt the refresh rate in case it remains in the loading state
  }
}

/**
 * Normal refreshing state.S
 * 
 * @extends module:state~RequestState
 */
class NormalRequestState extends RequestState {
}

/**
 * Reload state. The component is in a state when the data must be reloaded right now.
 * The default delay is 0ms here.
 *
 * @extends module:state~RequestState
 */
class ReloadState extends RequestState {
  /**
   * @override
   *
   * @param {string} context - State context
   * @param {string} key - State key
   * @param {PulseStateComponent} component - Pulse state component
   */
  constructor(context, key, component) {
    super(c => 0., context, key, component); // TODO: adapt the refresh rate in case it remains in reload state
  }

  /**
   * The beforeReload method of the Pulse component is first run if defined
   *
   * @override
   */
  enter (previousStateContext, previousStateKey) {
    if (this.component.beforeReload) {
      this.component.beforeReload();
    }
    super.enter(previousStateContext, previousStateKey);
  }
}

/**
 * Not available state. The data is not available right now (it may be in the future)
 *
 * @extends module:state~RequestState
 */
class NotAvailableState extends RequestState {
}

/**
 * Temporary error state. A temporary error happened.
 *
 * @extends module:state~RequestState
 */
class TemporaryState extends RequestState {
  /**
   * @override
   */
  enter (previousStateContext, previousStateKey) {
    this._enter_date_time = new Date();
    super.enter(previousStateContext, previousStateKey);
  }

  /**
   * @override
   */
  exit (nextStateContext, nextStateKey) {
    this._enter_date_time = undefined;
    super.exit(nextStateContext, nextStateKey);
  }

  stay () {
    console.assert(typeof (this._enter_date_time) != 'undefined');
    let age = new Date() - this._enter_date_time;
    if (this.component.transientErrorDelay < age) {
      this.component.switchToKey('TransientError', this.component.showError, this.component.removeError);
    }
    else {
      super.stay();
    }
  }
}

/**
 * Delay error state. A temporary error that can remain active potentially a long time happened.
 *
 * @extends module:state~RequestState
 */
class DelayState extends RequestState {
  /**
   * @override
   */
  enter (previousStateContext, previousStateKey) {
    this._enter_date_time = new Date();
    super.enter(previousStateContext, previousStateKey);
  }

  /**
   * @override
   */
  exit (nextStateContext, nextStateKey) {
    this._enter_date_time = undefined;
    super.exit(nextStateContext, nextStateKey);
  }

  stay () {
    console.assert(typeof (this._enter_date_time) != 'undefined');
    let age = new Date() - this._enter_date_time;
    if (this.component.transientErrorDelay < age) {
      this.component.switchToKey('TransientError', this.component.showError, this.component.removeError);
    }
    else {
      super.stay();
    }
  }
}

/**
 * Transient error state. State to use when many temporary or delay states already occurred.
 * Then the pulse component can be switch to a warning state.
 *
 * @extends module:state~RequestState
 */
class TransientErrorState extends RequestState {
  /**
   * If defined, the enterTransientErrorState method of the Pulse component is run
   *
   * @override
   */
  enter (previousStateContext, previousStateKey) {
    super.enter(previousStateContext, previousStateKey);
    if (this.component.enterTransientErrorState) {
      this.component.enterTransientErrorState();
    }
  }

  /**
   * If defined, the exitTransientErrorState method of the Pulse component is run
   *
   * @override
   */
  exit (nextStateContext, nextStateKey) {
    if (this.component.exitTransientErrorState) {
      this.component.exitTransientErrorState();
    }
    super.exit(nextStateContext, nextStateKey);
  }
}

/**
 * Error state.
 *
 * @extends module:state~State
 */
class ErrorState extends State {
  /**
   * If defined, the enterErrorState method of the Pulse component is run
   *
   * @override
   */
  enter (previousStateContext, previousStateKey) {
    super.enter(previousStateContext, previousStateKey);
    if (this.component.enterErrorState) {
      this.component.enterErrorState();
    }
  }

  /**
   * If defined, the exitErrorState method of the Pulse component is run
   *
   * @override
   */
  exit (nextStateContext, nextStateKey) {
    if (this.component.exitErrorState) {
      this.component.exitErrorState();
    }
    super.exit(nextStateContext, nextStateKey);
  }
}

/**
 * Not applicable state. 
 *
 * @extends module:state~State
 */
class NotApplicableState extends State {
}

/**
 * Stop state. State to use when a component should stop refresh. 
 * For example, when web services are not available.
 *
 * @extends module:state~State
 */
class StopState extends State {
}


exports.State = State;
exports.BeforeDestructionState = BeforeDestructionState;
exports.InitialState = InitialState;
exports.AutoPathInitialState = AutoPathInitialState;
exports.ParamAndPathValidationTimeoutState = ParamAndPathValidationTimeoutState;
exports.ResetState = ResetState;
exports.StaticState = StaticState;
exports.NoActionState = NoActionState;
exports.WaitState = WaitState;
exports.ParamValidationTimeoutState = ParamValidationTimeoutState;
exports.RequestState = RequestState;
exports.LoadState = LoadState;
exports.NormalRequestState = NormalRequestState;
exports.ReloadState = ReloadState;
exports.NotAvailableState = NotAvailableState;
exports.TemporaryState = TemporaryState;
exports.DelayState = DelayState;
exports.TransientErrorState = TransientErrorState;
exports.ErrorState = ErrorState;
exports.NotApplicableState = NotApplicableState;
exports.StopState = StopState;

},{"eventBus":"eventBus","pulseConfig":"pulseConfig","pulseLogin":"pulseLogin","pulseService":"pulseService"}],4:[function(require,module,exports){
module.exports={"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\"","QUOT":"\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}

},{}],5:[function(require,module,exports){
'use strict';


////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) { return Object.prototype.toString.call(obj); }
function isString(obj) { return _class(obj) === '[object String]'; }
function isObject(obj) { return _class(obj) === '[object Object]'; }
function isRegExp(obj) { return _class(obj) === '[object RegExp]'; }
function isFunction(obj) { return _class(obj) === '[object Function]'; }


function escapeRE(str) { return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&'); }

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};


function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}


var defaultSchemas = {
  'http:': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http =  new RegExp(
          '^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'
        );
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:':  'http:',
  'ftp:':    'http:',
  '//':      {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
      // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http =  new RegExp(
          '^' +
          self.re.src_auth +
          // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' +
          self.re.src_port +
          self.re.src_host_terminator +
          self.re.src_path,

          'i'
        );
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') { return 0; }
        if (pos >= 3 && text[pos - 3] === '/') { return 0; }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto =  new RegExp(
          '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'
        );
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__   = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re = self.re = require('./lib/re')(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re.src_xn);

  re.src_tlds = tlds.join('|');

  function untpl(tpl) { return tpl.replace('%TLDS%', re.src_tlds); }

  re.email_fuzzy      = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy       = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test  = RegExp(untpl(re.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) { return; }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate =
      self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize =
      self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__)
                      .filter(function (name) {
                        // Filter disabled & fake schemas
                        return name.length > 0 && self.__compiled__[name];
                      })
                      .map(escapeRE)
                      .join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test   = RegExp('(^|(?!_)(?:[><\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp(
    '(' + self.re.schema_test.source + ')|(' + self.re.host_fuzzy_test.source + ')|@',
    'i'
  );

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end   = self.__last_index__,
      text  = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema    = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index     = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw       = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text      = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url       = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}


/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__           = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__          = -1;
  this.__last_index__     = -1; // Next scan position
  this.__schema__         = '';
  this.__text_cache__     = '';

  this.__schemas__        = assign({}, defaultSchemas, schemas);
  this.__compiled__       = {};

  this.__tlds__           = tlds_default;
  this.__tlds_replaced__  = false;

  this.re = {};

  compile(this);
}


/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};


/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};


/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__      = -1;

  if (!text.length) { return false; }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__     = m[2];
        this.__index__      = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__     = '';
            this.__index__      = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next  = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ ||
            (shift === this.__index__ && next > this.__last_index__)) {
          this.__schema__     = 'mailto:';
          this.__index__      = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};


/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};


/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};


/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0, result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};


/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [ list ];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list)
                                  .sort()
                                  .filter(function (el, idx, arr) {
                                    return el !== arr[idx - 1];
                                  })
                                  .reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) { match.url = 'http://' + match.url; }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};


/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {
};


module.exports = LinkifyIt;

},{"./lib/re":6}],6:[function(require,module,exports){
'use strict';


module.exports = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = require('uc.micro/properties/Any/regex').source;
  re.src_Cc  = require('uc.micro/categories/Cc/regex').source;
  re.src_Z   = require('uc.micro/categories/Z/regex').source;
  re.src_P   = require('uc.micro/categories/P/regex').source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [ re.src_Z, re.src_P, re.src_Cc ].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [ re.src_Z, re.src_Cc ].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uff5c]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter       = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 =

    '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth    = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port =

    '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator =

    '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path =

    '(?:' +
      '[/?#]' +
        '(?:' +
          '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-;]).|' +
          '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' +
          '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' +
          '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' +
          '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' +
          "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" +
          "\\'(?=" + re.src_pseudo_letter + '|[-]).|' +  // allow `I'm_king` if no pair found
          '\\.{2,}[a-zA-Z0-9%/&]|' + // google has many dots in "google search" links (#66, #81).
                                     // github has ... in commit range links,
                                     // Restrict to
                                     // - english
                                     // - percent-encoded
                                     // - parts of file path
                                     // - params separator
                                     // until more examples found.
          '\\.(?!' + re.src_ZCc + '|[.]).|' +
          (opts && opts['---'] ?
            '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
            :
            '\\-+|'
          ) +
          ',(?!' + re.src_ZCc + ').|' +       // allow `,,,` in paths
          ';(?!' + re.src_ZCc + ').|' +       // allow `;` if not followed by space-like char
          '\\!+(?!' + re.src_ZCc + '|[!]).|' +  // allow `!!!` in paths, but not at the end
          '\\?(?!' + re.src_ZCc + '|[?]).' +
        ')+' +
      '|\\/' +
    ')?';

  // Allow anything in markdown spec, forbid quote (") at the first position
  // because emails enclosed in quotes are far more common
  re.src_email_name =

    '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';

  re.src_xn =

    'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

    // Allow letters & digits (http://test1)
    '(?:' +
      re.src_xn +
      '|' +
      re.src_pseudo_letter + '{1,63}' +
    ')';

  re.src_domain =

    '(?:' +
      re.src_xn +
      '|' +
      '(?:' + re.src_pseudo_letter + ')' +
      '|' +
      '(?:' + re.src_pseudo_letter + '(?:-|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' +
    ')';

  re.src_host =

    '(?:' +
    // Don't need IP check, because digits are already allowed in normal domain names
    //   src_ip4 +
    // '|' +
      '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain/*_root*/ + ')' +
    ')';

  re.tpl_host_fuzzy =

    '(?:' +
      re.src_ip4 +
    '|' +
      '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' +
    ')';

  re.tpl_host_no_ip_fuzzy =

    '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict =

    re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict =

    re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict =

    re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict =

    re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict =

    re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;


  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test =

    'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy =

      '(^|' + text_separators + '|"|\\(|' + re.src_ZCc + ')' +
      '(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
      // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' +
      '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
      // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' +
      '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

},{"uc.micro/categories/Cc/regex":65,"uc.micro/categories/P/regex":67,"uc.micro/categories/Z/regex":68,"uc.micro/properties/Any/regex":70}],7:[function(require,module,exports){
'use strict';


module.exports = require('./lib/');

},{"./lib/":16}],8:[function(require,module,exports){
// HTML5 entities map: { name -> utf16string }
//
'use strict';

/*eslint quotes:0*/
module.exports = require('entities/lib/maps/entities.json');

},{"entities/lib/maps/entities.json":4}],9:[function(require,module,exports){
// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks

'use strict';


module.exports = [
  'address',
  'article',
  'aside',
  'base',
  'basefont',
  'blockquote',
  'body',
  'caption',
  'center',
  'col',
  'colgroup',
  'dd',
  'details',
  'dialog',
  'dir',
  'div',
  'dl',
  'dt',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'frame',
  'frameset',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hr',
  'html',
  'iframe',
  'legend',
  'li',
  'link',
  'main',
  'menu',
  'menuitem',
  'nav',
  'noframes',
  'ol',
  'optgroup',
  'option',
  'p',
  'param',
  'section',
  'source',
  'summary',
  'table',
  'tbody',
  'td',
  'tfoot',
  'th',
  'thead',
  'title',
  'tr',
  'track',
  'ul'
];

},{}],10:[function(require,module,exports){
// Regexps to match html elements

'use strict';

var attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted      = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute   = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag    = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag   = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing  = '<[?][\\s\\S]*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata       = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +
                        '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

},{}],11:[function(require,module,exports){
// Utilities
//
'use strict';


function _class(obj) { return Object.prototype.toString.call(obj); }

function isString(obj) { return _class(obj) === '[object String]'; }

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) { return false; }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }
  // control codes
  if (c >= 0x00 && c <= 0x08) { return false; }
  if (c === 0x0B) { return false; }
  if (c >= 0x0E && c <= 0x1F) { return false; }
  if (c >= 0x7F && c <= 0x9F) { return false; }
  // out of range
  if (c > 0x10FFFF) { return false; }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}


var UNESCAPE_MD_RE  = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = require('./entities');

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ?
      parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);

    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) { return str; }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) { return str; }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) { return escaped; }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) { return true; }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/
var UNICODE_PUNCT_RE = require('uc.micro/categories/P/regex');

// Currently without astral characters support.
function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
}


// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21/* ! */:
    case 0x22/* " */:
    case 0x23/* # */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x26/* & */:
    case 0x27/* ' */:
    case 0x28/* ( */:
    case 0x29/* ) */:
    case 0x2A/* * */:
    case 0x2B/* + */:
    case 0x2C/* , */:
    case 0x2D/* - */:
    case 0x2E/* . */:
    case 0x2F/* / */:
    case 0x3A/* : */:
    case 0x3B/* ; */:
    case 0x3C/* < */:
    case 0x3D/* = */:
    case 0x3E/* > */:
    case 0x3F/* ? */:
    case 0x40/* @ */:
    case 0x5B/* [ */:
    case 0x5C/* \ */:
    case 0x5D/* ] */:
    case 0x5E/* ^ */:
    case 0x5F/* _ */:
    case 0x60/* ` */:
    case 0x7B/* { */:
    case 0x7C/* | */:
    case 0x7D/* } */:
    case 0x7E/* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // Trim and collapse whitespace
  //
  str = str.trim().replace(/\s+/g, ' ');

  // In node v10 'ẞ'.toLowerCase() === 'Ṿ', which is presumed to be a bug
  // fixed in v12 (couldn't find any details).
  //
  // So treat this one as a special case
  // (remove this when node v10 is no longer supported).
  //
  if ('ẞ'.toLowerCase() === 'Ṿ') {
    str = str.replace(/ẞ/g, 'ß');
  }

  // .toLowerCase().toUpperCase() should get rid of all differences
  // between letter variants.
  //
  // Simple .toLowerCase() doesn't normalize 125 code points correctly,
  // and .toUpperCase doesn't normalize 6 of them (list of exceptions:
  // İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently
  // uppercased versions).
  //
  // Here's an example showing how it happens. Lets take greek letter omega:
  // uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)
  //
  // Unicode entries:
  // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;
  // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398
  // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398
  // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;
  //
  // Case-insensitive comparison should treat all of them as equivalent.
  //
  // But .toLowerCase() doesn't change ϑ (it's already lowercase),
  // and .toUpperCase() doesn't change ϴ (already uppercase).
  //
  // Applying first lower then upper case normalizes any character:
  // '\u0398\u03f4\u03b8\u03d1'.toLowerCase().toUpperCase() === '\u0398\u0398\u0398\u0398'
  //
  // Note: this is equivalent to unicode case folding; unicode normalization
  // is a different step that is not required here.
  //
  // Final result should be uppercased, because it's later stored in an object
  // (this avoid a conflict with Object.prototype members,
  // most notably, `__proto__`)
  //
  return str.toLowerCase().toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib                 = {};
exports.lib.mdurl           = require('mdurl');
exports.lib.ucmicro         = require('uc.micro');

exports.assign              = assign;
exports.isString            = isString;
exports.has                 = has;
exports.unescapeMd          = unescapeMd;
exports.unescapeAll         = unescapeAll;
exports.isValidEntityCode   = isValidEntityCode;
exports.fromCodePoint       = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml          = escapeHtml;
exports.arrayReplaceAt      = arrayReplaceAt;
exports.isSpace             = isSpace;
exports.isWhiteSpace        = isWhiteSpace;
exports.isMdAsciiPunct      = isMdAsciiPunct;
exports.isPunctChar         = isPunctChar;
exports.escapeRE            = escapeRE;
exports.normalizeReference  = normalizeReference;

},{"./entities":8,"mdurl":62,"uc.micro":69,"uc.micro/categories/P/regex":67}],12:[function(require,module,exports){
// Just a shortcut for bulk export
'use strict';


exports.parseLinkLabel       = require('./parse_link_label');
exports.parseLinkDestination = require('./parse_link_destination');
exports.parseLinkTitle       = require('./parse_link_title');

},{"./parse_link_destination":13,"./parse_link_label":14,"./parse_link_title":15}],13:[function(require,module,exports){
// Parse link destination
//
'use strict';


var unescapeAll = require('../common/utils').unescapeAll;


module.exports = function parseLinkDestination(str, pos, max) {
  var code, level,
      lines = 0,
      start = pos,
      result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ''
      };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
    pos++;
    while (pos < max) {
      code = str.charCodeAt(pos);
      if (code === 0x0A /* \n */) { return result; }
      if (code === 0x3C /* < */) { return result; }
      if (code === 0x3E /* > */) {
        result.pos = pos + 1;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code === 0x5C /* \ */ && pos + 1 < max) {
        pos += 2;
        continue;
      }

      pos++;
    }

    // no closing '>'
    return result;
  }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) { break; }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) { break; }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 0x20) { break; }
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
      level++;
      if (level > 32) { return result; }
    }

    if (code === 0x29 /* ) */) {
      if (level === 0) { break; }
      level--;
    }

    pos++;
  }

  if (start === pos) { return result; }
  if (level !== 0) { return result; }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

},{"../common/utils":11}],14:[function(require,module,exports){
// Parse link label
//
// this function assumes that first character ("[") already matches;
// returns the end of the label
//
'use strict';

module.exports = function parseLinkLabel(state, start, disableNested) {
  var level, found, marker, prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
      if (prevPos === state.pos - 1) {
        // increase level if we find text `[`, which is not a part of any token
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

},{}],15:[function(require,module,exports){
// Parse link title
//
'use strict';


var unescapeAll = require('../common/utils').unescapeAll;


module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ''
      };

  if (pos >= max) { return result; }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return result; }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) { marker = 0x29; }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x28 /* ( */ && marker === 0x29 /* ) */) {
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

},{"../common/utils":11}],16:[function(require,module,exports){
// Main parser class

'use strict';


var utils        = require('./common/utils');
var helpers      = require('./helpers');
var Renderer     = require('./renderer');
var ParserCore   = require('./parser_core');
var ParserBlock  = require('./parser_block');
var ParserInline = require('./parser_inline');
var LinkifyIt    = require('linkify-it');
var mdurl        = require('mdurl');
var punycode     = require('punycode');


var config = {
  default: require('./presets/default'),
  zero: require('./presets/zero'),
  commonmark: require('./presets/commonmark')
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) { /**/ }
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) { /**/ }
    }
  }

  // add '%' to exclude list because of https://github.com/markdown-it/markdown-it/issues/720
  return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + '%');
}


/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(str, { language: lang, ignoreIllegals: true }).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(str, { language: lang, ignoreIllegals: true }).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new ParserInline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new ParserBlock();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new ParserCore();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new Renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new LinkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;


  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);


  this.options = {};
  this.configure(presetName);

  if (options) { this.set(options); }
}


/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};


/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you will - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this, presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) { throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name'); }
  }

  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\'t be empty'); }

  if (presets.options) { self.set(presets.options); }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};


/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) { list = [ list ]; }

  [ 'core', 'block', 'inline' ].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};


/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) { list = [ list ]; }

  [ 'core', 'block', 'inline' ].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};


/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};


/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and return list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};


/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};


/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};


/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};


module.exports = MarkdownIt;

},{"./common/utils":11,"./helpers":12,"./parser_block":17,"./parser_core":18,"./parser_inline":19,"./presets/commonmark":20,"./presets/default":21,"./presets/zero":22,"./renderer":23,"linkify-it":5,"mdurl":62,"punycode":64}],17:[function(require,module,exports){
/** internal
 * class ParserBlock
 *
 * Block-level tokenizer.
 **/
'use strict';


var Ruler           = require('./ruler');


var _rules = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  [ 'table',      require('./rules_block/table'),      [ 'paragraph', 'reference' ] ],
  [ 'code',       require('./rules_block/code') ],
  [ 'fence',      require('./rules_block/fence'),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'reference',  require('./rules_block/reference') ],
  [ 'html_block', require('./rules_block/html_block'), [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'lheading',   require('./rules_block/lheading') ],
  [ 'paragraph',  require('./rules_block/paragraph') ]
];


/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
  }
}


// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok, i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) { break; }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) { break; }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) { break; }
    }

    // set state.tight if we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};


/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) { return; }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};


ParserBlock.prototype.State = require('./rules_block/state_block');


module.exports = ParserBlock;

},{"./ruler":24,"./rules_block/blockquote":25,"./rules_block/code":26,"./rules_block/fence":27,"./rules_block/heading":28,"./rules_block/hr":29,"./rules_block/html_block":30,"./rules_block/lheading":31,"./rules_block/list":32,"./rules_block/paragraph":33,"./rules_block/reference":34,"./rules_block/state_block":35,"./rules_block/table":36}],18:[function(require,module,exports){
/** internal
 * class Core
 *
 * Top-level rules executor. Glues block/inline parsers and does intermediate
 * transformations.
 **/
'use strict';


var Ruler  = require('./ruler');


var _rules = [
  [ 'normalize',      require('./rules_core/normalize')      ],
  [ 'block',          require('./rules_core/block')          ],
  [ 'inline',         require('./rules_core/inline')         ],
  [ 'linkify',        require('./rules_core/linkify')        ],
  [ 'replacements',   require('./rules_core/replacements')   ],
  [ 'smartquotes',    require('./rules_core/smartquotes')    ]
];


/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}


/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = require('./rules_core/state_core');


module.exports = Core;

},{"./ruler":24,"./rules_core/block":37,"./rules_core/inline":38,"./rules_core/linkify":39,"./rules_core/normalize":40,"./rules_core/replacements":41,"./rules_core/smartquotes":42,"./rules_core/state_core":43}],19:[function(require,module,exports){
/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/
'use strict';


var Ruler           = require('./ruler');


////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [
  [ 'text',            require('./rules_inline/text') ],
  [ 'newline',         require('./rules_inline/newline') ],
  [ 'escape',          require('./rules_inline/escape') ],
  [ 'backticks',       require('./rules_inline/backticks') ],
  [ 'strikethrough',   require('./rules_inline/strikethrough').tokenize ],
  [ 'emphasis',        require('./rules_inline/emphasis').tokenize ],
  [ 'link',            require('./rules_inline/link') ],
  [ 'image',           require('./rules_inline/image') ],
  [ 'autolink',        require('./rules_inline/autolink') ],
  [ 'html_inline',     require('./rules_inline/html_inline') ],
  [ 'entity',          require('./rules_inline/entity') ]
];

var _rules2 = [
  [ 'balance_pairs',   require('./rules_inline/balance_pairs') ],
  [ 'strikethrough',   require('./rules_inline/strikethrough').postProcess ],
  [ 'emphasis',        require('./rules_inline/emphasis').postProcess ],
  [ 'text_collapse',   require('./rules_inline/text_collapse') ]
];


/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}


// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok, i, pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;


  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) { break; }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) { state.pos++; }
  cache[pos] = state.pos;
};


// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok, i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) { break; }
      }
    }

    if (ok) {
      if (state.pos >= end) { break; }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};


/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};


ParserInline.prototype.State = require('./rules_inline/state_inline');


module.exports = ParserInline;

},{"./ruler":24,"./rules_inline/autolink":44,"./rules_inline/backticks":45,"./rules_inline/balance_pairs":46,"./rules_inline/emphasis":47,"./rules_inline/entity":48,"./rules_inline/escape":49,"./rules_inline/html_inline":50,"./rules_inline/image":51,"./rules_inline/link":52,"./rules_inline/newline":53,"./rules_inline/state_inline":54,"./rules_inline/strikethrough":55,"./rules_inline/text":56,"./rules_inline/text_collapse":57}],20:[function(require,module,exports){
// Commonmark default options

'use strict';


module.exports = {
  options: {
    html:         true,         // Enable HTML tags in source
    xhtmlOut:     true,         // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'normalize',
        'block',
        'inline'
      ]
    },

    block: {
      rules: [
        'blockquote',
        'code',
        'fence',
        'heading',
        'hr',
        'html_block',
        'lheading',
        'list',
        'reference',
        'paragraph'
      ]
    },

    inline: {
      rules: [
        'autolink',
        'backticks',
        'emphasis',
        'entity',
        'escape',
        'html_inline',
        'image',
        'link',
        'newline',
        'text'
      ],
      rules2: [
        'balance_pairs',
        'emphasis',
        'text_collapse'
      ]
    }
  }
};

},{}],21:[function(require,module,exports){
// markdown-it default options

'use strict';


module.exports = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   100            // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

},{}],22:[function(require,module,exports){
// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
// modes. For example, to parse bold/italic only.

'use strict';


module.exports = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'normalize',
        'block',
        'inline'
      ]
    },

    block: {
      rules: [
        'paragraph'
      ]
    },

    inline: {
      rules: [
        'text'
      ],
      rules2: [
        'balance_pairs',
        'text_collapse'
      ]
    }
  }
};

},{}],23:[function(require,module,exports){
/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/
'use strict';


var assign          = require('./common/utils').assign;
var unescapeAll     = require('./common/utils').unescapeAll;
var escapeHtml      = require('./common/utils').escapeHtml;


////////////////////////////////////////////////////////////////////////////////

var default_rules = {};


default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return  '<code' + slf.renderAttrs(token) + '>' +
          escapeHtml(tokens[idx].content) +
          '</code>';
};


default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return  '<pre' + slf.renderAttrs(token) + '><code>' +
          escapeHtml(tokens[idx].content) +
          '</code></pre>\n';
};


default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      langAttrs = '',
      highlighted, i, arr, tmpAttrs, tmpToken;

  if (info) {
    arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join('');
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without modifying original token.
  // May be, one day we will add .deepClone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i        = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push([ 'class', options.langPrefix + langName ]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return  '<pre><code' + slf.renderAttrs(tmpToken) + '>'
          + highlighted
          + '</code></pre>\n';
  }


  return  '<pre><code' + slf.renderAttrs(token) + '>'
        + highlighted
        + '</code></pre>\n';
};


default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] =
    slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};


default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n';
};


default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};


default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};


/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independent static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}


/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) { return ''; }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};


/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;

        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};


/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};


/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    } else if (tokens[i].type === 'softbreak') {
      result += '\n';
    }
  }

  return result;
};


/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to render
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i, len, type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

},{"./common/utils":11}],24:[function(require,module,exports){
/**
 * class Ruler
 *
 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
 *
 * - keep rules in defined order
 * - assign the name to each rule
 * - enable/disable rules
 * - add/replace rules
 * - allow assign rules to additional named chains (in the same)
 * - cacheing lists of active rules
 *
 * You will not need use this class directly until write plugins. For simple
 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
 * [[MarkdownIt.use]].
 **/
'use strict';


/**
 * new Ruler()
 **/
function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};


// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [ '' ];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) { return; }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) { return; }

      if (chain && rule.alt.indexOf(chain) < 0) { return; }

      self.__cache__[chain].push(rule.fn);
    });
  });
};


/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typographer replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) { throw new Error('Parser rule not found: ' + name); }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};


/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};


/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};


/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) { return; }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};


/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  this.__rules__.forEach(function (rule) { rule.enabled = false; });

  this.enable(list, ignoreInvalid);
};


/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) { return; }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};


/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

},{}],25:[function(require,module,exports){
// Block quotes

'use strict';

var isSpace = require('../common/utils').isSpace;


module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      isOutdented,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) { return true; }

  // set offset past spaces and ">"
  initial = offset = state.sCount[startLine] + 1;

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
    // ' >   test '
    //     ^ -- position start of line here:
    pos++;
    initial++;
    offset++;
    adjustTab = false;
    spaceAfterMarker = true;
  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
    spaceAfterMarker = true;

    if ((state.bsCount[startLine] + offset) % 4 === 3) {
      // '  >\t  test '
      //       ^ -- position start of line here (tab has width===1)
      pos++;
      initial++;
      offset++;
      adjustTab = false;
    } else {
      // ' >\t  test '
      //    ^ -- position start of line here + shift bsCount slightly
      //         to make extra space appear
      adjustTab = true;
    }
  } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [ state.bMarks[startLine] ];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [ state.bsCount[startLine] ];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [ state.sCount[startLine] ];
  state.sCount[startLine] = offset - initial;

  oldTShift = [ state.tShift[startLine] ];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    isOutdented = state.sCount[nextLine] < state.blkIndent;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {
      // This line is inside the blockquote.

      // set offset past spaces and ">"
      initial = offset = state.sCount[nextLine] + 1;

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
        // ' >   test '
        //     ^ -- position start of line here:
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
        spaceAfterMarker = true;

        if ((state.bsCount[nextLine] + offset) % 4 === 3) {
          // '  >\t  test '
          //       ^ -- position start of line here (tab has width===1)
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          // ' >\t  test '
          //    ^ -- position start of line here + shift bsCount slightly
          //         to make extra space appear
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) { break; }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token        = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map    = lines = [ startLine, 0 ];

  state.md.block.tokenize(state, startLine, nextLine);

  token        = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

},{"../common/utils":11}],26:[function(require,module,exports){
// Code block (4 spaces padded)

'use strict';


module.exports = function code(state, startLine, endLine/*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) { return false; }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token         = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + '\n';
  token.map     = [ startLine, state.line ];

  return true;
};

},{}],27:[function(require,module,exports){
// fences (``` lang, ~~~ lang)

'use strict';


module.exports = function fence(state, startLine, endLine, silent) {
  var marker, len, params, nextLine, mem, token, markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  if (pos + 3 > max) { return false; }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {
    return false;
  }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) { return false; }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (marker === 0x60 /* ` */) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }

  // Since start is found, we can report success here in validation mode
  if (silent) { return true; }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) { continue; }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) { continue; }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) { continue; }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token         = state.push('fence', 'code', 0);
  token.info    = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup  = markup;
  token.map     = [ startLine, state.line ];

  return true;
};

},{}],28:[function(require,module,exports){
// heading (#, ##, ...)

'use strict';

var isSpace = require('../common/utils').isSpace;


module.exports = function heading(state, startLine, endLine, silent) {
  var ch, level, tmp, token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  ch  = state.src.charCodeAt(pos);

  if (ch !== 0x23/* # */ || pos >= max) { return false; }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23/* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || (pos < max && !isSpace(ch))) { return false; }

  if (silent) { return true; }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token        = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map    = [ startLine, state.line ];

  token          = state.push('inline', '', 0);
  token.content  = state.src.slice(pos, max).trim();
  token.map      = [ startLine, state.line ];
  token.children = [];

  token        = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

},{"../common/utils":11}],29:[function(require,module,exports){
// Horizontal rule

'use strict';

var isSpace = require('../common/utils').isSpace;


module.exports = function hr(state, startLine, endLine, silent) {
  var marker, cnt, ch, token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x5F/* _ */) {
    return false;
  }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace(ch)) { return false; }
    if (ch === marker) { cnt++; }
  }

  if (cnt < 3) { return false; }

  if (silent) { return true; }

  state.line = startLine + 1;

  token        = state.push('hr', 'hr', 0);
  token.map    = [ startLine, state.line ];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

},{"../common/utils":11}],30:[function(require,module,exports){
// HTML block

'use strict';


var block_names = require('../common/html_blocks');
var HTML_OPEN_CLOSE_TAG_RE = require('../common/html_re').HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [
  [ /^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true ],
  [ /^<!--/,        /-->/,   true ],
  [ /^<\?/,         /\?>/,   true ],
  [ /^<![A-Z]/,     />/,     true ],
  [ /^<!\[CDATA\[/, /\]\]>/, true ],
  [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true ],
  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'),  /^$/, false ]
];


module.exports = function html_block(state, startLine, endLine, silent) {
  var i, nextLine, token, lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  if (!state.md.options.html) { return false; }

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }
  }

  if (i === HTML_SEQUENCES.length) { return false; }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) { break; }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) { nextLine++; }
        break;
      }
    }
  }

  state.line = nextLine;

  token         = state.push('html_block', '', 0);
  token.map     = [ startLine, nextLine ];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

},{"../common/html_blocks":9,"../common/html_re":10}],31:[function(require,module,exports){
// lheading (---, ===)

'use strict';


module.exports = function lheading(state, startLine, endLine/*, silent*/) {
  var content, terminate, i, l, token, pos, max, level, marker,
      nextLine = startLine + 1, oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {
          pos = state.skipChars(pos, marker);
          pos = state.skipSpaces(pos);

          if (pos >= max) {
            level = (marker === 0x3D/* = */ ? 1 : 2);
            break;
          }
        }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) { continue; }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token          = state.push('heading_open', 'h' + String(level), 1);
  token.markup   = String.fromCharCode(marker);
  token.map      = [ startLine, state.line ];

  token          = state.push('inline', '', 0);
  token.content  = content;
  token.map      = [ startLine, state.line - 1 ];
  token.children = [];

  token          = state.push('heading_close', 'h' + String(level), -1);
  token.markup   = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

},{}],32:[function(require,module,exports){
// Lists

'use strict';

var isSpace = require('../common/utils').isSpace;


// Search `[-+*][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x2B/* + */) {
    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) { return -1; }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }

  for (;;) {
    // EOL -> fail
    if (pos >= max) { return -1; }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {

      // List marker should have no more than 9 digits
      // (prevents integer overflow in browsers)
      if (pos - start >= 10) { return -1; }

      continue;
    }

    // found valid marker
    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {
      break;
    }

    return -1;
  }


  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i, l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}


module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldListIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  // Special case:
  //  - item 1
  //   - item 2
  //    - item 3
  //     - item 4
  //      - this one is a paragraph continuation
  if (state.listIndent >= 0 &&
      state.sCount[startLine] - state.listIndent >= 4 &&
      state.sCount[startLine] < state.blkIndent) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.sCount[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.slice(start, posAfterMarker - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;

  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;

  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) { return true; }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token       = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [ [ 'start', markerValue ] ];
    }

  } else {
    token       = state.push('bullet_list_open', 'ul', 1);
  }

  token.map    = listLines = [ startLine, 0 ];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 0x20) {
        offset++;
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) { indentAfterMarker = 1; }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token        = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map    = itemLines = [ startLine, 0 ];
    if (isOrdered) {
      token.info = state.src.slice(start, posAfterMarker - 1);
    }

    // change current state, then restore it after parser subcall
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldSCount = state.sCount[startLine];

    //  - example list
    // ^ listIndent position will be here
    //   ^ blkIndent position will be here
    //
    oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;

    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldSCount;
    state.tight = oldTight;

    token        = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) { break; }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) { break; }

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4) { break; }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
      start = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }
  }

  // Finalize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

},{"../common/utils":11}],33:[function(require,module,exports){
// Paragraph

'use strict';


module.exports = function paragraph(state, startLine/*, endLine*/) {
  var content, terminate, i, l, token, oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) { continue; }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token          = state.push('paragraph_open', 'p', 1);
  token.map      = [ startLine, state.line ];

  token          = state.push('inline', '', 0);
  token.content  = content;
  token.map      = [ startLine, state.line ];
  token.children = [];

  token          = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

},{}],34:[function(require,module,exports){
'use strict';


var normalizeReference   = require('../common/utils').normalizeReference;
var isSpace              = require('../common/utils').isSpace;


module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&
        state.src.charCodeAt(pos - 1) !== 0x5C/* \ */) {
      if (pos + 1 === max) { return false; }
      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }
      break;
    }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) { continue; }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
      return false;
    } else if (ch === 0x5D /* ] */) {
      labelEnd = pos;
      break;
    } else if (ch === 0x0A /* \n */) {
      lines++;
    } else if (ch === 0x5C /* \ */) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) { return false; }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) { return false; }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace(ch)) { break; }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) { break; }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) { return true; }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

},{"../common/utils":11}],35:[function(require,module,exports){
// Parser state class

'use strict';

var Token = require('../token');
var isSpace = require('../common/utils').isSpace;


function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md     = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = [];  // line begin offsets for fast jumps
  this.eMarks = [];  // line end offsets for fast jumps
  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)
  this.sCount = [];  // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent  = 0; // required block content indent (for example, if we are
                       // inside a list, it would be positioned after list marker)
  this.line       = 0; // line index in src
  this.lineMax    = 0; // lines count
  this.tight      = false;  // loose/tight mode for lists
  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)
  this.listIndent = -1; // indent of the current list block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) { pos++; }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) this.level--; // closing tag
  token.level = this.level;
  if (nesting > 0) this.level++; // opening tag

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace(ch)) { break; }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) { return pos; }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1; }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) { break; }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) { return pos; }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i, lineIndent, ch, first, last, queue, lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = Token;


module.exports = StateBlock;

},{"../common/utils":11,"../token":58}],36:[function(require,module,exports){
// GFM table, https://github.github.com/gfm/#tables-extension-

'use strict';

var isSpace = require('../common/utils').isSpace;


function getLine(state, line) {
  var pos = state.bMarks[line] + state.tShift[line],
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      isEscaped = false,
      lastPos = 0,
      current = '';

  ch  = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x7c/* | */) {
      if (!isEscaped) {
        // pipe separating cells, '|'
        result.push(current + str.substring(lastPos, pos));
        current = '';
        lastPos = pos + 1;
      } else {
        // escaped pipe, '\|'
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }

    isEscaped = (ch === 0x5c/* \ */);
    pos++;

    ch = str.charCodeAt(pos);
  }

  result.push(current + str.substring(lastPos));

  return result;
}


module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, l, nextLine, columns, columnCount, token,
      aligns, t, tableLines, tbodyLines, oldParentType, terminate,
      terminatorRules, firstCh, secondCh;

  // should have at least two lines
  if (startLine + 2 > endLine) { return false; }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) { return false; }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false; }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) { return false; }

  firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 0x7C/* | */ && firstCh !== 0x2D/* - */ && firstCh !== 0x3A/* : */) { return false; }

  if (pos >= state.eMarks[nextLine]) { return false; }

  secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 0x7C/* | */ && secondCh !== 0x2D/* - */ && secondCh !== 0x3A/* : */ && !isSpace(secondCh)) {
    return false;
  }

  // if first character is '-', then second character must not be a space
  // (due to parsing ambiguity with list)
  if (firstCh === 0x2D/* - */ && isSpace(secondCh)) { return false; }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace(ch)) { return false; }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) { return false; }
    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {
      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');
    } else if (t.charCodeAt(0) === 0x3A/* : */) {
      aligns.push('left');
    } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) { return false; }
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === '') columns.shift();
  if (columns.length && columns[columns.length - 1] === '') columns.pop();

  // header row will define an amount of columns in the entire table,
  // and align row should be exactly the same (the rest of the rows can differ)
  columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) { return false; }

  if (silent) { return true; }

  oldParentType = state.parentType;
  state.parentType = 'table';

  // use 'blockquote' lists for termination because it's
  // the most similar to tables
  terminatorRules = state.md.block.ruler.getRules('blockquote');

  token     = state.push('table_open', 'table', 1);
  token.map = tableLines = [ startLine, 0 ];

  token     = state.push('thead_open', 'thead', 1);
  token.map = [ startLine, startLine + 1 ];

  token     = state.push('tr_open', 'tr', 1);
  token.map = [ startLine, startLine + 1 ];

  for (i = 0; i < columns.length; i++) {
    token          = state.push('th_open', 'th', 1);
    if (aligns[i]) {
      token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
    }

    token          = state.push('inline', '', 0);
    token.content  = columns[i].trim();
    token.children = [];

    token          = state.push('th_close', 'th', -1);
  }

  token     = state.push('tr_close', 'tr', -1);
  token     = state.push('thead_close', 'thead', -1);

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) { break; }

    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) { break; }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) { break; }
    if (state.sCount[nextLine] - state.blkIndent >= 4) { break; }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === '') columns.shift();
    if (columns.length && columns[columns.length - 1] === '') columns.pop();

    if (nextLine === startLine + 2) {
      token     = state.push('tbody_open', 'tbody', 1);
      token.map = tbodyLines = [ startLine + 2, 0 ];
    }

    token     = state.push('tr_open', 'tr', 1);
    token.map = [ nextLine, nextLine + 1 ];

    for (i = 0; i < columnCount; i++) {
      token          = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
      }

      token          = state.push('inline', '', 0);
      token.content  = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token          = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }

  if (tbodyLines) {
    token = state.push('tbody_close', 'tbody', -1);
    tbodyLines[1] = nextLine;
  }

  token = state.push('table_close', 'table', -1);
  tableLines[1] = nextLine;

  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
};

},{"../common/utils":11}],37:[function(require,module,exports){
'use strict';


module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token          = new state.Token('inline', '', 0);
    token.content  = state.src;
    token.map      = [ 0, 1 ];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

},{}],38:[function(require,module,exports){
'use strict';

module.exports = function inline(state) {
  var tokens = state.tokens, tok, i, l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

},{}],39:[function(require,module,exports){
// Replace link-like texts with link nodes.
//
// Currently restricted by `md.validateLink()` to http/https/ftp
//
'use strict';


var arrayReplaceAt = require('../common/utils').arrayReplaceAt;


function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}


module.exports = function linkify(state) {
  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,
      level, htmlLinkLevel, url, fullUrl, urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) { return; }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' ||
        !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) { continue; }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) { continue; }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token         = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level   = level;
            nodes.push(token);
          }

          token         = new state.Token('link_open', 'a', 1);
          token.attrs   = [ [ 'href', fullUrl ] ];
          token.level   = level++;
          token.markup  = 'linkify';
          token.info    = 'auto';
          nodes.push(token);

          token         = new state.Token('text', '', 0);
          token.content = urlText;
          token.level   = level;
          nodes.push(token);

          token         = new state.Token('link_close', 'a', -1);
          token.level   = --level;
          token.markup  = 'linkify';
          token.info    = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token         = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level   = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

},{"../common/utils":11}],40:[function(require,module,exports){
// Normalize input string

'use strict';


// https://spec.commonmark.org/0.29/#line-ending
var NEWLINES_RE  = /\r\n?|\n/g;
var NULL_RE      = /\0/g;


module.exports = function normalize(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

},{}],41:[function(require,module,exports){
// Simple typographic replacements
//
// (c) (C) → ©
// (tm) (TM) → ™
// (r) (R) → ®
// +- → ±
// (p) (P) -> §
// ... → … (also ?.... → ?.., !.... → !..)
// ???????? → ???, !!!!! → !!!, `,,` → `,`
// -- → &ndash;, --- → &mdash;
//
'use strict';

// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i, token, inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i, token, inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content
          .replace(/\+-/g, '±')
          // .., ..., ....... -> …
          // but ?..... & !..... -> ?.. & !..
          .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..')
          .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
          // em-dash
          .replace(/(^|[^-])---(?=[^-]|$)/mg, '$1\u2014')
          // en-dash
          .replace(/(^|\s)--(?=\s|$)/mg, '$1\u2013')
          .replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, '$1\u2013');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}


module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) { return; }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') { continue; }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }

  }
};

},{}],42:[function(require,module,exports){
// Convert straight quotation marks to typographic ones
//
'use strict';


var isWhiteSpace   = require('../common/utils').isWhiteSpace;
var isPunctChar    = require('../common/utils').isPunctChar;
var isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */


function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,
      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,
      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) { break; }
    }
    stack.length = j + 1;

    if (token.type !== 'text') { continue; }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER:
    while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) { break; }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = (t[0] === "'");

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20
          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20
          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
          // special case: 1"" - count first quote as an inch
          canClose = canOpen = false;
        }
      }

      if (canOpen && canClose) {
        // Replace quotes in the middle of punctuation sequence, but not
        // in the middle of the words, i.e.:
        //
        // 1. foo " bar " baz - not replaced
        // 2. foo-"-bar-"-baz - replaced
        // 3. foo"bar"baz     - not replaced
        //
        canOpen = isLastPunctChar;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) { break; }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(
              tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) { pos += openQuote.length - 1; }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}


module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) { return; }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' ||
        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

},{"../common/utils":11}],43:[function(require,module,exports){
// Core state object
//
'use strict';

var Token = require('../token');


function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = Token;


module.exports = StateCore;

},{"../token":58}],44:[function(require,module,exports){
// Process autolinks '<protocol:...>'

'use strict';


/*eslint max-len:0*/
var EMAIL_RE    = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;


module.exports = function autolink(state, silent) {
  var url, fullUrl, token, ch, start, max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  start = state.pos;
  max = state.posMax;

  for (;;) {
    if (++pos >= max) return false;

    ch = state.src.charCodeAt(pos);

    if (ch === 0x3C /* < */) return false;
    if (ch === 0x3E /* > */) break;
  }

  url = state.src.slice(start + 1, pos);

  if (AUTOLINK_RE.test(url)) {
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) { return false; }

    if (!silent) {
      token         = state.push('link_open', 'a', 1);
      token.attrs   = [ [ 'href', fullUrl ] ];
      token.markup  = 'autolink';
      token.info    = 'auto';

      token         = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token         = state.push('link_close', 'a', -1);
      token.markup  = 'autolink';
      token.info    = 'auto';
    }

    state.pos += url.length + 2;
    return true;
  }

  if (EMAIL_RE.test(url)) {
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) { return false; }

    if (!silent) {
      token         = state.push('link_open', 'a', 1);
      token.attrs   = [ [ 'href', fullUrl ] ];
      token.markup  = 'autolink';
      token.info    = 'auto';

      token         = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token         = state.push('link_close', 'a', -1);
      token.markup  = 'autolink';
      token.info    = 'auto';
    }

    state.pos += url.length + 2;
    return true;
  }

  return false;
};

},{}],45:[function(require,module,exports){
// Parse backticks

'use strict';


module.exports = function backtick(state, silent) {
  var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60/* ` */) { return false; }

  start = pos;
  pos++;
  max = state.posMax;

  // scan marker length
  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }

  marker = state.src.slice(start, pos);
  openerLength = marker.length;

  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent) state.pending += marker;
    state.pos += openerLength;
    return true;
  }

  matchStart = matchEnd = pos;

  // Nothing found in the cache, scan until the end of the line (or until marker is found)
  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    // scan marker length
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }

    closerLength = matchEnd - matchStart;

    if (closerLength === openerLength) {
      // Found matching closer length.
      if (!silent) {
        token     = state.push('code_inline', 'code', 0);
        token.markup  = marker;
        token.content = state.src.slice(pos, matchStart)
          .replace(/\n/g, ' ')
          .replace(/^ (.+) $/, '$1');
      }
      state.pos = matchEnd;
      return true;
    }

    // Some different length found, put it in cache as upper limit of where closer can be found
    state.backticks[closerLength] = matchStart;
  }

  // Scanned through the end, didn't find anything
  state.backticksScanned = true;

  if (!silent) state.pending += marker;
  state.pos += openerLength;
  return true;
};

},{}],46:[function(require,module,exports){
// For each opening emphasis-like marker find a matching closing one
//
'use strict';


function processDelimiters(state, delimiters) {
  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,
      isOddMatch, lastJump,
      openersBottom = {},
      max = delimiters.length;

  if (!max) return;

  // headerIdx is the first delimiter of the current (where closer is) delimiter run
  var headerIdx = 0;
  var lastTokenIdx = -2; // needs any value lower than -1
  var jumps = [];

  for (closerIdx = 0; closerIdx < max; closerIdx++) {
    closer = delimiters[closerIdx];

    jumps.push(0);

    // markers belong to same delimiter run if:
    //  - they have adjacent tokens
    //  - AND markers are the same
    //
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }

    lastTokenIdx = closer.token;

    // Length is only used for emphasis-specific "rule of 3",
    // if it's not defined (in strikethrough or 3rd party plugins),
    // we can default it to 0 to disable those checks.
    //
    closer.length = closer.length || 0;

    if (!closer.close) continue;

    // Previously calculated lower bounds (previous fails)
    // for each marker, each delimiter length modulo 3,
    // and for whether this closer can be an opener;
    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [ -1, -1, -1, -1, -1, -1 ];
    }

    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length % 3)];

    openerIdx = headerIdx - jumps[headerIdx] - 1;

    newMinOpenerIdx = openerIdx;

    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      opener = delimiters[openerIdx];

      if (opener.marker !== closer.marker) continue;

      if (opener.open && opener.end < 0) {

        isOddMatch = false;

        // from spec:
        //
        // If one of the delimiters can both open and close emphasis, then the
        // sum of the lengths of the delimiter runs containing the opening and
        // closing delimiters must not be a multiple of 3 unless both lengths
        // are multiples of 3.
        //
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }

        if (!isOddMatch) {
          // If previous delimiter cannot be an opener, we can safely skip
          // the entire sequence in future checks. This is required to make
          // sure algorithm has linear complexity (see *_*_*_*_*_... case).
          //
          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?
            jumps[openerIdx - 1] + 1 :
            0;

          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;

          closer.open  = false;
          opener.end   = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          // treat next token as start of run,
          // it optimizes skips in **<...>**a**<...>** pathological case
          lastTokenIdx = -2;
          break;
        }
      }
    }

    if (newMinOpenerIdx !== -1) {
      // If match for this delimiter run failed, we want to set lower bound for
      // future lookups. This is required to make sure algorithm has linear
      // complexity.
      //
      // See details here:
      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442
      //
      openersBottom[closer.marker][(closer.open ? 3 : 0) + ((closer.length || 0) % 3)] = newMinOpenerIdx;
    }
  }
}


module.exports = function link_pairs(state) {
  var curr,
      tokens_meta = state.tokens_meta,
      max = state.tokens_meta.length;

  processDelimiters(state, state.delimiters);

  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(state, tokens_meta[curr].delimiters);
    }
  }
};

},{}],47:[function(require,module,exports){
// Process *this* and _that_
//
'use strict';


// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function emphasis(state, silent) {
  var i, scanned, token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) { return false; }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token         = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // A position of the token this delimiter corresponds to.
      //
      token:  state.tokens.length - 1,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end:    -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open:   scanned.can_open,
      close:  scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};


function postProcess(state, delimiters) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      max = delimiters.length;

  for (i = max - 1; i >= 0; i--) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {
      continue;
    }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the previous delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i > 0 &&
               delimiters[i - 1].end === startDelim.end + 1 &&
               // check that first two markers match and adjacent
               delimiters[i - 1].marker === startDelim.marker &&
               delimiters[i - 1].token === startDelim.token - 1 &&
               // check that last two markers are adjacent (we can safely assume they match)
               delimiters[startDelim.end + 1].token === endDelim.token + 1;

    ch = String.fromCharCode(startDelim.marker);

    token         = state.tokens[startDelim.token];
    token.type    = isStrong ? 'strong_open' : 'em_open';
    token.tag     = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup  = isStrong ? ch + ch : ch;
    token.content = '';

    token         = state.tokens[endDelim.token];
    token.type    = isStrong ? 'strong_close' : 'em_close';
    token.tag     = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup  = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = '';
      state.tokens[delimiters[startDelim.end + 1].token].content = '';
      i--;
    }
  }
}


// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function emphasis(state) {
  var curr,
      tokens_meta = state.tokens_meta,
      max = state.tokens_meta.length;

  postProcess(state, state.delimiters);

  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
};

},{}],48:[function(require,module,exports){
// Process html entity - &#123;, &#xAF;, &quot;, ...

'use strict';

var entities          = require('../common/entities');
var has               = require('../common/utils').has;
var isValidEntityCode = require('../common/utils').isValidEntityCode;
var fromCodePoint     = require('../common/utils').fromCodePoint;


var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;


module.exports = function entity(state, silent) {
  var ch, code, match, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
      match = state.src.slice(pos).match(DIGITAL_RE);
      if (match) {
        if (!silent) {
          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
        }
        state.pos += match[0].length;
        return true;
      }
    } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) { state.pending += entities[match[1]]; }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) { state.pending += '&'; }
  state.pos++;
  return true;
};

},{"../common/entities":8,"../common/utils":11}],49:[function(require,module,exports){
// Process escaped chars and hardbreaks

'use strict';

var isSpace = require('../common/utils').isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) { ESCAPED.push(0); }

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'
  .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1; });


module.exports = function escape(state, silent) {
  var ch, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C/* \ */) { return false; }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) { state.pending += state.src[pos]; }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) { break; }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) { state.pending += '\\'; }
  state.pos++;
  return true;
};

},{"../common/utils":11}],50:[function(require,module,exports){
// Process html tags

'use strict';


var HTML_TAG_RE = require('../common/html_re').HTML_TAG_RE;


function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
}


module.exports = function html_inline(state, silent) {
  var ch, match, max, token,
      pos = state.pos;

  if (!state.md.options.html) { return false; }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||
      pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21/* ! */ &&
      ch !== 0x3F/* ? */ &&
      ch !== 0x2F/* / */ &&
      !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) { return false; }

  if (!silent) {
    token         = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

},{"../common/html_re":10}],51:[function(require,module,exports){
// Process ![image](<src> "title")

'use strict';

var normalizeReference   = require('../common/utils').normalizeReference;
var isSpace              = require('../common/utils').isSpace;


module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) { return false; }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
    //
    // Inline link
    //

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace(code) && code !== 0x0A) { break; }
    }
    if (pos >= max) { return false; }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = '';
      }
    }

    // [link](  <href>  "title"  )
    //                ^^ skipping these spaces
    start = pos;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace(code) && code !== 0x0A) { break; }
    }

    // [link](  <href>  "title"  )
    //                  ^^^^^^^ parsing link title
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;

      // [link](  <href>  "title"  )
      //                         ^^ skipping these spaces
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) { break; }
      }
    } else {
      title = '';
    }

    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') { return false; }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) { label = state.src.slice(labelStart, labelEnd); }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(
      content,
      state.md,
      state.env,
      tokens = []
    );

    token          = state.push('image', 'img', 0);
    token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];
    token.children = tokens;
    token.content  = content;

    if (title) {
      attrs.push([ 'title', title ]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

},{"../common/utils":11}],52:[function(require,module,exports){
// Process [link](<to> "stuff")

'use strict';

var normalizeReference   = require('../common/utils').normalizeReference;
var isSpace              = require('../common/utils').isSpace;


module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      token,
      href = '',
      title = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) { return false; }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
    //
    // Inline link
    //

    // might have found a valid shortcut link, disable reference parsing
    parseReference = false;

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace(code) && code !== 0x0A) { break; }
    }
    if (pos >= max) { return false; }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = '';
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) { break; }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 0x0A) { break; }
        }
      }
    }

    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
      // parsing a valid shortcut link failed, fallback to reference
      parseReference = true;
    }
    pos++;
  }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') { return false; }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) { label = state.src.slice(labelStart, labelEnd); }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token        = state.push('link_open', 'a', 1);
    token.attrs  = attrs = [ [ 'href', href ] ];
    if (title) {
      attrs.push([ 'title', title ]);
    }

    state.md.inline.tokenize(state);

    token        = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

},{"../common/utils":11}],53:[function(require,module,exports){
// Proceess '\n'

'use strict';

var isSpace = require('../common/utils').isSpace;


module.exports = function newline(state, silent) {
  var pmax, max, ws, pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A/* \n */) { return false; }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        // Find whitespaces tail of pending chars.
        ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 0x20) ws--;

        state.pending = state.pending.slice(0, ws);
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }

    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace(state.src.charCodeAt(pos))) { pos++; }

  state.pos = pos;
  return true;
};

},{"../common/utils":11}],54:[function(require,module,exports){
// Inline parser state

'use strict';


var Token          = require('../token');
var isWhiteSpace   = require('../common/utils').isWhiteSpace;
var isPunctChar    = require('../common/utils').isPunctChar;
var isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;


function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).
  this.cache = {};

  // List of emphasis-like delimiters for current tag
  this.delimiters = [];

  // Stack of delimiter lists for upper level tags
  this._prev_delimiters = [];

  // backtick length => last seen position
  this.backticks = {};
  this.backticksScanned = false;
}


// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
};


// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);
  var token_meta = null;

  if (nesting < 0) {
    // closing tag
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }

  token.level = this.level;

  if (nesting > 0) {
    // opening tag
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  this.tokens_meta.push(token_meta);
  return token;
};


// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start, lastChar, nextChar, count, can_open, can_close,
      isLastWhiteSpace, isLastPunctChar,
      isNextWhiteSpace, isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking  || isNextPunctChar);
  } else {
    can_open  = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open:  can_open,
    can_close: can_close,
    length:    count
  };
};


// re-export Token class to use in block rules
StateInline.prototype.Token = Token;


module.exports = StateInline;

},{"../common/utils":11,"../token":58}],55:[function(require,module,exports){
// ~~strike through~~
//
'use strict';


// Insert each marker as a separate text token, and add it to delimiter list
//
module.exports.tokenize = function strikethrough(state, silent) {
  var i, scanned, token, len, ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) { return false; }

  if (marker !== 0x7E/* ~ */) { return false; }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) { return false; }

  if (len % 2) {
    token         = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token         = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      length: 0,     // disable "rule of 3" length checks meant for emphasis
      token:  state.tokens.length - 1,
      end:    -1,
      open:   scanned.can_open,
      close:  scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};


function postProcess(state, delimiters) {
  var i, j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      max = delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E/* ~ */) {
      continue;
    }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token         = state.tokens[startDelim.token];
    token.type    = 's_open';
    token.tag     = 's';
    token.nesting = 1;
    token.markup  = '~~';
    token.content = '';

    token         = state.tokens[endDelim.token];
    token.type    = 's_close';
    token.tag     = 's';
    token.nesting = -1;
    token.markup  = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' &&
        state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
}


// Walk through delimiter list and replace text tokens with tags
//
module.exports.postProcess = function strikethrough(state) {
  var curr,
      tokens_meta = state.tokens_meta,
      max = state.tokens_meta.length;

  postProcess(state, state.delimiters);

  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
};

},{}],56:[function(require,module,exports){
// Skip text characters for text token, place those to pending buffer
// and increment current pos

'use strict';


// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A/* \n */:
    case 0x21/* ! */:
    case 0x23/* # */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x26/* & */:
    case 0x2A/* * */:
    case 0x2B/* + */:
    case 0x2D/* - */:
    case 0x3A/* : */:
    case 0x3C/* < */:
    case 0x3D/* = */:
    case 0x3E/* > */:
    case 0x40/* @ */:
    case 0x5B/* [ */:
    case 0x5C/* \ */:
    case 0x5D/* ] */:
    case 0x5E/* ^ */:
    case 0x5F/* _ */:
    case 0x60/* ` */:
    case 0x7B/* { */:
    case 0x7D/* } */:
    case 0x7E/* ~ */:
      return true;
    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) { return false; }

  if (!silent) { state.pending += state.src.slice(state.pos, pos); }

  state.pos = pos;

  return true;
};

// Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

},{}],57:[function(require,module,exports){
// Clean up tokens after emphasis and strikethrough postprocessing:
// merge adjacent text nodes into one and re-calculate all token levels
//
// This is necessary because initially emphasis delimiter markers (*, _, ~)
// are treated as their own separate text tokens. Then emphasis rule either
// leaves them as text (needed to merge with adjacent text) or turns them
// into opening/closing tags (which messes up levels inside).
//
'use strict';


module.exports = function text_collapse(state) {
  var curr, last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels after emphasis/strikethrough turns some text nodes
    // into opening/closing tags
    if (tokens[curr].nesting < 0) level--; // closing tag
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0) level++; // opening tag

    if (tokens[curr].type === 'text' &&
        curr + 1 < max &&
        tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) { tokens[last] = tokens[curr]; }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

},{}],58:[function(require,module,exports){
// Token class

'use strict';


/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/
function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type     = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag      = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs    = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map      = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting  = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level    = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content  = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup   = '';

  /**
   * Token#info -> String
   *
   * Additional information:
   *
   * - Info string for "fence" tokens
   * - The value "auto" for autolink "link_open" and "link_close" tokens
   * - The string value of the item marker for ordered-list "list_item_open" tokens
   **/
  this.info     = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta     = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block    = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden   = false;
}


/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) { return -1; }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) { return i; }
  }
  return -1;
};


/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [ attrData ];
  }
};


/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [ name, value ];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};


/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name), value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};


/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([ name, value ]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};


module.exports = Token;

},{}],59:[function(require,module,exports){

'use strict';


/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i, ch, cache = decodeCache[exclude];
  if (cache) { return cache; }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}


// Decode percent-encoded string.
//
function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    var i, l, b1, b2, b3, b4, chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);

          if (chr < 0x80) {
            result += '\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);

          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {
            result += '\ufffd\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\ufffd\ufffd\ufffd\ufffd';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\ufffd';
    }

    return result;
  });
}


decode.defaultChars   = ';/?:@&=+$,#';
decode.componentChars = '';


module.exports = decode;

},{}],60:[function(require,module,exports){

'use strict';


var encodeCache = {};


// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) { return cache; }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}


// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i, l, code, nextCode, cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped  = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";


module.exports = encode;

},{}],61:[function(require,module,exports){

'use strict';


module.exports = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

},{}],62:[function(require,module,exports){
'use strict';


module.exports.encode = require('./encode');
module.exports.decode = require('./decode');
module.exports.format = require('./format');
module.exports.parse  = require('./parse');

},{"./decode":59,"./encode":60,"./format":61,"./parse":63}],63:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = [ '<', '>', '"', '`', ' ', '\r', '\n', '\t' ],

    // RFC 2396: characters not allowed for various reasons.
    unwise = [ '{', '}', '|', '\\', '^', '`' ].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = [ '\'' ].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),
    hostEndingChars = [ '/', '?', '#' ],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    /* eslint-disable no-script-url */
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    };
    /* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, slashesDenoteHost) {
  var i, l, lowerProto, hec, slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') { hostEnd--; }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function(host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

module.exports = urlParse;

},{}],64:[function(require,module,exports){
(function (global){(function (){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],65:[function(require,module,exports){
module.exports=/[\0-\x1F\x7F-\x9F]/
},{}],66:[function(require,module,exports){
module.exports=/[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/
},{}],67:[function(require,module,exports){
module.exports=/[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/
},{}],68:[function(require,module,exports){
module.exports=/[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/
},{}],69:[function(require,module,exports){
'use strict';

exports.Any = require('./properties/Any/regex');
exports.Cc  = require('./categories/Cc/regex');
exports.Cf  = require('./categories/Cf/regex');
exports.P   = require('./categories/P/regex');
exports.Z   = require('./categories/Z/regex');

},{"./categories/Cc/regex":65,"./categories/Cf/regex":66,"./categories/P/regex":67,"./categories/Z/regex":68,"./properties/Any/regex":70}],70:[function(require,module,exports){
module.exports=/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
},{}],71:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-checkconfigupdate
 * @requires module:pulseComponent
 * 
 * Check if the config ON THE SERVER changed
 */
var pulseComponent = require('pulsecomponent');
var pulseConfig = require('pulseConfig');
var eventBus = require('eventBus');

(function () {

  class checkconfigupdateComponent extends pulseComponent.PulseParamAutoPathRefreshingComponent {
    initialize () {
      this.addClass('pulse-nodisplay');
      
      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    validateParameters () {
      this.switchToNextContext();
    }

    displayError (message) {
      // Do nothing
    }

    removeError () {
      // Do nothing
      this.displayError('');
    }

    get refreshRate () {
      // Return here the refresh rate in ms.
      return 1000 * Number(this.getConfigOrAttribute('refreshSeconds', 300));
    }

    getShortUrl () {
      // Return the Web Service URL here without path
      return 'Config/LastUpdate';
    }

    refresh (data) {
      // Update the component
      if (typeof this._updateDateTime == 'undefined') {
        this._updateDateTime = data.UpdateDateTime;
      }
      else {
        let configHasChanged = true;
        if (JSON.stringify(this._updateDateTime) === JSON.stringify(data.UpdateDateTime)) {
          configHasChanged = false;
        }
        if (configHasChanged) {
          let href = window.location.href;
          if ('live' == pulseConfig.getAppContextOrRole()) {
            // reload for live
            window.open(href, '_self');
          }
          else {
            // Display a message
            let messageInfo = {
              'id': 'CONFIG Server',
              'message': 'Configuration on server has changed ',
              'level': 'info',
              'clickToClose': false,
              'reloadURL': href
            };
            eventBus.EventBus.dispatchToAll('showMessageSignal',
              messageInfo);
          }
        }
      }
    }
  }

  pulseComponent.registerElement('x-checkconfigupdate', checkconfigupdateComponent);
})();

},{"eventBus":"eventBus","pulseConfig":"pulseConfig","pulsecomponent":2}],72:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-checkcurrenttime
 * @requires module:pulseComponent
 */

var pulseComponent = require('pulsecomponent');
var pulseConfig = require('pulseConfig');
var eventBus = require('eventBus');

/**
 * Build a custom tag <x-checkcurrenttime> to check currenttime.  
 */
(function () {

  class CheckCurrentTimeComponent extends pulseComponent.PulseParamAutoPathRefreshingComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      // DOM -> never in contructor
      self._content = undefined; // Optional

      return self;
    }

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
    }

    initialize () {
      this.addClass('pulse-nodisplay');

      // Update here some internal parameters

      // listeners

      // In case of clone, need to be empty :
      //$(this.element).empty();

      // Create DOM - NO DOM

      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    /**
     * Validate the (event) parameters
     */
    validateParameters () {
      this.switchToNextContext();
    }

    // Overload to always refresh value
    get isVisible () {
      return true;
    }

    get refreshRate () {
      // Return here the refresh rate in ms. 
      return 1000 * 60 * 60 * 24; // 1 day
    }

    getShortUrl () {
      // Return the Web Service URL here without path
      let url = 'CurrentTime/';
      return url;
    }

    refresh (data) {
      let now = new Date();
      let serverDate = new Date(data.Utc);

      // Find diff + store
      let diffServerTimeMinusNowMSec = serverDate.getTime() - now.getTime();
      pulseConfig.setGlobal('diffServerTimeMinusNowMSec', diffServerTimeMinusNowMSec);

      // default 30 seconds (can be overload)
      let allowedDiff = this.getConfigOrAttribute('seconds', '30');
      if (Math.abs(diffServerTimeMinusNowMSec) > allowedDiff * 1000) {
        let messageInfo = {
          'id': 'Current Time',
          'message': pulseConfig.pulseTranslate('check.PleaseSyncTime',
            'Please synchonize date and time '),
          'level': 'warning',
          'clickToClose': true
        };
        //messageInfo.id = id;
        // 'permanent' -> NO messageInfo.time
        messageInfo.clickToClose = false;
        eventBus.EventBus.dispatchToAll('showMessageSignal',
          messageInfo);
      }
    }

    // Callback events
  }

  pulseComponent.registerElement('x-checkcurrenttime',
    CheckCurrentTimeComponent);
})();

},{"eventBus":"eventBus","pulseConfig":"pulseConfig","pulsecomponent":2}],73:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-checklogin
 * @requires module:pulseComponent
 */
var pulseComponent = require('pulsecomponent');
var pulseConfig = require('pulseConfig');
var pulseLogin = require('pulseLogin');
var pulseService = require('pulseService');
//var pulseUtility = require('pulseUtility');
var eventBus = require('eventBus');

(function () {

  class CheckLoginComponent extends pulseComponent.PulseParamAutoPathSingleRequestComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      //self._content = undefined;
      self._pendingRefreshToken = false;

      return self;
    }

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
      /*switch (attr) {
        default:
          break;
      }*/
    }

    initialize () {
      this.addClass('pulse-nodisplay');
      //this.addClass('pulse-text'); // Mandatory for loader
      
      // Listener and dispatchers
      eventBus.EventBus.addGlobalEventListener(this, 'AuthorizationErrorEvent',
        this.onAuthorizationError.bind(this));

      eventBus.EventBus.addGlobalEventListener(this, 'TokenHasChangedEvent',
        this.onTokenHaschanged.bind(this));

      // In case of clone, need to be empty :
      $(this.element).empty();

      // No DOM

      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    clearInitialization () {
      super.clearInitialization();
    }

    validateParameters () {
      // If connection not allowed - return to page login

      if (!pulseConfig.isLoginPage()) { // If not in page login or validate
        // FOR Pulse Web App - app context or role is mandatory
        if (pulseConfig.isCurrentApp('PulseWebApp')) {
          if ('' == pulseConfig.getAppContextOrRole()) {
            // Clean all cookies linked to login
            pulseLogin.cleanLoginRole();

            // Role or AppContext is mandatory -> go to page login (if not)
            pulseConfig.goToPageLogin();
            return;
          }
        }

        // FOR ALL apps, check login
        this._checkLoginIsValid();
      }

      this.switchToContext('Loaded'); // To stop refresh 

      // this.switchToNextContext();-> to restore if web service is used
    }

    _checkLoginIsValid () {
      let useLogin = pulseConfig.getBool('useLogin', false);
      if (useLogin) {
        if ('' == pulseLogin.getLogin()) {
          this._disconnectAndGoToPageLogin();
          return;
        }
        else {
          // Check Token expiration
          if (this._checkIfTokenIsExpired()) {
            this._disconnectAndGoToPageLogin();
            return;
          }

          // Start timer to check if another page / tab / app asked for deconnection
          this._checkLoginIsValidTimer = setTimeout(
            this._checkLoginIsValid.bind(this),
            60000); // 1 min
        }
      }
    }

    displayError (message) {
      // Nothing
    }

    removeError () {
      // Nothing
    }

    getShortUrl () {
      // Return the Web Service URL here without path
      //return 'Get...' + this.element.getAttribute('myattr');
      return '';
    }

    refresh (data) {
      // Update the component with data which is returned by the web service in case of success
      // For example:
      //$(this._content).html(data.Name);
    }

    /**
     * Event callback in case a config is updated: (re-)start the component
     *
     * @param {*} event
     */
    onConfigChange (event) {
      // Default = do nothing
      // Maybe re start ?
    }

    // Token changed -> prepare timeout for disconnection (useful for static display like reporting)
    onTokenHaschanged (event) {
      if (event.target.kind != 'AccessToken') {
        // Ignore
        return;
      }
      // Check Token expiration
      if (this._checkIfTokenIsExpired()) {
        this._disconnectAndGoToPageLogin();
        return;
      }
    }

    _checkIfTokenIsExpired () {
      let access_token_exp = pulseLogin.getAccessTokenExpiration();
      if (access_token_exp == '') {
        // Nothing to do
        return false;
      }

      let now = new Date();
      let tokenDate = new Date(access_token_exp);

      // Find diff + store
      let diffMSec = tokenDate.getTime() - now.getTime();
      if (diffMSec > 0) {
        return false;
      }
      else {
        return true; // expired
      }
    }

    _disconnectAndGoToPageLogin () {
      // Clean all cookies linked to login
      pulseLogin.cleanLoginRole();

      // Goto page login with an error message to be displayed
      if (!pulseConfig.isLoginPage()) { // If not in page login
        pulseConfig.goToPageLogin();
        return true;
      }
    }

    // Token expired -> GLOBAL refresh token
    onAuthorizationError (event) {
      if (!this._pendingRefreshToken) {
        this._pendingRefreshToken = true;

        let login = pulseLogin.getLogin();
        let refresh_token = pulseLogin.getRefreshToken();

        if (login == '' ||
          refresh_token == '') {
          // Error
          this._renewTokenError.bind(this);
          return;
        }

        let url = this.getConfigOrAttribute('path', '')
          + 'User/RenewToken';

        let timeout = this.timeout;
        pulseService.postAjax(0, url,
          {
            'Login': login,
            'RefreshToken': refresh_token
          },
          timeout,
          this._renewTokenSuccess.bind(this),
          this._renewTokenError.bind(this),
          this._renewTokenFail.bind(this));
      }
    }

    _renewTokenSuccess (token, data) {
      pulseLogin.storeLoginRoleFromRefreshDTO(data, true);
      this._pendingRefreshToken = false;
    }

    _renewTokenError (token, error) {
      pulseConfig.setGlobal('loginError', 'Authentication Error. Please retry');
      // Clean all cookies linked to login
      pulseLogin.cleanLoginRole();

      // Goto page login with an error message to be displayed
      if (!pulseConfig.isLoginPage()) { // If not in page login
        pulseConfig.goToPageLogin();
        return true;
      }
      this._pendingRefreshToken = false;
    }

    _renewTokenFail (token, url, isTimeout, xhrStatus) {
      pulseConfig.setGlobal('loginError', 'Authentication Error. Please retry');
      // Clean all cookies linked to login
      pulseLogin.cleanLoginRole();

      // Goto page login with an error message to be displayed
      if (!pulseConfig.isLoginPage()) { // If not in page login
        pulseConfig.goToPageLogin();
        return true;
      }
      this._pendingRefreshToken = false;
    }

  }

  pulseComponent.registerElement('x-checklogin', CheckLoginComponent);
})();

},{"eventBus":"eventBus","pulseConfig":"pulseConfig","pulseLogin":"pulseLogin","pulseService":"pulseService","pulsecomponent":2}],74:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-checkpath
 * @requires module:pulseComponent
 */
var pulseComponent = require('pulsecomponent');
var pulseConfig = require('pulseConfig');
var eventBus = require('eventBus');

(function () {

  class CheckPathComponent extends pulseComponent.PulseParamSingleRequestComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      self._content = undefined;

      return self;
    }

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
    }

    initialize () {
      this.addClass('pulse-nodisplay');

      //this.addClass('pulse-bigdisplay');

      // Create DOM - Loader (DO NOT REMOVE code => will be used once the global error message will display info)
      // To display BIG LOADING on the whole page - removed FOR THE MOMENT
      // DO NOT REMOVE THESE 2 LINES !!!
      /*let loader = $('<div></div>').addClass('pulse-loader').html('Loading...').css('display', 'none');
      let loaderDiv = $('<div></div>').addClass('pulse-loader-div').append(loader);
      $(this._content).append(loaderDiv);*/
      // Create DOM - Content
      //this._content = $('<div></div>').addClass('pulse-checkpath-content');

      // Listener

      // Initialization OK => switch to the next context
      this.switchToNextContext();
    }

    validateParameters () {
      // Additional checks with attribute param
     
      let skip = this.getConfigOrAttribute('skipWebServiceAddress', 'false');

      if ( skip == true || skip == 'true' ) {
        let mainpath = this.getConfigOrAttribute('mainpath', ''); // Probably ""
        if (mainpath != '') {
          // '/' at the end ?
          let lastChar = mainpath.charAt(mainpath.length - 1);
          if (lastChar != '/') {
            mainpath = mainpath + '/';
          }
          let oldpath = this.getConfigOrAttribute('path', '');
          if (oldpath != mainpath) { // Reload only if different, else endless reload at beginning when server is stopped.
            pulseConfig.setGlobal('path', mainpath); // SessionStorage
            // Warn all components to reload :
            eventBus.EventBus.dispatchToAll('pathChangeEvent', {});
          }
        }
        this.setError('Skip web service path');
      }
      else{
        this.switchToNextContext();
      }
    }

    // Overload to always refresh value
    get isVisible () {
      if (!this._connected) { // == is connected
        return false;
      }
      return true;
    }

    get url () {
      let mainpath = this.getConfigOrAttribute('mainpath', ''); // Probably ""
      if (mainpath == '') {
        let href = window.location.href;
        // Hack for local path (on dev computers)
        if ('file' == href.slice(0, 4)) {
          mainpath = 'https://lctr:5001/';
        }
        else {
          // Search in Page URL : http://lctr/RtdWebApp/...
          let posSlash = href.indexOf('/', 8);  // = more than 7<->length of http://
          if (posSlash != -1) {
            mainpath = href.slice(0, posSlash) + ':5001/'; // https://lctr:5001
            if ( mainpath.indexOf('https') != -1 ) {
              // path do not include 'https'
              if ( mainpath.startsWith('http') ) {
                // Add 's' after http
                mainpath = 'https' + mainpath.slice(4);
              }
            }
          }
        }
      }
      // '/' at the end ?
      let lastChar = mainpath.charAt(mainpath.length - 1);
      if (lastChar != '/') {
        mainpath += '/';
      }
      // Return the Web Service URL here
      return mainpath + 'WebServiceAddress/';
    }

    refresh (data) {
      let previousPath = this.getConfigOrAttribute('path', '');

      let secondarypath = data.Url;
      if (secondarypath.length > 1) {
        // '/' at the end ?
        let lastChar = secondarypath.charAt(secondarypath.length - 1);
        if (lastChar != '/') {
          secondarypath = secondarypath + '/';
        }
      }
      pulseConfig.setGlobal('path', secondarypath); // SessionStorage
      if (secondarypath != previousPath) {
        // Warn all components to reload :
        console.log('dispatch path change event');
        eventBus.EventBus.dispatchToAll('pathChangeEvent', {});
      }
    }

    manageError (data) {
      /* NO Message here, because it can happens if WebServiceAddress is badly configured
      var messageInfo = {
        'id': 'MAINPATH',
        'message': pulseConfig.pulseTranslate('check.PleaseCheckServerOrPath', 'Please check server access (or path)'),
        // Keep or mainpath here. Because it is probably linked to path when the message comes from here --RR
        'level': 'error',
        'time': 20 // seconds to display message
      };
      messageInfo.clickToClose = true;
      eventBus.EventBus.dispatchToAll('showMessageSignal',
        messageInfo);*/

      // In case of error, try to use mainpath defined in config
      let mainpath = this.getConfigOrAttribute('mainpath', ''); // Probably ""
      if (mainpath != '') {
        // '/' at the end ?
        let lastChar = mainpath.charAt(mainpath.length - 1);
        if (lastChar != '/') {
          mainpath = mainpath + '/';
        }
        let oldpath = this.getConfigOrAttribute('path', '');
        if (oldpath != mainpath) { // Reload only if different, else endless reload at beginning when server is stopped.
          pulseConfig.setGlobal('path', mainpath); // SessionStorage
          // Warn all components to reload :
          eventBus.EventBus.dispatchToAll('pathChangeEvent', {});
        }
      }

      super.manageError(data);
    }

    manageFailure (isTimeout, xhrStatus) {
      var messageInfo = {
        'id': 'PATH',
        'message': pulseConfig.pulseTranslate('check.PleaseCheckServerOrPath', 'Please check server access (or path)'),
        // Keep 'or path' here. Because it is probably linked to path when the message comes from here --RR
        'level': 'error',
        'time': 20 // seconds to display message
      };
      messageInfo.clickToClose = true;
      eventBus.EventBus.dispatchToAll('showMessageSignal',
        messageInfo);

      // In case of error, try to use mainpath defined in config
      let mainpath = this.getConfigOrAttribute('mainpath', ''); // Probably ""
      if (mainpath != '') {
        // '/' at the end ?
        let lastChar = mainpath.charAt(mainpath.length - 1);
        if (lastChar != '/') {
          mainpath = mainpath + '/';
        }
        let oldpath = this.getConfigOrAttribute('path', '');
        if (oldpath != mainpath) { // Reload only if different, else endless reload at beginning when server is stopped.
          pulseConfig.setGlobal('path', mainpath); // SessionStorage
          // Warn all components to reload :
          eventBus.EventBus.dispatchToAll('pathChangeEvent', {});
        }
      }

      super.manageFailure(isTimeout, xhrStatus);
    }
  }

  pulseComponent.registerElement('x-checkpath', CheckPathComponent);
})();

},{"eventBus":"eventBus","pulseConfig":"pulseConfig","pulsecomponent":2}],75:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-checkserveraccess
 * @requires module:pulseComponent
 */
var pulseComponent = require('pulsecomponent');
var eventBus = require('eventBus');
var pulseSvg = require('pulseSvg');
var pulseConfig = require('pulseConfig');

(function () {

  class CheckServerAccessComponent extends pulseComponent.PulseParamAutoPathRefreshingComponent {

    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      self._databaseIsDisconnected = false;
      self._serverProbablyOff = false;
      this._serverProbablyDisconnected = false;

      return self;
    }


    initialize () {
      this.addClass('pulse-nodisplay');
      
      // In case of clone, need to be empty :
      $(this.element).empty();
      this._databaseIsDisconnected = false;

      // listeners
      eventBus.EventBus.addGlobalEventListener(this, 'serverProbablyDisconnected',
        this.onServerProbablyDisconnectedChange.bind(this));
      eventBus.EventBus.addGlobalEventListener(this, 'databaseProbablyDisconnected',
        this.onDatabaseDisconnectedChange.bind(this));
      eventBus.EventBus.addGlobalEventListener(this, 'pulseMaintenance',
        this.onPulseMaintenance.bind(this));

      // Create DOM - None

      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    /**
      * Clear anything that was done during intialization, so that initialize can be called once again.
      * Remove all the dispatchers and listeners.
      * Please note that no state switch is done here
    */
    clearInitialization () {
      // DOM
      $(this.element).empty();

      this._databaseIsDisconnected = false;

      super.clearInitialization();
    }

    reset () { // Optional implementation = called after 'start'
      // Code here to clean the component when the component has been initialized
      // for example after a parameter change
      //this.removeError();
      // Empty this._content

      // this._databaseIsDisconnected = false;... Surtout pas ! le restart passe ici

      this.switchToNextContext();
    }

    /**
     * Validate the (event) parameters
     */
    validateParameters () {
      this.switchToNextContext();
    }

    manageError (data) {
      super.manageError(data);
    }

    displayError (message) {
      // Not here !!! Can be called anywhere else
    }

    displayErrorAndStopAll () {
      // No display but send message for outside display

      let messageInfo = {
        'id': 'NO_SERVER', // same as clear
        'message': pulseConfig.pulseTranslate('check.PleaseCheckServer',
          'Please check server access'), // server OR database
        'level': 'error', // or 'warning', ?
        'clickToClose': false
      };

      if (this._databaseIsDisconnected) {
        messageInfo.message = pulseConfig.pulseTranslate('check.PleaseDatabaseAccess',
          'Please check database access');
      }

      eventBus.EventBus.dispatchToAll('showMessageSignal', messageInfo);

      // Store state
      this._serverProbablyOff = true;
      eventBus.EventBus.dispatchToAll('serverProbablyOffStopRefresh', {});
    }

    removeError () {
      // Do nothing
      //this._databaseIsDisconnected = false; ... Surtout pas ! le restart passe ici
    }

    get refreshRate () {
      return 1000 * Number(this.getConfigOrAttribute('refreshingRate.currentRefreshSeconds', 10));
    }

    get transientErrorDelay () {
      //return Number(1000); // == 1sec // DO NOT USE freezeMinutes == too long *
      let basicFreezeMinutes = this.getConfigOrAttribute('stopRefreshingRate.freezeMinutes', this._defaultTransientErrorDelay / 60 / 1000);
      let fastRefreshRate = 1000 * Number(this.getConfigOrAttribute('refreshingRate.currentRefreshSeconds', 10));
      return (Number(basicFreezeMinutes) * 60 * 1000)
        - 2 * fastRefreshRate; // To refresh faster than other components = avoid long 'Not Connected' display
    }

    getShortUrl () {
      let url = 'Data/Computer/GetLctr?Cache=No'; // was 'Test';
      return url;
    }

    manageSuccess (data) {
      // Hide message
      let messageInfo = {
        'id': 'NO_SERVER' // same as show
      };
      eventBus.EventBus.dispatchToAll('clearMessageSignal', messageInfo);

      // Hide 'Maintenance' - always to be sure !
      pulseSvg.hidePulseMaintenance();

      if (this._databaseIsDisconnected || this._serverProbablyOff) {
        this._databaseIsDisconnected = false;
        this._serverProbablyOff = false;

        // start to load data again (database / server or maintenance END )
        eventBus.EventBus.dispatchToAll('serverProbablyAvailable', {});
      }
      else { // Call here too to avoid frozen display
        // start to load data again (database / server or maintenance END )
        eventBus.EventBus.dispatchToAll('serverProbablyAvailable', {});
      }
      this._serverProbablyDisconnected = false;

      // Stop context
      this.switchToContext('Stop');
    }

    // Callback events

    /**
     * Event bus callback triggered when receivving event server probably diconnected
     *
     * @param {Object} event
     */
    onServerProbablyDisconnectedChange (event) {
      /* DO NOT REMOVE : here is how to find origin of info : */
      /*let target = event.target;
      let url = event.target.url;
      let source = event.target.source;
      let when = event.target.when;*/

      if (false == this._serverProbablyDisconnected) {
        this._serverProbablyDisconnected = true;
        this._serverProbablyDisconnectedSince = new Date();
      }
      else { // = if (this._serverProbablyDisconnected == true)
        let now = new Date();
        let elapsedMSec = now.getTime() - this._serverProbablyDisconnectedSince.getTime();

        // Display after 1 minute == when we are sure that many services failed, for example
        let Min = 1;
        if (elapsedMSec >= Min * 60 * 1000) {
          // Check my self if it is true

          // DO NOT removed comment yet -- 2022 02
          // The following code will be executed if server is REALLY disconnected = manageError
          // Store state
          //this._serverProbablyOff = true;
          // Stop All components
          //eventBus.EventBus.dispatchToAll('serverProbablyOffStopRefresh', {}); -> NO
          //this.displayError(''); // == display message AND Call onServerOffStopRefresh
          this.displayErrorAndStopAll();
        }
        if (this.stateContext == 'Stop') {
          // Start checking again
          this.start();
        }
      }
    }

    /**
     * Event bus callback triggered when receivving event server probably diconnected
     *
     * @param {Object} event
     */
    onDatabaseDisconnectedChange (event) {
      /* DO NOT REMOVE : here is how to find origin of info : */
      /*let target = event.target;
      let url = event.target.url;
      let source = event.target.source;
      let when = event.target.when;*/

      this._databaseIsDisconnected = true;

      //this.displayError(''); // == display message AND Call onServerOffStopRefresh
      this.displayErrorAndStopAll();

      if (this.stateContext == 'Stop') {
        // Start checking again
        this.start();
      } // else continue
    }

    /**
     * Event bus callback triggered when receivving event pulse maintenance
     *
     * @param {Object} event
     */
    onPulseMaintenance (event) {
      /* DO NOT REMOVE : here is how to find origin of info : */
      /*let target = event.target;
      let url = event.target.url;
      let source = event.target.source;
      let when = event.target.when;*/

      // Display 'Maintenance' if not already done
      pulseSvg.showPulseMaintenance();

      // Store state
      this._serverProbablyOff = true;
      // Stop All components
      eventBus.EventBus.dispatchToAll('serverProbablyOffStopRefresh', {});
      if (this.stateContext == 'Stop') {
        // Start checking again
        this.start();
      }  // else continue

    }

    /**
     * Default event callback in case server is off : OVERLOAD - Do nothing
     * 
     * @param {*} event 
     */
    onServerOffStopRefresh (event) {
      // Nothing -> to keep == overload default
      //console.log('checkserveraccess.onServerOffStopRefresh');
    }

    /**
     * Default event callback in case server is available: OVERLOAD - Do nothing
     * 
     * @param {*} event 
     */
    onServerAvailableChange (event) {
      // Nothing -> to keep == overload default
    }

    // Not added, included in previous ones
    // onDatabaseOffStopRefresh
    // onDatabaseAvailableChange 

  }

  pulseComponent.registerElement('x-checkserveraccess', CheckServerAccessComponent);
})();

},{"eventBus":"eventBus","pulseConfig":"pulseConfig","pulseSvg":"pulseSvg","pulsecomponent":2}],76:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-checkversion
 * @requires module:pulseComponent
 */
var pulseComponent = require('pulsecomponent');
var pulseUtility = require('pulseUtility');
var pulseConfig = require('pulseConfig');
var eventBus = require('eventBus');

(function () {

  class checkversionComponent extends pulseComponent.PulseParamAutoPathRefreshingComponent {
    initialize () {
      this.addClass('pulse-nodisplay');
      
      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }
    
    validateParameters () {
      this.switchToNextContext();
    }

    displayError (message) {
      // Do nothing
    }

    removeError () {
      // Do nothing
      this.displayError('');
    }

    get refreshRate () {
      // Return here the refresh rate in ms.
      return 60 * 60 * 1000; // Check every hour
    }

    getShortUrl () {
      // Return the Web Service URL here without path
      return 'PulseVersions/Get';
    }

    refresh (data) {
      // Update the component
      if (typeof this._currentVersions == 'undefined') {
        this._currentVersions = data.Versions;
      }
      else {
        let versionsHasChanged = true;
        if (JSON.stringify(this._currentVersions) === JSON.stringify(data.Versions)) {
          versionsHasChanged = false;
        }
        if (versionsHasChanged) { // reload
          let href = window.location.href;
          href = pulseUtility.changeURLParameter(href,
            'pulseVersion', data.Versions.Pulse);

          if ('live' == pulseConfig.getAppContextOrRole()) {
            // direct reload for live
            window.open(href, '_self');
          }
          else {
            // Display a message
            let messageInfo = {
              'id': 'Version',
              'message': 'Version has changed ',
              'level': 'info',
              'clickToClose': false,
              'reloadURL': href
            };
            eventBus.EventBus.dispatchToAll('showMessageSignal',
              messageInfo);
          }
        }
      }
    }
  }

  pulseComponent.registerElement('x-checkversion', checkversionComponent);
})();

},{"eventBus":"eventBus","pulseConfig":"pulseConfig","pulseUtility":"pulseUtility","pulsecomponent":2}],77:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-clock
 * @requires module:pulseComponent
 */

var pulseComponent = require('pulsecomponent');


/**
 * Build a custom tag <x-clock> to display an clock component. This tag gets following attribute : 
*  display-seconds : Boolean
*  display-24h : Boolean
 */
(function () {

  class ClockComponent extends pulseComponent.PulseInitializedComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      // DOM
      self._textclock = undefined;
      self._content = undefined;


      return self;
    }

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
      switch (attr) {
        case 'display-seconds':
        case 'display-24h':
          this.start();
          break;
        default:
          break;
      }
    }

    initialize () {
      this.addClass('pulse-text');

      // In case of clone, need to be empty :
      $(this.element).empty();

      // Create DOM - No Loader / no error

      // Create DOM - Content
      this._textclock = $('<div>00:00:00</div>').addClass('clock-text');
      this._content = $('<div></div>').addClass('clock-div')
        .append(this._textclock);
      $(this.element).append(this._content);

      this._startTime();

      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    clearInitialization () {
      // Parameters
      // DOM
      $(this.element).empty();
      this._textclock = undefined;
      this._content = undefined;
      
      super.clearInitialization();
    }

    _startTime () {
      let now = moment();

      let stringToDisplay = '';
      let msBeforeNextChange = 1000 - now.millisecond();
      if (this.element.getAttribute('display-seconds') == 'true'
        || this.element.getAttribute('display-seconds') == true) {
        if (this.element.getAttribute('display-24h') == 'true'
          || this.element.getAttribute('display-24h') == true) {
          stringToDisplay = now.format('HH:mm:ss');
        }
        else {
          stringToDisplay = now.format('hh:mm:ss a');
        }
      }
      else { //let stringToDisplay = now.format('LT');
        if (this.element.getAttribute('display-24h') == 'true'
          || this.element.getAttribute('display-24h') == true) {
          stringToDisplay = now.format('HH:mm');
        }
        else {
          stringToDisplay = now.format('hh:mm a');
        }
        msBeforeNextChange += 1000 * (60 - now.second());
      }
      this._textclock.html(stringToDisplay);
      setTimeout(this._startTime.bind(this), msBeforeNextChange);
    }
  }

  pulseComponent.registerElement('x-clock', ClockComponent, ['display-seconds', 'display-24h']);
})();

},{"pulsecomponent":2}],78:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-datepicker
 * @requires module:pulseComponent
 */

var pulseComponent = require('pulsecomponent');
var pulseUtility = require('pulseUtility');

/**
 * Build a custom tag <x-datepicker> to display a date selector. This tag gets following attribute : 
 *  defaultdate : String (ISO)
 *  mindate : String
 *  maxdate : String
 *  disabled
 */
(function () {

  class DatePickerComponent extends pulseComponent.PulseParamInitializedComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      // Parameters - Default values
      self._dateInput = undefined;

      self.methods = {
        isValid: self.isValid,
        getISOValue: self.getISOValue,
        getValueAsIs: self.getValueAsIs
      };

      return self;
    }

    //get content () { return this._content; }

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
      switch (attr) {
        case 'disabled': {
          if (this.isInitialized()) {
            if (this.element.hasAttribute('disabled')
              && (newVal == 'disabled' || newVal == 'true')) {
              this._dateInput[0].disabled = true;
            }
            else {
              this._dateInput[0].disabled = false;
            }
          }
        } break;
        case 'defaultdate':
          if (this.isInitialized()) {
            this._setDefaultDate();
          }
          break;
        case 'maxdate':
          if (this.isInitialized()) {
            this._fillMinMaxDate();
          }
          break;
        case 'mindate':
          if (this.isInitialized()) {
            this._fillMinMaxDate();
          }
          break;
        default:
          console.warn('Unhandled attribute : ' + attr);
          break;
      }
    }

    initialize () {
      //this.addClass('pulse-bigdisplay'); -> No

      // Create DOM - NO Loader
      let dateDiv = $('<div></div>').addClass('datepicker-datediv');
      $(this.element).append(dateDiv);

      // DOM - date
      this._dateInput = $('<input type="date"></input>')
        .addClass('datepicker-input-date');
      dateDiv.append(this._dateInput);

      // if disabled
      if (this.element.hasAttribute('disabled')
        && (this.element.getAttribute('disabled') == 'disabled'
          || this.element.getAttribute('disabled') == 'true')) {
        this._dateInput[0].disabled = true;
      }

      // Fill Date
      this._setDefaultDate();

      // Set min/max date
      this._fillMinMaxDate();

      this._dateInput.change(function () {
        // Restore default if empty
        if ('' == this._dateInput[0].value) {
          this._setDefaultDate();
        }

        // Tell parent if needed
        var event = new Event('change');
        this.element.dispatchEvent(event);

      }.bind(this));

      // NO - Listener and dispatcher

      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    clearInitialization () {
      // DOM
      $(this.element).empty();

      super.clearInitialization();
    }

    reset () { // Optional implementation
      // Code here to clean the component when the component has been initialized for example after a parameter change
      this.removeError();
      // Empty this._content

      this.switchToNextContext();
    }

    validateParameters () {
      this.switchToNextContext();
    }

    _setDefaultDate () {
      // Set default
      let defaultDate = this.element.hasAttribute('defaultdate')
        ? new Date(this.element.getAttribute('defaultdate'))
        : new Date();

      if (undefined == defaultDate || 'Invalid Date' == defaultDate) {
        defaultDate = new Date();
      }
      let displayedDate = defaultDate.getFullYear() + '-'
        + pulseUtility.leadingZero(defaultDate.getMonth() + 1) + '-'
        + pulseUtility.leadingZero(defaultDate.getDate());
      
      this._dateInput[0].value = displayedDate;
      //this._dateInput[0].setAttribute('value', displayedDate); //'2018-07-22');
      //this._dateInput[0].defaultValue = displayedDate;
    }

    _fillMinMaxDate () {
      if (this.element.hasAttribute('mindate')) {
        // Use it as is because of cut-off mannagement
        let minDate = this.element.getAttribute('mindate');

        /* let minDateTime = new Date(this.element.getAttribute('mindate'));
        let minDate = minDateTime.getFullYear() + '-'
          + pulseUtility.leadingZero(minDateTime.getMonth() + 1) + '-'
          + pulseUtility.leadingZero(minDateTime.getDate());
        */
        this._dateInput[0].setAttribute('min', minDate);
      }
      if (this.element.hasAttribute('maxdate')) {
        let maxDate = this.element.getAttribute('maxdate');
        /*
        let maxDateTime = new Date(this.element.getAttribute('maxdate'));

        let maxDate = maxDateTime.getFullYear() + '-'
          + pulseUtility.leadingZero(maxDateTime.getMonth() + 1) + '-'
          + pulseUtility.leadingZero(maxDateTime.getDate());
        */
        this._dateInput[0].setAttribute('max', maxDate);
      }
    }

    isValid () {
      let crtDate = new Date(this._dateInput[0].value);
      if (this.element.hasAttribute('mindate')) {
        let minDate = new Date(this.element.getAttribute('mindate'));
        if (crtDate < minDate)
          return false;

      }
      if (this.element.hasAttribute('maxdate')) {
        let maxDate = new Date(this.element.getAttribute('maxdate'));
        if (crtDate > maxDate)
          return false;
      }

      return true;
    }

    getISOValue () {
      return pulseUtility.convertDayForWebService(this._dateInput[0].value);
    }

    getValueAsIs () { //'YYYY-MM-DD
      return this._dateInput[0].value;
    }

    // Callback events
  }

  pulseComponent.registerElement('x-datepicker', DatePickerComponent,
    ['defaultdate', 'maxdate', 'mindate', 'disabled']);
})();

},{"pulseUtility":"pulseUtility","pulsecomponent":2}],79:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-datetimepicker
 * @requires module:pulseComponent
 */

var pulseComponent = require('pulsecomponent');
var pulseUtility = require('pulseUtility');

/**
 * Build a custom tag <x-datetimepicker> to display a datetime selector. This tag gets following attribute : 
 *  defaultdatetime : String (ISO)
 *  mindatetime : String
 *  maxdatetime : String
 *  showseconds : Boolean
 *  nullable : Boolean
 *  novaluetext : String
 *  disabled
 */
(function () {

  class DateTimePickerComponent extends pulseComponent.PulseParamInitializedComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      // Parameters - Default values
      self._dateInput = undefined;
      self._timeInput = undefined;
      self._inputNullable = undefined;
      self._inputNullableText = undefined;
      self._inputNullableDiv = undefined;

      self.methods = {
        isValid: self.isValid,
        getISOValue: self.getISOValue,
        getValueAsIs: self.getValueAsIs
      };

      return self;
    }

    //get content () { return this._content; }

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
      switch (attr) {
        case 'disabled': {
          if (this.isInitialized()) {
            this._enabledisableInput();
          }
        } break;
        case 'defaultdatetime':
          if (this.isInitialized()) {
            this._setDefaultDate();
            this._setDefaultTime();
          }
          break;
        case 'maxdatetime':
          if (this.isInitialized()) {
            this._fillMinMaxDate();
            this._fillMinMaxTime();
          }
          break;
        case 'mindatetime':
          if (this.isInitialized()) {
            this._fillMinMaxDate();
            this._fillMinMaxTime();
          }
          break;
        case 'novaluetext':
          if (this._inputNullable) {
            this._inputNullableText.html(newVal); // OK
          }
          break;
        case 'showseconds':
          // Show seconds or not
          if (this.isInitialized()) {
            if (this.element.hasAttribute('showseconds')) {
              this._timeInput[0].setAttribute('step', 1); // 1 sec == show sec
            }
            else {
              this._timeInput[0].setAttribute('step', 60); // 1 min
            }
          }
          break;
        case 'nullable':
          if (this.isInitialized()) {
            if (newVal) {
              this._inputNullableDiv.show();
            }
            else {
              this._inputNullableDiv.hide();
            }
          }
          break;
        default:
          console.warn('Unhandled attribute : ' + attr);
          break;
      }
    }

    initialize () {
      this.addClass('pulse-bigdisplay');

      // Create DOM - NO Loader
      let datetimeDiv = $('<div></div>').addClass('datetimepicker-datetimediv');
      $(this.element).append(datetimeDiv);

      // DOM - date
      this._dateInput = $('<input type="date"></input>')
        .addClass('datetimepicker-input-date');
      this._timeInput = $('<input type="time"></input>')
        .addClass('datetimepicker-input-time');
      datetimeDiv.append(this._dateInput).append(this._timeInput);

      // With or without seconds
      if (this.element.hasAttribute('showseconds')) {
        this._timeInput[0].setAttribute('step', 1); // 1 sec == show sec
      }
      else {
        this._timeInput[0].setAttribute('step', 60); // 1 min
      }

      // DOM - NULLABLE
      this._inputNullable = $('<input type="checkbox" name="datetime-nullable"></input>')
        .addClass('datetimepicker-input-nullable');
      this._inputNullableText = $('<label for="datetime-nullable"></label>')
        .addClass('datetimepicker-input-nullable-label')
        .html((this.element.hasAttribute('novaluetext')) ? this.element.getAttribute('novaluetext') : 'No value');
      this._inputNullableDiv = $('<div"></div>').addClass('datetimepicker-input-nullable-div')
        .append(this._inputNullable).append(this._inputNullableText);
      datetimeDiv.append(this._inputNullableDiv);
      if ((this.element.hasAttribute('nullable')) == false) {
        this._inputNullableDiv.hide();
      }

      // Fill DateTime
      this._setDefaultDate();
      this._setDefaultTime();

      // Set min/max date
      this._fillMinMaxDate();
      this._fillMinMaxTime();

      // if disabled
      this._enabledisableInput();

      this._dateInput.change(function () {
        // Restore default if empty
        if ('' == this._dateInput[0].value) {
          this._setDefaultDate();
        }
        // Manage min/max time
        this._fillMinMaxTime();

        // Tell parent if needed
        var event = new Event('change');
        this.element.dispatchEvent(event);

      }.bind(this));

      this._timeInput.change(function () {
        // Restore default if empty
        if ('' == this._timeInput[0].value) {
          this._setDefaultTime();
        }
        // Tell parent if needed
        if (typeof this._onChangeCallback === 'function')
          this._onChangeCallback();

      }.bind(this));

      // If user click to set datetime to null
      this._inputNullable.change(function () {
        this._enabledisableInput();
        // Tell parent if needed
        if (typeof this._onChangeCallback === 'function')
          this._onChangeCallback();

      }.bind(this));

      // NO - Listener and dispatcher

      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    clearInitialization () {
      // Parameters

      // DOM
      $(this.element).empty();

      this._inputNullable = undefined;
      this._inputNullableText = undefined;

      super.clearInitialization();
    }

    reset () { // Optional implementation
      // Code here to clean the component when the component has been initialized for example after a parameter change
      this.removeError();
      // Empty this._content

      this.switchToNextContext();
    }

    validateParameters () {
      this.switchToNextContext();
    }

    _enabledisableInput () {
      if (this.element.hasAttribute('disabled')
        && (this.element.getAttribute('disabled') == 'disabled'
          || this.element.getAttribute('disabled') == 'true')) {
        this._dateInput[0].disabled = true;
        this._timeInput[0].disabled = true;
        this._inputNullable[0].disabled = true;
      }
      else {
        if ($(this._inputNullable).is(':checked')) {
          this._dateInput[0].disabled = true;
          this._timeInput[0].disabled = true;
        }
        else {
          this._dateInput[0].disabled = false;
          this._timeInput[0].disabled = false;
        }
        this._inputNullable[0].disabled = false;
      }
    }

    _setDefaultDate () {
      // nullable ?
      if ((this.element.hasAttribute('nullable'))
        && !this.element.hasAttribute('defaultdatetime')) {
        // Set IS NULL
        $(this._inputNullable)[0].checked = true;
      }
      // same as check changed
      this._enabledisableInput();

      // Set default
      let defaultDatetime = this.element.hasAttribute('defaultdatetime')
        ? new Date(this.element.getAttribute('defaultdatetime'))
        : new Date();
      if ('Invalid Date' == defaultDatetime)
        defaultDatetime = new Date();

      let displayedDate = defaultDatetime.getFullYear() + '-'
        + pulseUtility.leadingZero(defaultDatetime.getMonth() + 1) + '-'
        + pulseUtility.leadingZero(defaultDatetime.getDate());

      this._dateInput[0].value = displayedDate;
      //this._dateInput[0].setAttribute('value', displayedDate); //'2018-07-22');
      //this._dateInput[0].defaultValue = displayedDate;
    }

    _setDefaultTime () {
      let defaultDatetime = this.element.hasAttribute('defaultdatetime')
        ? new Date(this.element.getAttribute('defaultdatetime'))
        : new Date();
      if ('Invalid Date' == defaultDatetime)
        defaultDatetime = new Date();

      defaultDatetime.setMilliseconds(0);
      // Remove seconds if not useful
      /*if (!this.element.hasAttribute('showseconds')) {
        defaultDatetime.setSeconds(0);
      }*/

      let displayedTime = defaultDatetime.toLocaleTimeString('en-GB',// And NOT : [],
        { hour: '2-digit', minute: '2-digit', second: '2-digit' });

      // Remove seconds if not useful - 
      if (!this.element.hasAttribute('showseconds')) {
        displayedTime = defaultDatetime.toLocaleTimeString('en-GB',// And NOT : [],
          { hour: '2-digit', minute: '2-digit' });
      }

      // '2-digit' displays only 1 digit for hour... sometimes
      if (1 == displayedTime.indexOf(':')) {
        displayedTime = '0' + displayedTime;
      }

      this._timeInput[0].value = displayedTime; // Fonctionne pour LAT, mais pas Paragon Metal
      //this._timeInput[0].setAttribute('value', displayedTime); //'08:00');
      //this._timeInput[0].defaultValue = displayedTime;
    }

    _fillMinMaxDate () {
      if (this.element.hasAttribute('mindatetime')) {
        let minDatetime = new Date(this.element.getAttribute('mindatetime'));

        let minDate = minDatetime.getFullYear() + '-'
          + pulseUtility.leadingZero(minDatetime.getMonth() + 1) + '-'
          + pulseUtility.leadingZero(minDatetime.getDate());

        this._dateInput[0].setAttribute('min', minDate);
      }
      if (this.element.hasAttribute('maxdatetime')) {
        let maxDatetime = new Date(this.element.getAttribute('maxdatetime'));

        let maxDate = maxDatetime.getFullYear() + '-'
          + pulseUtility.leadingZero(maxDatetime.getMonth() + 1) + '-'
          + pulseUtility.leadingZero(maxDatetime.getDate());

        this._dateInput[0].setAttribute('max', maxDate);
      }
    }

    _fillMinMaxTime () {
      if (this.element.hasAttribute('mindatetime')) {
        // Check if min date >= value
        let minDate = new Date(this._dateInput[0].getAttribute('min'));
        let crtDate = new Date(this._dateInput[0].value);
        if (minDate < crtDate) {
          this._timeInput[0].removeAttribute('min');
        }
        else {
          let minDatetime = new Date(this.element.getAttribute('mindatetime'));
          // Remove ms, not compatible
          minDatetime.setMilliseconds(0);

          // Find & format min time
          let minTime = minDatetime.toLocaleTimeString();
          // Remove seconds if not useful
          if (!this.element.hasAttribute('showseconds')) {
            minTime = minTime.substring(0, 5); // Hide sec, not compatible
          }
          this._timeInput[0].setAttribute('min', minTime);
        }
      }
      if (this.element.hasAttribute('maxdatetime')) {
        // Check if min date >= value
        let maxDate = new Date(this._dateInput[0].getAttribute('max'));
        let crtDate = new Date(this._dateInput[0].value);
        if (crtDate < maxDate) {
          this._timeInput[0].removeAttribute('max');
        }
        else {
          let maxDatetime = new Date(this.element.getAttribute('maxdatetime'));
          // Remove ms, not compatible
          maxDatetime.setMilliseconds(0);

          // Find & format max time
          let maxTime = maxDatetime.toLocaleTimeString();
          // Remove seconds if not useful
          if (!this.element.hasAttribute('showseconds')) {
            maxTime = maxTime.substring(0, 5); // Hide sec, not compatible
          }

          this._timeInput[0].setAttribute('max', maxTime);
        }
      }
    }

    isValid () {
      if ((this.element.hasAttribute('nullable')) && (this._inputNullable.is(':checked'))) {
        return true;
      }

      let crtDateTime = new Date(this._dateInput[0].value + ' ' + this._timeInput[0].value);
      if (this.element.hasAttribute('mindatetime')) {
        let minDatetime = new Date(this.element.getAttribute('mindatetime'));
        if (crtDateTime < minDatetime)
          return false;

      }
      if (this.element.hasAttribute('maxdatetime')) {
        let maxDatetime = new Date(this.element.getAttribute('maxdatetime'));
        if (crtDateTime > maxDatetime)
          return false;
      }

      return true;
    }

    getISOValue () {
      if ((this.element.hasAttribute('nullable')) && (this._inputNullable.is(':checked'))) {
        return null;
      }
      else {
        let crtDateTime = new Date(this._dateInput[0].value + ' ' + this._timeInput[0].value);
        return crtDateTime.toISOString();
      }
    }

    getValueAsIs () { //'YYYY-MM-DD HH:mm:ss 
      return (this._dateInput[0].value + ' ' + this._timeInput[0].value);
    }

    // Callback events
  }

  pulseComponent.registerElement('x-datetimepicker', DateTimePickerComponent,
    ['defaultdatetime', 'maxdatetime', 'mindatetime', 'novaluetext', 'showseconds', 'nullable', 'disabled']);
})();

},{"pulseUtility":"pulseUtility","pulsecomponent":2}],80:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-freetext
 * @requires module:pulseComponent
 * @requires module:pulseRange
 */
var pulseComponent = require('pulsecomponent');
var pulseUtility = require('pulseUtility');
var eventBus = require('eventBus');

(function () {

  class freetextComponent extends pulseComponent.PulseInitializedComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      self.methods = {
        cleanDisplay: self.cleanDisplay // used by machineselection
      };

      // DOM - not here
      self._content = undefined;

      return self;
    }

    cleanDisplay () {
      $(this._content).empty();
    }

    //get content () { return this._content; } // Optional

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
      switch (attr) {
        case 'machine-id':
        case 'group': // Not fully defined yet
          if (this.isInitialized()) {
            // Check 'textchange-context'
            if (this.element.hasAttribute('textchange-context')) {
              let textchangecontext = pulseUtility.getTextChangeContext(this);
              eventBus.EventBus.removeEventListenerBySignal(this,
                'textChangeEvent');
              eventBus.EventBus.addEventListener(this,
                'textChangeEvent', textchangecontext,
                this.onTextChange.bind(this));
            }
            this.start(); // == re load
          } break;
        case 'textchange-context':
          if (this.isInitialized()) {
            let textchangecontext = pulseUtility.getTextChangeContext(this);
            eventBus.EventBus.removeEventListenerBySignal(this,
              'textChangeEvent');
            eventBus.EventBus.addEventListener(this,
              'textChangeEvent', textchangecontext,
              this.onTextChange.bind(this));

            eventBus.EventBus.dispatchToContext('askForTextChangeEvent', textchangecontext);
          }
          //this.start(); // To re-validate parameters
          break;
        default:
          break;
      }
    }

    initialize () {
      this.addClass('pulse-text'); // Mandatory for loader

      // Update here some internal parameters

      // In case of clone, need to be empty :
      $(this.element).empty();

      // Create DOM - Content
      this._content = $('<div></div>').addClass('freetext-content');
      $(this.element).append(this._content);

      // Create DOM - NO Loader / No message

      // listeners/dispatchers
      if (this.element.hasAttribute('textchange-context')) {
        let textchangecontext = pulseUtility.getTextChangeContext(this);
        eventBus.EventBus.addEventListener(this,
          'textChangeEvent', textchangecontext,
          this.onTextChange.bind(this));

        eventBus.EventBus.dispatchToContext('askForTextChangeEvent', textchangecontext);
      }

      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    clearInitialization () {
      // Parameters
      // DOM
      $(this.element).empty();

      //this._messageSpan = undefined;
      this._content = undefined;

      super.clearInitialization();
    }

    /**
       * Event bus callback triggered when the text changes
       *
       * @param {Object} event
       */
    onTextChange (event) {
      if ('' == event.target.text) {
        $(this._content).empty();
      }
      else {
        $(this._content).empty();
        $(this._content).append($('<span></span>').html(event.target.text));
      }
    }
  }

  pulseComponent.registerElement('x-freetext', freetextComponent, ['machine-id', 'group', 'textchange-context']);
})();

},{"eventBus":"eventBus","pulseUtility":"pulseUtility","pulsecomponent":2}],81:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-grouparray
 * @requires module:pulseComponent
 * @requires module:pulseRange
 */
var pulseComponent = require('pulsecomponent');
var pulseUtility = require('pulseUtility');
var pulseLogin = require('pulseLogin');
var pulseConfig = require('pulseConfig');
var state = require('state');
var eventBus = require('eventBus');

/*
 ** Attributes :
 - templateid
 - machine
 - group
 - column (getConfigOrAttribute)
 - row (getConfigOrAttribute)
 - canUseRowsToSetHeight
 - allowpagerotation : bool true to start page rotation
 - rotation (getConfigOrAttribute) = rotation delay
 - refreshrate (ELSE rotation*nbPages ELSE 1hr)
 */
(function () {

  class GroupComponent extends pulseComponent.PulseParamAutoPathRefreshingComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      // Default
      self._lastUpdateDate = undefined;

      // DOM -> never in contructor
      self._content = undefined;
      self._dynamic = false;
      self._currentDisplayedPage = 1;
      self._nbPagesTotal = 1;
      self._showHideTimer = null;

      self._machineIdsArray = [];
      self.methods = {
        'getMachinesList': self.getMachinesList
      };

      return self;
    }

    // Overload to always refresh value
    get isVisible () {
      if (!this._connected) { // == is connected
        return false;
      }
      return true;
    }

    /** Get list of machines as string
     */
    getMachinesList () {
      return this._machineIdsArray.join();
    }

    get content () {
      return this._content;
    }

    _displayOrUpdateMachineList () {
      //$(this._content).empty(); No !

      if ((false == this._dynamic)
        && (this._machineIdsArray.length == 0)) {
        let noMachines = $('<div></div>').addClass('no-machines')
          .html('No machine in selection');// I18N ?
        $(this._content).append(noMachines);
      }
      else {
        $(this._content).find('.no-machines').remove();
      }

      // init possible rotation
      this._currentDisplayedPage = 1;

      // Get the box to clone element from DOM
      let boxtocloneid = this.element.getAttribute('templateid');
      if (pulseUtility.isNotDefined(boxtocloneid))
        boxtocloneid = 'boxtoclone';

      // Calculate width for multi-column (and height)
      let column_width = null;
      let row_height = null;
      let nbColumnToDisplay = this.getConfigOrAttribute('column');
      let nbRowToDisplay = this.getConfigOrAttribute('row', 2);
      let canUseRowsToSetHeight = this.getConfigOrAttribute('canUseRowsToSetHeight', 'false');
      let allowpagerotation = this.getConfigOrAttribute('allowpagerotation', 'false');

      if (!pulseUtility.isNotDefined(nbColumnToDisplay)) {
        column_width = 100.0 / nbColumnToDisplay + '%';
        if (allowpagerotation == 'true') { // No page rotation == auto-size
          if ((canUseRowsToSetHeight == 'true') || (canUseRowsToSetHeight == true)) {
            if (!pulseUtility.isNotDefined(nbRowToDisplay)) {
              row_height = 100.0 / nbRowToDisplay + '%';
            }
          }
        }
      }

      // Update the component with data returned by the web service
      function machineIdIsInList (machineId, List) {
        for (let i = 0; i < List.length; i++) {
          if (Number(machineId) == Number(List[i]))
            return true;
        }
        return false;
      }

      // REMOVE machine not in list anymore
      let self = this;
      $(this.element).find('.group-single').each(function () {
        let machineId = $(this).attr('machine-id'); // this = group-single
        if (false == machineIdIsInList(machineId, self._machineIdsArray)) { // self = x-grouparray
          $(this).remove(); // this = group-single
        }
        else {
          $(this).find('*').addClass('disableDeleteWhenDisconnect');
          /* DO NOT used this.element : not defined here ! this == '.group-single' */
        }
      });

      // Reset pages
      for (let i = 1; i <= this._nbPagesTotal; i++) {
        let page_class = 'li-page-' + i;
        $(this.element).find('.' + page_class).removeClass(page_class);
      }

      //$(this.element).find('*').addClass('disableDeleteWhenDisconnect');

      // Update list of machines - Add ROWS
      for (let i = 0; i < this._machineIdsArray.length; i++) {
        let singleid = this._machineIdsArray[i];
        let li;

        // Find if already exists
        let machineRow = $(this._content).find(".group-single[machine-id='" + singleid + "']");
        // NO remove ELSE display can become not smooth enough
        if (machineRow.length != 0) { // if exists
          // disableDeleteWhenDisconnect
          //machineRow[0].find ('*').addClass('disableDeleteWhenDisconnect');

          // Move at end of the list to order all
          //$(this._content).append(machineRow[0]);
          li = machineRow[0];
        }
        else {
          // Else Create NEW = copy the element and its child nodes
          let copy = pulseUtility.cloneWithNewMachineId(boxtocloneid, singleid);
          /*let copy = $('#' + boxtocloneid).clone(true);
          $(copy).removeAttr('id');
          $(copy).attr('machine-id', singleid);
          $(copy).find('*').attr('machine-id', singleid);*/

          // Append the cloned element to the list
          li = $('<li></li>').addClass('group-single');
          li.attr('machine-id', singleid);
          li.append(copy);
        }

        if (nbColumnToDisplay != 0 && nbRowToDisplay != 0) {
          // Add page class to ease page rotation
          let page_class = 'li-page-' + Math.ceil((i + 1) / (nbColumnToDisplay * nbRowToDisplay));
          $(li).addClass(page_class);

          // Set height / width
          if (null != column_width)
            $(li).css({
              'width': column_width
            });
          if (null != row_height)
            $(li).css({
              'height': row_height
            });
        }

        $(this._content).append(li);

        /*if (machineRow.length != 0) { // if exists
          // restoreDeleteWhenDisconnect 
          machineRow[0].find ('*').removeClass('disableDeleteWhenDisconnect');
        }*/
      }
      //$(this.element).find('.disableDeleteWhenDisconnect').removeClass('disableDeleteWhenDisconnect'); // too early

      // Warn fieldlegend : machine list has changed
      if ('false' == this.getConfigOrAttribute('donotwarngroupreload', 'false')) {
        eventBus.EventBus.dispatchToAll('groupIsReloaded', {
          newMachinesList: this._machineIdsArray.join(',')
        });
      }

      this._dealWithRotation();

      // TIMEOUT to be sure that all is cleared
      // (else the mecanism is not working as it should)
      let rotationDelay = Number(this.getConfigOrAttribute('rotation', '90'));
      setTimeout(this._removeDisable.bind(this),
        rotationDelay / 2 * 1000);

    } // _displayOrUpdateMachineList

    _removeDisable () {
      $(this.element).find('.disableDeleteWhenDisconnect')
        .removeClass('disableDeleteWhenDisconnect');
    }

    _dealWithRotation () {
      let nbColumnToDisplay = Number(this.getConfigOrAttribute('column', '3'));
      let nbRowToDisplay = Number(this.getConfigOrAttribute('row', '2'));

      this._currentDisplayedPage = 1; //re-init

      let allowpagerotation = this.getConfigOrAttribute('allowpagerotation', 'false');
      if (allowpagerotation == 'true' &&
        nbColumnToDisplay > 0 &&
        nbRowToDisplay > 0) {

        //this._currentDisplayedPage = 1; //re-init
        let nbMachine = this._machineIdsArray.length;
        this._nbPagesTotal = Math.ceil(nbMachine / (nbColumnToDisplay * nbRowToDisplay));
        if (this._nbPagesTotal == 0)
          this._nbPagesTotal = 1; // To avoid too log refresh rate
      }
      else { // NO rotation
        this._nbPagesTotal = 1;
      }
      this._rotationAndProgressDisplay();
    }

    _rotationAndProgressDisplay () {
      // Clear timer if exist ! To avoid many living timers
      if (this._showHideTimer) {
        clearTimeout(this._showHideTimer);
        this._showHideTimer = null;
      }

      let allowpagerotation = this.getConfigOrAttribute('allowpagerotation', 'false');
      if (allowpagerotation == 'true') {
        this._showHidePages();

        if (this._nbPagesTotal > 1) {
          let rotationDelay = Number(this.getConfigOrAttribute('rotation', '90'));

          // Display pagination and progress line
          $('.pulse-header-rotation-progress').html('<span style="width:0"></span>'); // Initialisation a 0px line
          $('.pulse-header-rotation-progress > span').animate({
            width: '100%'
          }, rotationDelay * 1000, 'linear'); // Increase its width until 100%
          $('#pulse-pagination').html((this._currentDisplayedPage) + ' / ' + this._nbPagesTotal);

          // Prepare next page rotation
          this._currentDisplayedPage++;
          if (this._currentDisplayedPage > this._nbPagesTotal) {
            this._currentDisplayedPage = 1;
          }
          this._showHideTimer = setTimeout(function () {
            this._rotationAndProgressDisplay();
          }.bind(this), rotationDelay * 1000);
        }
        else { // 1 page only
          // Reset rotation
          $('.pulse-header-rotation-progress').html('');
          $('#pulse-pagination').html('');
        }
      }
    }

    _showHidePages () {
      // Hide or show pages
      for (let index_page = 1; index_page <= this._nbPagesTotal; index_page++) {
        let page_class = '.li-page-' + index_page.toString();
        let li = $(this.element).find(page_class);
        if (index_page == this._currentDisplayedPage) {
          // $(li).css('display', 'inline-block'); //NO ! Because of ManagerWiew Page
          $(li).show();
          $(li).find('x-datetimegraduation').load(); // datetimegraduation can not manage 'width' when hidden
          // a best solution is to manage onShow Event.. once it exists
        }
        else {
          $(li).hide();
        }
      } // end for
    }

    /**
     * @override
     * 
     * @param {!string} context - Context
     * @return {!string} key
     */
    getStartKey (context) {
      switch (context) {
        case 'Loaded':
          return 'Standard';
        default:
          return super.getStartKey(context);
      }
    }

    /**
     * @override
     * 
     * @param {!string} context - Context
     * @param {!string} key - Key
     * @returns {!State} Created states
     */
    defineState (context, key) {
      switch (context) {
        case 'Loaded': // == No Refresh until click on button 'Start'
          return new state.StaticState(context, key, this);
        default:
          return super.defineState(context, key);
      }
    }

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
      switch (attr) {
        case 'templateid':
        case 'group':
        case 'machine':
        case 'column':
        case 'row':
        case 'canUseRowsToSetHeight':
        case 'allowpagerotation':
          //case 'rotation':
          //case 'refreshrate':
          this.start();
          break;
        default:
          break;
      }
    }

    initialize () {
      this.addClass('pulse-bigdisplay');

      // Update here some internal parameters

      // listeners

      // Empty display if already filled
      $(this.element).empty();

      // Create DOM - Content
      this._content = $('<ol></ol>').addClass('group-main');
      $(this.element)
        .addClass('group')
        .append(this._content);
      // Create DOM - Loader
      let loader = $('<div></div>').addClass('pulse-loader').html('Loading...').css('display', 'none');
      let loaderDiv = $('<div></div>').addClass('pulse-loader-div').append(loader);
      $(this._content).append(loaderDiv);
      // Create DOM - message for error
      this._messageSpan = $('<span></span>')
        .addClass('pulse-message').html('');
      let messageDiv = $('<div></div>')
        .addClass('pulse-message-div')
        .append(this._messageSpan);
      $(this._content).append(messageDiv);

      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    clearInitialization () {
      // STOP timer
      if (this._showHideTimer) {
        clearTimeout(this._showHideTimer);
        this._showHideTimer = null;
      }

      // Parameters
      // DOM
      $(this.element).empty();

      this.removeError();
      this._messageSpan = undefined;
      this._content = undefined;

      super.clearInitialization();
    }

    /*reset () { // Optional implementation - REMOVED else too many refreshs on LCTR and memory grows endlessly
      // Code here to clean the component when the component has been initialized for example after a parameter change
      /*this.removeError();
      // Empty this._content
      $(this.content).empty();

      // STOP timer
      if (this._showHideTimer) {
        clearTimeout(this._showHideTimer);
        this._showHideTimer = null;
      }

      this.switchToNextContext();
    }*/

    /**
     * Validate the (event) parameters
     */
    validateParameters () {
      let groups = this.getConfigOrAttribute('group');
      let machines = this.getConfigOrAttribute('machine');
      if ((groups == null || groups == '') &&
        (machines == null || machines == '')) {
        /*missingConfigs.push({
          selector: 'x-machineselection, #editmachines',
          message: 'Please select at least one machine before launching the page.'
        }); */
        console.warn('missing attribute groups or machines in x-grouparray');
        // Delayed display :
        //this.setError('Please select a machine'); // delayed error message
        // Immediat display :
        this.switchToKey('Error', () => this.displayError('Please select a machine'), () => this.removeError());
        return;
      }

      // Additional checks with attribute param

      this.switchToNextContext();
    }

    displayError (message) {
      $(this._messageSpan).html(message);

      $('.grouparray-dependant').addClass('grouparray-in-error'); //).hide();

      // STOP timer
      if (this._showHideTimer) {
        clearTimeout(this._showHideTimer);
        this._showHideTimer = null;
      }
    }

    removeError () {
      $(this._messageSpan).html('');

      $('.grouparray-dependant').removeClass('grouparray-in-error'); //.show();
    }

    get refreshRate () {
      // Return here the refresh rate in ms.
      if (this._nbPagesTotal >= 1) {
        let rotationDelay = Number(this.getConfigOrAttribute('rotation', '90'));
        return rotationDelay * this._nbPagesTotal * 1000;
      }
      else if (this.element.hasAttribute('refreshrate')) {
        return 1000 * this.element.getAttribute('refreshrate');
      }
      else {
        return 1000 * 60 * 60; // 1 hr
      }
    }

    /*
      Replace _runAjaxWhenIsVisible when NO url should be called
      return true if something is done, false if _runAjaxWhenIsVisible should be called
    */
    _runAlternateGetData () {
      let groups = this.getConfigOrAttribute('group'); //this.element.getAttribute('groups');
      if ((pulseUtility.isNotDefined(groups)) ||
        (groups == '')) {

        this.removeError();

        this._dynamic = false;
        // Manage list of machines NOW
        let machines = this.getConfigOrAttribute('machine');
        this._machineIdsArray = machines.split(',');
        this._displayOrUpdateMachineList();

        this._lastUpdateDate = Date();
        if (this.element.hasAttribute('textchange-context')) {
          // Send empty string
          eventBus.EventBus.dispatchToContext('textChangeEvent',
            this.element.getAttribute('textchange-context'),
            { text: '' });
        }

        // BECAUSE this._dynamic == false; // STOP calling Ajax request
        this.switchToContext('Loaded');
        // AND NOT this.switchToNextContext();
        return true;
      }
      // else Call WebService
      return false;
    }

    getShortUrl () {
      // Return the Web Service URL here without path
      let groups = this.getConfigOrAttribute('group');
      let url = 'MachinesFromGroups?GroupIds=' + groups;
      // Login is set in global service call
      return url;
    }

    refresh (data) {
      this._displayOrUpdateMachineList();
    }

    manageSuccess (data) {
      /* public List<int> MachineIds { get; set; }
      public int? SortKind { get; set; }
      public string SortKindTip { get; set; }*/
      this.removeError();

      this._machineIdsArray = data.MachineIds;
      this._dynamic = data.Dynamic;
      if (this.getConfigOrAttribute('forcestaticlist') == 'true' ||
        this.getConfigOrAttribute('forcestaticlist') == true) {
        this._dynamic = false;
      }
      this._lastUpdateDate = Date();
      if (this.element.hasAttribute('textchange-context')) {
        let textToSend = '';
        if (this._dynamic) {
          // Format Date and send
          let _lastMoment = pulseUtility.convertDateToMoment(this._lastUpdateDate);
          textToSend = _lastMoment.format('LTS')
        }
        eventBus.EventBus.dispatchToContext('textChangeEvent',
          this.element.getAttribute('textchange-context'),
          { text: textToSend });
      }

      if (false == this._dynamic) {
        this._displayOrUpdateMachineList();

        // STOP calling Ajax request
        this.switchToContext('Loaded');
      }
      else {
        // Success:
        super.manageSuccess(data);
        // or this.switchToNextContext(() => this.refresh(data));
      }
    }

    // Callback events

    /**
     * Event callback in case a config is updated: (re-)start the component
     *
     * @param {*} event
     */
    onConfigChange (event) {
      if ((event.target.config == 'machine')
        || (event.target.config == 'group')) {
        this.start();
      }
      if ((event.target.config == 'row')
        || (event.target.config == 'column')) {
        this._displayOrUpdateMachineList();
      }
      if (event.target.config == 'rotation') {
        this._currentDisplayedPage = 1;
        this._rotationAndProgressDisplay();
      }
    }

  }

  pulseComponent.registerElement('x-grouparray', GroupComponent, ['templateid', 'group', 'machine', 'column', 'row', 'canUseRowsToSetHeight', 'allowpagerotation']);
})();

},{"eventBus":"eventBus","pulseConfig":"pulseConfig","pulseLogin":"pulseLogin","pulseUtility":"pulseUtility","pulsecomponent":2,"state":3}],82:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-logindisplay
 * @requires module:pulseComponent
 */

var pulseComponent = require('pulsecomponent');
var pulseConfig = require('pulseConfig');
var pulseLogin = require('pulseLogin');
var pulseSvg = require('pulseSvg');

/**
 * Build a custom tag <x-logindisplay> 
 */
(function () {

  class LoginDisplayComponent extends pulseComponent.PulseInitializedComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      // DOM: never in constructor, use the initialize method instead

      return self;
    }


    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
    }

    _fillDisplay () {
      if (pulseConfig.currentRoleOrAppContextIsDefined()) {
        $(this._span).html(pulseConfig.getCurrentUserDisplay());
        $(this._content).show();
      }
      else {
        // Disable the navigation panel, a role must be chosen first
        $(this._content).hide();
      }
    }

    _defineClick () {
      // Logout button
      $(this._content).click(function (e) {
        // Remove the current role
        pulseLogin.cleanLoginRole();

        pulseConfig.goToPageLogin();
      });
    }

    initialize () {
      this.addClass('pulse-text');

      // In case of clone, need to be empty :
      $(this.element).empty();

      // Create DOM - Loader -> Not needed here

      // Create DOM - Content
      this._span = $('<span></span>').addClass('logindisplay-span');
      this._icon = $('<span></span>').addClass('logindisplay-icon');
      this._content = $('<div></div>').addClass('logindisplay-content')
        .append(this._span).append(this._icon);
      $(this.element).append(this._content);

      this._fillDisplay();

      this._defineClick();

      // Create DOM - message for error -> Not needed here
      
      // Disable inline for reporting - the latest to hope displaying colors always
      if ( this.getConfigOrAttribute('donotuseinline', 'false') == 'false' ){
        // inline icon
        pulseSvg.inlineBackgroundSvg(this._icon);
      }

      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    displayError (message) {
      // Code here to display the error message
    }

    removeError () {
      // Code here to remove the error message
    }

    /**
     * Event callback in case a config is updated: (re-)start the component
     *
     * @param {*} event
     */
    onConfigChange (event) {
      // Default = do nothing
      // Example :
      //if ( event.target.config == 'myConfig')
      //  this.start();
    }

  }

  pulseComponent.registerElement('x-logindisplay', LoginDisplayComponent, []);
})();

},{"pulseConfig":"pulseConfig","pulseLogin":"pulseLogin","pulseSvg":"pulseSvg","pulsecomponent":2}],83:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-machinedisplay
 * @requires module:pulseComponent
 * @requires module:pulseUtility
 */
var pulseUtility = require('pulseUtility');
var pulseComponent = require('pulsecomponent');
var eventBus = require('eventBus');

(function () {

  class MachineDisplayComponent extends pulseComponent.PulseParamAutoPathSingleRequestComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      self._dataElement = undefined;

      return self;
    }

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
      switch (attr) {
        case 'group': // Not group-id because of url compatibility
        case 'machine-id':
          this.start();
          break;
        case 'machine-context':
          if (this.isInitialized()) {
            eventBus.EventBus.removeEventListenerBySignal(this, 'machineIdChangeSignal');
            eventBus.EventBus.addEventListener(this,
              'machineIdChangeSignal',
              newVal,
              this.onMachineIdChange.bind(this));
          }
          break;
        default:
          break;
      }
    }

    initialize () {
      this.addClass('pulse-text');

      // In case of clone, need to be empty :
      $(this.element).empty();

      // Create DOM - Content
      this._dataElement = $('<span></span>').addClass('machinedisplay-data');
      $(this.element).append(this._dataElement);
      // Create DOM - Loader
      let loader = $('<div></div>').addClass('pulse-loader').html('Loading...').css('display', 'none');
      let loaderDiv = $('<div></div>').addClass('pulse-loader-div').append(loader);
      $(this.element).append(loaderDiv);

      // Create DOM - message for error
      this._messageSpan = $('<span></span>')
        .addClass('pulse-message').html('');
      let messageDiv = $('<div></div>')
        .addClass('pulse-message-div')
        .append(this._messageSpan);
      $(this.element).append(messageDiv);

      // Listener and dispatchers
      if (this.element.hasAttribute('machine-context')) {
        eventBus.EventBus.addEventListener(this,
          'machineIdChangeSignal',
          this.element.getAttribute('machine-context'),
          this.onMachineIdChange.bind(this));
      }

      this.switchToNextContext();
    }

    clearInitialization () {
      // Parameters
      // DOM
      $(this.element).empty();

      this._messageSpan = undefined;
      this._dataElement = undefined;

      super.clearInitialization();
    }

    reset () {
      this.removeError();
      $(this._dataElement).html('');

      this.switchToNextContext();
    }

    validateParameters () {
      if (!this.element.hasAttribute('machine-id')) {
        if (!this.element.hasAttribute('group')) {
          if ('' === this.getConfigOrAttribute('group')) {

            if (this.isVisible) { // To avoid displayed error in hidden duplicated part
              console.error('missing attribute machine or group in MachineDisplayComponent.element');
            }
            //this.setError('missing machine-id'); // delayed error message
            this.switchToKey('Error', () => this.displayError('invalid machine or group'), () => this.removeError());
            return;
          }
        }
      }
      this.switchToNextContext();
    }

    getShortUrl () {
      let url = 'Machine/Name';
      if (this.element.hasAttribute('machine-id')) {
        url += '?MachineId=' + this.element.getAttribute('machine-id');
      }
      else {
        let group = '';
        if (this.element.hasAttribute('group')) {
          group = this.element.getAttribute('group');
        }
        else {
          group = this.getConfigOrAttribute('group'); // config first - keep getAttribute before
        }
        url += '?GroupId=' + group;
      }
      return url;
    }

    refresh (data) {
      if (!pulseUtility.isNotDefined(data.Display))
        $(this._dataElement).html(data.Display);
      else
        $(this._dataElement).html(data.Name);

      // string Id
      // string TreeName
      // bool Group // Is it a group ?
    }

    displayError (message) {
      $(this._dataElement).html('');
      $(this._messageSpan).html(message);
    }

    removeError () {
      this.displayError('');
    }

    // Callback events
    onMachineIdChange (event) {
      this.element.setAttribute('machine-id', event.target.newMachineId);
    }
  }

  pulseComponent.registerElement('x-machinedisplay', MachineDisplayComponent, ['group', 'machine-id', 'machine-context']);
})();

},{"eventBus":"eventBus","pulseUtility":"pulseUtility","pulsecomponent":2}],84:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-machineselection
 * @requires module:pulseComponent
 * @requires module:pulseUtility
 * @requires module:pulsecustomdialog
 */
var pulseUtility = require('pulseUtility');
var pulseSvg = require('pulseSvg');
var pulseComponent = require('pulsecomponent');
var pulseCustomDialog = require('pulseCustomDialog');
var pulseLogin = require('pulseLogin');
var pulseConfig = require('pulseConfig');
var eventBus = require('eventBus');


require('x-grouparray/x-grouparray');
require('x-machinedisplay/x-machinedisplay');
require('x-freetext/x-freetext');


/**
 * Build a custom tag <x-machineselection>
 * CAN BE Used by report web app OR pulse web app
 * 
 * Attributes :
 * unique-machine : bool if single machine is mandatory (rarely used)
 * 
 * // Special for reports
 * in-report = present if report version is enabled
 * groupDisplayForm = MACHINESGROUPS
 * groupName. ex = 
 * pulse-machines (storage in localstorage using pulseConfig for pulsewebapp)
 * pulse-groups (storage in localstorage using pulseConfig for pulsewebapp)
 */

(function () {
  class MachineSelectionComponent extends pulseComponent.PulseParamAutoPathSingleRequestComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      // Linked to config :
      self._configMachines = 'machine';
      self._configGroups = 'group';

      // current SELECTION storage (in config or local, before click on OK)
      self._groupSelectionArray = [];
      self._machineSelectionArray = [];
      self._useMachineSelection = false; // machine OR group

      // == data. from web service
      self._groups = [];

      // Map [id] = group or machine display
      // How to use map : https://www.zendevs.xyz/les-nouveaux-objets-set-et-map-en-javascript-es6/
      self._groupDisplays = new Map(); // == from data in web services = [id] displayed
      // Attention, la key de la map est une string, donc has(integer) ne fonctionne pas

      // Page capabilities
      self._uniquemachine = false; // ignored, only for error message

      // DOM default
      self._dialogPage1 = undefined;
      self._categoryList = undefined; // == group selection

      self._dialogPage2 = undefined;
      // Machine selection
      self._machinesSearchDiv = undefined;
      self._machinesList = undefined;
      self._machinesListContainer = undefined;
      // Selection
      self._selectionTitle = undefined;
      self._selectionHeader = undefined;
      self._selectionList = undefined;
      self._selectionListContainer = undefined;
      // Preview
      self._useMachineButton = undefined;
      self._previewHeader = undefined;
      self._previewList = undefined;
      self._previewListContainer = undefined;

      // Error
      self._messageSpan = undefined;
      // DOM : Display in main page, right panel config
      self._editbutton = undefined;
      self._summary = undefined;

      self._dialogId = undefined;
      self.methods = {
        'changeMachineSelection': self.changeMachineSelection,
        //,'getMachineSelection': self.getMachineSelection,
        'fillExternalSummaryDisplay': self.fillExternalSummaryDisplay,
        'getMachinesArray': self.getMachinesArray,
        'getGroupsArray': self.getGroupsArray,
        'getMachinesString': self.getMachinesString,
        'getGroupsString': self.getGroupsString

      };

      if (!this.element.hasAttribute('in-report')) {
        // Clean old storage 2020-12 (can be removed later)
        pulseConfig.setGlobal(this._configMachines, '');
        pulseConfig.setGlobal(this._configGroups, '');
      }

      return self;
    }

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
      switch (attr) {
        //case 'enableGroups': // Probably in config -> always
        case 'unique-machine': {
          this._uniquemachine = (this.element.hasAttribute('unique-machine')
            && this.element.getAttribute('unique-machine') == 'true');
          this.start();
        } break;
        default:
          break;
      }
    }

    validateParameters () {
      this.switchToNextContext();
    }

    clearInitialization () {
      $(this.element).empty();

      this._editbutton = undefined;
      this._summary = undefined;
      this._messageSpan = undefined;

      super.clearInitialization();
    }

    // return value input - maybe define this function in a common lib
    initParamForReport (divToFill, name, parameterkey, dataType, parameterType,
      defaultValue, value, required, hidden, helptext) {
      $(divToFill).addClass('parameter');
      $(divToFill).append("<input type='hidden' id='name' value='" + name + "' />");
      $(divToFill).append("<input type='hidden' id='parameterkey' value='" + parameterkey + "' />");
      $(divToFill).append("<input type='hidden' id='defaultvalue' value='" + defaultValue + "' />");
      let retInput = $("<input type='hidden' id='value' value='" + value + "' />");
      $(divToFill).append(retInput);
      $(divToFill).append("<input type='hidden' id='datatype' value='" + dataType + "' />");
      $(divToFill).append("<input type='hidden' id='parametertype' value='" + parameterType + "' />");
      $(divToFill).append("<input type='hidden' id='required' value='" + required + "' />");
      $(divToFill).append("<input type='hidden' id='helptext' value='" + helptext + "' />");
      $(divToFill).append("<input type='hidden' id='hidden' value='" + hidden + "' />");
      if (parameterkey == 'WEBAPP') {
        $(divToFill).append("<input type='hidden' id='widget' value='TEXTBOX' />");
        retInput = $("<input type='hidden' id='" + name + "_value' value= />");
        $(divToFill).append(retInput);
      }
      return retInput;
    }

    // Creation of the component (empty)
    initialize () {
      this.addClass('pulse-text'); // Mandatory for loader

      // Parameters
      this._uniquemachine =
        ('true' == this.getConfigOrAttribute('unique-machine', 'false'));

      // In case of clone, need to be empty :
      $(this.element).empty();

      // Create DOM - Content - By default, button enabled
      this._editbutton = $('<button title="Change machines" role="button" ></button>')
        .addClass('machineselection-editbutton')
        .html('edit')
        .click(
          function () {
            this.changeMachineSelection();
          }.bind(this)
        );
      this._summary = $('<div></div>')
        .addClass('machineselection-summary');
      $(this.element)
        .append(this._editbutton).append(this._summary);

      // Create DOM - Loader
      let loader = $('<div></div>').addClass('pulse-loader').html('Loading...').css('display', 'none');
      let loaderDiv = $('<div></div>').addClass('pulse-loader-div').append(loader);
      $(this.element).append(loaderDiv);
      // Create DOM - message for error
      this._messageSpan = $('<span></span>')
        .addClass('pulse-message').html('');
      let messageDiv = $('<div></div>')
        .addClass('pulse-message-div')
        .append(this._messageSpan);
      $(this.element).append(messageDiv);


      if (this.element.hasAttribute('in-report')) {
        // Hidden div for report
        let reportDiv = $('<div></div>').addClass('pulse-report-hidden');
        $(this.element).append(reportDiv);

        let groupReportDiv = $('<div></div>').addClass('pulse-report-hidden');
        this.initParamForReport(groupReportDiv,
          'PulseGroups', 'GROUPPOS', // name, parameterkey
          'STRING', // dataType = 'STRING'
          'SIMPLE', '', '', // , parameterType, defaultValue, value, 
          'false', 'false', ''); // required, hidden, helptext
        reportDiv.append(groupReportDiv);

        let machineReportDiv = $('<div></div>').addClass('pulse-report-hidden');
        this.initParamForReport(machineReportDiv,
          'PulseMachines', 'MACHINES', // not 'MACHINEPOS', because of history compatibility // name, parameterkey
          'STRING', // dataType = 'STRING'
          'SIMPLE', '', '', // parameterType, defaultValue, value, 
          'false', 'false', ''); // required, hidden, helptext
        reportDiv.append(machineReportDiv);
      }

      this.switchToNextContext();
    }

    displayError (message) {
      //this._disable(message);
    }

    // Overload to always refresh value
    get isVisible () {
      // Si page login = Hidden = Do not call web service
      if (pulseConfig.isLoginPage()) {
        return false;
      }
      // Normal behavior
      if (!this._connected) { // == is connected
        return false;
      }
      return true;
    }

    // Return the Web Service URL here
    getShortUrl () {
      let url = 'Machine/Groups?Zoom=true&MachineList=true';
      // Login is set in global service call
      return url;
    }

    // Update the component with data which is returned by the web service in case of success
    refresh (data) {
      // Store lists of available categories (=groups)
      this._groups = data.GroupCategories;
      this._machinesFromService = data.MachineList;
      this._storeDisplays();

      // Load current selections
      this._loadSelection();

      // Fill categories list (left panel)
      this._fillCategoryList();
      // Fill summary
      this._fillSummaryDisplay();

      // Fill list of machines 
      this._fillMachinesList();
    } // end refresh

    ///////////////////////////////////////////////////////////////
    // public FUNCTIONS FOR UPDATING THE SELECTION = open dialog //
    ///////////////////////////////////////////////////////////////
    changeMachineSelection () {
      this._createDialogIfNotDone();

      // open Dialog
      if (undefined == this._dialogId)
        return;
      pulseCustomDialog.open(this._dialogPage1, this._dialogId);
    }

    //////////////////////////////////////////
    // FUNCTIONS FOR DIALOG                 //
    //////////////////////////////////////////
    _createDialogIfNotDone () {
      if (undefined != this._dialogId)
        return;

      ////////// //////////
      // Page 1  //////////
      this._dialogPage1 = $('<div></div>').addClass('machineSelectionDialogPart1');
      let page1 = $('<div></div>').addClass('machineselection-page1');
      this._dialogPage1.append(page1);

      // FIRST div - for buttons CLEAR - Switch to machien selection
      let div_buttons = $('<div></div>').addClass('machineselection-buttons'); // = main
      // Button CLEAR
      this._clearFilters_button = $('<button></button>')
        .addClass('machineselection-button')
        .addClass('machineselection-clearfilters').html('CLEAR');
      this._clearFilters_button.click(function () {
        this._clearSelection();
      }.bind(this));
      div_buttons.append(this._clearFilters_button);
      // Button switch to group or machine selection ( = with empty selection)
      let div_switch_buttons = $('<div></div>').addClass('machineselection-switch-group-machines');
      // G
      this._switchToGroups_button = $('<button></button>')
        .addClass('machineselection-button')
        .addClass('machineselection-switch-to-groups').html('GROUPS');
      this._switchToGroups_button.click(function () {
        this._groupSelectionArray = [];
        this._machineSelectionArray = [];
        this._switchToGroupSelection();
        this._changeSelectionInCategoryList();
      }.bind(this));
      div_switch_buttons.append(this._switchToGroups_button);
      // M
      this._switchToMachines_button = $('<button></button>')
        .addClass('machineselection-button')
        .addClass('machineselection-switch-to-machines').html('MACHINES');
      this._switchToMachines_button.click(function () {
        this._groupSelectionArray = [];
        this._machineSelectionArray = [];
        this._switchToMachineSelection();
        this._changeSelectionInMachineList();
      }.bind(this));
      div_switch_buttons.append(this._switchToMachines_button);
      // append buttons
      div_buttons.append(div_switch_buttons);
      page1.append(div_buttons);
      // END - FIRST div - for buttons

      // GROUPS
      this._categoryList = $('<div></div>').addClass('machineselection-categorylist');
      page1.append(this._categoryList);

      // MACHINES
      this._machinesList = $('<div></div>').addClass('machineselection-machines-list');
      this._machinesListContainer = $('<div></div>')
        .addClass('machineselection-machines-list-container') // For scroll
        .append(this._machinesList);

      this._machinesSearchDiv = $('<div></div>').addClass('machineselection-machines-search-div');

      this._clearSearchButton = $('<button title="Clear search" role="button"></button>')
        .addClass('buttonDialog')
        .addClass('machineselection-clear-search');
      this._machinesSearchDiv.append(this._clearSearchButton);

      this._inputSearch = $('<input></input>').addClass('machineselection-machines-search-input')
        .attr('type', 'text').attr('placeholder', 'Search...');
      /*let spanSearch = $('<span></span>').addClass('machineselection-machines-search-span')
        .append(this._inputSearch);*/
      this._machinesSearchDiv.append(this._inputSearch);

      // FILL must be one AFTER dialog creation to display icons 
      //this._fillMachinesList();

      page1.append(this._machinesListContainer).append(this._machinesSearchDiv);

      // Use filter
      $(this._inputSearch).on('input', function () {
        this._showHideMachinesInList();
      }.bind(this));

      // Clear filter
      $(this._clearSearchButton).click(function () {
        $(this._inputSearch).val('');
        this._showHideMachinesInList();
      }.bind(this));


      ////////// //////////
      // Page 2  //////////
      this._dialogPage2 = $('<div></div>').addClass('machineSelectionDialogPart2');
      let page2 = $('<div></div>').addClass('machineselection-page2');
      this._dialogPage2.append(page2);

      // SELECTION
      this._selectionTitle = $('<span></span>').addClass('machineselection-title')
        .html('Selected');
      this._selectionHeader = $('<div></div>').addClass('machineselection-selection-header')
        .append(this._selectionTitle);
      this._selectionList = $('<div></div>').addClass('machineselection-selection-list');
      this._selectionListContainer = $('<div></div>')
        .addClass('machineselection-selection-list-container') // For scroll
        .append(this._selectionList);

      page2.append(this._selectionHeader).append(this._selectionListContainer);

      // PREVIEW
      let previewTitle = $('<span></span>').addClass('machineselection-preview-title')
        .html('preview machines');
      this._freeTextLastUpdate = pulseUtility.createjQueryElementWithAttribute('x-freetext', {
        'textchange-context': 'machineselection'
      });
      this._useMachineButton = $('<div></div>').addClass('machineselection-usemachines-button')
        .attr('title', 'Switch to machine selection');
      this._previewHeader = $('<div></div>').addClass('machineselection-preview-header')
        .append(previewTitle).append(this._freeTextLastUpdate).append(this._useMachineButton);
      this._previewList = $('<div></div>').addClass('machineselection-preview-list');
      this._previewListContainer = $('<div></div>')
        .addClass('machineselection-preview-list-container') // For scroll
        .append(this._previewList);

      page2.append(this._previewHeader).append(this._previewListContainer);

      pulseSvg.inlineBackgroundSvg(this._useMachineButton);

      this._useMachineButton.click(function () {
        let grouparrays = $(this._previewList).find('x-grouparray');
        if (grouparrays.length > 0) {
          let machinesList = grouparrays[0].getMachinesList();
          //this._groupSelectionArray = machinesList.split(','); // was [];
          this._machineSelectionArray = machinesList.split(',');
          // Change selection on left display
          this._changeSelectionInMachineList();
          //this._changeSelectionInCategoryList();

          //this._fillSelection(); == done in _switchToMachineSelection
        }
        this._switchToMachineSelection();
      }.bind(this));

      this._fillCategoryList();

      // Create a dialog
      this._dialogId = pulseCustomDialog.initialize(this._dialogPage1, {
        title: this._uniquemachine ? 'Select a machine' : 'Select machines',
        autoClose: false,
        onOpen: function () {
          // Reinitialize selection and view
          // If it can be changed anywhere else :
          // Load current selections
          this._loadSelection();

        }.bind(this),
        onOk: function () {
          if (this._useMachineSelection) {
            if (this._machineSelectionArray.length == 0) {
              pulseCustomDialog.openError(
                this._uniquemachine
                  ? 'Please select one machine.'
                  : 'Please select at least one machine.');
              return;
            }
          }
          else {
            if (this._groupSelectionArray.length == 0) {
              pulseCustomDialog.openError(
                'Please select at least one group');
              return;
            }
            // If 'no machine' in static groups
            if ($(this._previewList).find('.no-machines').length > 0) {
              // Find if static only
              let staticOnly = true;
              for (let iGroup = 0; iGroup < this._groupSelectionArray.length; iGroup++) {
                let groupId = this._groupSelectionArray[iGroup].toString();
                if (this._groupDisplays.has(groupId)) {
                  let displayClass = this._groupDisplays.get(groupId);
                  if (displayClass.dynamic)
                    staticOnly = false;
                }
              } // end for

              if (staticOnly) {
                pulseCustomDialog.openError(
                  'Please select groups including at least one machine.');
                return;
              }
            }
          }
          // Store the new displayed parameters in CONFIG
          this._storeSelection();

          // Update summary from selection
          this._fillSummaryDisplay();

          pulseCustomDialog.close(this._dialogPage1);
        }.bind(this),
        onCancel: function () {
          pulseCustomDialog.close(this._dialogPage1);
        }.bind(this),
        fullScreenOnSmartphone: true,
        fixedHeight: true,
        fullSize: true,
        helpName: 'machineselection'
      });
      pulseCustomDialog.addPage(this._dialogPage1, this._dialogPage2);
      // this._addDragAndDropEvents(); No. Not here !

      // FILL must be one AFTER dialog creation to display icons 
      this._fillMachinesList();

      // Default = useGroupSelection -> list of machines == hidden
      this._switchToGroupSelection();
    }


    ////////////////////////////////////////////////
    // Toggle between machine and group selection //
    ////////////////////////////////////////////////
    _switchToMachineSelection () {
      this._useMachineSelection = true;

      if (this._machinesListContainer == undefined)
        return;
      this._previewHeader.hide();
      this._previewListContainer.hide();

      this._selectionTitle.html('Selected machines');

      this._machinesSearchDiv.show();
      this._machinesListContainer.show();

      this._groupSelectionArray = []; // CLEAR GROUPS !
      // Update check boxes in left panel including _fillSelection, including Clear preview
      this._changeSelectionInCategoryList();
      this._categoryList.hide();

      this._changeSelectionInMachineList();

      this._switchToMachines_button.addClass('selected');
      this._switchToGroups_button.removeClass('selected');
      this._switchToMachines_button.prop('disabled', true);
      this._switchToGroups_button.prop('disabled', false);
    }

    _switchToGroupSelection () {
      this._useMachineSelection = false;

      if (this._machinesListContainer == undefined)
        return;
      this._previewHeader.show();
      this._previewListContainer.show();

      this._selectionTitle.html('Selected groups');

      this._machinesSearchDiv.hide();
      this._machinesListContainer.hide();

      this._categoryList.show();

      this._switchToMachines_button.removeClass('selected');
      this._switchToGroups_button.addClass('selected');
      this._switchToMachines_button.prop('disabled', false);
      this._switchToGroups_button.prop('disabled', true);
    }

    ////////////////
    // ADD EVENTS //
    ////////////////
    _addMoveUpDownEvents () {
      var machineselection = this;

      $(this._selectionList).find('.reorderDownButton').click(function () {
        $(this).parent('.machineselection-selection');
        let draggedOrder = parseInt($(this).parent().parent().css('order'));
        let newOrder = draggedOrder + 1;

        if (machineselection._useMachineSelection) {
          if (machineselection._machineSelectionArray.length > 0) {
            let movedItem = machineselection._machineSelectionArray[draggedOrder];
            machineselection._machineSelectionArray.splice(draggedOrder, 1);
            machineselection._machineSelectionArray.splice(newOrder, 0, movedItem);
          }
        }
        else {
          if (machineselection._groupSelectionArray.length > 0) {
            let movedItem = machineselection._groupSelectionArray[draggedOrder];
            machineselection._groupSelectionArray.splice(draggedOrder, 1);
            machineselection._groupSelectionArray.splice(newOrder, 0, movedItem);
          }
        }
        // Change order in display
        machineselection._fillSelection();
      });

      $(this._selectionList).find('.reorderUpButton').click(function () {
        let draggedOrder = parseInt($(this).parent().parent().css('order'));
        let newOrder = draggedOrder - 1;

        if (machineselection._useMachineSelection) {
          if (machineselection._machineSelectionArray.length > 0) {
            let movedItem = machineselection._machineSelectionArray[draggedOrder];
            machineselection._machineSelectionArray.splice(draggedOrder, 1);
            machineselection._machineSelectionArray.splice(newOrder, 0, movedItem);
          }
        }
        else {
          if (machineselection._groupSelectionArray.length > 0) {
            let movedItem = machineselection._groupSelectionArray[draggedOrder];
            machineselection._groupSelectionArray.splice(draggedOrder, 1);
            machineselection._groupSelectionArray.splice(newOrder, 0, movedItem);
          }
        }
        // Change order in display
        machineselection._fillSelection();
      });
    }

    _addDragAndDropEvents () {
      var machineselection = this;
      var dragSrcEl = null;

      function handleDragStart (e) {
        // Target (this) element is the source node.
        dragSrcEl = this;

        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', this.outerHTML);

        this.classList.add('dragElem');
      }
      function handleDragOver (e) {
        if (e.preventDefault) {
          e.preventDefault(); // Necessary. Allows us to drop.
        }
        e.dataTransfer.dropEffect = 'move';  // See the section on the DataTransfer object.

        if (e.clientY - this.getBoundingClientRect().top < this.clientHeight / 2) {
          // Insert above
          this.classList.remove('dragOverBottom');
          this.classList.add('dragOverTop');
        }
        else {
          // Insert below
          this.classList.remove('dragOverTop');
          this.classList.add('dragOverBottom');
        }
        return false;
      }

      function handleDragEnter (e) {
        // this / e.target is the current hover target.
      }

      function handleDragLeave (e) {
        // this / e.target is previous target element.
        this.classList.remove('dragOverTop');
        this.classList.remove('dragOverBottom');
      }

      function handleDrop (e) {
        // this/e.target is current target element.

        if (e.stopPropagation) {
          e.stopPropagation(); // Stops some browsers from redirecting.
        }
        // Don't do anything if dropping the same column we're dragging.
        if (dragSrcEl != this) {
          let draggedOrder = parseInt($(dragSrcEl).css('order'));
          let dragToTopOrder = undefined;
          let dragToBottomOrder = undefined;

          let toTop = $(this).hasClass('dragOverTop');
          if (toTop) {
            dragToTopOrder = parseInt($(this).css('order'));
          }
          let toBottom = $(this).hasClass('dragOverBottom');
          if (toBottom) {
            dragToBottomOrder = parseInt($(this).css('order'));
            if (dragToTopOrder == undefined)
              dragToTopOrder = dragToBottomOrder + 1;
          }

          if (dragToTopOrder == undefined && dragToBottomOrder == undefined)
            return; // Never

          // Check top / bottom & unify
          let newOrder;
          if (dragToTopOrder < draggedOrder) { // Move to Top
            newOrder = dragToTopOrder;
          }
          else { // Move To Bottom
            newOrder = parseInt(dragToTopOrder) - 1; //dragToBottomOrder;
          }
          if (machineselection._useMachineSelection) {
            if (machineselection._machineSelectionArray.length > 0) {
              let movedItem = machineselection._machineSelectionArray[draggedOrder];
              machineselection._machineSelectionArray.splice(draggedOrder, 1);
              machineselection._machineSelectionArray.splice(newOrder, 0, movedItem);
            }
          }
          else {
            if (machineselection._groupSelectionArray.length > 0) {
              let movedItem = machineselection._groupSelectionArray[draggedOrder];
              machineselection._groupSelectionArray.splice(draggedOrder, 1);
              machineselection._groupSelectionArray.splice(newOrder, 0, movedItem);
            }
          }
          // Change order in display
          machineselection._fillSelection();
        }

        //this.classList.remove('dragOverTop');
        //this.classList.remove('dragOverBottom');
        return false;
      }

      function handleDragEnd (e) {
        // this/e.target is the source node.
        this.classList.remove('dragOverTop');
        this.classList.remove('dragOverBottom');
      }

      let addEvents = function (elem) {
        elem.setAttribute('draggable', true);

        elem.addEventListener('dragstart', handleDragStart, false);
        elem.addEventListener('dragenter', handleDragEnter, false)
        elem.addEventListener('dragover', handleDragOver, false);
        elem.addEventListener('dragleave', handleDragLeave, false);
        elem.addEventListener('drop', handleDrop, false);
        elem.addEventListener('dragend', handleDragEnd, false);
      }

      $(machineselection._selectionList).find('.machineselection-selection').each(function () {
        addEvents(this);
      });
    }

    ////////////////////////////////////////////////////////////////////////
    // FUNCTIONS FOR UPDATING Machine List AND show/hide machines in list //
    ////////////////////////////////////////////////////////////////////////

    // Fill machines list
    _fillMachinesList () {
      if (this._machinesList == undefined)
        return;
      $(this._machinesList).empty();

      for (let displayClass of this._groupDisplays) {
        if (displayClass[1].singlemachine) {
          let id = displayClass[0];
          let displayStr = displayClass[1].display;

          // Button to add 
          let addButton = $('<div></div>').addClass('machineselection-add-machine-button')
            .attr('machine-id', id);
          let removeButton = $('<div></div>').addClass('machineselection-remove-machine-button')
            .attr('machine-id', id);

          let machSpan = $('<span></span>').addClass('machines-display')
            .html(displayStr);
          let machDiv = $('<div></div>').addClass('machines-div')
            .attr('machine-id', id).append(machSpan)
            .append(addButton).append(removeButton);

          if (displayClass[1].sortpriority != undefined)
            machDiv.css('order', displayClass[1].sortpriority);

          $(this._machinesList).append(machDiv);

          pulseSvg.inlineBackgroundSvg(addButton);
          pulseSvg.inlineBackgroundSvg(removeButton);

          machDiv.click(function (machineselection) { // to avoid closure
            return function () {
              let machid = $(this).attr('machine-id');

              if ($(this).hasClass('selected')) {
                // REMOVE MACHINE
                if (machineselection._machineSelectionArray.includes(machid)) {
                  machineselection._machineSelectionArray =
                    machineselection._machineSelectionArray.filter(
                      function (value, index, arr) {
                        return value != machid;
                      }
                    );
                }
              }
              else {
                // ADD MACHINE
                if (!machineselection._machineSelectionArray.includes(machid))
                  machineselection._machineSelectionArray.push(machid);
              }

              // Always
              // Update left panel
              machineselection._changeSelectionInMachineList();
              // Update right panel
              machineselection._fillSelection();
            }
          }(this));
          //selected ?
          /*
                    addButton.click(function (machineselection) { // to avoid closure
                      return function () {
                        let machid = $(this).attr('machine-id');
                        // ADD MACHINE
                        if (!machineselection._machineSelectionArray.includes(machid))
                          machineselection._machineSelectionArray.push(machid);
          
                        // Update left panel
                        machineselection._changeSelectionInMachineList();
                        // Update right panel
                        machineselection._fillSelection();
                      }
                    }(this));
          
          
                    removeButton.click(function (machineselection) { // to avoid closure
                      return function () {
                        let machid = $(this).attr('machine-id');
                        // REMOVE MACHINE
                        if (machineselection._machineSelectionArray.includes(machid)) {
                          machineselection._machineSelectionArray =
                            machineselection._machineSelectionArray.filter(
                              function (value, index, arr) {
                                return value != machid;
                              }
                            );
                        }
          
                        // Update left panel
                        machineselection._changeSelectionInMachineList();
                        // Update right panel
                        machineselection._fillSelection();
                      }
                    }(this));
                    */
        }
      }
    }

    _showHideMachinesInList () {
      let searchString = $(this._inputSearch)[0].value;
      // Use as filter

      let machinesDiv = $(this._machinesList).find('.machines-div');
      for (let i = 0; i < machinesDiv.length; i++) {
        let machineDisplay = $(machinesDiv[i]).find('.machines-display').html();
        if (machineDisplay.toLowerCase().includes(searchString.toLowerCase())) {
          $(machinesDiv[i]).show();
        }
        else {
          $(machinesDiv[i]).hide();
        }
      }
    }

    _changeSelectionInMachineList () {
      if (this._dialogPage1 == undefined)
        return;

      // Remove all selections
      $(this._machinesList).find('.machines-div.selected').removeClass('selected');

      // Add current selection
      for (let i = 0; i < this._machineSelectionArray.length; i++) {
        let machid = this._machineSelectionArray[i];

        let machDivs = $(this._machinesList).find('.machines-div[machine-id=' + machid + ']');
        if (machDivs.length > 0) {// Always
          machDivs.addClass('selected');
        }
      }

      // Change preview in right panel
      //this._fillSelection();
    }

    ///////////////////////////////////////////////////////////////
    // FUNCTIONS FOR UPDATING THE SELECTION : storage -> display //
    ///////////////////////////////////////////////////////////////

    _fillSelection () {// -> to fill right panel (Warning ! Change _fillSummaryDisplay accordingly)
      if (this._selectionList == undefined)
        return;
      $(this._selectionList).empty();

      let arrayToDisplay;
      if (false == this._useMachineSelection)
        arrayToDisplay = this._groupSelectionArray;
      else
        arrayToDisplay = this._machineSelectionArray;

      if (arrayToDisplay.length == 0) {
        let noSel = $('<span></span>').addClass('no-selection')
          .html('No selection');
        this._selectionList.append(noSel);

        // Update preview = empty
        this._fillMachinePreview();
        return;
      }

      for (let iGroup = 0; iGroup < arrayToDisplay.length; iGroup++) {
        let groupId = arrayToDisplay[iGroup].toString();

        let selection = $('<div></div>').addClass('machineselection-selection')
          .attr('groupId', groupId);

        if (!this._groupDisplays.has(groupId))
          continue; // Probably error when loading
        let displayClass = this._groupDisplays.get(groupId);

        let highlight = $('<div></div>').addClass('reorderHighlight');
        let upButton = $('<div></div>').addClass('reorderUpButton');         // smartphone ?
        let downButton = $('<div></div>').addClass('reorderDownButton');     // smartphone ?
        let reorderButton = $('<div></div>').addClass('reorderButton');

        let row = $('<div></div>').addClass('selection-position');
        row.append(highlight).append(upButton).append(downButton)
          .append(reorderButton);

        let spanDisplay = $('<span></span>').addClass('selection-display')
          .html(displayClass.display);
        let removeButton = $('<div></div>').addClass('remove-button')
          .attr('groupId', groupId);
        row.append(spanDisplay).append(removeButton);
        if (displayClass.singlemachine) {
          let spanMachine = $('<span></span>').addClass('machineselection-machine-label')
            .html('M');
          row.append(spanMachine);
        }
        else {
          let spanGroup = $('<span></span>').addClass('machineselection-group-label')
            .html('G');
          row.append(spanGroup);
        }
        if (displayClass.dynamic) {
          let spanDynamic = $('<span></span>').addClass('machineselection-dynamic-label')
            .html('DYNAMIC');
          row.append(spanDynamic);
        }
        selection.append(row);

        $(selection).css('order', iGroup);
        this._selectionList.append(selection);

        pulseSvg.inlineBackgroundSvg(upButton);
        pulseSvg.inlineBackgroundSvg(downButton);
        //pulseSvg.inlineBackgroundSvg(reorderButton); // Is PNG... not possible for the moment

        pulseSvg.inlineBackgroundSvg(removeButton);

        removeButton.click(function (machineselection) { // to avoid closure
          return function () {
            let group = $(this).attr('groupid');

            if (false == machineselection._useMachineSelection) {
              // remove group
              machineselection._groupSelectionArray =
                machineselection._groupSelectionArray.filter(
                  function (value, index, arr) {
                    return value != group;
                  }
                );
              // Change selection on left display
              machineselection._changeSelectionInCategoryList();
              // Update (nb of selection) -> useful when unchecked !
              let selectedCategory = $(machineselection._dialogPage1).find('input[groupid=' + group + ']');
              let parentsCategories = $(selectedCategory).parents('.machineselection-category');
              for (let iCat = 0; iCat < parentsCategories.length; iCat++)
                machineselection._updateNumberOfSelections(parentsCategories[iCat]);
            }
            else {
              // remove machine
              machineselection._machineSelectionArray =
                machineselection._machineSelectionArray.filter(
                  function (value, index, arr) {
                    return value != group;
                  }
                );

              machineselection._changeSelectionInMachineList();
            }
            // Update right panel
            machineselection._fillSelection();
          }
        }(this));

      } // and for 
      this._addDragAndDropEvents();
      this._addMoveUpDownEvents();

      this._fillMachinePreview();
    }

    _fillMachinePreview () {
      this._previewList.empty();
      this._freeTextLastUpdate[0].cleanDisplay();

      if (false == this._useMachineSelection) {
        // and REAL fill
        if (this._groupSelectionArray.length > 0) {
          // .hidden-content
          let singleMachine = pulseUtility.createjQueryElementWithAttribute('x-machinedisplay', {});
          let toClone = $('<div id=machinetoclone></div').addClass('preview-machine-position').append(singleMachine);
          let hidden = $('<div></div').addClass('hidden-content').append(toClone);
          this._previewList.append(hidden);

          // group to display many times hidden content
          let grouparray = pulseUtility.createjQueryElementWithAttribute('x-grouparray', {
            'templateid': 'machinetoclone',
            'group': this._groupSelectionArray.join(),
            //'machine': this._machineSelectionArray.join(), -> No NEVER !
            'canUseRowsToSetHeight': false,
            'allowpagerotation': 'false',
            'rotation': 10, // sec = refreshrate
            'row': 999, // To avoid displaying only some rows
            'textchange-context': 'machineselection',
            'donotwarngroupreload': 'true' // to avoid unwanted field legend reload
          });
          this._previewList.append(grouparray);
        }
      }
    }

    ///////////////////////////////////////////////////////
    // FUNCTIONS FOR UPDATING THE SELECTION : attributes //
    ///////////////////////////////////////////////////////

    // Array -> CONFIG
    _storeSelection () {
      if (false == this._useMachineSelection) {
        // Update machines list
        let grouparrays = $(this._previewList).find('x-grouparray');
        if (grouparrays.length > 0) {
          let machinesList = grouparrays[0].getMachinesList();
          this._machineSelectionArray = machinesList.split(',');
        }
        else {
          this._machineSelectionArray = [];
        }
      }
      else { // Store machines only
        // Warning ! Do not copy using '=' !
        this._groupSelectionArray = [].concat(this._machineSelectionArray);
      }


      let joinedMachines = this._machineSelectionArray.join();
      let joinedGroups = this._groupSelectionArray.join();
      if (!this.element.hasAttribute('in-report')) {
        // store machines
        pulseConfig.set(this._configMachines, joinedMachines, true);

        // Store groups
        if ((joinedGroups == joinedMachines)
          || (this._groupSelectionArray == []))
          pulseConfig.set(this._configGroups, '', true);
        else
          pulseConfig.set(this._configGroups, joinedGroups, true);

        // Config changed : warn xtags
        eventBus.EventBus.dispatchToAll('configChangeEvent',
          { 'config': this._configMachines });
        // Do nearly the same as previous line
        eventBus.EventBus.dispatchToAll('configChangeEvent',
          { 'config': this._configGroups });

        // Check LEGEND display - should be somewhere else, but where ?
        $('.legend-content').resize();
      }
      else {
        // For report only. But can be always
        this.element.setAttribute('pulse-machines', joinedMachines);
        this.element.setAttribute('pulse-groups', joinedGroups);
      }
    }

    _getSelectedIndexes (attribute) {
      let arr = [];
      let arrString = this.getConfigOrAttribute(attribute, '')
      if (arrString != '') {
        arr = arrString.split(',');
      }
      return arr;
    }

    // CONFIG -> this._groupSelectionArray / this._machineSelectionArray
    _loadSelection () {
      let joinedMachines = "";
      let joinedGroups = "";

      if (!this.element.hasAttribute('in-report')) {
        // get CONFIG + store here - PWA version
        this._groupSelectionArray = this._getSelectedIndexes(this._configGroups, false);
        this._machineSelectionArray = this._getSelectedIndexes(this._configMachines, false);

        if (this._groupSelectionArray.length == 0) {
          // Warning ! Do not copy using = !
          this._groupSelectionArray = [].concat(this._machineSelectionArray);
        }

        joinedMachines = this._machineSelectionArray.join();
        joinedGroups = this._groupSelectionArray.join();
      }
      else {
        // load initial data - for report use
        if (this.element.hasAttribute('pulse-machines')) {
          joinedMachines = this.element.getAttribute('pulse-machines');
        }
        if (this.element.hasAttribute('pulse-groups')) {
          joinedGroups = this.element.getAttribute('pulse-groups');
        }

        if (joinedGroups == "") {
          // Copy
          joinedGroups = joinedMachines;
        }

        if (joinedGroups == "") {
          // Empty
          this._groupSelectionArray = [];
        }
        else {
          this._groupSelectionArray = joinedGroups.split(',');
        }

        if (joinedMachines == "") {
          // Empty
          this._machineSelectionArray = [];
        }
        else {
          this._machineSelectionArray = joinedMachines.split(',');
        }
      }

      if (joinedGroups == joinedMachines
        && this._machineSelectionArray.length != 0) {
        this._switchToMachineSelection();

        this._changeSelectionInMachineList();
        this._fillSelection();
      }
      else {
        this._switchToGroupSelection();

        // Update check boxes in left panel including _fillSelection
        this._changeSelectionInCategoryList(true);
        this._changeSelectionInMachineList();
      }
    }

    _clearSelection () {
      $(this._dialogPage1).find('input:checkbox').prop('checked', false);
      //this._switchToGroupSelection(); // Show / Hide -> Not anymore

      this._groupSelectionArray = [];
      this._machineSelectionArray = [];

      // Update check boxes in left panel including _fillSelection
      this._changeSelectionInCategoryList();
      // And selection in machine list
      this._changeSelectionInMachineList();
    }

    _updateNumberOfSelections (mainCategory) {
      let selections = $(mainCategory).find('input:checkbox');
      let nbSel = 0;
      for (let iSel = 0; iSel < selections.length; iSel++) {
        if (selections[iSel].checked) {
          nbSel++;
        }
      }
      if (nbSel == 0) {
        $(mainCategory).children('.machineselection-category-row').find('.number-of-selections').html('');
      }
      else {

        $(mainCategory).children('.machineselection-category-row').find('.number-of-selections').html('(' + nbSel + ')');
      }
    }

    ///////////////////////////////////////////////////////////////////////
    _storeDisplays () {
      this._groupDisplays.clear();

      let storeSubGroups = function (machineselection, groups) {
        for (let iGroup = 0; iGroup < groups.length; iGroup++) {
          if (groups[iGroup].Display != '') {
            machineselection._groupDisplays.set(groups[iGroup].Id.toString(), {
              display: groups[iGroup].Display,
              dynamic: (groups[iGroup].Dynamic == true), // unknown => false
              singlemachine: (groups[iGroup].SingleMachine == true),
              sortpriority: groups[iGroup].SortPriority
            });

            // Add Sub Sub groups
            if (!pulseUtility.isNotDefined(groups[iGroup].Zoom)) {
              storeSubGroups(machineselection, groups[iGroup].Zoom);
            }
          }
        }
      }

      for (let catIndex = 0; catIndex < this._groups.length; catIndex++) {
        let groups = this._groups[catIndex].Groups;
        if (groups != null) {
          storeSubGroups(this, groups);
        }
      }

      // Check in this._machinesFromService = data.MachineList if machines are missing
      for (let machIndex = 0; machIndex < this._machinesFromService.length; machIndex++) {
        let mach = this._machinesFromService[machIndex];
        if (!this._groupDisplays.has(mach.Id.toString())) {
          // if not exists - ADD (Should rarely happen)
          this._groupDisplays.set(mach.Id.toString(), {
            display: mach.Display,
            dynamic: false,
            singlemachine: true,
            sortpriority: mach.DisplayPriority
          });
          console.warn('x-machineselection : machine '
            + mach.Display + ' is not in groups');
        }
      }

    }

    ///////////////////////////////////////////////////////////////////////
    // FUNCTIONS FOR DISPLAYING groups and selection in left panel       //
    ///////////////////////////////////////////////////////////////////////
    _fillCategoryList () {
      if (this._categoryList == undefined)
        return; // Can happen before dialog creation

      let getSubGroups = function (machineselection, container, groups, isMain) {

        let nbSubGroups = 0;
        for (let i = 0; i < groups.length; i++) {
          if (groups[i].Display != '') {
            // Show / Hide Icon
            let svgShow = $('<div></div>').addClass('show-sub');
            let svgHide = $('<div></div>').addClass('hide-sub');
            let showHide = $('<div></div>').addClass('machineselection-subcategory-visibility')
              //.addClass('closed') not here
              .append(svgShow).append(svgHide);
            pulseSvg.inlineBackgroundSvg(svgShow);
            pulseSvg.inlineBackgroundSvg(svgHide);

            // display / (x) / check / showHide / isSub
            let spanDisplay = $('<span></span>').addClass('category-display')
              .html(groups[i].TreeName);
            let nbSel = $('<span></span>').addClass('number-of-selections').html('');
            let checkbox = $('<input type="checkbox" groupid="' + groups[i].Id + '" dynamic="' + groups[i].Dynamic + '">');
            let divRow = $('<div></div>').addClass('machineselection-category-row')
              .append(spanDisplay).append(nbSel);
            if (isMain)
              divRow.addClass('is-main');
            divRow.append(showHide).append(checkbox);
            if (groups[i].Dynamic) {
              let spanDynamic = $('<span></span>').addClass('machineselection-dynamic-label')
                .html('DYNAMIC');
              divRow.append(spanDynamic);
            }
            let category = $('<div></div>').addClass('machineselection-category').append(divRow);

            // Collapse / Expand machine categories
            showHide.click(function () {
              if ($(this).hasClass('closed')) {
                $(this).removeClass('closed');
                $(this).addClass('opened');

                $(this).closest('.machineselection-category')
                  .children('.machineselection-category-content').toggle();
              }
              else if ($(this).hasClass('opened')) {
                $(this).removeClass('opened');
                $(this).addClass('closed');

                $(this).closest('.machineselection-category')
                  .children('.machineselection-category-content').toggle();
              }
            });

            // click on checkbox
            checkbox.change(function (machineselection) { // to avoid closure
              return function () {
                machineselection._switchToGroupSelection();

                let group = $(this).attr('groupid');
                let isChecked = $(this).is(':checked');
                if (isChecked) {
                  // add group if not exists
                  if (!machineselection._groupSelectionArray.includes(group))
                    machineselection._groupSelectionArray.push(group);
                }
                else {
                  // remove group
                  machineselection._groupSelectionArray =
                    machineselection._groupSelectionArray.filter(
                      function (value, index, arr) {
                        return value != group;
                      }
                    );
                }
                // Find all displays for groupid
                let changedCategory = $(machineselection._dialogPage1).find('input[groupid=' + group + ']');
                // Check/Uncheck similar groups
                changedCategory.prop('checked', isChecked);

                for (let iChanged = 0; iChanged < changedCategory.length; iChanged++) {
                  // Update (nb of selection) here AND in parents
                  let parentsCat = $(changedCategory[iChanged]).parents('.machineselection-category');
                  for (let iParent = 0; iParent < parentsCat.length; iParent++)
                    machineselection._updateNumberOfSelections(parentsCat[iParent]);
                }
                //if (false == machineselection._useMachineSelection) ???
                // Update right panel
                machineselection._fillSelection();
              }
            }(machineselection));

            // Add Sub Sub groups in li
            if (!pulseUtility.isNotDefined(groups[i].Zoom)) {
              let hiddenSubGroup = $('<div></div>').addClass('machineselection-category-content');
              let nbSubSubGroups = getSubGroups(machineselection, hiddenSubGroup, groups[i].Zoom);
              if (nbSubSubGroups > 0) {
                category.append(hiddenSubGroup);
                //if (nbSubSubGroups >= 2) {
                category.addClass('expandable');
                hiddenSubGroup.css('display', 'none');
                showHide.addClass('closed');
                /*}
                else {
                  showHide.empty();
                  showHide.addClass('noChild');
                }*/
              }
            }
            else {
              showHide.empty();
              showHide.addClass('noChild');
            }

            container.append(category);
            nbSubGroups++;
          }
        }
        return nbSubGroups;
      }

      this._categoryList.empty();

      // Real list
      let fullListToScroll = $('<div></div>').addClass('machineselection-categorylist-full');
      let list = '';
      for (let catIndex = 0; catIndex < this._groups.length; catIndex++) {
        let groups = this._groups[catIndex].Groups;
        let omitCat = this._groups[catIndex].OmitGroupCategory;
        if (groups != null && groups.length > 0) {
          if (!pulseUtility.isNotDefined(omitCat) && omitCat == true
            && groups.length == 1 && groups[0].Display != '') {
            // Ignore ONE LEVEL
            let category = $('<div></div>').addClass('machineselection-category');
            let nbSubGroups = getSubGroups(this, category, groups, true);
            if (nbSubGroups == 1)
              fullListToScroll.append(category);

          }
          else {
            // Show / Hide Icon
            let svgShow = $('<div></div>').addClass('show-sub');
            let svgHide = $('<div></div>').addClass('hide-sub');
            let showHide = $('<div></div>').addClass('machineselection-subcategory-visibility')
              //.addClass('closed') Not here
              .append(svgShow).append(svgHide);
            pulseSvg.inlineBackgroundSvg(svgShow);
            pulseSvg.inlineBackgroundSvg(svgHide);

            //
            let span = $('<span></span>').addClass('category-display')
              .html(this._groups[catIndex].Display); // TreeName = not defined
            let nbSel = $('<span></span>').addClass('number-of-selections').html('');
            let divHeader = $('<div></div>')
              .addClass('machineselection-category-row').addClass('is-main')
              .append(span).append(nbSel).append(showHide);
            let category = $('<div></div>').addClass('machineselection-category')
              .append(divHeader);

            // Collapse / Expand machine categories
            showHide.click(function () {
              if ($(this).hasClass('closed')) {
                $(this).removeClass('closed');
                $(this).addClass('opened');

                $(this).closest('.machineselection-category')
                  .children('.machineselection-category-content').toggle();
              }
              else if ($(this).hasClass('opened')) {
                $(this).removeClass('opened');
                $(this).addClass('closed');

                $(this).closest('.machineselection-category')
                  .children('.machineselection-category-content').toggle();
              }
            });

            let hiddenSubGroup = $('<div style="display:none;"></div>').addClass('machineselection-category-content');
            let nbSubGroups = getSubGroups(this, hiddenSubGroup, groups);
            if (nbSubGroups > 0) {
              category.append(hiddenSubGroup);
              category.addClass('expandable');
              showHide.addClass('closed');
            }
            fullListToScroll.append(category);
          }
        }
      }
      fullListToScroll.append(list);

      this._categoryList.append(fullListToScroll);
    }

    // _groupSelectionArray -> fill check boxes accordingly
    // (andOpen == true) -> open selection
    _changeSelectionInCategoryList (andOpen) {
      if (this._dialogPage1 == undefined)
        return;

      // Remove all checks
      $(this._dialogPage1).find('input:checkbox').prop('checked', false);

      // Add current selection
      for (let i = 0; i < this._groupSelectionArray.length; i++) {
        let group = this._groupSelectionArray[i];
        let selectedCategory = $(this._dialogPage1).find('input[groupid=' + group + ']');
        if (selectedCategory.length == 0) {
          // Error in config ! -> 
          console.warn('Check group configuration for ' + group);
          // Remove group from selection
          this._groupSelectionArray.splice(i, 1);
          // Re-start this method
          this._changeSelectionInCategoryList(andOpen);
          // Exit
          return;
        }
        else {
          selectedCategory.prop('checked', true);

          for (let iCat = 0; iCat < selectedCategory.length; iCat++) {
            if (andOpen == true) {
              // Open parent
              $(selectedCategory[iCat]).parents('.machineselection-category')
                .find('.machineselection-category-content').show();
              // Change ShowHide icon
              $(selectedCategory[iCat]).parents('closed')
                .addClass('opened').removeClass('closed');
            }
          }
        }
      }
      // Update (nb of selection) for ALL categories
      let parentsCat = $(this._dialogPage1).find('.machineselection-category');
      for (let iParent = 0; iParent < parentsCat.length; iParent++)
        this._updateNumberOfSelections(parentsCat[iParent]);

      // Change preview in right panel
      this._fillSelection();
    }

    /////////////////////////////////////////////////////////
    // FUNCTIONS FOR DISPLAYING selected machines / groups //
    /////////////////////////////////////////////////////////
    // this._machines && this._categories -> this._summary
    _fillSummaryDisplay () { // Inpired from _fillSelection
      if (this._summary == undefined)
        return;
      $(this._summary).empty();

      let ul = $('<div></div>');

      let arrayToDisplay;
      if (false == this._useMachineSelection)
        arrayToDisplay = this._groupSelectionArray;
      else
        arrayToDisplay = this._machineSelectionArray;

      let oneGroupIsAdded = false;
      for (let iGroup = 0; iGroup < arrayToDisplay.length; iGroup++) {
        let groupId = arrayToDisplay[iGroup].toString();
        let display = 'No machine selection';
        if (this._groupDisplays.has(groupId)) {
          let displayClass = this._groupDisplays.get(groupId);
          display = displayClass.display;
        }
        let li = $('<div></div>');
        let span = $('<span></span>').html(display);
        li.append(span);
        ul.append(li);
        oneGroupIsAdded = true;
      }

      // Missing config or not :
      if (!oneGroupIsAdded) {
        //if (false == this._useMachineSelection) {
        /*this._summary.html(
          (this._uniquemachine)
            ? 'No machines selected'
            : 'All machines selected');*/
        this._summary.html('No machines selected');
        this._summary.addClass('missing-config');
        $(this.element).parent().addClass('missing-config');
        $(this.element).parent().parent().addClass('missing-config');
        /*}
        else {
          this._summary.html('No group selected');
          this._summary.addClass('missing-config');
          $(this.element).parent().addClass('missing-config');
          $(this.element).parent().parent().addClass('missing-config');
        }*/
      }
      else {
        this._summary.append(ul);

        this._summary.removeClass('missing-config');
        $(this.element).parent().removeClass('missing-config');
        $(this.element).parent().parent().removeClass('missing-config');
      }
    }

    /////////////////////////////////////////////////////////////
    // EXTERNAL FUNCTION TO DISPLAY selected machines / groups //
    /////////////////////////////////////////////////////////////
    // summary = existing div
    fillExternalSummaryDisplay (summary) { // Inpired from _fillSelection
      if (summary == undefined)
        return;
      $(summary).empty();

      let ul = $('<div></div>');

      let arrayToDisplay;
      if (false == this._useMachineSelection)
        arrayToDisplay = this._groupSelectionArray;
      else
        arrayToDisplay = this._machineSelectionArray;

      let oneGroupIsAdded = false;
      for (let iGroup = 0; iGroup < arrayToDisplay.length; iGroup++) {
        let groupId = arrayToDisplay[iGroup];
        let display = 'No machine selection';
        if (this._groupDisplays.has(groupId)) {
          let displayClass = this._groupDisplays.get(groupId);
          display = displayClass.display;
        }
        let li = $('<div></div>');
        let span = $('<span></span>').html(display);
        li.append(span);
        ul.append(li);
        oneGroupIsAdded = true;
      }

      // Missing config or not :
      if (!oneGroupIsAdded) {
        summary.html('No machines selected');
        summary.addClass('missing-config');
      }
      else {
        summary.append(ul);
        summary.removeClass('missing-config');
      }
    }

    /////////////////////////////////////////////////////////////
    // EXTERNAL FUNCTIONS TO get selected machines / groups    //
    /////////////////////////////////////////////////////////////
    getMachinesArray () {
      return ([].concat(this._machineSelectionArray));
    }
    getGroupsArray () {
      return ([].concat(this._groupSelectionArray));
    }
    getMachinesString () {
      return this._machineSelectionArray.join();
    }
    getGroupsString () {
      return this._groupSelectionArray.join();
    }

  }

  pulseComponent.registerElement('x-machineselection', MachineSelectionComponent, ['unique-machine']);
})();

},{"eventBus":"eventBus","pulseConfig":"pulseConfig","pulseCustomDialog":"pulseCustomDialog","pulseLogin":"pulseLogin","pulseSvg":"pulseSvg","pulseUtility":"pulseUtility","pulsecomponent":2,"x-freetext/x-freetext":80,"x-grouparray/x-grouparray":81,"x-machinedisplay/x-machinedisplay":83}],85:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-markdowntext
 * @requires module:pulseComponent
 */

var pulseComponent = require('pulsecomponent');
//var pulseUtility = require('pulseUtility');

(function () {

  class markDownTextComponent extends pulseComponent.PulseInitializedComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      self.methods = {
        setText: self.setText // used by reporting
      };

      // DOM - not here
      self._content = undefined;

      return self;
    }

    setText (textToDisplay) {
      $(this._content).empty();

      if (textToDisplay == null) {
        console.warn('Please FILL markdown text ! ');
      }
      else {
        // See use here : https://www.npmjs.com/package/markdown-it
        var MarkdownIt = require('markdown-it');
        let md = new MarkdownIt();
        let result = md.render(textToDisplay);

        $(this._content).append(
          $('<div></div>').addClass('markdowntext-maindiv').html(result)
        );
      }
    }

    //get content () { return this._content; } // Optional

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
      /*
      switch (attr) {
        case 'machine-id':
          break;
        default:
          break;
      }
      */
    }

    initialize () {
      this.addClass('pulse-text'); // Mandatory for loader

      // Update here some internal parameters

      // In case of clone, need to be empty :
      $(this.element).empty();

      // Create DOM - Content
      this._content = $('<div></div>').addClass('markdowntext-content');
      $(this.element).append(this._content);

      // Create DOM - NO Loader / No message

      // listeners/dispatchers / None

      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    clearInitialization () {
      // Parameters
      // DOM
      $(this.element).empty();

      //this._messageSpan = undefined;
      this._content = undefined;

      super.clearInitialization();
    }

  }

  pulseComponent.registerElement('x-markdowntext', markDownTextComponent, []);
})();

},{"markdown-it":7,"pulsecomponent":2}],86:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-message
 * @requires module:pulseComponent
 */

var pulseComponent = require('pulsecomponent');
var pulseConfig = require('pulseConfig');
var pulseSvg = require('pulseSvg');
var pulseUtility = require('pulseUtility');
var eventBus = require('eventBus');

/**
 * Build a custom tag <x-message> to display a floating message.
 *  
 * Listen messages on context : 'MESSAGE'
 * 
 * var messageInfo = {
        'id': {String} to allow remove and avoid duplicated messages 
        'message': {String} 'Message to display',
        'time' : {Integer} time duration to display the message in second. (default permanent)
        'level': {String} 'error' | 'warning' | 'info'| 'default'
        'clickToClose' {Boolean} : Tells if user may click on panel to close it. Default = false
        'reloadURL' {String} : New URL to use to reload page. Default = no reload
        'internalLAT': internal message to explain where it comes from
      };
   eventBus.EventBus.dispatchToAll('showMessageSignal', messageInfo);
 */
(function () {

  class MessageComponent extends pulseComponent.PulseParamInitializedComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      self._content = undefined;
      self._timerId = null;

      return self;
    }

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
    }

    initialize () {
      // Listener and dispatchers
      eventBus.EventBus.addGlobalEventListener(this,
        'showMessageSignal',
        this.onShowMessage.bind(this));
      eventBus.EventBus.addGlobalEventListener(this,
        'clearMessageSignal',
        this.onClearMessage.bind(this));

      // In case of clone, need to be empty :
      $(this.element).empty();

      // Create DOM - Content
      this._content = $('<div></div>').addClass('xmessage');
      // Create DOM - No Loader
      // Create DOM - No message for error

      $(this.element).append(this._content);

      // Check if login error exists
      let err = pulseConfig.get('loginError', '');
      if (err != '') {
        // Display
        let messageInfo = {
          'id': 'LOGIN_ERROR',
          'message': err,
          'level': 'error',
          'clickToClose': true
        };
        // Same as : eventBus.EventBus.dispatchToAll('showMessageSignal', messageInfo);
        this.showMessage(messageInfo);

        // Remove tmp storage
        pulseConfig.setGlobal('loginError', '');
      }

      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    clearInitialization () {
      // STOP timer
      if (this._timerId) {
        clearTimeout(this._timerId);
        this._timerId = null;
      }

      // Parameters
      // DOM
      $(this.element).empty();

      //this._messageSpan = undefined;
      this._content = undefined;

      super.clearInitialization();
    }


    validateParameters () {
      this.switchToNextContext();
    }

    /**
     * @function showMessage
     * 
     * @param data including show header for details
     *
     */
    showMessage (data) {
      console.log('component x-message showMessage function!');
      let notFound = true;
      if (!pulseUtility.isNotDefined(data.id)) {
        // if a message with same id already exists, get it and replace text
        let allAlerts = $('.message-alert');
        for (let i = 0; i < allAlerts.length; i++) {
          if (allAlerts[i].hasAttribute('message-id'))
            if (allAlerts[i].getAttribute('message-id') == data.id) {
              notFound = false;

              let elem = allAlerts[i];
              if (data.message) {
                //elem.html(data.message.replace(/\n/g, '<br />'));
                let msgspan = $(elem).find('.message-span');
                if (msgspan.length == 0) {
                  msgspan = $('<span></span>').addClass('message-span');
                  elem.append(msgspan);
                }
                $(msgspan).html(data.message.replace(/\n/g, '<br />'));
              }

              if (data.internalLAT) {
                let internspan = $(elem).find('.hidden-span');
                if (internspan.length == 0) {
                  internspan = $('<span></span>').addClass('hidden-span');
                  elem.append(internspan);
                }
                $(internspan).html(data.internalLAT.replace(/\n/g, '<br />'));
              }
            }
        }
      }
      if (notFound) {
        // if not found create new
        let elem = $('<div></div>').addClass('message-alert');

        // Unique Id
        let elemId = 'pulseMessage' + new Date().getTime() + '' + parseInt(Math.random() * 10000, 10);
        elem.id = elemId;
        $(this._content).append(elem);

        //let closeButton = $('<span></span>').addClass('message-closebtn');
        //onclick="this.parentElement.style.display='none';"
        //elem.append(closeButton);

        if (data.message) {
          let msgspan = $('<span></span>').addClass('message-span');
          msgspan.html(data.message.replace(/\n/g, '<br />'));
          elem.append(msgspan);
          //elem.html(data.message.replace(/\n/g, '<br />'));
        }
        
        if (data.internalLAT) {
          let internspan = $('<span></span>').addClass('hidden-span');
          internspan.html(data.internalLAT.replace(/\n/g, '<br />'));
          elem.append(internspan);
        }              

        let className = 'xmessage-default';
        switch (data.level) {
          case 'error':
            className = 'xmessage-error';
            break;
          case 'warning':
            className = 'xmessage-warning';
            break;
          case 'info':
            className = 'xmessage-info';
            break;
          default:
            className = 'xmessage-default';
        }

        elem.addClass(className);

        if (data.id)
          elem.attr('message-id', data.id);

        if (data.clickToClose == true) {
          elem.addClass('closable');
          elem.bind('click', function () {
            $(this).remove();
          });
          // Button "close"
          var closeBtn = $('<div></div>').addClass('message-close');
          elem.append(closeBtn);      
          pulseSvg.inlineBackgroundSvg(closeBtn);    
        }

        if (!pulseUtility.isNotDefined(data.reloadURL)) {
          let button = $('<a></a>').addClass('message-reload-button').html('Reload');
          button.attr('href', data.reloadURL);
          /*button.bind('click', function () {
            // RELOAD
            window.open(data.reloadURL, '_self');
          });*/
          elem.append(button);
        }

        if (data.time) {
          var alert = elem;
          this._timerId = setTimeout(function () {
            $(alert).remove();
          }, data.time * 1000);
        }
      }
    }

    clearMessage (id) {
      if (id) {
        // if a message with same id already exists, remove it
        let allAlerts = $('.message-alert');
        for (let i = 0; i < allAlerts.length; i++) {
          if (allAlerts[i].hasAttribute('message-id'))
            if (allAlerts[i].getAttribute('message-id') == id) {
              let elem = allAlerts[i];
              $(elem).remove();
            }
        }
      }
    }

    clearAllMessage () {
      $('message-alert').remove();
    }

    // Callback events
    onShowMessage (event) {
      let data = event.target;
      this.showMessage(data);
    }

    onClearMessage (event) {
      let data = event.target;
      this.clearMessage(data.id);
    }
  }

  pulseComponent.registerElement('x-message', MessageComponent);
})();

},{"eventBus":"eventBus","pulseConfig":"pulseConfig","pulseSvg":"pulseSvg","pulseUtility":"pulseUtility","pulsecomponent":2}],87:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-modificationmanager
 * @requires module:pulseComponent
 */

var pulseComponent = require('pulsecomponent');
var pulseUtility = require('pulseUtility');
var pulseService = require('pulseService');
var eventBus = require('eventBus');
var pulseRange = require('pulseRange');

/**
 * Build a custom tag <x-modificationmanager> with 0 attribute
 */
(function () {

  class SingleModification {
    /**
       * Constructor
       * @param {modif} == revisionid,range,kind,machineid,initModifications,pendingModifications}
       * @param {modificationManager} == parent
       */
    constructor(modif, modificationManager, path) {
      this.modif = modif;
      this._modificationManager = modificationManager;
      this._path = path;

      this._possibleNbFails = 150; // == 150 seconds before ignoring in case of error
      this._refreshRate = 1000; // 1 second

      // log : NEW modification
      console.log('modificationmanager : NEW (mach=' + modif.machineid
        + ',kind=' + modif.kind + ',rev=' + modif.revisionid);
      //+ ',range=' + this.modif.ranges[0]; -> NO becausse range.toString is badly defined

      // Tell all xtags
      eventBus.EventBus.dispatchToAll('modificationEvent', modif);

      this.methods = { // To prepare export
        addModification: this.addModification,
        getModifications: this.getModifications
      }; 

      this._askWebService();
    }

    /**
   * Ask web service for modifications
   * @param {!Object} modif 
   */
    _askWebService () {
      let url = this._path
        + 'GetPendingModificationsFromRevision?Id=' + this.modif.revisionid;

      let thisModif = this;
      pulseService.runAjaxSimple(url,
        this._getPendingModificationSuccess.bind(thisModif),
        this._getPendingModificationError.bind(thisModif),
        this._getPendingModificationFail.bind(thisModif));
    }

    /**
     * Web service - success
     * @param {!Object} data 
     */
    _getPendingModificationSuccess (data) {
      if (this.modif.initModifications == undefined) {
        this.modif.initModifications = data.Number;
      }
      if (this.modif.pendingModifications != data.Number) {
        // log : modification change
        console.log('modificationmanager : CHANGE pending='
          + this.modif.pendingModifications + '->' + data.Number
          + ' /total=' + this.modif.initModifications
          + ' (mach=' + this.modif.machineid
          + ', kind=' + this.modif.kind + ', rev=' + this.modif.revisionid);
        //+ ',range=' + this.modif.ranges[0]; -> NO becausse range.toString is badly defined
        this.modif.pendingModifications = data.Number;
      }

      //  ALWAYS Send Message
      eventBus.EventBus.dispatchToAll('modificationEvent', this.modif);

      // Re-start timer
      if (data.Number == 0) { // No more modif
        // Kill me
        this._modificationManager.removeModification(this.modif.revisionid);
        // log : end of modification
        console.log('modificationmanager : END (mach=' + this.modif.machineid
          + ',kind=' + this.modif.kind + ',rev=' + this.modif.revisionid);
        //+ ',range=' + this.modif.ranges[0]; -> NO becausse range.toString is badly defined
      }
      else { // Continue modif
        setTimeout(function () {
          this._askWebService();
        }.bind(this), this._refreshRate);
      }
    }

    
    _getPendingModificationError (data) {
      if (this._possibleNbFails <= 0) {
        // Kill me
        this._modificationManager.removeModification(this.modif.revisionid);
      }
      else {
        this._possibleNbFails--;
        // Restart timer
        setTimeout(function () {
          this._askWebService();
        }.bind(this), this._refreshRate);
      }
    }
    /**
     * Web service - error OR fail
     * @param {!String} url 
     * @param {!Boolean} isTimeout, 
     * @param {!Object} xhrStatus 
     */
    _getPendingModificationFail (url, isTimeout, xhrStatus) {
      if (this._possibleNbFails <= 0) {
        // Kill me
        this._modificationManager.removeModification(this.modif.revisionid);
      }
      else {
        this._possibleNbFails--;
        // Restart timer
        setTimeout(function () {
          this._askWebService();
        }.bind(this), this._refreshRate);
      }
    }

  } // end class SingleModification


  class ModificationManagerComponent extends pulseComponent.PulseParamInitializedComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      self.methods = {
        addModification: self.addModification,
        getModifications: self.getModifications
      };

      // Map [revisionid] = SingleModification
      // How to use map : https://www.zendevs.xyz/les-nouveaux-objets-set-et-map-en-javascript-es6/
      self._mapOfModifications = new Map();

      return self;
    }

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
    }

    initialize () {
      // Attributes
      // Listener and dispatchers

      // In case of clone, need to be empty :
      $(this.element).empty();

      // Create NO DOM -> revisionprogress... will display if needed

      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    clearInitialization () {
      super.clearInitialization();
    }

    validateParameters () {
      // Additional checks with attribute param

      this.switchToNextContext();
    }

    displayError (message) {
      // Nothing
    }

    removeError () {
      // Nothing
    }

    /*
     * Add a modification to check - private method
     *
     * @param {!integer} revisionid - Id of the revision (access to modifications in database)
     * @param {!integer} kind - can be 'reason', 'MST', 'serialnumber'...
     * @param {!integer} machineid
     * @param {![pulseRange:Range]} arrayofpulseRange - Range of the modification
     * @returns {!Boolean} true = success
     */
    addModification (revisionid, kind, machineid, arrayOfPulseRanges) {
      let modif = {
        revisionid: revisionid,
        machineid: machineid,
        kind: kind,
        ranges: arrayOfPulseRanges,
        initModifications: undefined, // pending modifications the first time
        pendingModifications: undefined
      };
      let singleModif = new SingleModification(modif, this, this.getConfigOrAttribute('path', ''));
      this._mapOfModifications.set(revisionid, singleModif);
      return true;
    }

    /**
     * Remove a modification 
     *
     * @param {!integer} revisionid - Id of the revision (access to modifications in database)
     * @returns {!Boolean} true = success
     */
    removeModification (revisionid) {
      this._mapOfModifications.delete(revisionid);
      return true;
    }

    /**
     * Get existing modifications
     *
     * @param {!integer} kind - can be 'reason', 'mos', 'serialnumber'...
     * @param {!integer} machineid
     * @param {!pulseRange:Range} range - optional range (modif.ranges[i] should be included in this range)
     * @returns {!Object} list of modifications
     */
    getModifications (kind, machineid, range) {
      let returnedMap = new Map();

      for (let modif of this._mapOfModifications) {
        if ((modif[1].modif.kind == kind)
          && (modif[1].modif.machineid == machineid)) {
          let addModif = false;
          for (let i = 0; i < modif[1].modif.ranges.length; i++) {
            if ((pulseUtility.isNotDefined(range)
              || !(pulseRange.intersects(modif[1].modif.ranges[i], range)).isEmpty())) {
              addModif = true;
            }
          }
          if (addModif)
            returnedMap.set(modif[0], modif[1].modif);
        }
      }
      return returnedMap;
    }

    // Callback events
    /**
     * Event callback in case a config is updated: (re-)start the component
     *
     * @param {*} event
     */
    onConfigChange (event) {
      // Default = do nothing
    }
  }

  pulseComponent.registerElement('x-modificationmanager', ModificationManagerComponent);
})();

},{"eventBus":"eventBus","pulseRange":"pulseRange","pulseService":"pulseService","pulseUtility":"pulseUtility","pulsecomponent":2}],88:[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @module x-reportdatetime
 * @requires module:pulseComponent
 * 
 */
var pulseComponent = require('pulsecomponent');
var pulseRange = require('pulseRange');
var pulseUtility = require('pulseUtility');

require('x-datepicker/x-datepicker');
require('x-datetimepicker/x-datetimepicker');

/**
 * Build a custom tag <x-reportdatetime>
 * Used by report web app
 * 
 * Parameters :
 * groupDisplayForm = DATERANGE
 * groupName. ex = 
 * dataType = DATE or DATETIME
 * webapp. Ex : Last_1_day IN
 * webappname IN
 * mindate IN
 * mindatename IN
 * maxdate IN
 * maxdatename IN
 */

(function () {

  class ReportDateTimeComponent extends pulseComponent.PulseParamAutoPathSingleRequestComponent {
    /**
     * Constructor
     * 
     * @param  {...any} args 
     */
    constructor(...args) {
      const self = super(...args);

      self._content = undefined;

      self.methods = {
        isValid: self.isValid,
        getValueAsIs: self.getValueAsIs,
        getMinValueAsIs: self.getMinValueAsIs,
        getMaxValueAsIs: self.getMaxValueAsIs,
        getWebAppRange: self.getWebAppRange
        //,getWebAppRangeFromMinMax: self.getWebAppRangeFromMinMax // static
      };

      // DOM: never in constructor, use the initialize method instead

      return self;
    }

    //get content () { return this._content; } // Optional

    attributeChangedWhenConnectedOnce (attr, oldVal, newVal) {
      super.attributeChangedWhenConnectedOnce(attr, oldVal, newVal);
      switch (attr) {
        case 'groupDisplayForm':
          this.start(); // restart the component. == validate + send ajax request
          break;
        case 'groupName':
          this.start(); // restart the component. == validate + send ajax request
          break;
        case 'dataType':
          this.reset(); // Call initialize again
          break;
        case 'webapp':
          this._setSelectionFromWebApp(newVal);
          // show / hide is done by change selection - not needed here
          //this.start(); // validate + send ajax request when needed - done by change selection
          break;
        case 'mindate': {
          let isDateTime = (this.element.getAttribute('dataType') == 'DATETIME');
          $(this._minDTP).attr(isDateTime ? 'defaultdatetime' : 'defaultdate', newVal);
        } break;
        case 'maxdate': {
          let isDateTime = (this.element.getAttribute('dataType') == 'DATETIME');
          $(this._maxDTP).attr(isDateTime ? 'defaultdatetime' : 'defaultdate', newVal);
        } break;
        default:
          break;
      }
    }

    _setSelectionFromWebApp (val) {
      // show / hide is done by change selection - not needed here

      let isDateTime = (this.element.getAttribute('dataType') == 'DATETIME');
      let parts = val.split("_");
      this._selectTypeCB(parts[0]);
      switch (parts[0]) {
        case ('since'): {
          if (parts.length >= 2) {
            $(this._minDTP).attr(isDateTime ? 'defaultdatetime' : 'defaultdate', parts[1]);
          }
        } break;
        case ('past'): {
          if (parts.length >= 3) {
            $(this._pastNb)[0].value = parts[1];
            this._selectPastCB(parts[2]);
          }
        } break;
        case ('current'): {
          if (parts.length >= 3) {
            this._selectCurrentCB(parts[1] + '_' + parts[2]);
          }
        } break;
        case ('explicit'): {
          if (parts.length >= 3) {
            $(this._minDTP).attr(isDateTime ? 'defaultdatetime' : 'defaultdate', parts[1]);
            $(this._maxDTP).attr(isDateTime ? 'defaultdatetime' : 'defaultdate', parts[2]);
          }
          else { // Exemple : in report made from another report
            if (this.element.hasAttribute('mindate')) {
              $(this._minDTP).attr(isDateTime ? 'defaultdatetime' : 'defaultdate',
                this.element.getAttribute('mindate'));
            }
            if (this.element.hasAttribute('maxdate')) {
              $(this._maxDTP).attr(isDateTime ? 'defaultdatetime' : 'defaultdate',
                this.element.getAttribute('maxdate'));
            }
          }
        } break;
        // Never default ? NO !!! Can happen when min and max are given + change parameters
        default: {
          if (this.element.hasAttribute('mindate')) {
            $(this._minDTP).attr(isDateTime ? 'defaultdatetime' : 'defaultdate',
              this.element.getAttribute('mindate'));
          }
          if (this.element.hasAttribute('maxdate')) {
            $(this._maxDTP).attr(isDateTime ? 'defaultdatetime' : 'defaultdate',
              this.element.getAttribute('maxdate'));
          }
        }
      }
    }

    _setChangeSel () {
      this._typeSelectCB[0].addEventListener('change', this.onChangeSel.bind(this), false);
      this._pastNb[0].addEventListener('change', this.onChangeSel.bind(this), false);
      this._pastUnitCB[0].addEventListener('change', this.onChangeSel.bind(this), false);
      this._currentCB[0].addEventListener('change', this.onChangeSel.bind(this), false);
    }

    _selectItemByValue (elmnt, value) {
      for (let i = 0; i < elmnt.options.length; i++) {
        if (elmnt.options[i].value === value) {
          elmnt.selectedIndex = i;
          break;
        }
      }
    }
    _selectTypeCB (value) {
      this._selectItemByValue(this._typeSelectCB[0], value);
    }
    _selectPastCB (value) {
      this._selectItemByValue(this._pastUnitCB[0], value);
    }
    _selectCurrentCB (value) {
      this._selectItemByValue(this._currentCB[0], value);
    }


    _fillTypeCB () {
      // Combobox
      $(this._typeSelectCB).empty();

      let optionCB = $('<option value=explicit></option>').html("From... to...");
      this._typeSelectCB.append(optionCB);
      optionCB = $('<option value=since></option>').html("Since...");
      this._typeSelectCB.append(optionCB);
      optionCB = $('<option value=past></option>').html("Past");
      this._typeSelectCB.append(optionCB);
      optionCB = $('<option value=current></option>').html("Current");
      this._typeSelectCB.append(optionCB);
    }

    _fillPastCB () {
      // Combobox
      $(this._pastUnitCB).empty();

      let optionCB = $('<option value=hour></option>').html("hour(s)")
        .addClass('hide-for-full-day');
      this._pastUnitCB.append(optionCB);
      optionCB = $('<option value=shift></option>').html("shift(s)")
        .addClass('hide-for-full-day');
      this._pastUnitCB.append(optionCB);
      optionCB = $('<option value=day selected></option>').html("day(s)");
      this._pastUnitCB.append(optionCB);
      optionCB = $('<option value=week></option>').html("week(s)");
      this._pastUnitCB.append(optionCB);
      optionCB = $('<option value=month></option>').html("month(s)");
      this._pastUnitCB.append(optionCB);
      optionCB = $('<option value=quarter></option>').html("quarter(s)");
      this._pastUnitCB.append(optionCB);
      optionCB = $('<option value=year></option>').html("year(s)");
      this._pastUnitCB.append(optionCB);

      // Remove hours and shifts if dates are required -> done using CSS !
      /*if (isDate) {
        $("#WebAppParamsDateTime_unit option[value='hour']").remove();
        $("#WebAppParamsDateTime_duration option[value='1_hour']").remove();
        $("#WebAppParamsDateTime_unit option[value='shift']").remove();
        $("#WebAppParamsDateTime_duration option[value='1_shift']").remove();
      }*/
    }

    _fillCurrentCB () {
      // Combobox
      $(this._currentCB).empty();

      let optionCB = $('<option value=1_hour></option>').html("1 hour")
        .addClass('hide-for-full-day');
      this._currentCB.append(optionCB);
      optionCB = $('<option value=1_shift></option>').html("1 shift")
        .addClass('hide-for-full-day');
      this._currentCB.append(optionCB);
      optionCB = $('<option value=1_day selected></option>').html("today");
      this._currentCB.append(optionCB);
      optionCB = $('<option value=2_day></option>').html("today + yesterday");
      this._currentCB.append(optionCB);
      optionCB = $('<option value=1_week></option>').html("1 week");
      this._currentCB.append(optionCB);
      optionCB = $('<option value=2_week></option>').html("1 weeks");
      this._currentCB.append(optionCB);
      optionCB = $('<option value=1_month></option>').html("1 month");
      this._currentCB.append(optionCB);
      optionCB = $('<option value=1_quarter></option>').html("1 quarter");
      this._currentCB.append(optionCB);
      optionCB = $('<option value=1_year></option>').html("1 year");
      this._currentCB.append(optionCB);

    }

    // return value input
    initParamForReport (divToFill, name, parameterkey, dataType, parameterType,
      defaultValue, value, required, hidden, helptext) {
      $(divToFill).addClass('parameter');
      $(divToFill).append("<input type='hidden' id='name' value='" + name + "' />");
      $(divToFill).append("<input type='hidden' id='parameterkey' value='" + parameterkey + "' />");
      $(divToFill).append("<input type='hidden' id='defaultvalue' value='" + defaultValue + "' />");
      let retInput = $("<input type='hidden' id='value' value='" + value + "' />");
      $(divToFill).append(retInput);
      $(divToFill).append("<input type='hidden' id='datatype' value='" + dataType + "' />");
      $(divToFill).append("<input type='hidden' id='parametertype' value='" + parameterType + "' />");
      $(divToFill).append("<input type='hidden' id='required' value='" + required + "' />");
      $(divToFill).append("<input type='hidden' id='helptext' value='" + helptext + "' />");
      $(divToFill).append("<input type='hidden' id='hidden' value='" + hidden + "' />");
      if (parameterkey == 'WEBAPP') {
        $(divToFill).append("<input type='hidden' id='widget' value='TEXTBOX' />");
        retInput = $("<input type='hidden' id='" + name + "_value' value= />");
        $(divToFill).append(retInput);
      }
      return retInput;
      /*
        <input type="hidden" id="widget" value="DATEBOX" />
  <input type="hidden" id="name" value="${scalarParameter.name}" />
  
  <x-datepicker id='${scalarParameter.name}_value'></x-datepicker>
      */
    }

    initialize () {
      this.addClass('pulse-text'); // Mandatory for loader
      //pulse-text / pulse-icon / pulse-lastbar / pulse-slotbar / pulse-piegauge / pulse-bigdisplay

      // Listener and dispatchers

      // In case of clone, need to be empty :
      $(this.element).empty();

      // Create DOM - Content - added in parameterGroupContent no-left-border
      this._content = $('<div></div>').addClass('pulse-report-content');
      $(this.element)
        .addClass('pulse-report-datetime')
        .append(this._content);

      let isDateTime = (this.element.getAttribute('dataType') == 'DATETIME');
      if (isDateTime) {
        this._content.addClass('pulse-report-isdatetime');
      } else {
        this._content.addClass('pulse-report-isdate');
      }

      // First row 'pulse-report-datetime-main-sel-div'

      // explicit / since / past / current
      this._typeSelectCB = $('<select class="pulse-report-datetime-type-CB" ></select>');
      this._fillTypeCB();

      // past details - ex : 1 + day
      this._pastNb = $('<input type="number" value="1" min="1" max="365"></input>')
        .addClass('pulse-report-datetime-past-number');
      this._pastUnitCB = $('<select></select>').addClass('pulse-report-datetime-past-unit-CB');
      this._fillPastCB();

      // current details
      this._currentCB = $('<select></select>').addClass('pulse-report-datetime-current-CB');
      this._fillCurrentCB();

      // WebAppParamsDateTime_row1
      let typeMainSelDiv = $('<div></div>').addClass('pulse-report-datetime-main-sel-div')
        .append(this._typeSelectCB).append(this._pastNb).append(this._pastUnitCB).append(this._currentCB);

      $(this._content).append(typeMainSelDiv);

      // DIV for min / max / loader / error 
      let minMaxDiv = $('<div></div>').addClass('pulse-report-datetime-min-max-div');

      // Create DOM - Loader
      let loader = $('<div></div>').addClass('pulse-loader').html('Loading...').css('display', 'none');
      let loaderDiv = $('<div></div>').addClass('pulse-loader-div').append(loader);
      $(minMaxDiv).append(loaderDiv);

      // Create DOM - message for error
      this._messageSpan = $('<span></span>').addClass('pulse-message').html('');
      let messageDiv = $('<div></div>').addClass('pulse-message-div')
        .append(this._messageSpan);
      $(minMaxDiv).append(messageDiv);

      // MIN / MAX - same position as loader AND error message - WebAppParamsDateTime_row3
      this._minDTP = pulseUtility.createjQueryElementWithAttribute(
        isDateTime ? 'x-datetimepicker' : 'x-datepicker', {
        'showseconds': "true"
      });

      this._minDTP.addClass('pulse-report-datetime-min-DTP');
      //.addClass('parameter'); // Used by reporting to retrieve scalarparameter
      let minDiv = $('<div></div>').addClass('pulse-report-datetime-min-div')
        .append(this._minDTP);

      this._maxDTP = pulseUtility.createjQueryElementWithAttribute(
        isDateTime ? 'x-datetimepicker' : 'x-datepicker', {
        'showseconds': "true"
      });
      this._maxDTP.addClass('pulse-report-datetime-max-DTP');
      //.addClass('parameter'); // Used by reporting to retrieve scalarparameter
      let maxDiv = $('<div></div>').addClass('pulse-report-datetime-max-div')
        .append(this._maxDTP);

      minMaxDiv.append(minDiv).append(maxDiv);
      $(this._content).append(minMaxDiv);

      // Remove the left border of the group
      $(this.element).parent().addClass('no-left-border');

      // Show / Hide for consistancy
      let rangeType = this._typeSelectCB[0].options[this._typeSelectCB[0].selectedIndex].value;
      this._showHide(rangeType);

      // On change selection => change display
      this._setChangeSel();

      // Get Attributes => change selection
      if (this.element.hasAttribute('webapp')) {
        let webAppValue = this.element.getAttribute('webapp');
        this._setSelectionFromWebApp(webAppValue);
      }

      // Hidden div for report
      let minReportDiv = $('<div></div>').addClass('pulse-report-hidden');
      this.initParamForReport(minReportDiv,
        this.element.getAttribute('mindatename'), 'MINDATE', // name, parameterkey
        this.element.getAttribute('dataType'), // dataType = 'DATE':'DATETIME'
        'SIMPLE', '', '', // , parameterType, defaultValue, value, 
        'false', 'false', ''); // required, hidden, helptext
      minMaxDiv.append(minReportDiv);

      let maxReportDiv = $('<div></div>').addClass('pulse-report-hidden');
      this.initParamForReport(maxReportDiv,
        this.element.getAttribute('maxdatename'), 'MAXDATE', // name, parameterkey
        this.element.getAttribute('dataType'), // dataType = 'DATE':'DATETIME'
        'SIMPLE', '', '', // parameterType, defaultValue, value, 
        'false', 'false', ''); // required, hidden, helptext
      minMaxDiv.append(maxReportDiv);

      let webappReportDiv = $('<div></div>').addClass('pulse-report-hidden');
      this._webAppValue = this.initParamForReport(webappReportDiv,
        this.element.getAttribute('webappname'), 'WEBAPP', // name, parameterkey
        'STRING', // dataType
        'SIMPLE', '', '', // parameterType, defaultValue, value, 
        'false', 'true', ''); // required, hidden, helptext
      minMaxDiv.append(webappReportDiv);

      // Initialization OK => switch to the next context
      this.switchToNextContext();
      return;
    }

    /**
      * Clear anything that was done during intialization, so that initialize can be called once again.
      * Remove all the dispatchers and listeners.
      * Please note that no state switch is done here
    */
    clearInitialization () {
      // Parameters

      // DOM
      $(this.element).empty();
      this._content = undefined;

      super.clearInitialization();
    }

    reset () { // Optional implementation
      // Code here to clean the component when the component has been initialized for example after a parameter change
      this.removeError();
      // Empty this._content

      this.switchToNextContext();
    }

    validateParameters () {
      if (!this.element.hasAttribute('groupDisplayForm')) {
        console.error('missing attribute groupDisplayForm in reportdatetime.element');
        // Delayed display :
        //this.setError('missing display form');
        // or
        // Immediat display :
        this.switchToKey('Error', () => this.displayError('invalid groupDisplayForm'), () => this.removeError());
        return;
      }
      if (!this.element.hasAttribute('groupName')) {
        console.error('missing attribute groupName in reportdatetime.element');
        // Delayed display :
        //this.setError('missing groupName');
        // or
        // Immediat display :
        this.switchToKey('Error', () => this.displayError('invalid groupName'), () => this.removeError());
        return;
      }
      if (!this.element.hasAttribute('dataType')) {
        console.error('missing attribute dataType in reportdatetime.element');
        // Delayed display :
        //this.setError('missing dataType');
        // or
        // Immediat display :
        this.switchToKey('Error', () => this.displayError('invalid dataType'), () => this.removeError());
        return;
      }

      this.switchToNextContext();
    }


    /**
     * @override
     */
    manageError (data) {
      super.manageError(data);
    }

    /**
     * @override
     */
    manageFailure (isTimeout, xhrStatus) {
      super.manageFailure(isTimeout, xhrStatus);
    }

    /**
     * @override
     */
    displayError (text) {
      if (typeof text == 'undefined') {
        return; // No message to display, do not display any error
      }
      if (typeof this._messageSpan !== 'undefined') {
        $(this._messageSpan).html(text);
      }
    }

    removeError () {
      // Code here to remove the error message. Only required if displayError is implemented
      // For example:
      this.displayError('');
    }

    // Overload to always refresh value
    get isVisible () {
      return true;
    }

    _showHide (rangeType) {

      if (rangeType == 'past') {
        this._pastNb.show();
        this._pastUnitCB.show();
      }
      else {
        this._pastNb.hide();
        this._pastUnitCB.hide();
      }

      if (rangeType == 'current') {
        this._currentCB.show();
      }
      else {
        this._currentCB.hide();
      }

      switch (rangeType) {
        case ('since'): {
          // only from visible + enabled
          //$(this._minDTP).show();
          //$(this._minDTP).enable();
          this._minDTP.prop('disabled', false);

          $(this._maxDTP).hide();
        } break;
        case ('explicit'): {
          // visible + enabled
          $(this._maxDTP).show();

          //$(this._minDTP).enable();
          this._minDTP.prop('disabled', false);
          this._maxDTP.prop('disabled', false);
          //$(this._maxDTP).enable();
        } break;
        case ('current'):
        case ('past'):
        default: {
          {
            // visible + disabled
            $(this._maxDTP).show();

            this._minDTP.prop('disabled', true);
            this._maxDTP.prop('disabled', true);
            //$(this._minDTP).disable();
            //$(this._maxDTP).disable();
          } break;
        }
      }
    }

    _storeWebAppValue () {
      let webapprange = this.getWebAppRange();
      $(this._webAppValue).attr('value', webapprange);
    }

    /** Replace _runAjaxWhenIsVisible when NO url should be called
     *  return true if something is done, false if _runAjaxWhenIsVisible should be called
     */
    _runAlternateGetData () {
      let rangeType = this._typeSelectCB[0].options[this._typeSelectCB[0].selectedIndex].value;
      this._showHide(rangeType); // Always here

      if (rangeType == 'explicit' || rangeType == 'since') {
        this._storeWebAppValue();
        // (_minDateMoment, _maxDateMoment); -> need to be read
        this.switchToContext('Loaded'); // to STOP calling Ajax request
        return true;
      }
      else {
        // Call web service
        return false;
      }
    }

    getShortUrl () {
      let rangeType = this._typeSelectCB[0].options[this._typeSelectCB[0].selectedIndex].value;
      if (rangeType == 'past') {
        let number = $(this._pastNb)[0].value;
        let unit = this._pastUnitCB[0].options[this._pastUnitCB[0].selectedIndex].value;
        return 'Time/PastRange/' + number + '_' + unit;
      }
      else {
        let crt = this._currentCB[0].options[this._currentCB[0].selectedIndex].value;
        return 'Time/CurrentRange/' + crt;
      }
    }

    refresh (data) {
      // Update the component with data returned by the web service in case of success
      let isDateTime = (this.element.getAttribute('dataType') == 'DATETIME');
      if (isDateTime) {
        // "YYYY-MM-DDTHH:mm:ss"
        let r = pulseRange.createStringRangeFromString(data.UtcDateTimeRange);
        $(this._minDTP).attr('defaultdatetime', r.lower);
        $(this._maxDTP).attr('defaultdatetime', r.upper);
      }
      else {
        // YYYY-MM-DD
        let r = pulseRange.createStringRangeFromString(data.DayRange);
        $(this._minDTP).attr('defaultdate', r.lower);
        $(this._maxDTP).attr('defaultdate', r.upper);
      }

      this._storeWebAppValue();
    }

    // Callback events

    onChangeSel () {
      // Show / Hide
      let rangeType = this._typeSelectCB[0].options[this._typeSelectCB[0].selectedIndex].value;
      this._showHide(rangeType);

      // Reload if necessary
      switch (rangeType) {
        case ('current'):
        case ('past'): {
          // Force re-load
          this.start();
        } break;
        case ('since'):
        case ('explicit'):
        default: {
          this._storeWebAppValue();
          // Do nothing more
        }
      }
    }

    // External methods
    isValid () { // cf _callback_validate_settings () {
      if (!this._beginDTP[0].isValid()) {
        //pulseCustomDialog.openError('Start date/time is not valid.');
        return false;
      }
      if (!this._endDTP[0].isValid()) {
        //pulseCustomDialog.openError('End date/time is not valid.');
        return false;
      }
      if (null == this._endDTP[0].getISOValue()) {
        //pulseCustomDialog.openError('End date/time is not valid.');
        return false;
      }

      let beginDateTime = new Date(this._beginDTP[0].getISOValue());
      let endDateTime = new Date(this._endDTP[0].getISOValue());

      // Check the range
      if (endDateTime) {
        if (endDateTime < beginDateTime) {
          //pulseCustomDialog.openError('End date/time is before start date/time.');
          return false;
        }
        else {
          if (beginDateTime < endDateTime) {
            // Do nothing = it is OK
          }
          else {
            //pulseCustomDialog.openError('Empty period.');
            return false;
          }
        }
      }
      return true;
    } // end isValid

    getValueAsIs (name) {
      if (this.element.getAttribute('mindatename') == name) {
        return this.getMinValueAsIs();
      }
      if (this.element.getAttribute('maxdatename') == name) {
        return this.getMaxValueAsIs();
      }
      return '';
    }

    getMinValueAsIs () { //'YYYY-MM-DD HH:mm:ss 
      return this._minDTP[0].getValueAsIs();
    }

    getMaxValueAsIs () { //'YYYY-MM-DD HH:mm:ss 
      return this._maxDTP[0].getValueAsIs();
    }

    getWebAppRange () {
      let rangeType = this._typeSelectCB[0].options[this._typeSelectCB[0].selectedIndex].value;

      let retVal = rangeType + '_';
      switch (rangeType) {
        case ('since'): {
          retVal += this.getMinValueAsIs();
        } break;
        case ('explicit'): {
          retVal += this.getMinValueAsIs() + '_' + this.getMaxValueAsIs();
        } break;
        case ('current'): {
          retVal += this._currentCB[0].options[this._currentCB[0].selectedIndex].value;
        } break;
        case ('past'): {
          let number = this._pastNb[0].value;
          let unit = this._pastUnitCB[0].options[this._pastUnitCB[0].selectedIndex].value;
          retVal += number + '_' + unit;
        } break;
        default: {
          // Never
        }
      }
      return retVal;
    }
    //_storeWebAppValue
    // Get "WebAppParamsDate" from "PulseMinDate", "PulseMaxDate"
    /*
    static getWebAppRangeFromMinMax(min, max) {      
      let retVal = 'explicit_' + min + '_' + max;
      return retVal;
    }
    */

  }

  pulseComponent.registerElement('x-reportdatetime', ReportDateTimeComponent,
    ['groupDisplayForm', 'groupName', 'dataType', 'webapp', 'mindate', 'maxdate',
      'mindatename', 'maxdatename', 'webappname']);
  // mindatename','maxdatename' == PulseMinDate / PulseMaxDate
})();

},{"pulseRange":"pulseRange","pulseUtility":"pulseUtility","pulsecomponent":2,"x-datepicker/x-datepicker":78,"x-datetimepicker/x-datetimepicker":79}],"eventBus":[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/* Singleton class to manage events sent between pulse components */

var EventBusClass = {};
EventBusClass = function () {
  this.listeners = {};
  this.globalListeners = {};
};
EventBusClass.prototype = {
  /**
    * Add a signal listener for a given context on event bus for 1 component=scope
    *
    * @function addEventListener
    * @param {Object} scope listener scope (= this in callback = xtag class)
    * @param {String} signal generic name of signal to listen on event bus
    * @param {String} context context concern by signal sent (ex:period-context)
    * @param {Method} callback callback to call
  */
  addEventListener: function (scope, signal, context, callback) {
    // hope (context != 'undefined' && context != '') {
    if (typeof this.listeners[signal] == 'undefined') {
      this.listeners[signal] = {};
    }
    if (typeof this.listeners[signal][context] == 'undefined') {
      this.listeners[signal][context] = [];
    }
    this.listeners[signal][context].push({ scope: scope, callback: callback });
    console.log(`${scope.getInfo ? scope.getInfo() : ''}: add listener event=${signal}_${context}`);
  },
  /**
    * Add a signal listener for all contexts on event bus for 1 component=scope
    *
    * @function addGlobalEventListener
    * @param {Object} scope listener scope (= this in callback)
    * @param {String} signal generic name of signal to listen on event bus
    * @param {Method} callback callback to call
  */
  addGlobalEventListener: function (scope, signal, callback) {
    // global listener = for all contexts
    if (typeof this.globalListeners[signal] == 'undefined') {
      this.globalListeners[signal] = [];
    }
    this.globalListeners[signal].push({ scope: scope, callback: callback });
    console.log(`${scope.getInfo ? scope.getInfo() : ''}: add global listener signal=${signal} DONE`);
  },
  /**
    * Remove all signal listeners for all contexts on event bus for 1 component=scope
    *
    * @function removeEventListenerBySignal
    * @param {Object} scope listener scope (= this in callback)
    * @param {String} signal generic name of signal to listen on event bus
  */
  removeEventListenerBySignal: function (scope, signal) {
    if (typeof this.listeners[signal] != 'undefined') {
      for (let context in this.listeners[signal]) {
        // For ALL founded contexts : remove listeners
        if (typeof this.listeners[signal][context] != 'undefined') {
          let newArray = [];
          for (let i = 0; i < this.listeners[signal][context].length; i++) {
            let listener = this.listeners[signal][context][i];
            if (listener.scope != scope) {
              newArray.push(listener);
            }
            else {
              console.log(`${scope.getInfo ? scope.getInfo() : ''}: remove listener signal=${signal} context=${context}`);
            }
          }
          this.listeners[signal][context] = newArray;
        }
      }
    }
    // Global listeners
    if (typeof this.globalListeners[signal] != 'undefined') {
      let newArray = [];
      for (let i = 0; i < this.globalListeners[signal].length; i++) {
        let listener = this.globalListeners[signal][i];
        if (listener.scope != scope) {
          newArray.push(listener);
        }
        else {
          console.log(`${scope.getInfo ? scope.getInfo() : ''}: remove global listener signal=${signal}`);
        }
      }
      this.globalListeners[signal] = newArray;
    }
    //console.log(`${scope.getInfo ? scope.getInfo() : ''}: remove listeners by signal=${signal} DONE`);
  },

  /**
  * Remove all signal listeners for all contexts on event bus for 1 component=scope
  *
  * @function removeEventListenerByScope
  * @param {Object} scope listener scope (= this in callback)
  */
  removeEventListenerByScope: function (scope) {
    for (let signal in this.listeners) {
      for (let context in this.listeners[signal]) {
        // For ALL founded signal + contexts : remove listeners
        if (typeof this.listeners[signal][context] != 'undefined') {
          let newArray = [];
          for (let i = 0; i < this.listeners[signal][context].length; i++) {
            let listener = this.listeners[signal][context][i];
            if (listener.scope != scope) {
              newArray.push(listener);
            }
            else {
              console.log(`${scope.getInfo ? scope.getInfo() : ''}: remove listener signal=${signal} context=${context}`);
            }
          }
          this.listeners[signal][context] = newArray;
        }
      }
    }
    // Global listeners
    for (let signal in this.globalListeners) {
      let newArray = [];
      for (let i = 0; i < this.globalListeners[signal].length; i++) {
        let listener = this.globalListeners[signal][i];
        if (listener.scope != scope) {
          newArray.push(listener);
        }
        else {
          console.log(`${scope.getInfo ? scope.getInfo() : ''}: remove global listener signal=${signal}`);
        }
      }
      this.globalListeners[signal] = newArray;
    }
    //console.log(`${scope.getInfo ? scope.getInfo() : ''}: remove (all) listeners DONE`);
  },
  /**
    * Dispatch a signal for a given context on event bus
    *
    * @function dispatchToContext
    * @param {String} signal generic name of signal to dispatch to on event bus
    * @param {String} context context concern by signal sent (ex:period-context)
    * @param {Object} target main information to give to listeners
  */
  dispatchToContext: function (signal, context, target) {
    console.log(`dispatch to listeners signal=${signal} context=${context}`);
    let event = {
      /*signal: signal,
      context: context,
      type: signal + '_' + context,*/
      target: target
    };
    let args = [];
    var numOfArgs = arguments.length;
    for (var i = 0; i < numOfArgs; i++) {
      args.push(arguments[i]);
    }
    args = args.length > 3 ? args.splice(3, args.length - 1) : [];
    args = [event].concat(args);
    if (typeof this.listeners[signal] != 'undefined') {
      if (typeof this.listeners[signal][context] != 'undefined') {
        let numOfCallbacks = this.listeners[signal][context].length;
        for (let i = 0; i < numOfCallbacks; i++) {
          let listener = this.listeners[signal][context][i];
          if (listener && listener.callback) {
            listener.callback.apply(listener.scope, args);
          }
        }
      }
    }
    // WARNING :
    // Global listeners DO NOT receive this event with context to allow "local" communication.
    // For example : page Running (no context) + Details
  },
  /**
    * Dispatch a signal to GLOBAL context on event bus
    *
    * @function dispatchToGlobalOnly
    * @param {String} signal generic name of signal to dispatch to on event bus
    * @param {Object} target main information to give to listeners
  */
  dispatchToGlobalOnly: function (signal, target) {
    let event = {
      /*signal: signal,
      context: '',
      type: signal,*/
      target: target
    };
    let args = [];
    var numOfArgs = arguments.length;
    for (var i = 0; i < numOfArgs; i++) {
      args.push(arguments[i]);
    }
    args = args.length > 2 ? args.splice(2, args.length - 1) : [];
    args = [event].concat(args);
    // + global
    if (typeof this.globalListeners[signal] != 'undefined') {
      let numOfCallbacks = this.globalListeners[signal].length;
      for (let i = 0; i < numOfCallbacks; i++) {
        let listener = this.globalListeners[signal][i];
        if (listener && listener.callback) {
          listener.callback.apply(listener.scope, args);
        }
      }
    }
  },
  /**
    * Dispatch a signal to ALL contexts on event bus
    *
    * @function dispatchToAll
    * @param {String} signal generic name of signal to dispatch to on event bus
    * @param {Object} target main information to give to listeners
  */
  dispatchToAll: function (signal, target) {
    let event = {
      /*signal: signal,
      context: '',
      type: signal,*/
      target: target
    };
    let args = [];
    var numOfArgs = arguments.length;
    for (var i = 0; i < numOfArgs; i++) {
      args.push(arguments[i]);
    }
    args = args.length > 2 ? args.splice(2, args.length - 1) : [];
    args = [event].concat(args);
    if (typeof this.listeners[signal] != 'undefined') {
      for (let context in this.listeners[signal]) {
        // For ALL founded contexts : dispatch
        if (typeof this.listeners[signal][context] != 'undefined') {
          let numOfCallbacks = this.listeners[signal][context].length;
          for (let i = 0; i < numOfCallbacks; i++) {
            let listener = this.listeners[signal][context][i];
            if (listener && listener.callback) {
              listener.callback.apply(listener.scope, args);
            }
          }
        }
      }
    }
    // + global
    if (typeof this.globalListeners[signal] != 'undefined') {
      let numOfCallbacks = this.globalListeners[signal].length;
      for (let i = 0; i < numOfCallbacks; i++) {
        let listener = this.globalListeners[signal][i];
        if (listener && listener.callback) {
          listener.callback.apply(listener.scope, args);
        }
      }
    }
  },
};

exports.EventBus = new EventBusClass();

},{}],"pulseConfig":[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @file access configuration.
 */

/**
* @module pulseConfig
* @requires pulseUtility
* @requires pulseLogin
*/
var pulseUtility = require('pulseUtility');
var pulseLogin = require('pulseLogin');


////////// ////////// //////////
// TRANSLATION                //
////////// ////////// //////////

/**
 * function called to find a translation
 * @param {String} key Key linked to a translation 
 * @param {String} defaultTranslation Translation returned if the key is not found
 * @return {String} string to display
 */
exports.pulseTranslate = function (key, defaultTranslation) {
  let result = defaultTranslation;

  // Translations accessible?
  if (!pulseUtility.isNotDefined(PULSE_TRANSLATION)) {
    let translation = PULSE_TRANSLATION;
    let listOfKeys = key.split('.');
    for (let i = 0; i < listOfKeys.length; i++) {
      translation = translation[listOfKeys[i]];
      if ((pulseUtility.isNotDefined(translation)) || ('' === translation))
        break;
      if (i == (listOfKeys.length - 1))
        result = translation;
    }
  }

  return result;
};

////////// ////////// //////////
// Local Functions            //
////////// ////////// //////////

var getAppName = function () {
  /* This could be found in URL - BUT can not, because of hardcoded script in template.html (case sensitive, other app...) 
  More : in we read app name in URL, it will be more difficult to share data between app, for exemple machines 
  */
  return LEM_CONFIG_DEFAULT.appName;
}

var getPageName = exports.getPageName = function () {
  let href = window.location.href; // ".../pagename.html"
  var posReq = href.lastIndexOf('?');
  if (posReq != -1) {
    href = href.slice(0, posReq); // To ignore all after ?
  }
  var posPt = href.lastIndexOf('.');
  var posSlash = href.lastIndexOf('/');
  let pageName = '';
  if ((posPt != -1) && (posSlash != -1)) { // Found both
    pageName = href.slice(posSlash + 1, posPt);
  }

  return pageName;
};


//var isCurrentApp = 
exports.isCurrentApp = function (appName) {
  // Find app name
  let app = getAppName();
  if (app == appName) {
    return true;
  }
  return false;
};

var getAppContextOnly = exports.getAppContextOnly = function () {
  // get AppContext in URL
  let appCtxConfig = getURLConfig('AppContext');
  if (appCtxConfig.found) {
    return appCtxConfig.value;
  }

  return '';
}

var getAppContextOrRole = exports.getAppContextOrRole = function () {
  // get AppContext in URL
  let appCtxConfig = getURLConfig('AppContext');
  if (appCtxConfig.found) {
    return appCtxConfig.value;
  }

  // If not found, get role
  return pulseLogin.getRole();
}

var getLoginAppContextOrRole = exports.getLoginAppContextOrRole = function () {
  let login = pulseLogin.getLogin();
  if (login != '') {
    return login;
  }

  // get AppContext in URL
  let appCtxConfig = getURLConfig('AppContext');
  if (appCtxConfig.found) {
    return appCtxConfig.value;
  }

  // If not found, get role
  return pulseLogin.getRole();
}

////////// ////////// //////////
// "SEARCH IN CONFIG" METHODS //
////////// ////////// //////////

var getURLConfig = function (key) {
  let retVal = { found: false, value: '' };
  let href = window.location.href;
  // To find config LIKE production.thresholdNbOfPieces, SPLIT
  let listOfKeys = key.split('.');
  if (listOfKeys.length >= 1) {
    let lastKey = listOfKeys[listOfKeys.length - 1];
    let allValues;
    if ('machine' == lastKey) {
      allValues = pulseUtility.getALLMachineIdParameterValue(href); // For Compatibility
    }
    else {
      allValues = pulseUtility.getURLParameterValues(href, lastKey);
    }
    if (allValues != null && allValues.length != 0) {
      if (allValues.length == 1) {
        retVal.value = allValues[0];
        retVal.found = true;
      }
      else {
        retVal.value = allValues;
        retVal.found = true;
      }
    }
  }
  return retVal;
};

var getLocalConfig = function (key, login, pageName) {
  let retVal = { found: false, value: '' };
  if (key == 'path') {
    if (typeof sessionStorage != 'undefined') {
      let item = sessionStorage.getItem(key);
      if (item != null) {
        retVal.value = JSON.parse(item);
        if (Array.isArray(retVal.value)) {
          // reset
          retVal.value = '';
          // Remove from local storage error
          console.warn('Config Strange array for key=' + key);
        }
        else {
          retVal.found = true;
          return retVal;
        }
      }
    }
  }
  if (typeof localStorage == 'undefined') {
    console.warn('Config can not read local storage ');
  }
  else {
    // Find app name
    let app = getAppName();

    // Get GLOBAL
    let keyString = 'PULSE.' + app + '.' + key;
    let item = localStorage.getItem(keyString);
    if (item != null) {
      retVal.value = JSON.parse(item);
      if (Array.isArray(retVal.value)) {
        // reset
        retVal.value = '';
        // Remove from local storage error
        console.warn('Config remove array ' + keyString);
        //reset(keyString);
        localStorage.removeItem(keyString);
      }
      else {
        retVal.found = true;
        return retVal;
      }
    }
    // Get by login + page
    keyString = 'PULSE.' + app + '.' + login + '.' + pageName + '.' + key;
    item = localStorage.getItem(keyString);
    if (item != null) {
      retVal.value = JSON.parse(item); // Parse is not mandatory. But can be done
      if (Array.isArray(retVal.value)) {
        // reset
        retVal.value = '';
        // Remove from local storage error
        console.warn('Config remove array ' + keyString);
        //reset(keyString);
        localStorage.removeItem(keyString);
      }
      else {
        retVal.found = true;
        return retVal;
      }
    }
    // Get by login only (was role)
    keyString = 'PULSE.' + app + '.' + login + '.' + key;
    item = localStorage.getItem(keyString);
    if (item != null) {
      retVal.value = JSON.parse(item); // Parse is not mandatory. But can be done
      if (Array.isArray(retVal.value)) {
        // reset
        retVal.value = '';
        // Remove from local storage error
        console.warn('Config remove array ' + keyString);
        //reset(keyString);
        localStorage.removeItem(keyString);
      }
      else {
        retVal.found = true;
        return retVal;
      }
    }
  }
  return retVal;
};

var getRolePageConfig = function (key, role, pageName) {
  let retVal = { found: false, value: '' };
  if ((!pulseUtility.isNotDefined(role)) && (role != '')
    && (!pulseUtility.isNotDefined(pageName)) && (pageName != '')) {
    // Get New config (old is removed 2018-11)
    if (typeof PULSE_DEFAULT_CONFIG == 'undefined') {
      console.warn('PULSE_DEFAULT_CONFIG is undefined');
      return retVal;
    }
    // SEARCH in NEW role CONFIG
    if ((typeof PULSE_DEFAULT_CONFIG.rolespages != 'undefined')
      && (PULSE_DEFAULT_CONFIG.rolespages !== undefined)) {
      if ((typeof PULSE_DEFAULT_CONFIG.rolespages[role] != 'undefined')
        && (PULSE_DEFAULT_CONFIG.rolespages[role] !== undefined)) {
        let cfg = PULSE_DEFAULT_CONFIG.rolespages[role][pageName];
        if (!pulseUtility.isNotDefined(cfg)) {
          let listOfKeys = key.split('.');
          for (let i = 0; i < listOfKeys.length; i++) {
            cfg = cfg[listOfKeys[i]];
            if ((pulseUtility.isNotDefined(cfg)) || ('' === cfg)) {
              break; // To exit for
            }
            if (i == (listOfKeys.length - 1)) {
              retVal.found = true;
              retVal.value = cfg;
              return retVal;
            }
          }
        }
      }
    }
  }

  return retVal;
};

var getRoleConfig = function (key, role, pageName) {
  let retVal = { found: false, value: '' };
  if (typeof PULSE_DEFAULT_CONFIG == 'undefined') {
    console.warn('PULSE_DEFAULT_CONFIG is undefined - normal for docs');
    return retVal;
  }

  if ((!pulseUtility.isNotDefined(role)) && (role != '')) {
    // SEARCH in NEW role CONFIG
    if ((typeof PULSE_DEFAULT_CONFIG.roles != 'undefined')
      && (PULSE_DEFAULT_CONFIG.roles !== undefined)) {
      let cfg = PULSE_DEFAULT_CONFIG.roles[role];
      if (!pulseUtility.isNotDefined(cfg)) {
        let listOfKeys = key.split('.');
        for (let i = 0; i < listOfKeys.length; i++) {
          cfg = cfg[listOfKeys[i]];
          if ((pulseUtility.isNotDefined(cfg)) || ('' === cfg)) {
            break; // To exit for
          }
          if (i == (listOfKeys.length - 1)) {
            retVal.found = true;
            retVal.value = cfg;
            return retVal;
          }
        }
      }
    }
  }
  return retVal;
}

var getPageConfig = function (key, role, pageName) {
  let retVal = { found: false, value: '' };
  if (typeof PULSE_DEFAULT_CONFIG == 'undefined') {
    console.warn('PULSE_DEFAULT_CONFIG is undefined');
    return retVal;
  }

  if ((!pulseUtility.isNotDefined(pageName)) && (pageName != '')) {
    // Search the key for the current pages
    if ((typeof PULSE_DEFAULT_CONFIG.pages != 'undefined')
      && (PULSE_DEFAULT_CONFIG.pages !== undefined)) {
      let cfg = PULSE_DEFAULT_CONFIG.pages[pageName];
      if (!pulseUtility.isNotDefined(cfg)) {
        let listOfKeys = key.split('.');
        for (let i = 0; i < listOfKeys.length; i++) {
          cfg = cfg[listOfKeys[i]];
          if ((pulseUtility.isNotDefined(cfg)) || ('' === cfg)) {
            break; // To exit for
          }
          if (i == (listOfKeys.length - 1)) {
            retVal.found = true;
            retVal.value = cfg;
            return retVal;
          }
        }
      }
    }
  }
  return retVal;
};

var getAppConfig = function (key, role, pageName) {
  let retVal = { found: false, value: '' };
  if (typeof PULSE_DEFAULT_CONFIG == 'undefined') {
    console.warn('PULSE_DEFAULT_CONFIG is undefined');
    return retVal;
  }

  // Search the key in the global section
  if ((typeof PULSE_DEFAULT_CONFIG != 'undefined')
    && (PULSE_DEFAULT_CONFIG !== undefined)) {
    let cfg = PULSE_DEFAULT_CONFIG.general;
    if (!pulseUtility.isNotDefined(cfg)) {
      let listOfKeys = key.split('.');
      for (let i = 0; i < listOfKeys.length; i++) {
        cfg = cfg[listOfKeys[i]];
        if (pulseUtility.isNotDefined(cfg)) {
          return retVal;
        }
        if ('' === cfg) {
          return retVal;
        }
        if (i == (listOfKeys.length - 1)) {
          retVal.found = true;
          retVal.value = cfg;
          return retVal;
        }
      }
    }
  }
  return retVal;
}

/** Get configuration using all paramaters
 * 
 * @memberof module:pulseConfig
 * @function getComponentDefaultConfig
 * @param key key to check
 * @return {String} configuration to use
 */
var getComponentDefaultConfig = function (key) {
  let retVal = { found: false, value: '' };
  if ((pulseUtility.isNotDefined(key)) || (key === '')) {
    // LOG ERROR here
    return retVal;
  }
  let cfg = tagConfig;
  if (!pulseUtility.isNotDefined(cfg)) {
    let listOfKeys = key.split('.');
    for (let i = 0; i < listOfKeys.length; i++) {
      cfg = cfg[listOfKeys[i]];
      if ((pulseUtility.isNotDefined(cfg)) || (cfg === '')) {
        return retVal;
      }
    }
    retVal.found = true;
    retVal.value = cfg;
    return retVal;
  }
  return retVal;
};
////////// ////////// //////////
// END of Local Functions     //
////////// ////////// //////////


/** Get configuration using all paramaters
 * 
 * @memberof module:pulseConfig
 * @function getFullConfig
 * @param key key to check
 * @param defaultValue default Value
 * @param onlyDefault - if true, don't take into account the overrides (url or localstorage)
 * @param {String} pageName - specific page, if needed
 * @param {String} role - hidden param, role if should be used
 * @return {String} configuration to use
 */
var getFullConfig = function (key, defaultValue, onlyDefault, pageName, role) {
  // Find role
  if (role == null)
    role = getAppContextOrRole(); // WAS getRole(); //LATER : maybe use login if exist ?

  let login = getLoginAppContextOrRole();

  let config = { found: false, value: defaultValue };

  // Find page name
  if (pageName == null)
    pageName = getPageName();

  // Are the overrides taken into account?
  if (onlyDefault == null || onlyDefault == false) {
    try {
      // Search the value in the current URL
      config = getURLConfig(key);
      if (config.found) { return config; }
    }
    catch (error) {
      console.error('getFullConfig - getURLConfig error for key=' + key + ' Default=' + defaultValue);
    }

    try {
      // Search the value in the localstorage, related to the current app
      config = getLocalConfig(key, login, pageName);
      if (config.found) { return config; }
    }
    catch (error) {
      console.error('getFullConfig - getLocalConfig error for key=' + key + ' Default=' + defaultValue);
    }
  }

  try {
    // Search role/page config
    config = getRolePageConfig(key, role, pageName);
    if (config.found) { return config; }
  }
  catch (error) {
    console.error('getFullConfig - getRolePageConfig error for key=' + key + ' Default=' + defaultValue);
  }

  try {
    // Search role config
    config = getRoleConfig(key, role, pageName);
    if (config.found) { return config; }
  }
  catch (error) {
    console.error('getFullConfig - getRoleConfig error for key=' + key + ' Default=' + defaultValue);
  }

  try {
    // Search page config
    config = getPageConfig(key, role, pageName);
    if (config.found) { return config; }
  }
  catch (error) {
    console.error('getFullConfig - getPageConfig error for key=' + key + ' Default=' + defaultValue);
  }

  try {
    // Search App config (general)
    config = getAppConfig(key, role, pageName);
    if (config.found) { return config; }
  }
  catch (error) {
    console.error('getFullConfig - getAppConfig error for key=' + key + ' Default=' + defaultValue);
  }

  try {
    // Return default (tagConfig = PWC config)
    config = getComponentDefaultConfig(key);
    if (config.found) { return config; }
  }
  catch (error) {
    console.error('getFullConfig - getComponentDefaultConfig error for key=' + key + ' Default=' + defaultValue);
  }

  //if NOT found (probably for AppContext), search in role
  let realRole = pulseLogin.getRole();
  if (role != realRole)
    return getFullConfig(key, defaultValue, onlyDefault, pageName, realRole);

  // Default = not found
  return config;
};

/** Get a configuration with no specific type, read in this order:
 * - in the url
 * - in localStorage of the web page
 * - in role+page configuration
 * - in role configuration
 * - in page configuration
 * - global default value - tagConfig
 * - value specified in the argument "defaultValue"
 * 
 *  /!\ Use it only for complex objects /!\
 * 
 * @memberof module:pulseConfig
 * @function get
 * @param {!String} key - key to check
 * @param {String} defaultValue - default Value
 * @param {String} page - specific page, if needed
 */
var get = exports.get = function (key, defaultValue, page) {
  // Get config
  let listOfKeys = key.split('.'); // Ex: 'ANY_tagName.realKey'
  if (listOfKeys.length > 1) { // Find overload first
    let lastKey = listOfKeys[listOfKeys.length - 1];
    let config = getFullConfig(lastKey, defaultValue, false, page);
    if (config.found)
      return config.value;
  }

  // FULL tag.key to find default component config
  let config = getFullConfig(key, defaultValue, false, page);
  if (config.found)
    return config.value;

  return defaultValue;
};

/** Get a configuration returned as a BOOLEAN
 * 
 * @memberof module:pulseConfig
 * @function getBool
 * @param {!String} key - key to check
 * @param {String} defaultValue - default Value
 * @param {String} page - specific page, if needed
 */
exports.getBool = function (key, defaultValue, page) {
  let tmp = get(key, defaultValue, page);
  return (tmp == true || tmp == 'true' || tmp == '1' || tmp == 1);
};

/** Get a configuration returned as an INTEGER
 * 
 * @memberof module:pulseConfig
 * @function getInt
 * @param {!String} key - key to check
 * @param {String} defaultValue - default Value
 * @param {String} page - specific page, if needed
 */
exports.getInt = function (key, defaultValue, page) {
  let tmp = get(key, defaultValue, page);
  return parseInt(tmp, 10);
}

/** Get a configuration returned as an FLOAT
 * 
 * @memberof module:pulseConfig
 * @function getFloat
 * @param {!String} key - key to check
 * @param {String} defaultValue - default Value
 * @param {String} page - specific page, if needed
 */
exports.getFloat = function (key, defaultValue, page) {
  let tmp = get(key, defaultValue, page);
  return parseFloat(tmp);
}

/** Get a configuration returned as a STRING
 * 
 * @memberof module:pulseConfig
 * @function getString
 * @param {!String} key - key to check
 * @param {String} defaultValue - default Value
 * @param {String} page - specific page, if needed
 */
var getString = exports.getString = function (key, defaultValue, page) {
  let tmp = get(key, defaultValue, page);
  if (tmp == undefined || tmp == null)
    tmp = '';
  return String(tmp);
}

/** Get a configuration returned as an ARRAY
 * 
 * @memberof module:pulseConfig
 * @function getArray
 * @param {!String} key - key to check
 * @param {String} defaultValue - default Value
 * @param {String} page - specific page, if needed
 */
var getArray =
  exports.getArray = function (key, defaultValue, page) {
    let tmp = get(key, defaultValue, page);
    if (tmp == null)
      return [];

    if (!Array.isArray(tmp)) {
      if (typeof tmp == 'string')
        return tmp.split(',');

      return [tmp];
    }
    // OK for roles in config file / KO for localstorage
    console.log('pulseConfig.get found ARRAY for key=' + key);
    return tmp;
  }

/** Get the defualt value with no specific type, read in this order
 * - in custom local definition (depending on the role first)
 * - default value for the current page
 * - global default value
 * - value specified in the argument "defaultValue"
 * 
 *  /!\ Use it only for complex objects /!\
 * 
 * @memberof module:pulseConfig
 * @function getDefault
 * @param {!String} key - key to check
 * @param {String} defaultValue - default Value
 */
var getDefault = exports.getDefault = function (key, defaultValue) {
  // Get config
  let listOfKeys = key.split('.'); // Ex: 'ANY_tagName.realKey'
  if (listOfKeys.length > 1) { // Find overload first
    let lastKey = listOfKeys[listOfKeys.length - 1];
    let config = getFullConfig(lastKey, defaultValue, true);
    if (config.found) {
      return config.value;
    }
  }
  // FULL tag.key to find default component config
  let config = getFullConfig(key, defaultValue, true);
  if (config.found) {
    return config.value;
  }
  return defaultValue;
};

/** Get a default configuration returned as a BOOLEAN
 * 
 * @memberof module:pulseConfig
 * @function getDefaultBool
 * @param {!String} key - key to check
 * @param {String} defaultValue - default Value
 */
exports.getDefaultBool = function (key, defaultValue) {
  let tmp = getDefault(key, defaultValue);
  return (tmp == true || tmp == 'true' || tmp == '1' || tmp == 1);
};

/** Get a default configuration returned as an INTEGER
 * 
 * @memberof module:pulseConfig
 * @function getDefaultInt
 * @param {!String} key - key to check
 * @param {String} defaultValue - default Value
 */
exports.getDefaultInt = function (key, defaultValue) {
  let tmp = getDefault(key, defaultValue);
  return parseInt(tmp, 10);
}

/** Get a default configuration returned as an FLOAT
 * 
 * @memberof module:pulseConfig
 * @function getDefaultFloat
 * @param {!String} key - key to check
 * @param {String} defaultValue - default Value
 */
exports.getDefaultFloat = function getDefaultFloat (key, defaultValue) {
  let tmp = getDefault(key, defaultValue);
  return parseFloat(tmp);
}

/** Get a default configuration returned as a STRING
 * 
 * @memberof module:pulseConfig
 * @function getDefaultString
 * @param {!String} key - key to check
 * @param {String} defaultValue - default Value
 */
exports.getDefaultString = function (key, defaultValue) {
  let tmp = getDefault(key, defaultValue);
  if (tmp == undefined || tmp == null)
    tmp = '';
  return String(tmp);
}

/** Get a default configuration returned as an ARRAY
 * 
 * @memberof module:pulseConfig
 * @function getDefaultArray
 * @param {!String} key - key to check
 * @param {String} defaultValue - default Value
 */
exports.getDefaultArray = function (key, defaultValue) {
  let tmp = getDefault(key, defaultValue);
  if (tmp == null)
    return [];
  if (!Array.isArray(tmp))
    return [tmp];
  return tmp;
}


/** Set GLOBAL configuration for the WHOLE app
 * For example : role, theme, machine...
 * Special session storage for path
 * 
 * @memberof module:pulseConfig
 * @function setGlobal (no role, no page)
 * @param key - key to fill
 * @param value - value associated to the key
 */
var setGlobal = exports.setGlobal = function (key, value) {
  // Find app name
  let app = getAppName();

  // STORE
  if (key == 'path') {
    // STORE
    if (typeof sessionStorage != 'undefined') {
      if (value === '') { // Keep '===' because '==' fails when false
        sessionStorage.removeItem(key);
      }
      else {
        sessionStorage.setItem(key, JSON.stringify(value));
      }
    }
    return;
  }

  if (typeof localStorage != 'undefined') {
    let keyString = 'PULSE.' + app + '.' + key;
    if (value === '') { // Keep '===' because '==' fails when false
      localStorage.removeItem(keyString);
    }
    else {
      if (Array.isArray(value)) { // Avoid array in local storage to keep compatibility with url / attributes == string
        let str = value.join();
        localStorage.setItem(keyString, JSON.stringify(str));
      }
      else {
        localStorage.setItem(keyString, JSON.stringify(value));
      }
    }
  }
  else {
    console.warn('Config can not set local storage (' + key + ')');
  }
}

/** Set configuration (in local storage)
 * 
 * @memberof module:pulseConfig
 * @function set
 * @param key - key to fill
 * @param value - value associated to the key
 * @param ignorePageName - if true, we should store by role only (default false)
 * @param global - if true, the configuration will be global for all pages
 */
var set = exports.set = function (key, value, ignorePageName) {
  /* TODO : probably add an error for role, theme, path */
  if (key == 'role' || key == 'theme' || key == 'path') {
    console.error(`Config.set should not be call with key = ${key}`);
    setGlobal(key, value);
    return;
  }

  // STORE
  if (typeof localStorage != 'undefined') {
    // Find app name / role / page
    let app = getAppName();
    //let role = getAppContextOrRole(); // WAS getRole();
    let login = getLoginAppContextOrRole();

    let keyString;
    if (ignorePageName) {
      // Determine the prefix
      keyString = 'PULSE.' + app + '.' + login + '.' + key;
    }
    else {
      let pageName = getPageName();
      // Determine the prefix
      keyString = 'PULSE.' + app + '.' + login + '.' + pageName + '.' + key;
    }

    if (value === '') { // Keep '===' because '==' fails when false
      localStorage.removeItem(keyString);
    }
    else {
      if (Array.isArray(value)) { // Avoid array in local storage to keep compatibility with url / attributes == string
        let str = value.join();
        localStorage.setItem(keyString, JSON.stringify(str));
      }
      else {
        localStorage.setItem(keyString, JSON.stringify(value));
      }
    }
  }
  else {
    console.warn('Config can not set value in local storage  (' + key + ')');
  }
}

/** Clear local configuration
 * 
 * @memberof module:pulseConfig
 * @function reset
 * @param key - key to clear
 */
exports.reset = function (key) {
  // Local
  set(key, '');
  // by role
  setGlobal(key, '', true);
  // Global
  setGlobal(key, '');
}

////////// ////////// //////////
// is login page              //
////////// ////////// //////////

exports.isLoginPage = function () {
  if ('login' == getPageName()) {
    return true;
  }
  if ('validate' == getPageName()) {
    return true;
  }
  return false;
}

/** Clear local configuration
 * 
 * @memberof module:pulseConfig
 * @function goToPageLogin
 */
exports.goToPageLogin = function () {
  let pwa_path = getString('pulsewebapppath', '');
  let newfullURL = window.location.href;
  if ('' == pwa_path) {
    newfullURL = pulseUtility.changePageName(window.location.href, 'login');
  }
  else {
    newfullURL = pwa_path + '/login.html';

    // Add 'path' if exists in url :
    let tmpPath = pulseUtility.getURLParameterValues(window.location.href, 'path');
    if (tmpPath.length > 0) {
      newfullURL = pulseUtility.changeURLParameter(newfullURL, 'path', tmpPath[0]);
    }
    let tmpMainPath = pulseUtility.getURLParameterValues(window.location.href, 'mainpath');
    if (tmpMainPath.length > 0) {
      newfullURL = pulseUtility.changeURLParameter(newfullURL, 'mainpath', tmpMainPath[0]);
    }
    // Remove Code if exists (validate page)
    let tmpCode = pulseUtility.getURLParameterValues(window.location.href, 'code');
    if (tmpCode.length > 0) {
      newfullURL = pulseUtility.removeURLParameter(newfullURL, 'code');
    }
  }

  window.location.href = newfullURL;
}

/** Clear local configuration
 * 
 * @memberof module:pulseConfig
 * @function goToPageLogin
 */
exports.goToFirstPage = function (role) {
  // Go to firstPage (if defined)
  let roles = getArray('roles');

  // Browse all roles
  for (let iRole = 0; iRole < roles.length; iRole++) {
    let aRole = roles[iRole];
    if (role == aRole.role) {
      // role found == aRole.display;
      if (pulseUtility.isNotDefined(aRole.firstPage)) { // Maybe add soon
        // go to home
        let fullURL = window.location.pathname;
        let newfullURL = fullURL.substring(0, fullURL.lastIndexOf('/') + 1) + 'home.html';

        // Add 'path' if exists in url :
        let tmpPath = pulseUtility.getURLParameterValues(window.location.href, 'path');
        if (tmpPath.length > 0) {
          newfullURL = pulseUtility.changeURLParameter(newfullURL, 'path', tmpPath[0]);
        }
        let tmpMainPath = pulseUtility.getURLParameterValues(window.location.href, 'mainpath');
        if (tmpMainPath.length > 0) {
          newfullURL = pulseUtility.changeURLParameter(newfullURL, 'mainpath', tmpMainPath[0]);
        }

        window.location.href = newfullURL;
      }
      else { // go to firstPage
        let firstPage = aRole.firstPage;
        //let fullURL = window.location.pathname;
        //let newfullURL = fullURL.substring(0, fullURL.lastIndexOf('/') + 1) + firstPage + '.html';
        let newfullURL = pulseUtility.changePageName(window.location.pathname, firstPage);

        // Add 'path' if exists in url :
        let tmpPath = pulseUtility.getURLParameterValues(window.location.href, 'path');
        if (tmpPath.length > 0) {
          newfullURL = pulseUtility.changeURLParameter(newfullURL, 'path', tmpPath[0]);
        }
        let tmpMainPath = pulseUtility.getURLParameterValues(window.location.href, 'mainpath');
        if (tmpMainPath.length > 0) {
          newfullURL = pulseUtility.changeURLParameter(newfullURL, 'mainpath', tmpMainPath[0]);
        }

        window.location.href = newfullURL;
      }
    }
  }
}


////////// ////////// //////////
// login / user / context     //
////////// ////////// //////////

//var currentRoleOrAppContextIsDefined = 
exports.currentRoleOrAppContextIsDefined = function () {
  let roles = getArray('roles');
  let currentRole = getAppContextOrRole(); // WAS getRole();
  for (let i = 0; i < roles.length; i++) {
    if (roles[i].role == currentRole) {
      return true;
    }
  }
  return false;
}

// get login / role or appContext display according to what is available
//var getCurrentUserDisplay = 
exports.getCurrentUserDisplay = function () {
  let roles = getArray('roles');

  // App Context
  let appContext = getAppContextOnly();
  if (appContext != '') {
    for (let i = 0; i < roles.length; i++) {
      if (roles[i].role == appContext) {
        if (roles[i].display != null) {
          return roles[i].display;
        }
        else {
          break;
        }
      }
    }
  }

  // Or login
  let login = pulseLogin.getLoginDisplay();
  if (login != '') {
    return login;
  }

  // Or role
  let currentRole = pulseLogin.getRole();
  for (let i = 0; i < roles.length; i++) {
    if (roles[i].role == currentRole) {
      if (roles[i].display != null) {
        return roles[i].display;
      }
      else {
        break;
      }
    }
  }

  return '';
}

////////// ////////// //////////
//                            //
////////// ////////// //////////
},{"pulseLogin":"pulseLogin","pulseUtility":"pulseUtility"}],"pulseCustomDialog":[function(require,module,exports){
(function (global){(function (){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
* @module pulseCustomDialog
* @requires pulseUtility
* @requires pulseSvg
*/

var pulseUtility = require('pulseUtility');
var pulseSvg = require('pulseSvg');

var pulseCustomDialog = function () {
  // Convenient object to store and get data attached to a dialog
  var _dataManager = pulseUtility.createDataManager('customDialogId');

  // List of open dialogs
  var _openIds = [];

  var _displayNavigation = function (selector) {
    var id = _dataManager.getId(selector);
    var dialogId = 'customDialog' + id;
    var data = _dataManager.get(id);

    // Extract parameters defining the element visibility
    var currentPage = data['currentPage'];
    var pageCount = data['pageCount'];
    var cancelButton = data['attributes']['cancelButton']; // can be null, "hidden"
    var previousButton = data['attributes']['previousButton']; // can be null, "hidden"
    var nextButton = data['attributes']['nextButton']; // can be null, "hidden"
    var okButton = data['attributes']['okButton']; // can be null, "hidden"
    var multiPage = data['attributes']['multiPage']; // can be "auto" / null, "on", "off"

    // First and/or last page?
    $('#' + dialogId).toggleClass('customDialogFirstPage', currentPage == 0);
    $('#' + dialogId).toggleClass('customDialogLastPage', currentPage == pageCount - 1);

    // Hidden buttons?
    $('#' + dialogId).toggleClass('customDialogNoCancel', cancelButton == 'hidden');
    $('#' + dialogId).toggleClass('customDialogNoPrevious', previousButton == 'hidden');
    $('#' + dialogId).toggleClass('customDialogNoNext', nextButton == 'hidden');
    $('#' + dialogId).toggleClass('customDialogNoOk', okButton == 'hidden');

    // Multipage state
    $('#' + dialogId).toggleClass('customDialogMultiPageOn', multiPage == 'on');
    $('#' + dialogId).toggleClass('customDialogMultiPageOff', multiPage == 'off');

    // Set current page
    for (var i = 0; i < pageCount; i++)
      $('#' + dialogId + ' .customDialogPage' + i).toggleClass('customDialogCurrentPage', i == currentPage);
  };

  /*
  * Close a prepared dialog
  * selector: the div containing the dialog
  */
  var close = function (selector) {
    var id = _dataManager.getId(selector);
    var attributes = _dataManager.get(id)['attributes'];

    var dialogId = 'customDialog' + id;

    // onClose?
    if (attributes['onClose'] != null)
      attributes['onClose']();

    $('#' + dialogId).removeClass('customDialogEnabled');

    // autoDelete?
    if (attributes['autoDelete'] != null && attributes['autoDelete'] == true) {
      $('#' + dialogId).remove();
      _dataManager.reset(id);
    }

    var index = _openIds.indexOf(id);
    if (index > -1) {
      _openIds.splice(index, 1)

      if (_openIds.length > 0) {
        // Unblur the previous dialog
        $('#customDialog' + _openIds[_openIds.length - 1]).css('filter', 'blur(0)');
      }
      else {
        // Unblur behind the first dialog
        $('.pulse-header').css('filter', 'blur(0)');
        $('#pulse-inner').css('filter', 'blur(0)');
      }
    }
  };

  /*
  * Call "cancel" of a dialog
  */
  var cancel = function (selector) {
    var id = _dataManager.getId(selector);
    var attributes = _dataManager.get(id)['attributes'];

    // onCancel?
    if (attributes['onCancel'] != null)
      attributes['onCancel']();

    // autoClose?
    if ((attributes['autoClose'] != null && attributes['autoClose'] == true) || (attributes['onCancel'] == null)) // If no autoClose AND no method Cancel : X should close dialog
      close(selector);
  };

  /*
  * Call "ok" of a dialog
  */
  var ok = function (selector) {
    var id = _dataManager.getId(selector);
    var attributes = _dataManager.get(id)['attributes'];

    // onOk?
    if (attributes['onOk'] != null)
      attributes['onOk']();

    // autoClose?
    if (attributes['autoClose'] != null && attributes['autoClose'] == true)
      close(selector);
  };

  /*
  * Call "previous" of a dialog
  */
  var previous = function (selector) {
    var id = _dataManager.getId(selector);
    var currentPage = _dataManager.get(id)['currentPage'];
    if (currentPage > 0)
      _dataManager.set(id, 'currentPage', currentPage - 1);
    _displayNavigation(selector);
  };

  /*
  * Call "next" of a dialog
  */
  var next = function (selector) {
    var id = _dataManager.getId(selector);
    var pageCount = _dataManager.get(id)['pageCount'];
    var currentPage = _dataManager.get(id)['currentPage'];
    if (currentPage < pageCount - 1)
      _dataManager.set(id, 'currentPage', currentPage + 1);
    _displayNavigation(selector);
  };

  /*
  * Display a defined page of a dialog
  */
  var goToPage = function (selector, nb) {
    var id = _dataManager.getId(selector);
    var pageCount = _dataManager.get(id)['pageCount'];
    if (nb < pageCount && nb >= 0)
      _dataManager.set(id, 'currentPage', nb);
    _displayNavigation(selector);
  };

  var _createDialog = function (attributes) {
    // Create an id
    var id = _dataManager.createNewId();
    var dialogId = 'customDialog' + id;

    // Options
    var closeButton = (attributes['closeButton'] != 'hidden');
    var fullScreenOnSmartphone = (attributes['fullScreenOnSmartphone'] == true);
    var bigSize = (attributes['bigSize'] == true);
    var fullSize = (attributes['fullSize'] == true);
    var smallSize = (attributes['smallSize'] == true);
    var helpName = attributes['helpName'];

    // Create a dialog
    $('body').append(
      "<div id='" + dialogId + "' class='customDialog'>" +
      "<div class='customDialogShadow'></div>" +
      "<div class='customDialogWindow" + (fullScreenOnSmartphone ? ' customDialogWindowFullScreenOnSmartphone' : '') +
      (fullSize ? ' fullSize' : (bigSize ? ' bigSize' : (smallSize ? ' smallSize' : ''))) + "'>" +
      "<div class='customDialogHeader'>" +
      (closeButton ? "<div class='customDialogCloseBox' title='Close dialog'></div>" : '') +
      (helpName ? "<div class='customDialogHelpBox' title='Help file' helpname='" + helpName + "'></div>" : '') +
      "<div class='customDialogTitle'>" + attributes['title'] + '</div>' +
      '</div>' +
      "<div class='customDialogContent'></div>" +
      "<div class='customDialogButtons'>" +
      "<button class='customDialogCancel buttonDialog' title='Cancel' role='button'></button>" +
      "<button class='customDialogPrevious buttonDialog' title='Previous' role='button'></button>" +
      "<button class='customDialogNext buttonDialog' title='Next' role='button'></button>" +
      "<button class='customDialogOk buttonDialog' title='Ok' role='button'></button>" +
      '</div>' +
      '</div>' +
      '</div>');
    _dataManager.initializeIdAttribute('#' + dialogId, id);

    pulseSvg.inlineBackgroundSvg('#' + dialogId + ' .customDialogCancel');
    pulseSvg.inlineBackgroundSvg('#' + dialogId + ' .customDialogPrevious');
    pulseSvg.inlineBackgroundSvg('#' + dialogId + ' .customDialogNext');
    pulseSvg.inlineBackgroundSvg('#' + dialogId + ' .customDialogOk');
    pulseSvg.inlineBackgroundSvg('#' + dialogId + ' .customDialogCloseBox');
    pulseSvg.inlineBackgroundSvg('#' + dialogId + ' .customDialogHelpBox');

    // Number of pages
    _dataManager.set(id, 'attributes', attributes);
    _dataManager.set(id, 'currentPage', 0);
    _dataManager.set(id, 'pageCount', 0);

    // Add callbacks
    $('#' + dialogId + ' .customDialogCloseBox').click(function () { cancel('#' + dialogId); });
    $('#' + dialogId + ' .customDialogCancel').click(function () { cancel('#' + dialogId); });
    $('#' + dialogId + ' .customDialogPrevious').click(function () { previous('#' + dialogId); });
    $('#' + dialogId + ' .customDialogNext').click(function () { next('#' + dialogId); });
    $('#' + dialogId + ' .customDialogOk').click(function () { ok('#' + dialogId); });

    $('.customDialogHelpBox').click(function () {
      //let helpName = this.getAttribute('helpname');
      let pathname = window.location.pathname;
      let pdfPath = pathname.substring(0, pathname.lastIndexOf('/') + 1) + 'help/' + helpName + '.pdf';
      // Open help file (if exists)
      function _fileExists (url) {
        if (url) {
          var req = new XMLHttpRequest();
          req.open('HEAD', url, false); // head is faster than GET
          req.send();
          return req.status == 200;
        } else {
          return false;
        }
      }
      if (_fileExists(pdfPath)) {
        window.open(pdfPath, 'resizable,scrollbars');
      }
      else {
        //pulseCustomDialog.openInfo('File not found !'); // impossible in dialog :(
        window.alert('File not found !');
      }
    });

    // Max height or height of the dialog
    if (attributes['fixedHeight'] == true) {
      $(window).on('resize', function () {
        $('#' + dialogId + ' .customDialogContent > div').css('height', (($(this).height() - 70) * (fullSize ? 0.99 : (bigSize ? 0.75 : 0.6))) + 'px');
      });
    }
    else {
      $(window).on('resize', function () {
        $('#' + dialogId + ' .customDialogContent > div').css('max-height', (($(this).height() - 70) * (fullSize ? 0.99 : (bigSize ? 0.75 : 0.6))) + 'px');
      });
    }

    // Vertical position of the dialog
    $(window).on('resize', function () {
      $('#' + dialogId + ' .customDialogWindow').css('top', (($(this).height() - $('#' + dialogId + ' .customDialogWindow').height()) * 0.3) + 'px');
    });

    return id;
  };

  /*
   * Add a page to a prepared dialog
   * selector: the div containing the dialog
   * pageSelector: the div that will be the new page
   */
  var addPage = function (selector, pageSelector) {
    // Id of the dialog
    var id = _dataManager.getId(selector);

    // Number of pages
    var pageCount = _dataManager.get(id)['pageCount'];
    var blockToInsert = $(pageSelector).detach().addClass('customDialogPage' + pageCount);
    blockToInsert.appendTo('#customDialog' + id + ' .customDialogContent');
    _dataManager.initializeIdAttribute(pageSelector, id);

    // Update data
    _dataManager.set(id, 'pageCount', pageCount + 1);

    // Dimensions of a page
    $('#customDialog' + id + ' .customDialogContent > div').css('width', (100 / (pageCount + 1)) + '%');
    var attributes = _dataManager.get(id)['attributes'];
    var bigSize = (attributes['bigSize'] == true);
    var fullSize = (attributes['fullSize'] == true);
    if (attributes['fixedHeight'] == true)
      $('#customDialog' + id + ' .customDialogContent > div')
        .css('height', (($(window).height() - 70) * (fullSize ? 0.99 : (bigSize ? 0.75 : 0.6))) + 'px');
    else
      $('#customDialog' + id + ' .customDialogContent > div')
        .css('max-height', (($(window).height() - 70) * (fullSize ? 0.99 : (bigSize ? 0.75 : 0.6))) + 'px');

    // Adapte the navigation buttons
    _displayNavigation(selector);
  };

  /* Create a dialog with initialize and addpage
   * Attributes:
   * - title
   * - cancelButton / previousButton / nextButton / okButton: can be set to "hidden"
   * - multipage: can be set to "auto" (default), "on", "off"
   * - onOpen, onOk, onCancel, onClose: functions that can be triggered
   * - autoClose: true / false (default), close automatically the dialog
   * - autoDelete: true / false (default), remove automatically the html associated to the dialog
   * - fixedHeight: true / false (default), force "full" height otherwise can be smaller
   * - bigSize: true / false (default), width 90% on big screen
   * - fullSize: true / false (default), width 99% on big screen
   * - fullScreenOnSmartphone: true / false (default), activate the full screen on smartphone
   *
   * Return the div name of the dialog
   */
  var initialize = function (selector, attributes) {
    if (attributes == null)
      attributes = {};

    // Create a new dialog
    var id = _createDialog(attributes);

    // Add a page
    addPage('#customDialog' + id, selector);

    return 'customDialog' + id;
  };

  var setAttribute = function (selector, key, value) {
    // Id of the dialog
    var id = _dataManager.getId(selector);

    // Update data
    var attributes = _dataManager.get(id)['attributes'];
    attributes[key] = value;
    _dataManager.set(id, 'attributes', attributes);

    // Possibly update the title
    if (key == 'title') {
      $('#customDialog' + id + ' .customDialogTitle').html(value);
    }
  };

  // Open common dialogs (info, warning, error, question)
  var _addCommonPage = function (id, message, icon) {
    var dialogId = 'customDialog' + id;
    var pageId = dialogId + 'content';
    $('body').append(
      "<div id='" + pageId + "'>" +
      "<div class='customDialogIcon customDialogIcon" + icon + "'></div>" +
      "<div class='customDialogMessage'>" + message + '</div>' +
      '</div>');
    addPage('#' + dialogId, '#' + pageId);

    // Keep after addPage to kkep color
    pulseSvg.inlineBackgroundSvg('#' + pageId + ' .customDialogIcon');
  };

  /*
  * Open a prepared dialog
  * selector: the div containing the dialog
  * knownDialogId : dialog id if known - else bug: open machine selection page twice => blur
  */
  var open = function (selector, knownDialogId) {
    _displayNavigation(selector);
    var id = _dataManager.getId(selector);
    var attributes = _dataManager.get(id)['attributes'];

    // Back to first page
    if (_dataManager.get(id)['currentPage'] > 0)
      _dataManager.set(id, 'currentPage', 0);
    _displayNavigation(selector);

    if (attributes['onOpen'] != null)
      attributes['onOpen']();
    $('#customDialog' + id).addClass('customDialogEnabled');

    // Adapt the position
    $('#customDialog' + id + ' .customDialogWindow').css('top', (($('#customDialog' + id + ' .customDialogShadow').height() - $('#customDialog' + id + ' .customDialogWindow').height()) * 0.3) + 'px');

    // Blur the previous dialog if not already done    
    if ('customDialog' + id != knownDialogId) {
      if (_openIds.length > 0) {
        $('#customDialog' + _openIds[_openIds.length - 1]).css('filter', 'blur(3px)');
      }
      else {
        // Blur behind the first dialog
        $('.pulse-header').css('filter', 'blur(2px)');
        $('#pulse-inner').css('filter', 'blur(2px)');
      }
      _openIds[_openIds.length] = id;
    }
  };

  /*
  * Open an info dialog.
  * It could be $.prompt BUT this one use Pomamo design.
  * message: message inside the window
  * title: title of the window
  * onClose: callback when the window is closed (ok or cancel)
  */
  var openInfo = function (message, title, onClose) {
    var id = _createDialog({
      title: (title == null ? 'Information' : title),
      cancelButton: 'hidden',
      previousButton: 'hidden',
      autoClose: true,
      autoDelete: true,
      onClose: onClose
    });
    _addCommonPage(id, message, 'Information');
    open('#customDialog' + id);

    return 'customDialog' + id;
  };

  /*
  * Open a warning dialog
  * message: message inside the window
  * title: title of the window
  * onClose: callback when the window is closed (ok or cancel)
  */
  var openWarning = function (message, title, onClose) {
    var id = _createDialog({
      title: (title == null ? 'Warning' : title),
      cancelButton: 'hidden',
      previousButton: 'hidden',
      autoClose: true,
      autoDelete: true,
      onClose: onClose
    });
    _addCommonPage(id, message, 'Warning');
    open('#customDialog' + id);
  };

  /*
  * Open an error dialog
  * message: message inside the window
  * title: title of the window
  * onClose: callback when the window is closed (ok or cancel)
  */
  var openError = function (message, title, onClose) {
    var id = _createDialog({
      title: (title == null ? 'Error' : title),
      cancelButton: 'hidden',
      previousButton: 'hidden',
      autoClose: true,
      autoDelete: true,
      onClose: onClose
    });
    _addCommonPage(id, message, 'Error');
    open('#customDialog' + id);
  };

  /*
  * Open a confirm dialog
  * message: message inside the window
  * title: title of the window
  * onOk: callback when "ok" is clicked
  * onCancel: callback when "cancel" is clicked
  */
  var openConfirm = function (message, title, onOk, onCancel) {
    var id = _createDialog({
      title: (title == null ? 'Confirmation' : title),
      autoClose: true,
      autoDelete: true,
      onOk: onOk,
      onCancel: onCancel
    });
    _addCommonPage(id, message, 'Question');
    open('#customDialog' + id);
  };

  /*
  * Open a loader
  * abortFunction: if set, the user can abort and this function is executed
  */
  var openLoader = function (abortFunction) {
    // Loader already open?
    var id; // To define id only once
    try {
      id = _dataManager.getId('#customDialogLoader');
      var dialogId = 'customDialog' + id;

      // Already open, just change the abort function
      var attributes = _dataManager.get(id)['attributes'];
      attributes['onCancel'] = abortFunction;
      attributes['cancelButton'] = (abortFunction == null ? 'hidden' : '');
      _dataManager.set(id, 'attributes', attributes);
      _displayNavigation('#' + dialogId);
      return;
    }
    catch (e) {
      //
    }

    // Create a new dialog with possibly a cancel button
    id = (abortFunction == null) ?
      _createDialog({
        title: 'Please wait...',
        cancelButton: 'hidden',
        previousButton: 'hidden',
        okButton: 'hidden',
        nextButton: 'hidden',
        closeButton: 'hidden',
        autoClose: true,
        autoDelete: true
      }) : _createDialog({
        title: 'Please wait...',
        previousButton: 'hidden',
        okButton: 'hidden',
        nextButton: 'hidden',
        closeButton: 'hidden',
        onCancel: abortFunction,
        autoClose: true,
        autoDelete: true
      });

    // Add a special class to this dialog
    $('#customDialog' + id).addClass('customDialogButtonRight');

    // Add content
    $('body').append(
      "<div id='customDialogLoader'>" +
      "<div class='customProgress' style='margin: 20px 10px'>" +
      "<div data-effect='slide-left' class='customProgressBar' role='progressbar' aria-valuenow='100' aria-valuemin='0' aria-valuemax='100' style='width: 100%; transition: all 0.7s ease-in-out 0s;'></div>" +
      '</div>' +
      '</div>');
    addPage('#customDialog' + id, '#customDialogLoader');

    // Open it
    open('#customDialog' + id);
  };

  /*
  * Close the loader
  */
  var closeLoader = function () {
    if ($('#customDialogLoader').length)
      close('#customDialogLoader');
  };

  /*
  * Close all dialogs
  */
  var closeAll = function () {
    $('.customDialog').each(function () { close('#' + this.id); });
  };

  /*
  * Close the last dialog
  */
  var closeLast = function () {
    if (_openIds.length > 0)
      cancel('#customDialog' + _openIds[_openIds.length - 1]);
  };

  // Connect the key "escape"
  $(document).keyup(function (e) {
    if (e.keyCode == 27)
      closeLast();
  });

  // List of exported functions
  return {
    cancel: cancel,
    close: close,
    ok: ok,
    previous: previous,
    next: next,
    goToPage: goToPage,
    addPage: addPage,
    initialize: initialize,
    setAttribute: setAttribute,
    open: open,
    openInfo: openInfo,
    openWarning: openWarning,
    openError: openError,
    openConfirm: openConfirm,
    openLoader: openLoader,
    closeLoader: closeLoader,
    closeAll: closeAll,
    closeLast: closeLast
  }
};

// Singleton: define global.singletonPulseCustomDialog if not set and return it in the exports
global.singletonPulseCustomDialog = global.singletonPulseCustomDialog || pulseCustomDialog();
module.exports = global.singletonPulseCustomDialog;
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"pulseSvg":"pulseSvg","pulseUtility":"pulseUtility"}],"pulseLogin":[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @file access login features.
 */

/**
* @module pulseLogin
* @requires pulseUtility
* NEVER ADD : pulseConfig here. pulseConfig can use pulseLogin.
*/
var pulseUtility = require('pulseUtility');
var eventBus = require('eventBus');

////////// ////////// ////////// //////////
// is login page = see in pulseConfig    //
////////// ////////// ////////// //////////

////////// ////////// //////////
// Access = get               //
////////// ////////// //////////

//var getLogin = 
exports.getLogin = function () {
  let login = pulseUtility.readCookie('PulseLogin');
  // Normal
  /*let name = 'PulseLogin=';
  let decodedCookie = decodeURIComponent(document.cookie);
  let ca = decodedCookie.split(';');
  for (let i = 0; i < ca.length; i++) {
    let c = ca[i];
    while (c.charAt(0) == ' ') {
      c = c.substring(1);
    }
    if (c.indexOf(name) == 0) {
      return c.substring(name.length, c.length);
    }
  }*/
  if (login == null)
    return '';
  else
    return login;
}

exports.getLoginDisplay = function () {
  let login = pulseUtility.readCookie('PulseUserDisplay');
  if (login == null)
    return '';
  else
    return login;
}

exports.getLoginForWebService = function () {
  let login = pulseUtility.readCookie('PulseLogin');
  if ((login == null)
    || (login == 'dev') || (login == 'support')
    || (login == 'Dev') || (login == 'Support'))
    return '';
  else
    return login;
}

//var getRole = 
exports.getRole = function () {
  // Find role in URL-> REMOVED !!!
  let role = pulseUtility.readCookie('PulseRole');
  if (role == null)
    return '';
  else
    return role;
}

exports.getAccessToken = function () {
  let token = pulseUtility.readCookie('PulseAccessToken');
  if (token == null)
    return '';
  else
    return token;
}
exports.getAccessTokenExpiration = function () {
  let token = pulseUtility.readCookie('PulseAccessTokenExpiredAt');
  if (token == null)
    return '';
  else
    return token;
}
exports.getRefreshToken = function () {
  let token = pulseUtility.readCookie('PulseRefreshToken');
  if (token == null)
    return '';
  else
    return token;
}
exports.getRefreshTokenExpiration = function () {
  let token = pulseUtility.readCookie('PulseRefreshTokenExpiredAt');
  if (token == null)
    return '';
  else
    return token;
}

////////// ////////// //////////
// Storage                    //
////////// ////////// //////////

var setAccessToken = exports.setAccessToken = function (access_token, expiredat) {
  if (access_token != null && access_token != '') {
    pulseUtility.createCookie('PulseAccessToken', access_token, 1);
    pulseUtility.createCookie('PulseAccessTokenExpiredAt', expiredat, 1);

    let target = {
      //url: url,
      //source: this.element.tagName,
      kind: 'AccessToken'
    };
    eventBus.EventBus.dispatchToAll('TokenHasChangedEvent', target);
  }
  else {
    pulseUtility.eraseCookie('PulseAccessToken');
    pulseUtility.eraseCookie('PulseAccessTokenExpiredAt');

    // No dispatch here, because goToPageLogin is always called just after
  }
}

var setRefreshToken = exports.setRefreshToken = function (refresh_token, expiredat) {
  if (refresh_token != null && refresh_token != '') {
    pulseUtility.createCookie('PulseRefreshToken', refresh_token, 1);
    pulseUtility.createCookie('PulseRefreshTokenExpiredAt', expiredat, 1);

    let target = {
      //url: url,
      //source: this.element.tagName,
      kind: 'RefreshToken'
    };
    eventBus.EventBus.dispatchToAll('TokenHasChangedEvent', target);
  }
  else {
    pulseUtility.eraseCookie('PulseRefreshToken');
    pulseUtility.eraseCookie('PulseRefreshTokenExpiredAt');

    // No dispatch here, because goToPageLogin is always called just after
  }
}

exports.storeRole = function (role) {
  pulseUtility.createCookie('PulseRole', role, 90);
  //document.cookie = 'PulseRole=' + role + ';path=/';
}

var storeLoginRole =
  exports.storeLoginRole = function (login, role, display, access_token, refresh_token,
    access_token_expiredat, refresh_token_expiredat, sessionOnly) {
    pulseUtility.createCookie('PulseLogin', login, sessionOnly?0:1);
    pulseUtility.createCookie('PulseRole', role, sessionOnly?0:1);
    //document.cookie = 'PulseLogin=' + login + ';path=/';
    //document.cookie = 'PulseRole=' + role + ';path=/'; // == storeRole(role);
    pulseUtility.createCookie('PulseUserDisplay', display, sessionOnly?0:1);

    setAccessToken(access_token, access_token_expiredat);
    setRefreshToken(refresh_token, refresh_token_expiredat);
  }

exports.storeLoginRoleFromRefreshDTO = function (data, sessionOnly) {
  let login = data.Login;
  let role = data.Role;
  role = role.toLowerCase();
  let display = data.UserDisplay; // from v 12
  if ( pulseUtility.isNotDefined(display) ) {
    display = data.UserName;
  }
  let access_token = data.AccessToken;
  // data.CompanyId
  let access_token_expiredat = data.ExpiresAt;
  let refresh_token = data.RefreshToken;
  let refresh_token_expiredat = data.RefreshTokenExpiresAt;

  storeLoginRole(login, role, display, access_token, refresh_token,
    access_token_expiredat, refresh_token_expiredat, sessionOnly);
}

////////// ////////// //////////
// Clean storage              //
////////// ////////// //////////

// goToPageLogin is always called just after
exports.cleanLoginRole = function () {
  pulseUtility.eraseCookie('PulseLogin');
  pulseUtility.eraseCookie('PulseRole');
  //document.cookie = 'PulseLogin=' + ';path=/';
  //document.cookie = 'PulseRole=' + ';path=/';
  pulseUtility.eraseCookie('PulseUserDisplay');
  setAccessToken('');
  setRefreshToken('');
}

////////// ////////// //////////
// Expiration                 //
////////// ////////// //////////

exports.isTokenExpired = function () {
  let refresh_token_expiration = pulseUtility.readCookie('PulseAccessTokenExpiredAt');
  if (refresh_token_expiration == null) {
    return true;
  }
  else {
    let m_expir = moment(refresh_token_expiration);
    let now = moment();
    if (now.isAfter(m_expir)) {
      return true;
    }
    else {
      return false;
    }
  }
}

/* Nearly expired */
var tokenNeedRefresh = exports.tokenNeedRefresh = function () {
  let refresh_token_expiration = pulseUtility.readCookie('PulseAccessTokenExpiredAt');
  if (refresh_token_expiration == null) {
    return false;
  }
  else {
    let m_expir = moment(refresh_token_expiration);
    let inXmin = moment().add(5, 'minutes');

    if (inXmin.isAfter(m_expir)) {
      return true;
    }
    else {
      return false;
    }
  }
}

////////// ////////// //////////
// Renew token = refresh      //
////////// ////////// //////////

var refreshToken = exports.refreshToken = function () {
  let target = {
    //url: url,
    //source: this.element.tagName,
    message: 'Authentication Error. Please retry'
  };
  eventBus.EventBus.dispatchToAll('AuthorizationErrorEvent', target);
}

exports.refreshTokenIfNeeded = function () {
  if (tokenNeedRefresh()) {
    refreshToken();
  }
}

////////// ////////// //////////
// Authentication / Validate  //
////////// ////////// //////////

exports.cleanAuthentication = function () {
  pulseUtility.eraseCookie('AuthenticationKind');
  pulseUtility.eraseCookie('AuthenticationName');
  pulseUtility.eraseCookie('AuthenticationLogin');
  pulseUtility.eraseCookie('AuthenticationState');
}

exports.storeAuthentication = function (AuthenticationKind,
  AuthenticationName, StateRequired, login) {
  pulseUtility.createCookie('AuthenticationKind', AuthenticationKind, 1);
  pulseUtility.createCookie('AuthenticationName', AuthenticationName, 1);
  pulseUtility.createCookie('AuthenticationLogin', login, 1);
  if ("true" == StateRequired) {
    let max = 4000000000; // max integer
    let state = Math.floor(Math.random() * max);
    pulseUtility.createCookie('AuthenticationState', state, 1);
  }
  else {
    pulseUtility.createCookie('AuthenticationState', '', 1);
  }
}

exports.getAuthenticationKind = function () {
  let auth = pulseUtility.readCookie('AuthenticationKind');
  if (auth == null)
    return '';
  else
    return auth;
}

exports.getAuthenticationName = function () {
  let auth = pulseUtility.readCookie('AuthenticationName');
  if (auth == null)
    return '';
  else
    return auth;
}

exports.getAuthenticationLogin = function () {
  let auth = pulseUtility.readCookie('AuthenticationLogin');
  if (auth == null)
    return '';
  else
    return auth;
}

exports.getAuthenticationState = function () {
  let auth = pulseUtility.readCookie('AuthenticationState');
  if (auth == null)
    return '';
  else
    return auth;
}

////////// ////////// //////////
// END                        //
////////// ////////// //////////


},{"eventBus":"eventBus","pulseUtility":"pulseUtility"}],"pulseRange":[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @file Module to manipulate ranges
 * @module pulseRange
 **/

/* FOR better understanding : Separate comment - hope it is not parsed
 * 
 * // Between x-tag == attribute + event + sent to web services
 * rangeString = '[isostring, isostring)'
 * 
 * // Tmp for compatibility
 * stringRange.lower = isostring 
 * stringRange.upper = isostring 
 * 
 * // Intern use only
 * dateRange.lower = Date()
 * dateRange.upper = Date()
 * 
 * // Conversion / Creation
 * pulseRange.createDateRangeFromString
 * pulseRange.createStringRangeFromString
 * pulseUtility.createSingleRangeForWebService
 * 
 * // Use :
 * pulseUtility.convertDateRangeForWebService
 * 
 */

/**
 * Generic class range
 *
 * @class
 */
class Range {
  /**
   * Constructor: create an empty range
   */
  constructor() {
    this._lower = null;
    this._lowerInclusive = false;
    this._upper = null;
    this._upperInclusive = false;
    this._empty = true;
  }

  /**
   * Lower value of the range
   * 
   * If the range is empty, an exception 'empty range' is raised
   */
  get lower () {
    if (this._empty) {
      console.error('Range.lower: empty range');
      throw 'empty range';
    }
    return this._lower;
  }
  set lower (l) {
    this._lower = l;
    if (this._lower == null) {
      this._lowerInclusive = false;
    }
    this._empty = false;
  }

  /** 
   * Is the lower value inclusive ?
   * 
   * If the range is empty, false is returned
   */
  get lowerInclusive () {
    return !this._empty && (this._lower != null) && this._lowerInclusive;
  }
  set lowerInclusive (li) {
    this._lowerInclusive = li;
  }

  /**
   * Upper value of the range
   * 
   * If the range is empty, an exception 'empty range' is raised
   */
  get upper () {
    if (this._empty) {
      console.error('Range.upper: empty range');
      throw 'empty range';
    }
    return this._upper;
  }
  set upper (u) {
    this._upper = u;
    if (this._upper == null) {
      this._upperInclusive = false;
    }
    this._empty = false;
  }

  /** 
   * Is the upper value inclusive ?
   * 
   * If the range is empty, false is returned
   */
  get upperInclusive () {
    return !this._empty && (this._upper != null) && this._upperInclusive;
  }
  set upperInclusive (ui) {
    this._upperInclusive = ui;
  }

  /** Inclusivity: [] or () or [) or (]
   * 
   * @return {string}
   */
  get inclusivity () {
    let s;
    if (this.lowerInclusive) {
      s = '[';
    }
    else {
      s = '(';
    }
    if (this.upperInclusive) {
      s += ']';
    }
    else {
      s += ')';
    }
    return s;
  }

  /** Set the inclusivity parsing a string: '(' and ')' is for exclusive, '[' and ']' is for inclusive
   * @param {string} inclusivity - Inclusivity string to parse: [] or [) or (] or ()
   */
  parseInclusivity (inclusivity) {
    if (inclusivity.length != 2) {
      console.error(`parseInclusivity: invalid inclusivity ${inclusivity}`);
      throw 'Invalid inclusivity'
    }
    switch (inclusivity.charAt(0)) {
      case '[':
        this._lowerInclusive = true;
        break;
      case '(':
        this._lowerInclusive = false;
        break;
      default:
        console.error(`parseInclusivity: invalid lower inclusivity in ${inclusivity}`);
        throw 'Invalid inclusivity';
    }
    switch (inclusivity.charAt(1)) {
      case ']':
        this._upperInclusive = true;
        break;
      case ')':
        this._upperInclusive = false;
        break;
      default:
        console.error(`parseInclusivity: invalid upper inclusivity in ${inclusivity}`);
        throw 'Invalid inclusivity';
    }
  }

  /** Is the range empty
   * @return {boolean} The range is empty
   */
  isEmpty () {
    if (this._empty) {
      return true;
    }
    else if (this._upper != null && this._lower != null) {
      if (this._upper < this._lower) {
        return true;
      }
      else if (this._upper == this._lower && (!this._upperInclusive || !this._lowerInclusive)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Callback to convert an object to a string
   * 
   * @callback toStringCallback
   * @param {Object} - Object to convert
   * @return {string} Result
   */

  /** To string conversion
   * @param {toStringCallback} boundToString - method to call to convert the lower or upper value to a string
   * @return {string}
   */
  toString (boundToString) {
    if (this.isEmpty()) {
      return 'empty';
    }
    else {
      return `${this.lowerInclusive ? '[' : '('}${(this.lower != null) ? boundToString(this.lower) : ''},${(this.upper != null) ? boundToString(this.upper) : ''}${!this.upperInclusive ? ')' : ']'}`;
    }
  }
}

/** Create an empty range
 * 
 * @memberof module:pulseRange
 * @function createEmpty
 * 
 * @return {Range} empty range
 */
var createEmpty = exports.createEmpty = function () {
  return new Range();
}

/** Create a range with the default inclusivity [)
 * 
 * @memberof module:pulseRange
 * @function createDefaultInclusivity
 * 
 * @param {*} lower - Lower value
 * @param {*} upper - Upper value
 * @return {Range} Range
 */
var createDefaultInclusivity = exports.createDefaultInclusivity = function (lower, upper) {
  let r = new Range();
  r.lower = lower;
  r.upper = upper;
  r.lowerInclusive = true;
  r.upperInclusive = false;
  return r;
}

/** Create a range
 * 
 * @memberof module:pulseRange
 * @function create
 * 
 * @param {*} lower - Lower value
 * @param {*} upper - Upper value
 * @param {string} inclusivity - Inclusivity: () or [] or [) or (]
 * @return {Range} Range
 */
var create = exports.create = function (lower, upper, inclusivity) {
  let r = new Range();
  r.lower = lower;
  r.upper = upper;
  r.parseInclusivity(inclusivity);
  return r;
}

/** Callback to parse a string
 * 
 * @callback parseCallback
 * @param {string} - string to parse
 * @return {Object} new object
 */

/** Extended method to parse a bound, considering null values
 * 
 * @param {string} arg - string to parse
 * @param {parseCallback} parseBound - Function to call to parse not empty lower and upper values
 * @return {Object} object returned by parseBound
 */
var parseBoundExt = function (arg, parseBound) {
  let s = arg.trim();
  if ((s.length == 0) || (s == '-oo') || (s == '+oo')) {
    return null;
  }
  else {
    return parseBound(s);
  }
}

/** Create a range from a string (parse it)
 * 
 * @memberof module:pulseRange
 * @function _createFromString
 * 
 * @param {string} arg - string to parse
 * @param {parseCallback} parseBound - Function to call to parse the lower and the upper values
 * @return {Range} Range
 */
var _createFromString =
  //exports.createFromString = 
  function (arg, parseBound) {
    let s = arg.trim();

    if (s == '' || s == 'empty') {
      return createEmpty();
    }

    if (s.length < 3) {
      console.error(`createFromString: ${s} is too short`);
      throw 'Invalid string length';
    }

    let pos = s.indexOf(',');
    if (pos == -1) {
      pos = s.indexOf(';');
    }
    if (pos == -1) {
      console.error('no separator');
      throw 'Invalid range, no separator';
    }
    else { // pos != -1
      let r = new Range();
      let lowerLimitChars = ['[', '('];
      let firstChar = s.charAt(0);
      if (lowerLimitChars.indexOf(firstChar) != -1) { // char found
        r.lowerInclusive = (firstChar == '[');
        let lower = s.substr(1, pos - 1);
        r.lower = parseBoundExt(lower, parseBound);
      }
      else {
        console.warn('Invalid lower limit in ' + arg);
        r.lowerInclusive = true;
        let lower = s.substr(0, pos).trim();
        r.lower = parseBoundExt(lower, parseBound);
      }
      let upperLimitChars = [']', ')'];
      let lastChar = s.charAt(s.length - 1);
      if (upperLimitChars.indexOf(lastChar) != -1) { // char found
        r.upperInclusive = (lastChar == ']');
        let upper = s.substr(pos + 1, s.length - 1 - (pos + 1));
        r.upper = parseBoundExt(upper, parseBound);
      }
      else {
        console.warn('Invalid upper limit in ' + arg);
        r.upperInclusive = false;
        let upper = s.substr(pos + 1, s.length - (pos + 1));
        r.upper = parseBoundExt(upper, parseBound);
      }
      return r;
    }
  }

/** Range where the bounds are native Javascript dates
 * 
 * @extends Range
 */
class DateRange extends Range {
  /** Constructor: create a DateRange from a string Range or a Date range
   * 
   * @override
   * 
   * @param {Range} r - Range to convert to a DateRange
   */
  constructor(r) {
    super();
    if (!r.isEmpty()) {
      let l;
      if (typeof r.lower == 'undefined') {
        l = null;
      }
      else if (typeof r.lower == 'string') {
        let trimmed = r.lower.trim();
        if ((trimmed == '') || (trimmed == '-oo')) {
          l = null;
        }
        else {
          l = new Date(r.lower);
        }
      }
      else {
        l = r.lower;
      }
      let u;
      if (typeof r.upper == 'undefined') {
        u = null;
      }
      else if (typeof r.upper == 'string') {
        let trimmed = r.upper.trim();
        if ((trimmed == '') || (trimmed == '+oo')) {
          u = null;
        }
        else {
          u = new Date(r.upper);
        }
      }
      else {
        u = r.upper;
      }
      super.lower = l;
      super.upper = u;
      super.lowerInclusive = r.lowerInclusive;
      super.upperInclusive = r.upperInclusive;
    }
  }
}

/** Create a native Javascript Date range from a string (calling new Date ())
 * 
 * @memberof module:pulseRange
 * @function createDateRangeFromString
 * 
 * @param {string} arg - String to parse
 * @return {DateRange} Range
 */
var createDateRangeFromString = exports.createDateRangeFromString = function (arg) {
  return new DateRange(_createFromString(arg, s => new Date(s)));
}

/** Create a native Javascript Date range with the default inclusivity
 * [) in case lower and upper are different and [] in case lower and upper are the same
 * 
 * In case lower or upper is a string, they are automatically converted to a Date
 * 
 * @memberof module:pulseRange
 * @function createDateRangeDefaultInclusivity
 * 
 * @param {string|Date} lower - Lower value
 * @param {string|Date} upper - Upper value
 * @return {DateRange} Range
 */
exports.createDateRangeDefaultInclusivity = function (lower, upper) {
  let l;
  if ((typeof lower == 'undefined') || (lower == 'null')) {
    l = null;
  }
  else if (typeof lower == 'string') {
    let trimmed = lower.trim();
    if ((trimmed == '') || (trimmed == '-oo')) {
      l = null;
    }
    else {
      l = new Date(lower);
    }
  }
  else {
    l = lower;
  }
  let u;
  if ((typeof upper == 'undefined') || (upper == 'null')) {
    u = null;
  }
  else if (typeof upper == 'string') {
    let trimmed = upper.trim();
    if ((trimmed == '') || (trimmed == '+oo')) {
      u = null;
    }
    else {
      u = new Date(upper);
    }
  }
  else {
    u = upper;
  }
  if ((l >= u) && (l <= u)) {
    return new DateRange(create(l, u, '[]'));
  }
  else {
    return new DateRange(create(l, u, '[)'));
  }
}

/** Create a native Javascript Date range
 * 
 * In case lower or upper is a string, they are automatically converted to a Date
 * 
 * @memberof module:pulseRange
 * @function createDateRange
 * 
 * @param {string|Date} lower - Lower value
 * @param {string|Date} upper - Upper value
 * @param {string} inclusivity - Inclusivity: [] or () or [) or (]
 * @return {DateRange} Range
 */
exports.createDateRange = function (lower, upper, inclusivity) {
  return new DateRange(create(lower, upper, inclusivity));
}

/** Convert a string or Date range to a Date range
 * 
 * @memberof module:pulseRange
 * @function convertToDateRange
 * 
 * @param {Range} range - string or Date range
 * @return {DateRange} Date range
 */
exports.convertToDateRange = function (range) {
  if (typeof range == 'string')
    return createDateRangeFromString(range);
  return new DateRange(range);
}

/** Range where the bounds are strings
 * 
 * @extends Range
 */
class StringRange extends Range {
  /** Constructor: create a StringRange from a Range
   * 
   * @override
   * 
   * @param {Range} r - Range to convert to a StringRange
   */
  constructor(r) {
    super();
    if (!r.isEmpty()) {
      let l;
      if (typeof r.lower == 'undefined') {
        l = null;
      }
      else if (typeof r.lower == 'string') {
        let trimmed = r.lower.trim();
        if ((trimmed == '') || (trimmed == '-oo')) {
          l = null;
        }
        else {
          l = r.lower;
        }
      }
      else if (r.lower == null) {
        l = null;
      }
      else {
        l = r.lower.toString();
      }
      let u;
      if (typeof r.upper == 'undefined') {
        r = null;
      }
      else if (typeof r.upper == 'string') {
        let trimmed = r.upper.trim();
        if ((trimmed == '') || (trimmed == '+oo')) {
          u = null;
        }
        else {
          u = r.upper;
        }
      }
      else if (r.upper == null) {
        u = null;
      }
      else {
        u = r.upper.toString();
      }
      super.lower = l;
      super.upper = u;
      super.lowerInclusive = r.lowerInclusive;
      super.upperInclusive = r.upperInclusive;
    }
  }
}

/** Create a string range (no conversion of the lower and upper values)
 * 
 * @memberof module:pulseRange
 * @function createStringRangeFromString
 * 
 * @param {string} arg - String to parse
 * @return {StringRange} range
 */
exports.createStringRangeFromString = function (arg) {
  return new StringRange(_createFromString(arg, s => s));
}

/** Callback to compare two objects
 * 
 * @callback eqCallback
 * @param {Object} - first object
 * @param {Object} - second object
 * @return {boolean} Equality comparison between the two objects
 */

/** Check the equality between two bound objects
  * 
  * Note that the bounds must be both lower or both upper
  * 
  * @memberof module:pulseRange
  * @function boundEquals
  * 
 * @param {Object} a - First bound to compare
 * @param {Object} b - Second bound to compare
 * @param {eqCallback} eq - Method to use to compare the bounds in case they are not null
 * @return {boolean} Equality
  */
var boundEquals = exports.boundEquals = function (a, b, eq) {
  if (null == a) {
    return (null == b);
  }
  else if (null == b) {
    return false;
  }
  else { // x and y not null
    return eq(a, b);
  }
}

/** Check the equality of the range
 * 
 * @memberof module:pulseRange
 * @function equals
 * 
 * @param {Range} a - First range to compare
 * @param {Range} b - Second range to compare
 * @param {eqCallback} eq - Method to use to compare the lower and upper values (when not null)
 * @return {boolean} Equality
 */
var equals = exports.equals = function (a, b, eq) {
  if (a === b) {
    return true;
  }
  if ((null == a) && (null == b)) {
    return true;
  }
  if ((null == a) || (null == b)) {
    return false;
  }
  if (a.isEmpty() && b.isEmpty()) {
    return true;
  }
  else if (a.isEmpty() || b.isEmpty()) {
    return false;
  }
  return boundEquals(a.lower, b.lower, eq) && boundEquals(a.upper, b.upper, eq)
    && (a.lowerInclusive == b.lowerInclusive)
    && (a.upperInclusive == b.upperInclusive);
}

/** Check the equality of the range with a default value equality comparison (>= && <=)
 * 
 * @param {Range} a - First range to compare
 * @param {Range} b - Second range to compare
 * @return {boolean} Equality
 */
exports.equalsDefault = function (a, b) {
  return equals(a, b, (a, b) => (a >= b) && (b <= a)); // Because for native javascript Date, a==b does not work
}

/** Overlap operator
 * 
 * If the operator can't be applied, false is returned
 * 
 * @memberof module:pulseRange
 * @function overlaps
 * 
 * @param {Range} a - first range
 * @param {Range} b - second range
 * @return true if a and b overlap
 */
var overlaps = exports.overlaps = function (a, b) {
  if (a.isEmpty() || b.isEmpty()) {
    console.warn('overlaps: empty, return false');
    return false;
  }
  else if ((null == a.lower) && (null == a.upper)) { // (,) => true
    return true;
  }
  else if (null == a.lower) { // (,... => compare upper only
    if (null == b.lower) {
      return true;
    }
    else if ((a.upper >= b.lower) && (a.upper <= b.lower)) { // Consider inclusivity. // Note: == does not work with Date
      return b.lowerInclusive && a.upperInclusive;
    }
    else if (b.lower < a.upper) {
      return true;
    }
    else {
      return false;
    }
  }
  else if (null == a.upper) { // ...,) => compare lower only
    if (null == b.upper) {
      return true;
    }
    if (a.lower < b.upper) {
      return true;
    }
    else if ((a.lower >= b.upper) && (a.lower <= b.upper)) { // Consider inclusivity. // Note: == does not work with Date
      return b.upperInclusive && a.lowerInclusive;
    }
    else {
      return false;
    }
  }
  else { // [(...,...)]
    if ((null != b.upper) && (null != b.lower)) {
      if ((b.lower >= a.upper) && (b.lower <= a.upper)) { // Note: == does not work with Date
        return b.lowerInclusive && a.upperInclusive;
      }
      else if ((b.upper >= a.lower) && (b.upper <= a.lower)) { // Note: == does not work with Date
        return b.upperInclusive && a.lowerInclusive;
      }
      else {
        return (b.lower < a.upper) && (a.lower < b.upper);
      }
    }
    else { // Reverse it ! In b, there is -oo or +oo
      return overlaps(b, a);
    }
  }
}

/** Intersects two ranges
 * 
 * @memberof module:pulseRange
 * @function intersects
 * 
 * @param {Range} a - first range
 * @param {Range} b - second range
 * @return {Range} Intersection of the two ranges
 */
exports.intersects = function (a, b) {
  if (!overlaps(a, b)) {
    // toString(no param) == undefined -> ignore log
    return createEmpty();
  }
  else { // Overlap ok
    let lower;
    let lowerInclusive;
    if (null == a.lower) {
      lower = b.lower;
      lowerInclusive = b.lowerInclusive;
    }
    else if (null == b.lower) {
      lower = a.lower;
      lowerInclusive = a.lowerInclusive;
    }
    else if ((a.lower >= b.lower) && (a.lower <= b.lower)) { // Note: == does not work with Date
      lower = a.lower;
      lowerInclusive = a.lowerInclusive && b.lowerInclusive;
    }
    else if (a.lower < b.lower) {
      lower = b.lower;
      lowerInclusive = b.lowerInclusive;
    }
    else {
      lower = a.lower;
      lowerInclusive = a.lowerInclusive
    }

    let upper;
    let upperInclusive;
    if (null == a.upper) {
      upper = b.upper;
      upperInclusive = b.upperInclusive;
    }
    else if (null == b.upper) {
      upper = a.upper;
      upperInclusive = a.upperInclusive;
    }
    else if ((a.upper >= b.upper) && (a.upper <= b.upper)) { // Note: == does not work with Date
      upper = a.upper;
      upperInclusive = a.upperInclusive && b.upperInclusive;
    }
    else if (a.upper < b.upper) {
      upper = a.upper;
      upperInclusive = a.upperInclusive;
    }
    else {
      upper = b.upper;
      upperInclusive = b.upperInclusive;
    }

    let r = createDefaultInclusivity(lower, upper);
    r.lowerInclusive = lowerInclusive;
    r.upperInclusive = upperInclusive;
    return r;
  }
}
},{}],"pulseService":[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @file Access web/asp services
 */

/**
* @module pulseService
* @requires pulseUtility
* @requires pulseLogin
*/

var pulseLogin = require('pulseLogin');

/**
 * Method to call an Ajax request (without token)
 *
 * @memberof module:pulseService
 *
 * @function runAjaxSimple
 * 
 * == without token
 *
 * @param {string} url url used by ajax request
 * @param {function} success callback function called if the request is successful and returns a valid data
 * @param {function} error callback function called if the request is completed but an error data is returned
 * @param {function} fail callback function called in case of request failure. First argument is the URL, second argument is if it is because of a timeout, third argument is the status
 * @param {Number} timeout Timeout in ms
 */
exports.runAjaxSimple = function (url, success, error, fail, timeout) {
  if (typeof url === 'undefined') {
    console.error('runAjaxSimple: no valid url');
    if (fail) {
      fail(url, false, null);
    }
    return;
  }
  $.support.cors = true;
  if ("" != pulseLogin.getAccessToken()) {
    $.ajax(
      {
        crossDomain: true,
        cache: false, /* for IE */
        type: 'GET',
        url: url,
        timeout: ((timeout == undefined) || (timeout == null) || (!isInteger(timeout))) ? 4 * 60 * 1000 : timeout, // default timeout = 4 min
        dataType: 'json',
        headers: {
          'Authorization': 'Bearer ' + pulseLogin.getAccessToken()
        }
      }
    )
      .done(function (data, textStatus, jqXHR) {
        if (data.ErrorMessage) {
          console.error(`runAjax: error, url=${url} message=${data.ErrorMessage}`);
          if (error) {
            error(data);
          }
        }
        else {
          console.log(`runAjax: success, url=${url}`);
          if (success) {
            success(data);
          }
        }
      })
      .fail(function (jqXHR, textStatus, errorThrown) {
        console.error(`runAjax: failure, url=${url} textStatus=${textStatus}`);
        if (fail) {
          if (textStatus == 'timeout') {
            fail(url, true, jqXHR.status);
          }
          else {
            fail(url, false, jqXHR.status);
          }
        }
      });
  }
  else {
    $.ajax(
      {
        crossDomain: true,
        cache: false, /* for IE */
        type: 'GET',
        url: url,
        timeout: ((timeout == undefined) || (timeout == null) || (!isInteger(timeout))) ? 4 * 60 * 1000 : timeout, // default timeout = 4 min
        dataType: 'json'
      }
    )
      .done(function (data, textStatus, jqXHR) {
        if (data.ErrorMessage) {
          console.error(`runAjax: error, url=${url} message=${data.ErrorMessage}`);
          if (error) {
            error(data);
          }
        }
        else {
          console.log(`runAjax: success, url=${url}`);
          if (success) {
            success(data);
          }
        }
      })
      .fail(function (jqXHR, textStatus, errorThrown) {
        console.error(`runAjax: failure, url=${url} textStatus=${textStatus}`);
        if (fail) {
          if (textStatus == 'timeout') {
            fail(url, true, jqXHR.status);
          }
          else {
            fail(url, false, jqXHR.status);
          }
        }
      });
  }
} // runAjaxSimple


/**
 * Utility method to call an Ajax request
 *
 * @memberof module:pulseService
 *
 * @function runAjax
 *
 * @param {Number} token Token to check a callback corresponds to the request
 * @param {string} url url used by ajax request
 * @param {Number} timeout Timeout in ms
 * @param {function} success callback function called if the request is successful and returns a valid data
 * @param {function} error callback function called if the request is completed but an error data is returned
 * @param {function} fail callback function called in case of request failure. First argument is the URL, second argument is if it is because of a timeout, third argument is the status
 */
exports.runAjax = function (token, url, timeout, success, error, fail) {
  if (typeof url === 'undefined') {
    console.error(`runAjax(${token}): no valid url`);
    if (fail) {
      fail(token, url, false, null);
    }
    return;
  }
  $.support.cors = true;
  if ("" != pulseLogin.getAccessToken()) {
    $.ajax(
      {
        crossDomain: true,
        cache: false, /* for IE */
        type: 'GET',
        url: url,
        timeout: ((timeout == undefined) || (timeout == null) || (!isInteger(timeout))) ? 4 * 60 * 1000 : timeout, // default timeout = 4 min
        dataType: 'json',
        headers: {
          'Authorization': 'Bearer ' + pulseLogin.getAccessToken()
        }
      }
    )
      .done(function (data, textStatus, jqXHR) {
        if (data.ErrorMessage) {
          console.error(`runAjax(${token}): error, url=${url} message=${data.ErrorMessage}`);
          if (error) {
            error(token, data);
          }
        }
        else {
          console.log(`runAjax(${token}): success, url=${url}`);
          if (success) {
            success(token, data);
          }
        }
      })
      .fail(function (jqXHR, textStatus, errorThrown) {
        console.error(`runAjax(${token}): failure, url=${url} textStatus=${textStatus}`);
        if (fail) {
          if (textStatus == 'timeout') {
            fail(token, url, true, jqXHR.status);
          }
          else {
            fail(token, url, false, jqXHR.status);
          }
        }
      });
  }
  else {
    $.ajax(
      {
        crossDomain: true,
        cache: false, /* for IE */
        type: 'GET',
        url: url,
        timeout: ((timeout == undefined) || (timeout == null) || (!isInteger(timeout))) ? 4 * 60 * 1000 : timeout, // default timeout = 4 min
        dataType: 'json'
      }
    )
      .done(function (data, textStatus, jqXHR) {
        if (data.ErrorMessage) {
          console.error(`runAjax(${token}): error, url=${url} message=${data.ErrorMessage}`);
          if (error) {
            error(token, data);
          }
        }
        else {
          console.log(`runAjax(${token}): success, url=${url}`);
          if (success) {
            success(token, data);
          }
        }
      })
      .fail(function (jqXHR, textStatus, errorThrown) {
        console.error(`runAjax(${token}): failure, url=${url} textStatus=${textStatus}`);
        if (fail) {
          if (textStatus == 'timeout') {
            fail(token, url, true, jqXHR.status);
          }
          else {
            fail(token, url, false, jqXHR.status);
          }
        }
      });
  }
}

/**
 * Utility method to get Ajax message for user display
 *
 * @memberof module:pulseService
 *
 * @function getAjaxErrorMessage
 *
 * @param {Number} xhrStatus xhrStatus (cf run or post Ajax for details)
 * @return {String} message to be displayed
 */
exports.getAjaxErrorMessage = function (xhrStatus) {
  if (typeof xhrStatus === 'undefined') {
    return 'Empty XHR status';
  }
  else {
    let statusMessageMap = {
      '0': 'Not connected, check the network',
      '400': 'Bad request',
      '401': 'Unauthorised access',
      '403': 'Forbidden resource, cannot be accessed',
      '404': 'Requested page not found',
      '500': 'Internal Server Error',
      '501': 'Not implemented',
      '502': 'Bad Gateway or Proxy Error',
      '503': 'Service Unavailable',
      '504': 'Gateway Timeout',
      '520': 'Unknown Error'
    };
    let message = statusMessageMap[xhrStatus];
    if (typeof message === 'undefined') {
      message = `unknown status ${xhrStatus}`;
    }
    return message;
  }
}

/**
 * Utility method to call an Ajax request
 *
 * @memberof module:pulseService
 *
 * @function postAjax
 *
 * @param {Number} token Token to check a callback corresponds to the request
 * @param {string} url url used by ajax request
 * @param {json} jsonData jsonData to post
 * @param {Number} timeout Timeout in ms
 * @param {function} success callback function called if the request is successful and returns a valid data
 * @param {function} error callback function called if the request is completed but an error data is returned
 * @param {function} fail callback function called in case of request failure. First argument is the URL, second argument is if it is because of a timeout, third argument is the status
 */
exports.postAjax = function (token, url, jsonData, timeout, success, error, fail) {
  if (typeof url === 'undefined') {
    console.error(`postAjax(${token}): no valid url`);
    if (fail) {
      fail(token, url, false, null);
    }
    return;
  }
  $.support.cors = true;
  if ("" != pulseLogin.getAccessToken()) {
    $.ajax({
      crossDomain: true,
      cache: false, /* for IE */
      type: 'POST',
      url: url,
      timeout: ((timeout == undefined) || (timeout == null) || (!isInteger(timeout))) ? 4 * 60 * 1000 : timeout, // default timeout = 4 min
      contentType: 'text/plain', // should be 'application/json' but do not work at all
      dataType: 'json',
      data: JSON.stringify(jsonData),
      headers: {
        'Authorization': 'Bearer ' + pulseLogin.getAccessToken()
      }
    })
      .done(function (data, textStatus, jqXHR) {
        if (data.ErrorMessage) {
          console.error(`postAjax(${token}): error, url=${url} message=${data.ErrorMessage}`);
          if (error) {
            error(token, data);
          }
        }
        else {
          console.log(`postAjax(${token}): success, url=${url}`);
          if (success) {
            success(token, data);
          }
        }
      })
      .fail(function (jqXHR, textStatus, errorThrown) {
        console.error(`postAjax(${token}): failure, url=${url} textStatus=${textStatus}`);
        if (fail) {
          if (textStatus == 'timeout') {
            fail(token, url, true, jqXHR.status);
          }
          else {
            fail(token, url, false, jqXHR.status);
          }
        }
      });
  }
  else {
    $.ajax({
      crossDomain: true,
      cache: false, /* for IE */
      type: 'POST',
      url: url,
      timeout: ((timeout == undefined) || (timeout == null) || (!isInteger(timeout))) ? 4 * 60 * 1000 : timeout, // default timeout = 4 min
      contentType: 'text/plain', // should be 'application/json' but do not work at all
      dataType: 'json',
      data: JSON.stringify(jsonData)
    })
      .done(function (data, textStatus, jqXHR) {
        if (data.ErrorMessage) {
          console.error(`postAjax(${token}): error, url=${url} message=${data.ErrorMessage}`);
          if (error) {
            error(token, data);
          }
        }
        else {
          console.log(`postAjax(${token}): success, url=${url}`);
          if (success) {
            success(token, data);
          }
        }
      })
      .fail(function (jqXHR, textStatus, errorThrown) {
        console.error(`postAjax(${token}): failure, url=${url} textStatus=${textStatus}`);
        if (fail) {
          if (textStatus == 'timeout') {
            fail(token, url, true, jqXHR.status);
          }
          else {
            fail(token, url, false, jqXHR.status);
          }
        }
      });
  }
}


},{"pulseLogin":"pulseLogin"}],"pulseSvg":[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

var pulseUtility = require('pulseUtility');
var _svgNS = 'http://www.w3.org/2000/svg';

/**
 * Return _svgNS for unique global definition
 */
exports.get_svgNS = function () {
  return _svgNS;
}

/**
 * Create and return radial gradient def
 * to display stacklight
 *
 * @memberof module:pulseSvg
 * @function createRadialGradientDef
 *
 * @return pattern def
 */
exports.createRadialGradientDef = function (color, newId) {
  let def = document.createElementNS(_svgNS, 'defs');

  let stop0 = document.createElementNS(_svgNS, 'stop');
  stop0.setAttribute('offset', '0%');
  stop0.setAttribute('style', 'stop-color:#DFDFDF;stop-opacity:1');
  let stop1 = document.createElementNS(_svgNS, 'stop');
  stop1.setAttribute('offset', '100%');
  stop1.setAttribute('style', 'stop-color:' + color + ';stop-opacity:1');

  let gradient = document.createElementNS(_svgNS, 'radialGradient');
  gradient.setAttribute('id', newId);
  gradient.setAttribute('cx', '40%');
  gradient.setAttribute('cy', '40%');
  gradient.setAttribute('r', '30%'); // defaut 50 ?
  gradient.setAttribute('fx', '50%');
  gradient.setAttribute('fy', '40%'); //50
  gradient.appendChild(stop0);
  gradient.appendChild(stop1);

  def.appendChild(gradient);
  return def;
}

/**
 * Create and return pattern def
 * to display patterns for MOS and other bars
 *
 * @memberof module:pulseSvg
 * @function createPatternDef
 *
 * @return pattern def
 */
exports.createPatternDef = function (patternName, color, newName) {
  let def = document.createElementNS(_svgNS, 'defs');
  let pattern = document.createElementNS(_svgNS, 'pattern');
  pattern.setAttribute('id', newName);
  pattern.setAttribute('x', 6);
  pattern.setAttribute('y', 6);
  pattern.setAttribute('width', 10);
  pattern.setAttribute('height', 10);
  pattern.setAttribute('patternUnits', 'userSpaceOnUse');
  if (patternName.substring(0, 7) == 'circles') {
    //if ( patternName.startsWith('circles') ) { Removed because IE fails
    let size = patternName.substr(8);
    let circle = document.createElementNS(_svgNS, 'circle');
    circle.setAttribute('cx', size / 2);
    circle.setAttribute('cy', size / 2);
    circle.setAttribute('r', size / 2);
    circle.setAttribute('style', 'stroke: none; fill: ' + color);
    pattern.appendChild(circle);
  }
  if (patternName.substring(0, 4) == 'dots') {
    //if ( patternName.startsWith('dots') ) { Removed because IE fails
    let size = patternName.substr(5);
    let rect = document.createElementNS(_svgNS, 'rect');
    rect.setAttribute('x', 0);
    rect.setAttribute('y', 0);
    rect.setAttribute('width', size);
    rect.setAttribute('height', size);
    rect.setAttribute('style', 'stroke: none; fill: ' + color);
    pattern.appendChild(rect);
  }
  if (patternName.substring(0, 17) == 'horizontal-stripe') {
    //if ( patternName.startsWith('horizontal-stripe') ) { Removed because IE fails
    let size = patternName.substr(18);
    let rect = document.createElementNS(_svgNS, 'rect');
    rect.setAttribute('x', 0);
    rect.setAttribute('y', 0);
    rect.setAttribute('width', 10); // Full width
    rect.setAttribute('height', size);
    rect.setAttribute('style', 'stroke: none; fill: ' + color);
    pattern.appendChild(rect);
  }
  if (patternName.substring(0, 15) == 'vertical-stripe') {
    //if ( patternName.startsWith('vertical-stripe') ) { Removed because IE fails
    let size = patternName.substr(16);
    let rect = document.createElementNS(_svgNS, 'rect');
    rect.setAttribute('x', 0);
    rect.setAttribute('y', 0);
    rect.setAttribute('width', size);
    rect.setAttribute('height', 10); // Full width
    rect.setAttribute('style', 'stroke: none; fill: ' + color);
    pattern.appendChild(rect);
  }
  if (patternName.substring(0, 14) == 'diagonal-strip') {
    //if ( patternName.startsWith('diagonal-stripe') ) { Removed because IE fails
    let size = patternName.substr(16);
    let line = document.createElementNS(_svgNS, 'line');
    line.setAttribute('x1', 0);
    line.setAttribute('y1', 10);
    line.setAttribute('x2', 10);
    line.setAttribute('y2', 0);
    line.setAttribute('style', 'stroke:' + color + ';stroke-width:' + size);
    pattern.appendChild(line);
    let line2 = document.createElementNS(_svgNS, 'line');
    line2.setAttribute('x1', -10);
    line2.setAttribute('y1', 10);
    line2.setAttribute('x2', 10);
    line2.setAttribute('y2', -10);
    line2.setAttribute('style', 'stroke:' + color + ';stroke-width:' + size);
    pattern.appendChild(line2);
    let line3 = document.createElementNS(_svgNS, 'line');
    line3.setAttribute('x1', 0);
    line3.setAttribute('y1', 20);
    line3.setAttribute('x2', 20);
    line3.setAttribute('y2', 0);
    line3.setAttribute('style', 'stroke:' + color + ';stroke-width:' + size);
    pattern.appendChild(line3);
  }

  def.appendChild(pattern);
  return def;
}

/**
 * Create and return SVG simple rect
 *
 * @memberof module:pulseSvg
 * @function createRect
 *
 * @return SVG rect
 */
var createRect = exports.createRect = function (x, y, width, height, color, mainClass) {
  let svg = document.createElementNS(_svgNS, 'svg');
  svg.setAttribute('width', width);
  svg.setAttribute('height', height);

  // CREATE SVG rect
  let rect = document.createElementNS(_svgNS, 'rect');
  svg.appendChild(rect);
  if (x == null)
    x = 0;
  if (y == null)
    y = 0;
  rect.setAttribute('x', x);
  rect.setAttribute('y', y);
  rect.setAttribute('width', width);
  rect.setAttribute('height', height);
  if (color != null)
    rect.setAttribute('fill', color);
  if (mainClass != null)
    rect.setAttribute('class', mainClass);

  return svg;
}

/**
 * Create base SVG to insert others SVG elements
 *
 * @memberof module:pulseSvg
 *
 * @function createBase
 * 
 * @param {Integer} width  
 * @param {Integer} height  
 * @param {string} mainClass  class to set
 * @param {Integer} viewBoxWidth  optional
 * @param {Integer} viewBoxHeight  optional
 * @return {Object} SVG
 */
var createBase = exports.createBase = function (width, height, mainClass, viewBoxWidth, viewBoxHeight) {
  let svg = document.createElementNS(_svgNS, 'svg');
  svg.setAttribute('width', width);
  svg.setAttribute('height', height);
  svg.setAttribute('class', mainClass);
  if ((!pulseUtility.isNotDefined(viewBoxWidth)) &&
    (!pulseUtility.isNotDefined(viewBoxHeight))) {
    svg.setAttribute('viewBox', '0 0 '
      + viewBoxWidth + ' '
      + viewBoxHeight);
  }
  return svg;
}

/**
 *
 * Create SVG ellipse
 *
 * @memberof module:pulseSvg
 *
 * @function createEllipse
 * 
 * @param {Integer} xMiddle
 * @param {Integer} yMiddle
 * @param {Integer} xRadius
 * @param {Integer} yRadius
 * @param {String} mainClass  class to set
 
 * @returns {Object} SVG
 */
exports.createEllipse = function (xMiddle, yMiddle, xRadius, yRadius, mainClass) {
  let ellipse = document.createElementNS(_svgNS, 'ellipse');
  ellipse.setAttribute('cx', xMiddle);
  ellipse.setAttribute('cy', yMiddle);
  ellipse.setAttribute('rx', xRadius);
  ellipse.setAttribute('ry', yRadius);
  ellipse.setAttribute('class', mainClass);
  return ellipse;
}

/**
 * Create SVG circle
 *
 * @memberof module:pulseSvg
 *
 * @function createCircle
 * 
 * @param {Integer} xMiddle
 * @param {Integer} yMiddle
 * @param {Integer} radius
 * @param {string} fillColor
 * @param {string} mainClass  class to set
 * @param {string} strokeColor
 * @param {Integer} strokeWidth
 
 * @return {Object} SVG
 */
exports.createCircle = function (xMiddle, yMiddle, radius, fillColor, mainClass, strokeColor, strokeWidth) {
  let circle = document.createElementNS(_svgNS, 'circle');
  circle.setAttribute('cx', xMiddle);
  circle.setAttribute('cy', yMiddle);
  circle.setAttribute('r', radius);
  if (!pulseUtility.isNotDefined(fillColor)) {
    circle.setAttribute('fill', fillColor);
  }
  circle.setAttribute('class', mainClass);
  if (!pulseUtility.isNotDefined(strokeWidth)) {
    circle.setAttribute('stroke-width', strokeWidth);
  }
  if (!pulseUtility.isNotDefined(strokeColor)) {
    circle.setAttribute('stroke', strokeColor);
  }
  return circle;
}
/**
 * Create SVG segment on donut
 *
 * @memberof module:pulseSvg
 *
 * @function changeSegmentOnDonutEnd
 * to be called after createSegmentOnDonut to only change end position
 * 
 * @param {DOM} circleProgress
 * @param {Integer} radius
 * @param {Double} widthPercent percent for the segment length
 * @param {string} mainClass  class to set (optional)
 
 * @return {Object} SVG
 */
exports.
  changeSegmentOnDonutEnd = function (circleProgress, radius, widthPercent, mainClass) {
    let circumference = 2.0 * Math.PI * radius;
    if (widthPercent >= 0.0) { // Keep '<=' and not '<' only to allow progress
      circleProgress.setAttribute('stroke-dasharray',
        (circumference * widthPercent).toFixed(0) + ' ' +
        (circumference * (1.0 - widthPercent)).toFixed(0)); //'85 15');
    }

    if (mainClass)
      circleProgress.setAttribute('class', mainClass);

    return circleProgress;
  }

/**
 * Create SVG segment on donut
 *
 * @memberof module:pulseSvg
 *
 * @function createSegmentOnDonut
 * 
 * @param {Integer} xMiddle
 * @param {Integer} yMiddle
 * @param {Integer} radius
 * @param {string} fillColor
 * @param {string} mainClass  class to set
 * @param {string} strokeColor
 * @param {Integer} strokeWidth in %
 * @param {Double} beginPercent percent for the begin of the segment
 * @param {Double} widthPercent percent for the segment length
 
 * @return {Object} SVG
 */
exports.createSegmentOnDonut = function (xMiddle, yMiddle, radius, fillColor, mainClass,
  strokeColor, strokeWidth, beginPercent, widthPercent) {
  if (widthPercent < 0) {
    return null;
  }
  //let magicCircleRadius = 15.91549430918954;
  let circumference = 2.0 * Math.PI * radius; // == 100 if magicCircleRadius is used

  let circleProgress = document.createElementNS(_svgNS, 'circle');
  circleProgress.setAttribute('cx', xMiddle);
  circleProgress.setAttribute('cy', yMiddle);
  circleProgress.setAttribute('r', radius);
  if (!pulseUtility.isNotDefined(fillColor)) {
    circleProgress.setAttribute('fill', fillColor);
  }
  circleProgress.setAttribute('class', mainClass);
  if (!pulseUtility.isNotDefined(strokeColor)) {
    circleProgress.setAttribute('stroke', strokeColor);
  }
  circleProgress.setAttribute('stroke-width', strokeWidth);
  // 2*pi*R = 2*3.14*radius = 100
  if (widthPercent >= 0.0) { // Keep '<=' and not '<' only to allow progress
    circleProgress.setAttribute('stroke-dasharray',
      (circumference * widthPercent).toFixed(0) + ' ' +
      (circumference * (1.0 - widthPercent)).toFixed(0)); //'85 15');
    circleProgress.setAttribute('stroke-dashoffset',
      (circumference * (1.0 - beginPercent)).toFixed(0));
    // was 25 = on top (+100 to avoid <0)
    // now = 0 = on the right - need rotate (+100 to avoid <0)
  }

  return circleProgress;
}

/**
 * Create SVG line on a donut
 *
 * @memberof module:pulseSvg
 *
 * @function createLineOnDonut
 * 
 * @param {Integer} xMiddle
 * @param {Integer} yMiddle
 * @param {Integer} middleRadius
 * @param {Integer} externRadius
 * @param {Double} percentPosition
 * @param {string} color
 * @param {string} strokeWidth
 
 * @return {Object} SVG
 */
exports.createLineOnDonut = function (xMiddle, yMiddle, middleRadius, externRadius,
  percentPosition, color, width, dasharray) {
  let angle = (percentPosition - 0.25) * 2 * Math.PI;
  let aLine = document.createElementNS(_svgNS, 'line');
  aLine.setAttribute('x1', xMiddle + middleRadius * Math.cos(angle));
  aLine.setAttribute('y1', yMiddle + middleRadius * Math.sin(angle));
  aLine.setAttribute('x2', xMiddle + externRadius * Math.cos(angle));
  aLine.setAttribute('y2', yMiddle + externRadius * Math.sin(angle));
  aLine.setAttribute('stroke-width', width);
  if (!pulseUtility.isNotDefined(color)) {
    aLine.setAttribute('stroke', color);
  }
  if (!pulseUtility.isNotDefined(dasharray)) {
    aLine.setAttribute('stroke-dasharray', dasharray.toFixed(0));
  }
  return aLine;
}

/**
 * Create SVG style to rotate a dash circle.
 * Rotation from beginSeconds until 60sec (if increase) else until 0 sec
 *
 * @memberof module:pulseSvg
 *
 * @function createStyleDashCircleRotation
 * 
 * @param {jQuery} caller x-tag component
 * @param {Number} circleRadius radius
 * @param {Number} beginSeconds between 0 and 60
 */
exports.initFixedDashCircleDasharray =
  function (caller, circleRadius, beginSeconds) {
    let fullPathLength = 2 * Math.PI * circleRadius; // circumference
    caller.setAttribute('stroke-dasharray',
      (fullPathLength * beginSeconds / 60).toFixed(0) + ' '
      + (fullPathLength * (60 - beginSeconds) / 60).toFixed(0));
  }

/**
 * Create SVG style to rotate a dash circle.
 * Rotation from beginSeconds until 60sec (if increase) else until 0 sec
 *
 * @memberof module:pulseSvg
 *
 * @function createStyleDashCircleRotation
 * 
 * @param {jQuery} caller x-tag component
 * @param {string} keyFrameName
 * @param {Number} circleRadius radius
 * @param {Boolean} increase rotation direction
 * @param {Number} beginSeconds between 0 and 60
 */
exports.createStyleDashCircleRotation =
  function (caller, keyFrameName, beginSeconds, circleRadius, increase) {
    let fullPathLength = 2 * Math.PI * circleRadius; // circumference
    let style = document.createElement('style');
    style.type = 'text/css';
    /* RR - if one day we need dots to the left for negative values
    let keyFrames = '\
    @keyframes '+ keyFrameName +' {\
      from {\
        stroke-dasharray: '+fullPathLength*beginSeconds/60+' '
                           +fullPathLength*(60-beginSeconds)/60+';\
        stroke-dashoffset: '+fullPathLength*(1.25-(60-beginSeconds)/60)+';\
      }\
      to {\
        stroke-dasharray: '+fullPathLength+' 0;\
        stroke-dashoffset: '+fullPathLength*1.25+';\
      }\
    }';*/
    let keyFrames;
    if (increase) {
      keyFrames = '\
    @keyframes '+ keyFrameName + ' {\
      from {\
        stroke-dasharray: '+ (fullPathLength * beginSeconds / 60).toFixed(0) + ' '
        + (fullPathLength * (60 - beginSeconds) / 60).toFixed(0) + ';\
      }\
      to {\
        stroke-dasharray: '+ fullPathLength.toFixed(0) + ' 0;\
      }\
    }';
    }
    else {
      keyFrames = '\
    @keyframes '+ keyFrameName + ' {\
      from {\
        stroke-dasharray: '+ (fullPathLength * beginSeconds / 60).toFixed(0) + ' '
        + (fullPathLength * (60 - beginSeconds) / 60).toFixed(0) + ';\
      }\
      to {\
        stroke-dasharray: 0 ' + fullPathLength.toFixed(0) + ';\
      }\
    }';
    }
    style.innerHTML = keyFrames; //.replace(/A_DYNAMIC_VALUE/g, "180deg");
    caller.appendChild(style);
  }

/**
 * Create SVG style to animate a segment.
 * Rotation from fromWidth to toWidth
 *
 * @memberof module:pulseSvg
 *
 * @function createStyleForSegmentOnDonut
 * 
 * @param {jQuery} caller x-tag component
 * @param {string} keyFrameName
 * @param {Number} circleRadius radius in %
 * @param {Number} fromWidth segment width in %
 * @param {Number} toWidth segment width after animation
 * 
 * @return {Object} SVG style
 */
exports.createStyleForSegmentOnDonut =
  function (caller, keyFrameName, circleRadius, fromWidth, toWidth) {
    let circumference = 2 * Math.PI * circleRadius; // = full path length
    let style = document.createElement('style');
    style.type = 'text/css';

    let keyFrames = '\
  @keyframes '+ keyFrameName + ' {\
    from {\
      stroke-dasharray: '+ (circumference * fromWidth).toFixed(0) + ' '
      + (circumference * (1.0 - fromWidth)).toFixed(0) + ';\
    }\
    to {\
      stroke-dasharray: '+ (circumference * toWidth).toFixed(0) + ' '
      + (circumference * (1.0 - toWidth)).toFixed(0) + ';\
    }\
  }';
    style.innerHTML = keyFrames;
    caller.appendChild(style);

    //console.log('CycleProgressPie(' + this.element.getAttribute('machine-id')
    // + '): append style - keyFrames = ' + keyFrames);

    return style;
  }

/**
 * Create SVG style to animate a segment.
 * Rotation until to toWidth (from must be defined in main svg)
 *
 * @memberof module:pulseSvg
 *
 * @function createStyleForEndAnimationOnDonut
 * 
 * @param {jQuery} caller x-tag component
 * @param {string} keyFrameName
 * @param {Number} circleRadius radius in %
 * @param {Number} toWidth segment width after animation in %
 */
/*exports.createStyleForEndAnimationOnDonut =
function (caller, keyFrameName, circleRadius, toWidth) {
  let circumference = 2 * Math.PI * circleRadius; // = full path length
  let style = document.createElement('style');
  style.type = 'text/css';

  let keyFrames = '\
@keyframes '+ keyFrameName + ' {\
  to {\
    stroke-dasharray: '+ (circumference * toWidth).toFixed(0) + ' '
    + (circumference * (1.0 - toWidth)).toFixed(0) + ';\
  }\
}';
  style.innerHTML = keyFrames;
  caller.appendChild(style);
}*/

/**
 * Create SVG style to animate a segment.
 * Rotation of BEGIN from fromWidth to toWidth
 *
 * @memberof module:pulseSvg
 *
 * @function createStyleForSegmentOnDonutMovingBegin
 * 
 * @param {jQuery} caller x-tag component
 * @param {string} keyFrameName
 * @param {Number} circleRadius radius
 * @param {Number} fromBegin segment begin
 * @param {Number} toBegin segment begin after animation
 * @param {Number} fromWidth segment width
 * @param {Number} toWidth segment width after animation
 */
exports.createStyleForSegmentOnDonutMovingBegin =
  function (caller, keyFrameName, circleRadius, fromBegin, toBegin, fromWidth, toWidth) {
    let circumference = 2 * Math.PI * circleRadius; // = full path length
    let style = document.createElement('style');
    style.type = 'text/css';

    let keyFrames = '\
  @keyframes '+ keyFrameName + ' {\
    from {\
      stroke-dasharray: '+ (circumference * fromWidth).toFixed(0) + ' '
      + (circumference * (1.0 - fromWidth)).toFixed(0) + ';\
      stroke-dashoffset: '+ (circumference * (1.0 - fromBegin)).toFixed(0) + ';\
    }\
    to {\
      stroke-dasharray: '+ (circumference * toWidth).toFixed(0) + ' '
      + (circumference * (1.0 - toWidth)).toFixed(0) + ';\
      stroke-dashoffset: '+ (circumference * (1.0 - toBegin)).toFixed(0) + ';\
    }\
  }';
    style.innerHTML = keyFrames;
    caller.appendChild(style);
  }

/**
 * Create SVG segment on gauge
 *
 * @memberof module:pulseSvg
 *
 * @function createSegmentOnGauge
 * 
 * @param {Integer} xMiddle
 * @param {Integer} yMiddle
 * @param {Integer} radius
 * @param {string} fillColor
 * @param {string} mainClass  class to set
 * @param {string} strokeColor
 * @param {Integer} strokeWidth
 * @param {Double} beginPercent percent for the begin of the segment
 * @param {Double} widthPercent percent for the segment length
 
 * @return {Object} SVG
 */
exports.createSegmentOnGauge = function (xMiddle, yMiddle, radius, fillColor, mainClass,
  strokeColor, strokeWidth, beginPercent, widthPercent) {
  //let magicCircleRadius = 15.91549430918954;
  let circumference = 2 * Math.PI * radius; // == 100 if magicCircleRadius is used

  let circleProgress = document.createElementNS(_svgNS, 'circle');
  circleProgress.setAttribute('cx', xMiddle);
  circleProgress.setAttribute('cy', yMiddle);
  circleProgress.setAttribute('r', radius);
  if (!pulseUtility.isNotDefined(fillColor)) {
    circleProgress.setAttribute('fill', fillColor);
  }
  circleProgress.setAttribute('class', mainClass);
  if (!pulseUtility.isNotDefined(strokeColor)) {
    circleProgress.setAttribute('stroke', strokeColor);
  }
  circleProgress.setAttribute('stroke-width', strokeWidth);
  // 2*pi*R = 2*3.14*radius = 100
  $(circleProgress).css('stroke-dasharray',
    (circumference * (widthPercent / 2.0)).toFixed(0) + ' ' +
    (circumference * (1.0 - (widthPercent / 2.0))).toFixed(0)); //'85 15');
  $(circleProgress).css('stroke-dashoffset',
    (circumference * (1.25 - (beginPercent / 2.0 + 0.75))).toFixed(0));
  return circleProgress;
}

/**
 * Create SVG line on a gauge
 *
 * @memberof module:pulseSvg
 *
 * @function createLineOnGauge
 * 
 * @param {Integer} xMiddle
 * @param {Integer} yMiddle
 * @param {Integer} middleRadius
 * @param {Integer} externRadius
 * @param {Double} percentPosition
 * @param {string} strokeColor
 * @param {string} strokeWidth
 
 * @return {Object} SVG
 */
exports.createLineOnGauge = function (xMiddle, yMiddle, middleRadius, externRadius,
  percentPosition, strokeColor, width, dasharray) {
  let angle = (percentPosition / 2 + 0.5) * 2 * Math.PI;
  let aLine = document.createElementNS(_svgNS, 'line');
  aLine.setAttribute('x1', xMiddle + middleRadius * Math.cos(angle));
  aLine.setAttribute('y1', yMiddle + middleRadius * Math.sin(angle));
  aLine.setAttribute('x2', xMiddle + externRadius * Math.cos(angle));
  aLine.setAttribute('y2', yMiddle + externRadius * Math.sin(angle));
  aLine.setAttribute('stroke-width', width);
  if (!pulseUtility.isNotDefined(strokeColor)) {
    aLine.setAttribute('stroke', strokeColor);
  }
  if (!pulseUtility.isNotDefined(dasharray)) {
    aLine.setAttribute('stroke-dasharray', dasharray.toFixed(0));
  }
  return aLine;
}

/**
 * Inline the svg specified as background-image of a div
 * The original background-image is removed and the inline svg is inserted in the element
 * @param {string} selector 
 * @param {function} callbackAfterInline (can be undefined)
 */
var inlineBackgroundSvg = exports.inlineBackgroundSvg = function (selector, callbackAfterInline) {
  // Check if SVG is supported and selector is valid
  if (typeof SVGRect == 'undefined' || $(selector) == null)
    return;

  // Try to change the image as long as the css is not loaded yet
  function checkBackgroundImage (selector) {
    let backgroundImage = $(selector).css('background-image');
    if (backgroundImage == null || !backgroundImage.includes('url')) {
      window.setTimeout(checkBackgroundImage, 100, selector);
    }
    else {
      // Request the SVG file
      let src = backgroundImage.replace('url(', '').replace(')', '').replace(/\"/gi, '');

      // Append the SVG to the target
      var ajaxReq = new XMLHttpRequest();
      ajaxReq.onload = function (e, d) {
        //if (ajaxReq.statusText == 'OK') { statusText == '' using https / Ford
        if (ajaxReq.status == 200) {
          $(selector).css('background-image', 'none');
          $(selector).append(ajaxReq.responseText);

          // Callback
          if (pulseUtility.isFunction(callbackAfterInline)) {
            callbackAfterInline();
          }
        }
      };
      ajaxReq.open('GET', src, true);
      ajaxReq.send();
    }
  }
  checkBackgroundImage(selector);
};

/* Get a class to know the icon FOR machine modes
*/
exports.getMachineModeClass = function (machineModeCategory) {
  let classBegin = 'pulse-mode-category-';
  switch (machineModeCategory) {
    case 1:
      return classBegin + 'inactive';
    case 2:
      return classBegin + 'active';
    case 3:
      return classBegin + 'error';
    case 4:
      return classBegin + 'unknown';
    case 5:
      return classBegin + 'eco';
    case 6:
      return classBegin + 'stopping';
    default:
      return null;
  }
}

/* Create an icon for colored legend. 
 * The color can be defined by a color OR class.
*/
exports.createColoredLegend = function (color, mainClass) {
  return createRect(0, 0, 15, 15, color, mainClass);
}

/**
 * Display maintenance screen
 *
 * @memberof module:pulseSvg
 *
 * @function showPulseMaintenance
 * 
 */
exports.showPulseMaintenance = function () {
  // if already exists, do nothing
  {
    let pulseMaintenance = $('body').find('.pulse-maintenance');
    if (pulseMaintenance.length != 0) {
      $(pulseMaintenance[0]).show();
      return;
    }
  }

  // else CREATE
  let text = $('<div></div>').addClass('pulse-maintenance-text')
    .html('The system is currently under maintenance');
  let svg = $('<div></div>').addClass('pulse-maintenance-svg');
  let centeredDiv = $('<div></div>').addClass('pulse-maintenance-centered-div')
    .append(svg).append(text);

  let shadow = $('<div></div>').addClass('pulse-maintenance-shadow');
  let box = $('<div></div>').addClass('pulse-maintenance-display-box')
    .append(centeredDiv);

  let pulseMaintenance = $('<div></div>').addClass('pulse-maintenance')
    .append(shadow).append(box);

  //pulseSvg.
  inlineBackgroundSvg(svg);

  // Create a div Maintenance
  $('body').append(pulseMaintenance);
}
/*
.pulse-maintenance-svg{
.create_svg('pulse-maintenance', @color_text, @color_text)
}
 */
/**
 * HIDE maintenance screen
 *
 * @memberof module:pulseSvg
 *
 * @function hidePulseMaintenance
 * 
 */
exports.hidePulseMaintenance = function () {
  //$('body').find('.pulse-maintenance').remove();
  $('body').find('.pulse-maintenance').hide();
}


/**
 * remove BAR chart created using next method
 *
 * @memberof module:pulseSvg
 *
 * @function createBarChart
 * @param {DOM} parent
 * @param {string} svgClass
 */
var removeBarChart = exports.removeBarChart = function (parent, svgClass) {
  if (parent == undefined) {
    return;
  }
  // clear svg
  let svg = $(parent).find('.' + svgClass);
  d3.selectAll(svg.toArray()).remove();
  $(parent).remove('.' + svgClass);
}

/**
 * create BAR chart
 *
 * @memberof module:pulseSvg
 *
 * @function createBarChart
 * @param {DOM} parent
 * @param {string} svgClass
 * @param {Object} chartData
 * @param {Object} options
 * 
 *  chartData = [
 *    {
 *      xDisplay: 'Rust',
 *       value: 78.9 -> value to display
 *       boundedValue -> value to draw in case of fixed height
 *    },{ ...}];
 *
 *  options = { // Each can be undefined
 *    minValue : number
 *    maxValue : number
 *    mainTitle : string
 *    leftTitle : string
 *    bottomTitle : string
 *    sourceText : string
 *    drawHorizontalGrid : bool, default false
 *    drawVerticalGrid : bool, default false
 *  }
 */
exports.createBarChart = function (parent, svgClass, chartData, options) {
  if (parent == undefined) {
    return;
  }
  removeBarChart(parent, svgClass);

  let minValue = 0;
  let maxValue = 0;

  // Automatic bounds
  for (let i = 0; i < chartData.length; i++) {
    let value = chartData[i].value;
    // Min / Max
    if (minValue > value) {
      minValue = value;
    }
    if (maxValue < value) {
      maxValue = value;
    }
  }
  // Cut display if needed
  if (!pulseUtility.isNotDefined(options.minValue)
    && '' != options.minValue) {
    if (minValue < options.minValue) {
      minValue = options.minValue;
    }
  }
  if (!pulseUtility.isNotDefined(options.maxValue)
    && '' != options.maxValue) {
    if (maxValue > options.maxValue) {
      maxValue = options.maxValue;
    }
  }

  // Minimum (was Default) size
  var chartMargin = 60;
  var chartWidth = 300;  //1000;
  var chartHeight = 240; //600;

  // Adapt size to parent's
  let pWidth = parent.width();
  let pHeight = parent.height();
  if (chartWidth < pWidth) {
    chartWidth = pWidth;
  }
  if (chartHeight < pHeight) {
    chartHeight = pHeight;
  }

  // Remove margin
  chartWidth -= 2 * chartMargin;
  chartHeight -= 2 * chartMargin;

  // Create BAR chart
  let svg = d3.selectAll(parent.toArray()).append('svg')
    .attr('class', svgClass);
  svg.attr('viewBox', '0 0 '
    + (chartWidth + 2 * chartMargin) // viewBoxWidth 
    + ' '
    + (chartHeight + 2 * chartMargin)); // + viewBoxHeight

  // Move to manage margin
  let chart = svg.append('g')
    .attr('transform', `translate(${chartMargin}, ${chartMargin})`);

  // Y Scale according to displayed values (linear scale)
  // X and Y Scale - scaleBand is in d3-scale, it splits range into bands
  let xScale = d3.scaleBand()
    .range([0, chartWidth])
    .domain(chartData.map((s) => s.xDisplay))
    .padding(0.2); // or 0.4
  let yScale = d3.scaleLinear()
    .range([chartHeight, 0])
    .domain([minValue, maxValue]);

  // Draw X axis
  // Ticks at bottom
  chart.append('g')
    .attr('class', 'x-bottom-axis')
    .attr('transform', `translate(0, ${chartHeight})`)
    .call(d3.axisBottom(xScale));

  // Draw X axis // Line at 0 (can be bottom, but not always)
  svg.append('g')
    .attr('class', 'x-0-axis')
    .append('line')
    .attr('y1', chartMargin + yScale(0))
    .attr('y2', chartMargin + yScale(0))
    .attr('x1', chartMargin)
    .attr('x2', chartMargin + chartWidth);

  // Left Y axis
  chart.append('g')
    .call(d3.axisLeft(yScale));

  if (options.drawVerticalGrid) {
    // vertical grid lines
    let makeXLines = () => d3.axisBottom()
      .scale(xScale)

    // vertical grid lines
    chart.append('g')
      .attr('class', 'grid')
      .attr('transform', `translate(0, ${chartHeight})`)
      .call(makeXLines()
        .tickSize(-chartHeight, 0, 0)
        .tickFormat('')
      )
  }

  if (options.drawHorizontalGrid) {
    // Horizontal grid lines
    let makeYLines = () => d3.axisLeft()
      .scale(yScale);

    chart.append('g')
      .attr('class', 'grid')
      .call(makeYLines()
        .tickSize(-chartWidth, 0, 0)
        .tickFormat('')
      );
  }

  // Draw data
  let barGroups = chart.selectAll()
    .data(chartData)
    .enter()
    .append('g');


  // g.value replaced with boundedValue
  barGroups
    .append('rect')
    //.attr('class', 'bar')
    .attr('class', (g) => (g.boundedValue > 0) ? 'bar positive' : 'bar negative')
    .attr('x', (g) => xScale(g.xDisplay))
    // can be .attr(’x’, (actual, index, array) => xScale(actual.value))
    .attr('y', (g) => (g.boundedValue > 0) ? yScale(g.boundedValue) : yScale(0))
    .attr('height', (g) => Math.abs(yScale(g.boundedValue) - yScale(0)))
    .attr('width', xScale.bandwidth());
  /*.on('mouseenter', function (actual, i) {
})
.on('mouseleave', function () {
}) */

  // Add text with value in bar - Not ready yet - Could be added
  /*barGroups
    .append('text')
    .attr('class', 'value')
    .attr('x', (a) => xScale(a.xDisplay) + xScale.bandwidth() / 2)
    .attr('y', (a) => yScale(a.value) + 30)
    .attr('text-anchor', 'middle')
    .text((a) => `${a.value}%`);*/

  if (!pulseUtility.isNotDefined(options.leftTitle)) {
    // Add left legend
    svg
      .append('text')
      .attr('class', 'label')
      .attr('x', -(chartHeight / 2) - chartMargin)
      .attr('y', chartMargin / 2.4)
      .attr('transform', 'rotate(-90)')
      .attr('text-anchor', 'middle')
      .text('Left legend');
  }
  if (!pulseUtility.isNotDefined(options.bottomTitle)) {
    // Add bottom legend
    svg.append('text')
      .attr('class', 'label')
      .attr('x', chartWidth / 2 + chartMargin)
      .attr('y', chartHeight + chartMargin * 1.7)
      .attr('text-anchor', 'middle')
      .text('Bottom legend');
  }
  if (!pulseUtility.isNotDefined(options.mainTitle)) {
    // Add main title
    svg.append('text')
      .attr('class', 'title')
      .attr('x', chartWidth / 2 + chartMargin)
      .attr('y', 40)
      .attr('text-anchor', 'middle')
      .text('Main title');
  }
  if (!pulseUtility.isNotDefined(options.sourceText)) {
    // Add bottom source text
    svg.append('text')
      .attr('class', 'source')
      .attr('x', chartWidth - chartMargin / 2)
      .attr('y', chartHeight + chartMargin * 1.7)
      .attr('text-anchor', 'start')
      .text('Source: ' + options.sourceText);
  }
  // Make it interactive
  /*svgElement
    .on('mouseenter', function (actual, i) {
      d3.select(this).attr(‘opacity’, 0.5)
    })
    .on('mouseleave’, function (actual, i) {
    d3.select(this).attr(‘opacity’, 1)
});
d3.mouse -> to get coordinate, show tooltip ...
*/

}

/**
 * create missing data (red dot)
 *
 * @memberof module:pulseSvg
 *
 * @function createMissingdata
 * @param {DOM} parent
 */
exports.createMissingdata = function (parent) {
  // To add in version 12
  let radius = 4;

  //createBase
  let svg = document.createElementNS(_svgNS, 'svg');
  svg.setAttribute('width', 2 * radius);
  svg.setAttribute('height', 2 * radius);
  svg.setAttribute('class', 'pulse-missing-data');
  svg.setAttribute('viewBox', '0 0 ' + 2 * radius + ' ' + 2 * radius);
  // Append
  $(parent).append(svg);

  // createCircle / could be an image
  let circle = document.createElementNS(_svgNS, 'circle');

  // = function (xMiddle, yMiddle, radius, fillColor, mainClass, strokeColor, strokeWidth) {
  circle.setAttribute('cx', radius);
  circle.setAttribute('cy', radius);
  circle.setAttribute('r', radius);
  circle.setAttribute('class', 'pulse-missing-data-circle');
  //circle.setAttribute('fill', 'red');
  //circle.setAttribute('stroke-width', '1px');      
  //circle.setAttribute('stroke', strokeColor);

  svg.appendChild(circle);
}
},{"pulseUtility":"pulseUtility"}],"pulseUtility":[function(require,module,exports){
// Copyright (C) 2009-2023 Lemoine Automation Technologies
//
// SPDX-License-Identifier: Apache-2.0

/**
 * @file Various tool functions.
 */

/**
* @module pulseUtility
* @requires pulseRange
*/
var pulseRange = require('pulseRange');

/** Get integer from string
 * 
 * @memberof module:pulseUtility
 * @function string2int
 */
exports.string2int = function string2int (str) {
  return (str == 'null' || str == null || str == '') ? -1 : parseInt(str);
};

/** Get contrated color from rgb OR #hex
 * 
 * @memberof module:pulseUtility
 * @function getContrastColor
 */
exports.getContrastColor = function getContrastColor (hexcolor) {
  if (hexcolor.indexOf('rgb') >= 0) { // rgb format
    let nums = /(.*?)rgb\((\d+),\s*(\d+),\s*(\d+)\)/i.exec(hexcolor);
    let r = parseInt(nums[2], 10).toString(16);
    let g = parseInt(nums[3], 10).toString(16);
    let b = parseInt(nums[4], 10).toString(16);

    let yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return (yiq >= 128) ? '#121212' : '#ededed'; //'black' : 'white';
  }
  else if (hexcolor.charAt(0) == '#') {
    let r = parseInt(hexcolor.substr(1, 2), 16);
    let g = parseInt(hexcolor.substr(3, 2), 16);
    let b = parseInt(hexcolor.substr(5, 2), 16);

    let yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return (yiq >= 128) ? '#121212' : '#ededed'; //'black' : 'white';
  }
  else {
    return '#7F7F7F'; // Grey... best than nothing
  }
}

/** Check whether given object represents decimal or float value.
 * Replace jquery obsolete method.
 *
 * @memberof module:pulseUtility
 * @function isNumeric
 * 
 * @param {Object} value  object to check
 * @return {Boolean}
 */
exports.isNumeric = function (value) {
  if ((parseFloat(value) == parseInt(value)) && !isNaN(value)) {
    return true;
  }
  else {
    return Number(value) === value && value % 1 !== 0;
  }
}

/** Check whether given object represents decimal value or not
 *
 * @memberof module:pulseUtility
 * @function isFloat
 * 
 * @param {Object} value  object to check
 * @return {Boolean}
 */
exports.isFloat = function (value) {
  return Number(value) === value && value % 1 !== 0;
}

/** Check whether given object represents integer value or not
 *
 * @memberof module:pulseUtility
 * @function isInteger
 * 
 * @param {Object} value  object to check
 * @return {Boolean}
 */
var isInteger = exports.isInteger = function (value) {
  if ((parseFloat(value) == parseInt(value)) && !isNaN(value)) {
    return true;
  }
  else {
    return false;
  }
}

/** Check whether given object represents a boolean value or not
 *
 * @memberof module:pulseUtility
 * @function isBoolean
 *
 * @param {Object} value an object
 * @return {Boolean}
 */
exports.isBoolean = function (value) {
  if (((typeof value) === 'boolean') || ((value instanceof Boolean) == true) || (value === 'true') || (value === 'false')) {
    return true;
  }
  else {
    return false;
  }
}


/** Check whether given object represents function value or not
 *
 * @memberof module:pulseUtility
 * @function isFunction
 *
 * @param {Object} value an object
 * @return {Boolean}
 */
exports.isFunction = function (value) {
  return (value !== undefined) && (value !== null) && (Object.prototype.toString.call(value) == '[object Function]');
}

/**
 * return a string with leading 0 - for date FORMAT on 2 digits
 **/
exports.leadingZero = function (value) {
  if (value < 10) {
    return '0' + value.toString();
  }
  return value.toString();
}

/**
 * return an array of string used to gradate widget with time labels
 *
 * @memberof module:pulseUtility
 *
 * @function getTimeMarkers
 *
 * @param {Number} datetime represents seconds since 1 Jan 1970 in UTC format
 * @param {string} format time format used to format label to display
 * @return {Array}
 */
exports.getTimeMarkers = function (datetime, format) {
  let utc = moment.utc(datetime);
  let m0 = utc.local();
  let m4 = m0.clone().add(1, 'd');
  let m1 = m0.clone().add(6, 'h');
  let m2 = m0.clone().add(12, 'h');
  let m3 = m0.clone().add(18, 'h');
  let array = new Array();
  array[0] = m0.format(format);
  array[1] = m1.format(format);
  array[2] = m2.format(format);
  array[3] = m3.format(format);
  array[4] = m4.format(format);
  return array;
};

/**
 * Converts integer that represents date to a moment object in local mode.
 *
 * @memberof module:pulseUtility
 *
 * @function getMomentLocalFromUtcDate
 *
 * @param {Number} datetime Integer that represents date in utc
 * @return {Moment}
 */
exports.getMomentLocalFromUtcDate = function (datetime) {
  let moment_utc = moment(datetime).utc();
  let m = moment_utc.clone();
  return m.local();
}

/** Convert a date for the REPORT
 * 
 * It just converts the date to a LOCAL string for calling reports
 * (used in toollifemachine bar)
 * 
 * If date is not defined or if it is an empty string, an empty string is returned
 * 
 * @memberof module:pulseUtility
 * @function convertDateForReport
 *
 * @param {string|Date} date - date to send to the web service
 * @return {string} Date string for any REPORT
 */
//var convertDateForReport =
exports.convertDateForReport = function (date) {
  if (isNotDefined(date)) {
    return '';
  }
  let pad2 = function (number) {
    return ('0' + number).slice(-2);
  }
  let pad3 = function (number) {
    return ('00' + number).slice(-3);
  }

  let d = new Date(date);
  let dateString =
    d.getFullYear() + '-' +
    pad2(d.getMonth()) + '-' +
    pad2(d.getDate()) + '+' +
    pad2(d.getHours()) + '%3A' +
    pad2(d.getMinutes()) + '%3A' +
    pad2(d.getSeconds()) + '.' +
    pad3(d.getMilliseconds());

  return dateString;
}

/** Convert a date for the web service
 * 
 * It just converts the date to an ISO string
 * 
 * If date is not defined or if it is an empty string, an empty string is returned
 * 
 * @memberof module:pulseUtility
 * @function convertDateForWebService
 *
 * @param {string|Date} date - date to send to the web service
 * @return {string} Date string for the web service
 */
var convertDateForWebService = exports.convertDateForWebService = function (date) {
  if (isNotDefined(date)) {
    return '';
  }

  let d;
  if (typeof date == 'string') {
    if (date.trim() == '') {
      return '';
    }
    d = new Date(date);
  }
  else {
    d = date;
  }
  return d.toISOString();
}

/** Convert a day for the web service
 * 
 * It just converts the day to an ISO string day (not date ! )
 * 
 * If day is not defined or if it is an empty string, an empty string is returned
 * 
 * @memberof module:pulseUtility
 * @function convertDateForWebService
 *
 * @param {string|Date} date - date to send to the web service ou day string
 * @return {string} Day string for the web service = YYYY-MM-DD
 */
//var convertDayForWebService = 
exports.convertDayForWebService = function (day) {
  if (isNotDefined(day)) {
    return '';
  }

  let d;
  if (typeof day == 'string') {
    if (day.trim() == '') {
      return '';
    }
    return day;
  }
  else {
    d = new Date(day);
    return d.toISOString();
  }
}

/**
 * Callback to convert an object to a string
 * 
 * @callback toStringCallback
 * @param {Object} - Object to convert
 * @return {string} Result
 */

/** Convert a range for the web service
 * 
 * @memberof module:pulseUtility
 * @function convertRangeForWebService
 *
 * @param {Range} range - Range to convert
 * @param {toStringCallback} boundToString - Callback to convert a bound to a string
 * @return {string} string for the web service
 */
var _convertRangeForWebService //= exports.convertRangeForWebService 
  = function (range, boundToString) {
    return range.toString(boundToString);
  }

/** Convert a range for the web service
 * 
 * @memberof module:pulseUtility
 * @function convertStringRangeForWebService
 *
 * @param {StringRange} stringrange - Range of strings to convert
 * @return {string} string for the web service
 */
exports.convertStringRangeForWebService = function (stringrange) {
  return _convertRangeForWebService(stringrange, a => a);
}

/** Convert a date range for the web service
 * 
 * @memberof module:pulseUtility
 * @function convertDateRangeForWebService
 *
 * @param {DateRange} daterange - Date range to convert
 * @return {string} string for the web service
 */
var convertDateRangeForWebService = exports.convertDateRangeForWebService = function (daterange) {
  return _convertRangeForWebService(daterange, a => convertDateForWebService(a));
}

/**
 * Create range for webservice containing only 1 single date
 *
 * @memberof module:pulseUtility
 * @function createSingleRangeForWebService
 *
 * @param {string|Date} datetime String that represents the datetime in ISO 8601 format or Date
 * @return {string} range String that represents the range in ISO 8601 format: [2016-05-01T00:03:00,2016-05-01T00:03:00]
 */
exports.createSingleRangeForWebService = function (datetime) {
  let r = pulseRange.createDateRange(datetime, datetime, '[]');
  return convertDateRangeForWebService(r);
}

/**
 * Create range for webservice
 * 
 * The default inclusivity for a DateRange is:
 * [) if begin and end are not the same
 * else []
 *
 * @memberof module:pulseUtility
 *
 * @function createDateRangeForWebService
 *
 * @param {string|Date} begin - Date or string that represents the range in ISO 8601 format.
 * @param {string|Date} end - Date or string that represents the range in ISO 8601 format.
 * @return {string} range String that represents the range in ISO 8601 format: [2016-05-01T00:03:00,)
 */
exports.createDateRangeForWebService = function (begin, end) {
  let r = pulseRange.createDateRangeDefaultInclusivity(begin, end);
  return convertDateRangeForWebService(r);
}

/**
 * Display a day
 *
 * @memberof module:pulseUtility
 *
 * @function getDisplayDay
 *
 * @param {string} begin String that represents the begin day in ISO 8601 format
 * @return {string} String that represents the day
 */
exports.getDisplayDay = function (day) {
  if ((!day) || (day == 'null')) {
    return '';
  }
  if (day.length > 10) { // TMP code to make getRangeAround < 2016-03-07 work    
    let _day = convertDateToMoment(day); // day + midnight
    _day = _day.add(12, 'hours'); // To be sure to display the right day
    return _day.format('ll');
  }
  else {
    let _day = moment(day, 'YYYY-MM-DD');
    return _day.format('ll');
  }
}

/** Display a single date
 * 
 * @memberof module:pulseUtility
 *
 * @function displayDate
 *
 * @param {date} date - date, with bounds of type native javascript Date or ISO 8601 format
 * @param {boolean} seconds - true == show seconds
 * @return {string} String that represents the date
 */
var displayDate = exports.displayDate = function (date, seconds) {
  let m = convertDateToMoment(date);
  if (seconds) {
    return (m.format('ll') // Month name, day of month, year, time
      + ', ' + m.format('LTS'));  // HH:MM:Sec
  }
  else {
    return m.format('lll'); // Month name, day of month, year, time
  }
}

/** Display a date range
 * 
 * @memberof module:pulseUtility
 *
 * @function displayDateRange
 *
 * @param {Range} range - date range, with bounds of type native javascript Date or ISO 8601 format
 * @param {boolean} seconds - true == show seconds
 * @return {string} String that represents the date range
 */
//var displayDateRange = 
exports.displayDateRange = function (range, seconds) {
  let r = pulseRange.convertToDateRange(range);
  if (r.isEmpty()) {
    return '';
  }
  else { // not empty
    if (r.lower == null) {
      console.warn('displayDateRange: lower is not defined');
      if (r.upper == null) {
        return '-oo - +oo';
      }
      else {
        return '-oo - ' + displayDate(r.upper, seconds);
      }
    }
    else { // range.lower not null
      if (r.upper == null) {
        let retVal = displayDate(r.lower, seconds)
          + ' - '
          + 'In progress'; // TODO: i18n
        return retVal;
      }
      else { // lower and upper are defined
        if (r.lower.getTime() == r.upper.getTime()) {
          return displayDate(r.lower, seconds);
        }
        else {
          let begin_local = convertDateToMoment(r.lower);
          let end_local = convertDateToMoment(r.upper);
          if (begin_local.isSame(end_local, 'day')) {
            let retVal = begin_local.format('ll')
              + '   '
              + (seconds ? begin_local.format('LTS') : begin_local.format('LT'))
              + ' - '
              + (seconds ? end_local.format('LTS') : end_local.format('LT'));
            return retVal;
          }
          else {
            let retVal = displayDate(r.lower, seconds)
              + ' - '
              + displayDate(r.upper, seconds);
            return retVal;
          }
        }
      }
    }
  }
}

/** Append a date range display with separated begin and end
 * 
 * @memberof module:pulseUtility
 *
 * @function  appendDateRangeDisplay
 * output classes : range-begin / range-end / range-begin-end / range-begin-end-date
 *
 * @param {DOMElement} parent - where span will be added
 * @param {Range} range - date range, with bounds of type native javascript Date or ISO 8601 format
 * @param {boolean} seconds - true == show seconds
 * @return {boolean} true in case of success
 */
//var appendDateRangeDisplay = 
exports.appendDateRangeDisplay = function (parent, range, seconds) {

  let appendRange = function (parent, beginString, endString) {
    let spanBegin = $('<span></span>').addClass('range-begin').html(beginString);
    let spanSep = $('<span></span>').addClass('range-separator').html(' - ');
    let spanEnd = $('<span></span>').addClass('range-end').html(endString);
    $(parent).append(spanBegin).append(spanSep).append(spanEnd);
  }

  let r = pulseRange.convertToDateRange(range);
  if (r.isEmpty()) {
    return false;
  }
  else { // not empty
    if (r.lower == null) {
      console.warn('displayDateRange: lower is not defined');
      if (r.upper == null) {
        appendRange(parent, '-oo', '+oo');
        return true;
      }
      else {
        appendRange(parent, '-oo', displayDate(r.upper, seconds));
        return true;
      }
    }
    else { // range.lower not null
      if (r.upper == null) {
        appendRange(parent, displayDate(r.lower, seconds), 'In progress'); // TODO: i18n
        return true;
      }
      else { // lower and upper are defined
        if (r.lower.getTime() == r.upper.getTime()) {
          // see appendRange - but unique !
          let spanRange = $('<span></span>').addClass('range-begin-end')
            .html(displayDate(r.lower, seconds));
          $(parent).append(spanRange);
          return true;
        }
        else {
          let begin_local = convertDateToMoment(r.lower);
          let end_local = convertDateToMoment(r.upper);
          if (begin_local.isSame(end_local, 'day')) {
            // see appendRange - but unique date - 2 times
            let spanDate = $('<span></span>').addClass('range-begin-end-date')
              .html(begin_local.format('ll'));
            let spanSepDT = $('<span></span>').addClass('range-separator-date-time').html(' ');
            let spanBegin = $('<span></span>').addClass('range-begin')
              .html((seconds ? begin_local.format('LTS') : begin_local.format('LT')));
            let spanSep = $('<span></span>').addClass('range-separator').html(' - ');
            let spanEnd = $('<span></span>').addClass('range-end')
              .html((seconds ? end_local.format('LTS') : end_local.format('LT')));
            $(parent).append(spanDate).append(spanSepDT)
              .append(spanBegin).append(spanSep).append(spanEnd);
            return true;
          }
          else {
            appendRange(parent, displayDate(r.lower, seconds), displayDate(r.upper, seconds));
            return true;
          }
        }
      }
    }
  }
}

/**
 * Convert a number of seconds to a string
 *
 * @memberof module:pulseUtility
 *
 * @function toHHMMSS
 *
 * @param {integer} nbSeconds number of seconds (duration)
 * @return string value
 */

exports.secondsToHHMMSS = function (nbSeconds) {
  let sec_num = parseInt(nbSeconds, 10); // don't forget the second param
  let hours = Math.floor(sec_num / 3600);
  let minutes = Math.floor((sec_num - (hours * 3600)) / 60);
  let seconds = sec_num - (hours * 3600) - (minutes * 60);

  if (hours >= 24) { hours = hours % 24; }

  if (hours < 10) { hours = '0' + hours; }
  if (minutes < 10) { minutes = '0' + minutes; }
  if (seconds < 10) { seconds = '0' + seconds; }
  return hours + ':' + minutes + ':' + seconds;
}

/**
 * Convert a duration string to a number of seconds
 *
 * @memberof module:pulseUtility
 *
 * @function HHMMSStoSeconds
 *
 * @param {string} HHHMMSS 
 * @return {integer} number of seconds (duration)
 */

exports.HHMMSStoSeconds = function (str) {
  let retVal = 0;
  let multiplier = 1;

  let splitedStr = str.split(':');
  for (let i = splitedStr.length - 1; i >= 0; i--) {
    retVal += multiplier * parseInt(splitedStr[i], 10);
    multiplier *= 60;
  }
  return retVal;
}

/**
 * search a parameter in an url and return its value
 *
 * @memberof module:pulseUtility
 *
 * @function getURLParameter
 *
 * @param {string} pageURL url address
 * @param {string} param parameter name whose name must be search in url
 * @return parameter value or null if given url do not contain this parameter name
 */
//var getURLParameter = 
exports.getURLParameter = function (pageURL, param) {
  let sQuery = pageURL.split('?')[1];
  if (sQuery) {
    let sURLVariables = sQuery.split('&');
    for (let i = 0; i < sURLVariables.length; i++) {
      let sParameterName = sURLVariables[i].split('=');
      if (sParameterName[0] == param) {
        return sParameterName[1];
      }
    }
  }
  return null;
}

/**
 * change or add a parameter in an url and return new url
 *
 * @memberof module:pulseUtility
 *
 * @function changeURLParameter
 *
 * @param {string} pageURL url address
 * @param {string} param parameter name whose name must be search in url
 * @param {string} value NEW parameter value to add in url
 * @return new URL
 */
exports.changeURLParameter = function (pageURL, param, value) {
  let sQuery = pageURL.split('?');
  if ((sQuery.length > 1) && (sQuery[1])) {
    let found = false;
    let sURLVariables = sQuery[1].split('&');
    for (let i = 0; i < sURLVariables.length; i++) {
      let sParameterName = sURLVariables[i].split('=');
      if (sParameterName[0] == param) {
        found = true;
        sParameterName[1] = value;
      }
      sURLVariables[i] = sParameterName.join('=');
    }
    if (!found) {
      sURLVariables[sURLVariables.length] = param + '=' + value;
    }
    sQuery[1] = sURLVariables.join('&');
  }
  else {
    sQuery[1] = param + '=' + value;
  }
  pageURL = sQuery.join('?');
  return pageURL;
}

/**
 * search a parameter in an url and return its values
 *
 * @memberof module:pulseUtility
 *
 * @function getURLParameterValues
 *
 * @param {string} pageURL url address
 * @param {string} param parameter name whose name must be search in url
 * @return an array with values of given parameters. if given url do not contain this parameter name, it returns an empty array 
 */
var getURLParameterValues = exports.getURLParameterValues = function (pageURL, param) {
  let splittedString = pageURL.split('?');
  let values = new Array();
  if (splittedString.length <= 1) {
    return values; // If no '?' exist
  }
  let sQuery = splittedString[1];
  if (sQuery) {
    let sURLVariables = sQuery.split('&');
    for (let i = 0; i < sURLVariables.length; i++) {
      let sParameterName = sURLVariables[i].split('=');
      if (sParameterName[0] == param) {
        values[values.length] = sParameterName[1];
      }
    }
  }
  let distinctValues = new Array();
  for (let j = 0; j < values.length; j++) {
    if (distinctValues.indexOf(values[j]) < 0) {
      distinctValues[distinctValues.length] = values[j];
    }
  }
  return distinctValues;
}

/**
 * Remove a parameter in an url and return new url
 *
 * @memberof module:pulseUtility
 *
 * @function removeURLParameter
 *
 * @param {string} pageURL url address
 * @param {string} param parameter name whose name must be search and removed in url
 * @return {string} an url
 */
//var removeURLParameter = 
exports.removeURLParameter = function (pageURL, param) {
  let splittedString = pageURL.split('?');
  if (splittedString.length == 0) {
    return '';
  }
  let newURL = splittedString[0];
  if (splittedString.length > 1) {
    let sQuery = splittedString[1];
    if (sQuery) {
      let sURLVariables = sQuery.split('&');
      for (let i = 0; i < sURLVariables.length; i++) {
        if (sURLVariables[i].length > 0) { // To avoid '?&' if any
          let sParameterName = sURLVariables[i].split('=');
          if (sParameterName[0] != param) {
            if (newURL.includes('?'))
              newURL += '&';
            else
              newURL += '?'
            newURL += sURLVariables[i];
          }
        }
      }
    }
  }
  return newURL;
}


/**
 * Remove a parameter in an url and return new url
 *
 * @memberof module:pulseUtility
 *
 * @function removeURLParameterContaining
 *
 * @param {string} pageURL url address
 * @param {string} param parameter whose name must be search and removed in url (*param*)
 * @return {string} an url
 */
//var removeURLParameterContaining = 
exports.removeURLParameterContaining = function (pageURL, param) {
  let splittedString = pageURL.split('?');
  if (splittedString.length == 0) {
    return '';
  }
  let newURL = splittedString[0];
  if (splittedString.length > 1) {
    let sQuery = splittedString[1];
    if (sQuery) {
      let sURLVariables = sQuery.split('&');
      for (let i = 0; i < sURLVariables.length; i++) {
        let sParameterName = sURLVariables[i].split('=');
        if (!sParameterName[0].includes(param)) {
          if (newURL.includes('?'))
            newURL += '&';
          else
            newURL += '?'
          newURL += sURLVariables[i];
        }
      }
    }
  }
  return newURL;
}

/**
 * search machine id parameter in an url and return its values.
 * This function look for all possible identifier of machine id parameter in url.
 *
 * @memberof module:pulseUtility
 *
 * @function getMachineIdParameterValue
 *
 * @param {string} pageURL url address
 * @return an array with values of machine id parameter values. if given url do not contain this parameter name, it returns an empty array 
 */
exports.getMachineIdParameterValue = function (pageURL) {
  let identifiers = ['machine', 'machine-ids'];
  let values = new Array();
  for (let id = 0; id < identifiers.length; id++) {
    values = getURLParameterValues(pageURL, identifiers[id]);
    if (values.length > 0) {
      return values;
    }
  }
  return values;
}

/**
 * search machine id parameter in an url and return its values.
 * This function look for all possible identifier of machine id parameter in url.
 *
 * @memberof module:pulseUtility
 *
 * @function getALLMachineIdParameterValue - TODO : REMOVE
 *
 * @param {string} pageURL url address
 * @return an array with values of machine id parameter values. if given url do not contain this parameter name, it returns an empty array 
 */
exports.getALLMachineIdParameterValue = function (pageURL) {
  let identifiers = ['machine', 'machine-ids', 'selected-machine-id', 'machinetop'];
  let values = new Array();
  for (let i = 0; i < identifiers.length; i++) {
    let tmpvalues = new Array();
    tmpvalues = getURLParameterValues(pageURL, identifiers[i]);
    values = values.concat(tmpvalues);
  }
  return values;
}

/**
 * search ALL parameters excluding machine id parameter in an url and return a string.
 *
 * @memberof module:pulseUtility
 *
 * @function getParametersExceptingMachineId
 *
 * @param {string} pageURL url address
 * @return an array with values of machine id parameter values. if given url do not contain this parameter name, it returns an empty array 
 */
exports.getParametersExceptingMachineId = function (pageURL) {
  let retString = '';
  let splittedString = pageURL.split('?');
  if (splittedString.length == 0) {
    console.log('pulseUtility.getParametersExceptingMachineId : no URL found !');
  }
  if (splittedString.length > 1) {
    let sQuery = splittedString[1];
    if (sQuery) {
      let sURLVariables = sQuery.split('&');
      for (let i = 0; i < sURLVariables.length; i++) {
        let sParameterName = sURLVariables[i].split('=');
        if ((sParameterName[0] != 'machine') &&
          (sParameterName[0] != 'machine-ids') &&
          (sParameterName[0] != 'selected-machine-id') &&
          (sParameterName[0] != 'machinetop')) {
          retString += '&' + sParameterName[0] + '=' + sParameterName[1];
        }
      }
    }
  }
  return retString;
}

/**
 * check if a value is not defined means that it is null or undefined
 *
 * @memberof module:pulseUtility
 *
 * @function isNotDefined
 *
 * @param value value to check
 * @return {Boolean}
 */
var isNotDefined = exports.isNotDefined = function (value) {
  if ((value === null) || (value == 'null') ||
    (value === undefined) || (typeof value == 'undefined')) {
    return true;
  }
  else {
    return false;
  }
}

/**
 *Get a duration in seconds and returns a text that represents
 *this duration in days, hours, minutes and seconds
 *
 * @memberof module:pulseUtility
 *
 * @function getTextDuration
 *
 * @param {Number} duration in seconds
 * @return {string}
 */
exports.getTextDuration = function (duration) {
  let seconds = parseInt(duration, 10);

  let days = Math.floor(seconds / (24 * 60 * 60));
  let hours = Math.floor((seconds - (days * 24 * 60 * 60)) / (60 * 60));
  let mins = Math.floor((seconds - (days * 24 * 60 * 60) - (hours * 60 * 60)) / 60);
  let secs = seconds - (days * 24 * 60 * 60) - (hours * 60 * 60) - (mins * 60);

  let text = '';

  if (days > 0) {
    text += days + ' d  ';
  }

  if (hours > 0) {
    text += hours + ' h ';
  }

  if (mins > 0) {
    text += mins + ' min ';
  }

  if ((days == 0) && (hours == 0) && (mins <= 5)) {
    if (secs > 0) {
      text += secs + ' sec ';
    }
  }
  return text;
}

/**
 * Get a duration in seconds and returns a text that represents
 *this duration in hours, minutes
 *
 * @memberof module:pulseUtility
 *
 * @function getHoursMinutesDuration
 *
 * @param {Number} duration in seconds
 * @return {string} 0:00 formatted text
 */
exports.getHoursMinutesDuration = function (duration) {
  let seconds = parseInt(duration, 10);

  let hours = Math.floor(seconds / (60 * 60));
  let mins = Math.floor((seconds - (hours * 60 * 60)) / 60);
  //let secs = seconds - (days *24 * 60 * 60) - (hours * 60 * 60) - (mins * 60);

  let text = hours + ':' + (mins > 9 ? '' + mins : '0' + mins);
  return text;
}

/**
 * Get a duration in seconds and returns remaining seconds after
 * text displayed with getHoursMinutesDuration
 *
 * @memberof module:pulseUtility
 *
 * @function getRemainingSecondsDuration
 *
 * @param {Number} duration in seconds
 * @return {Number}
 */
exports.getRemainingSecondsDuration = function (duration) {
  let seconds = parseInt(duration, 10);

  //let hours = Math.floor(seconds / (60 * 60));
  let mins = Math.floor(seconds / 60);
  let secs = seconds - (mins * 60);

  return secs;
}


/**
 * Convert datetime in iso string format to a moment object
 *
 * @memberof module:pulseUtility
 *
 * @function convertDateToMoment
 *
 * @param {string|Date} date Date or string that represends a date/time
 * @return {Moment} a moment object if parameter has right format otherwise null
 */
var convertDateToMoment = exports.convertDateToMoment = function (date) {
  let d;
  if (typeof lower == 'string') {
    d = new Date(date);
  }
  else {
    d = date;
  }
  let m = moment(d);
  if (!m.isValid()) {
    return null;
  }
  else {
    return m;
  }
}


/**
 * Convert moment object to datetime in iso string format 'YYYY-MM-DDTHH:mm:ssZ'
 * 
 *
 * @memberof module:pulseUtility
 *
 * @function convertMomentToDateTimeString
 *
 * @param {Moment} m dateTimeString representation of datetime with following format: 'YYYY-MM-DDTHH:mm:ssZ' / 'YYYY-MM-DDTHH:mm:ss.SSSZ'
 *
 * @return {string} a string object 
 */
exports.convertMomentToDateTimeString = function convertMomentToDateTimeString (m) {
  if (m.isValid()) {
    return m.toISOString();
  }
  else {
    return null;
  }
}
/** Default date format */
exports.defaultDateFormat = 'L';
/** Default time format*/
exports.defaultTimeFormat = 'LT';
/** Default time format with second*/
exports.defaultTimeFormatWithSecond = 'LTS';


/**
 * Function used to get default locate from navigator
 * 
 * @memberof module:pulseUtility
 * @function getDefaultLocale
 * 
 * @return Default locale
 */
exports.getDefaultLocale = function () {
  let locale = window.navigator.languages || [window.navigator.language || window.navigator.userLanguage];
  return locale[0];
}

/**
 * return true if time format for default locale use meridian(AM/PM)
 *  otherwise false
 * 
 * @memberof module:pulseUtility
 * @function is24HoursFormat
 *
 * @return {boolean} true if in 24 hours format
 */
exports.is24HoursFormat = function () {
  let longDateFormat = moment.localeData().longDateFormat('LTS').toUpperCase();
  if ((longDateFormat.indexOf('A') >= 0) || (longDateFormat.indexOf('P') >= 0)) {
    return false;
  }
  return true;
}


/**
 * Function used to return jQuery element with given tag name and attribute
 *
 * @memberof module:pulseUtility
 * @function createjQueryElementWithAttribute
 *
 * @param {string} tagName tag name
 *
 * @param {Object} an object in key-value form which represents attribute of element to create
 *
 * @return {DOMElement} a jQuery element 
 */
var createjQueryElementWithAttribute = exports.createjQueryElementWithAttribute = function (tagName, attributes) {
  let elt = null;

  if (window.navigator.userAgent.includes('Chrome')) {
    let str = '<' + tagName + ' ';
    for (let key in attributes) {
      let value = attributes[key];
      if (value) {
        str = str + key + "='" + value + "' ";
      }
    }
    str = str + '></' + tagName + '>';
    elt = $(str);
  }
  else {
    let domElt = document.createElement(tagName);
    for (let key in attributes) {
      let value = attributes[key];
      if (value) {
        domElt.setAttribute(key, value);
      }
    }
    elt = $(domElt);
  }

  /*else 
    let str = '<' + tagName + ' ';
    for (let key in attributes) {
      let value = attributes[key];
      if (value) {
        str = str + key + "='" + value + "' ";
      }
    }
    str = str + '></' + tagName + '>';
    elt = $(str);
  */

  /*if( !(elt.get(0) instanceof PulseComponent) ){
    console.log("Created element is not an instance of PulseComponent");
  }*/

  return elt;

  /*
  let domElt = document.createElement(tagName);
  for (let key in attributes) {
    let value = attributes[key];
    if(value){
      domElt.setAttribute(key, value);
    }
  }
  return $(domElt);*/
}

/**
 * Check if xTagName exists in body. If not, create it - useful to call addModification
 *
 * @memberof module:pulseUtility
 * @function getOrCreateSingleton
 *
 * @param {string} xTagName
 * @param {json} attributes (can be undefined)
 * @return {xTag} true searched element
 */
exports.getOrCreateSingleton = function (xTagName, attributes) {
  let attr = (null == attributes) ? {} : attributes;
  let tag = $('body').find(xTagName);
  if (tag.length == 0) {
    tag = createjQueryElementWithAttribute(xTagName, attr);
    $('body').append(tag);
  }
  if (tag.length > 0) {
    return tag[0];
  }
  return null; // Hope never !
}

/**
 * Check if DOM element has class
 *
 * @memberof module:pulseUtility
 * @function hasClass
 *
 * @param {DOMElement} element
 * @param {string} className
 * @return {Boolean} true if given element has class name, false otherwise
 */
exports.hasClass = function (element, className) {
  return element.className && new RegExp('(^|\\s)' + className + '(\\s|$)').test(element.className);
}

/** Create a cookie
 * 
 * @memberof module:pulseUtility
 * @function createCookie
 *
 */
var createCookie = exports.createCookie = function (name, value, days) {
  let expires;
  if (days && days > 0) {
    let date = new Date();
    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
    expires = '; expires=' + date.toGMTString();
  }
  else {
    expires = ''; // == Expire = end of session
  }
  document.cookie = name + '=' + value + expires + '; path=/';
  // ';path=/' == global path to share with reporting
}

/** Read a cookie
 * 
 * @memberof module:pulseUtility
 * @function readCookie
 */
var readCookie =
  exports.readCookie = function (name) {
    let nameEQ = name + '=';
    let ca = document.cookie.split(';');
    for (let i = 0; i < ca.length; i++) {
      let c = ca[i];
      while (c.charAt(0) == ' ') c = c.substring(1, c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
    }
    return null;
  }

var eraseCookie =
  exports.eraseCookie = function (name) {
    // erase cookie is done in x-checkcurrenttime.js
    createCookie(name, '', -1);
  }

/** change page in url
 * 
 * @memberof module:pulseUtility
 * @function changePageName
 */
exports.changePageName = function (href, newPageName) {
  //let href = window.location.href; // ".../pagename.html?xxx"
  let splitUrl = href.split('?');
  if (splitUrl.length < 1) {
    return href; // No change
  }
  let posPt = splitUrl[0].lastIndexOf('.');
  let posSlash = splitUrl[0].lastIndexOf('/');
  if ((posPt != -1) && (posSlash != -1)) { // Found both
    let crtPage = (splitUrl[0].slice(posSlash + 1, posPt));
    splitUrl[0] = splitUrl[0].replace(crtPage, newPageName);

    return splitUrl.join('?');
  }
  return href;
}

/** get current page
 * 
 * @memberof module:pulseUtility
 * @function getCurrentPageName
 */
exports.getCurrentPageName = function () {
  let href = window.location.href; // ".../pagename.html?xxx"
  let splitUrl = href.split('?');
  if (splitUrl.length < 1) {
    return '';
  }
  let posPt = splitUrl[0].lastIndexOf('.');
  let posSlash = splitUrl[0].lastIndexOf('/');
  if ((posPt != -1) && (posSlash != -1)) { // Found both
    return (splitUrl[0].slice(posSlash + 1, posPt));
  }
  return '';
}

/**
 * Create a convenient object that can store and retrieve data attached to divisions having specific ids
 * Used (at least) by customdialog and machine selection
 */
exports.createDataManager = function (idName) {
  return {
    _idName: idName,
    _id: 0,
    _data: [],
    createNewId: function () {
      this._data[this._id] = {};
      return this._id++;
    },
    initializeIdAttribute: function (selector, id) {
      $(selector).attr(this._idName, id);
    },
    getId: function (selector) {
      if ($(selector).length) {
        let attribute = $(selector).attr(this._idName);
        if (attribute == undefined || attribute === false) {
          // Search in parents
          let parent = $(selector)[0].closest('[' + this._idName + ']');
          if ($(parent).length > 0) {
            attribute = $(parent).attr(this._idName);
          }
          if (attribute == undefined || attribute === false) {
            throw "Selector '" + selector + "' has no attribute '" + this._idName + "'";
          }
        }
        let id = parseInt(attribute);
        if (id < 0 || id >= this._id) {
          throw 'Bad ' + this._idName + " '" + id + "' for selector '" + selector + "'";
        }
        return id;
      }
      else {
        throw "Selector '" + selector + "'doesn't exist";
      }
    },
    get: function (id) {
      return this._data[id];
    },
    set: function (id, field, data) {
      this._data[id][field] = data;
    },
    reset: function (id) {
      this._data[id] = null;
    }
  };
}

exports.addToolTip = function (element, text) {
  // Set the tooltip text
  // Replace $(element).attr('title', text); EVEN in a part of svg

  $(element).attr('tooltip', text);

  // Trigger the display
  $(element).hover(function () {
    // Hover over code
    let tooltip = $(this).attr('tooltip');
    if (tooltip != null && tooltip.length > 0) {
      $(this).removeAttr('title'); // In case it is defined by error to avoid 2 tooltips
      if ($('.mastertooltip').length == 0 && !$(this).hasClass('tooltip_disabled')) {
        $('<p class="mastertooltip"></p>')
          .text(tooltip)
          .appendTo('body')
          .fadeIn(400);
      }
    }
  }, function () {
    // Hover out code
    $('.mastertooltip').remove();
  }).mousemove(function (e) {
    // X
    if (e.pageX <= $(window).width() / 2) {
      let mousex = e.pageX + 20; // Get X coordinates
      $('.mastertooltip').css({ left: mousex });
    }
    else {
      let mousex = e.pageX - 20
        - $('.mastertooltip').width(); // Get X coordinates
      $('.mastertooltip').css({ left: mousex });
    }

    // Y
    if (e.pageY + $('.mastertooltip').height() + 10
      <= $(window).height()) {
      let mousey = e.pageY + 10; // Get Y coordinates
      $('.mastertooltip').css({ top: mousey });
    }
    else {
      // To be tested !!!
      let mousey = e.pageY - 10 - $('.mastertooltip').height(); // Get Y coordinates
      $('.mastertooltip').css({ top: mousey });
    }
  });
}

exports.removeToolTip = function (element) {
  $(element).removeAttr('title');
  $('.mastertooltip').remove();
}

exports.cloneWithNewMachineId = function (boxtocloneid, newMachineid) {
  // Copy
  let copy = $('#' + boxtocloneid).clone(true);
  // remove boxtocloneid
  $(copy).removeAttr('id');
  // Remove all classes linked to cloned component is done in clearDynamicStateContent
  // == (init state)

  // Set machineid (after all 'remove' to be ready to display)
  $(copy).attr('machine-id', newMachineid);
  $(copy).find('*').attr('machine-id', newMachineid);

  return copy;
}

exports.cloneWithNewGroupId = function (boxtocloneid, newGroupid, isMachine) {
  // Copy
  let copy = $('#' + boxtocloneid).clone(true);
  // remove boxtocloneid
  $(copy).removeAttr('id');
  // Remove all classes linked to cloned component is done in clearDynamicStateContent
  // == (init state)

  // Set group-id (after all 'remove' to be ready to display)
  $(copy).attr('group', newGroupid); // not group-id to be able to use getConfigOrAttribute
  $(copy).find('*').attr('group', newGroupid);
  if (isMachine == true) {
    $(copy).find('*').attr('machine-id', newGroupid);
  }
  return copy;
}

exports.getTextChangeContext = function (self) {
  let textchangecontext = '';
  if (self.element.hasAttribute('textchange-context')) {
    textchangecontext = self.element.getAttribute('textchange-context');
    if (textchangecontext.search('machine-id') != -1) {
      textchangecontext += '_' + self.element.getAttribute('machine-id');
    }
    if (textchangecontext.search('group') != -1) {
      textchangecontext += '_' + self.element.getAttribute('group');
    }
  }
  return textchangecontext;
}

},{"pulseRange":"pulseRange"}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWJyYXJpZXMvcHVsc2UuZXhwb3J0cy5saWdodC5qcyIsImxpYnJhcmllcy9wdWxzZWNvbXBvbmVudC5qcyIsImxpYnJhcmllcy9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9lbnRpdGllcy9saWIvbWFwcy9lbnRpdGllcy5qc29uIiwibm9kZV9tb2R1bGVzL2xpbmtpZnktaXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbGlua2lmeS1pdC9saWIvcmUuanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9lbnRpdGllcy5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL2h0bWxfYmxvY2tzLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9jb21tb24vaHRtbF9yZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9oZWxwZXJzL3BhcnNlX2xpbmtfZGVzdGluYXRpb24uanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbC5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9wYXJzZV9saW5rX3RpdGxlLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2Jsb2NrLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2lubGluZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9jb21tb25tYXJrLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wcmVzZXRzL2RlZmF1bHQuanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3ByZXNldHMvemVyby5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcmVuZGVyZXIuanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVyLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9ibG9ja3F1b3RlLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9jb2RlLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9mZW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaGVhZGluZy5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHIuanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2h0bWxfYmxvY2suanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2xoZWFkaW5nLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saXN0LmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9wYXJhZ3JhcGguanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svc3RhdGVfYmxvY2suanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL3RhYmxlLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2Jsb2NrLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2lubGluZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9saW5raWZ5LmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL25vcm1hbGl6ZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMuanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvc3RhdGVfY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2F1dG9saW5rLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFja3RpY2tzLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycy5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VtcGhhc2lzLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvZXNjYXBlLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUuanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9pbWFnZS5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2xpbmsuanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQuanMiLCJub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS90ZXh0X2NvbGxhcHNlLmpzIiwibm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi90b2tlbi5qcyIsIm5vZGVfbW9kdWxlcy9tZHVybC9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvbWR1cmwvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL21kdXJsL2Zvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9tZHVybC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZHVybC9wYXJzZS5qcyIsIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4LmpzIiwibm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2YvcmVnZXguanMiLCJub2RlX21vZHVsZXMvdWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4LmpzIiwibm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qcyIsIm5vZGVfbW9kdWxlcy91Yy5taWNyby9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleC5qcyIsIngtY2hlY2tjb25maWd1cGRhdGUveC1jaGVja2NvbmZpZ3VwZGF0ZS5qcyIsIngtY2hlY2tjdXJyZW50dGltZS94LWNoZWNrY3VycmVudHRpbWUuanMiLCJ4LWNoZWNrbG9naW4veC1jaGVja2xvZ2luLmpzIiwieC1jaGVja3BhdGgveC1jaGVja3BhdGguanMiLCJ4LWNoZWNrc2VydmVyYWNjZXNzL3gtY2hlY2tzZXJ2ZXJhY2Nlc3MuanMiLCJ4LWNoZWNrdmVyc2lvbi94LWNoZWNrdmVyc2lvbi5qcyIsIngtY2xvY2sveC1jbG9jay5qcyIsIngtZGF0ZXBpY2tlci94LWRhdGVwaWNrZXIuanMiLCJ4LWRhdGV0aW1lcGlja2VyL3gtZGF0ZXRpbWVwaWNrZXIuanMiLCJ4LWZyZWV0ZXh0L3gtZnJlZXRleHQuanMiLCJ4LWdyb3VwYXJyYXkveC1ncm91cGFycmF5LmpzIiwieC1sb2dpbmRpc3BsYXkveC1sb2dpbmRpc3BsYXkuanMiLCJ4LW1hY2hpbmVkaXNwbGF5L3gtbWFjaGluZWRpc3BsYXkuanMiLCJ4LW1hY2hpbmVzZWxlY3Rpb24veC1tYWNoaW5lc2VsZWN0aW9uLmpzIiwieC1tYXJrZG93bnRleHQveC1tYXJrZG93bnRleHQuanMiLCJ4LW1lc3NhZ2UveC1tZXNzYWdlLmpzIiwieC1tb2RpZmljYXRpb25tYW5hZ2VyL3gtbW9kaWZpY2F0aW9ubWFuYWdlci5qcyIsIngtcmVwb3J0ZGF0ZXRpbWUveC1yZXBvcnRkYXRldGltZS5qcyIsIkV2ZW50QnVzLmpzIiwicHVsc2UuY29uZmlnLmpzIiwibGlicmFyaWVzL3B1bHNlLmN1c3RvbWRpYWxvZy5qcyIsInB1bHNlLmxvZ2luLmpzIiwicHVsc2UucmFuZ2UuanMiLCJwdWxzZS5zZXJ2aWNlLmpzIiwicHVsc2Uuc3ZnLmpzIiwicHVsc2UudXRpbGl0eS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDLzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2g5QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1bkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1c0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNTlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDamtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZpQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4vLyBjb25maWcgLSBjb21tb24gZm9yIGFsbCBhcHBzXG4vL3JlcXVpcmUoJ2NvbmZpZ19wdWxzZWNvbXBvbmVudF9kZWZhdWx0LmpzJyk7IC0gbm90IHBvc3NpYmxlIEhFUkUgIVxuXG4vLyB0cmFuc2xhdGlvbiAtIGNvbW1vbiBcbi8vcmVxdWlyZSgndHJhbnNsYXRpb25fcHVsc2Vjb21wb25lbnRfZGVmYXVsdC5qcycpOyAtIG5vdCBwb3NzaWJsZSBIRVJFICFcblxuLy8gRm9yIGZhc3QgdGVzdHNcbnJlcXVpcmUoJ3gtY2xvY2sveC1jbG9jaycpO1xuXG4vLyBjaGVjayBhbmQgbG9naW5cbnJlcXVpcmUoJ3gtY2hlY2tjdXJyZW50dGltZS94LWNoZWNrY3VycmVudHRpbWUnKTtcbnJlcXVpcmUoJ3gtY2hlY2twYXRoL3gtY2hlY2twYXRoJyk7XG5yZXF1aXJlKCd4LWNoZWNrdmVyc2lvbi94LWNoZWNrdmVyc2lvbicpO1xucmVxdWlyZSgneC1jaGVja2NvbmZpZ3VwZGF0ZS94LWNoZWNrY29uZmlndXBkYXRlJyk7XG5yZXF1aXJlKCd4LWNoZWNrbG9naW4veC1jaGVja2xvZ2luJyk7XG5yZXF1aXJlKCd4LWxvZ2luZGlzcGxheS94LWxvZ2luZGlzcGxheScpO1xucmVxdWlyZSgneC1jaGVja3NlcnZlcmFjY2Vzcy94LWNoZWNrc2VydmVyYWNjZXNzJyk7XG5cbnJlcXVpcmUoJ3gtbWFya2Rvd250ZXh0L3gtbWFya2Rvd250ZXh0Jyk7XG5yZXF1aXJlKCd4LW1lc3NhZ2UveC1tZXNzYWdlJyk7XG5yZXF1aXJlKCd4LW1vZGlmaWNhdGlvbm1hbmFnZXIveC1tb2RpZmljYXRpb25tYW5hZ2VyJyk7IC8vIElzIGl0IHVzZWZ1bCA/IC0tIFJSIDIwMjNcblxucmVxdWlyZSgneC1tYWNoaW5lc2VsZWN0aW9uL3gtbWFjaGluZXNlbGVjdGlvbicpO1xuLyogbWFjaGluZXNlbGVjdGlvbiBhbHJlYWR5IGluY2x1ZGVzIDpcbnJlcXVpcmUoJ3gtZ3JvdXBhcnJheS94LWdyb3VwYXJyYXknKTtcbnJlcXVpcmUoJ3gtbWFjaGluZWRpc3BsYXkveC1tYWNoaW5lZGlzcGxheScpO1xucmVxdWlyZSgneC1mcmVldGV4dC94LWZyZWV0ZXh0Jyk7XG4qL1xuXG4vLyBEaXNwbGF5c1xucmVxdWlyZSgneC1yZXBvcnRkYXRldGltZS94LXJlcG9ydGRhdGV0aW1lJyk7XG5yZXF1aXJlKCd4LWRhdGV0aW1lcGlja2VyL3gtZGF0ZXRpbWVwaWNrZXInKTtcbnJlcXVpcmUoJ3gtZGF0ZXBpY2tlci94LWRhdGVwaWNrZXInKTtcbiIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG1vZHVsZSBwdWxzZUNvbXBvbmVudFxuICogQHJlcXVpcmVzIG1vZHVsZTpwdWxzZUNvbmZpZ1xuICogQHJlcXVpcmVzIG1vZHVsZTpwdWxzZVNlcnZpY2VcbiAqIEByZXF1aXJlcyBtb2R1bGU6ZXZlbnRCdXNcbiAqL1xudmFyIHB1bHNlQ29uZmlnID0gcmVxdWlyZSgncHVsc2VDb25maWcnKTtcbnZhciBwdWxzZUxvZ2luID0gcmVxdWlyZSgncHVsc2VMb2dpbicpO1xudmFyIHB1bHNlU2VydmljZSA9IHJlcXVpcmUoJ3B1bHNlU2VydmljZScpO1xudmFyIHB1bHNlVXRpbGl0eSA9IHJlcXVpcmUoJ3B1bHNlVXRpbGl0eScpO1xudmFyIHN0YXRlID0gcmVxdWlyZSgnc3RhdGUnKTtcbnZhciBldmVudEJ1cyA9IHJlcXVpcmUoJ2V2ZW50QnVzJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYW55IHdlYiBjb21wb25lbnQgXG4gKi9cbmNsYXNzIFdlYkNvbXBvbmVudCB7IC8vIGV4dGVuZHMgSFRNTEVsZW1lbnQgaWYgY3VzdG9tRWxlbWVudHMuZGVmaW5lIGlzIHVzZWQgZGlyZWN0bHlcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgLSBET00gZWxlbWVudCBcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICB0aGlzLm1ldGhvZHMgPSB7fTtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NvY2lhdGVkIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIGdldCBlbGVtZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCAgd2hlbiB0aGUgY3VzdG9tIGVsZW1lbnQgaXMgY29ubmVjdGVkIHRvIHRoZSBET00gZG9jdW1lbnRcbiAgICovXG4gIGNvbm5lY3RlZENhbGxiYWNrICgpIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBjdXN0b20gZWxlbWVudCBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgRE9NIGRvY3VtZW50XG4gICAqIHJldHVybiB0cnVlIGlmIERPTSBzaG91bGQgYmUgZGVzdHJveWVkIGFuZCB3aWxsIG5ldmVyIGNvbWUgYWdhaW5cbiAgICovXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBhdHRyaWJ1dGUgY2hhbmdlZCBjYWxsYmFjayBmb3IgeC10YWcgb3IgY3VzdG9tIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHIgLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFZhbCAtIE9sZCBhdHRyaWJ1dGUgdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1ZhbCAtIE5ldyBhdHRyaWJ1dGUgdmFsdWVcbiAgICovXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayAoYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIHN1cGVyLWNsYXNzIG9mIGFsbCBQdWxzZSBjb21wb25lbnRzLlxuICogXG4gKiBAZXh0ZW5kcyBtb2R1bGU6cHVsc2VDb21wb25lbnR+V2ViQ29tcG9uZW50XG4gKi9cbmNsYXNzIFB1bHNlQ29tcG9uZW50IGV4dGVuZHMgV2ViQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBzZWxmID0gc3VwZXIoLi4uYXJncyk7XG4gICAgc2VsZi5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgc2VsZi5fY29ubmVjdGVkT25jZSA9IGZhbHNlO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSBhc3NvY2lhdGVkIGN1c3RvbSBlbGVtZW50IGNvbm5lY3RlZCB0byB0aGUgRE9NIGRvY3VtZW50ID9cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gY29ubmVjdGVkXG4gICAqL1xuICBnZXQgY29ubmVjdGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhcyB0aGUgYXNzb2NpYXRlZCBjdXN0b20gZWxlbWVudCBiZWVuIGNvbm5lY3RlZCBvbmNlIHRvIHRoZSBET00gZG9jdW1lbnQgP1xuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBjb25uZWN0ZWRPbmNlXG4gICAqL1xuICBnZXQgY29ubmVjdGVkT25jZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZE9uY2U7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgIHdoZW4gdGhlIGN1c3RvbSBlbGVtZW50IGlzIGNvbm5lY3RlZCB0byB0aGUgRE9NIGRvY3VtZW50XG4gICAqL1xuICBjb25uZWN0ZWRDYWxsYmFjayAoKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2Nvbm5lY3RlZE9uY2UgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGN1c3RvbSBlbGVtZW50IGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBET00gZG9jdW1lbnRcbiAgICogcmV0dXJuIHRydWUgaWYgRE9NIHNob3VsZCBiZSBkZXN0cm95ZWQgYW5kIHdpbGwgbmV2ZXIgY29tZSBhZ2FpblxuICAgKi9cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2sgKCkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHJldHVybiBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIGF0dHJpYnV0ZSBjaGFuZ2VkIGNhbGxiYWNrIGZvciB4LXRhZyBvciBjdXN0b20gZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ciAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkVmFsIC0gT2xkIGF0dHJpYnV0ZSB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsIC0gTmV3IGF0dHJpYnV0ZSB2YWx1ZVxuICAgKi9cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIChhdHRyLCBvbGRWYWwsIG5ld1ZhbCkge1xuICAgIGlmICh0aGlzLl9jb25uZWN0ZWRPbmNlKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRXaGVuQ29ubmVjdGVkT25jZShhdHRyLCBvbGRWYWwsIG5ld1ZhbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGF0dHJpYnV0ZSBjaGFuZ2VkIGNhbGxiYWNrIGZvciB4LXRhZyBvciBjdXN0b20gZWxlbWVudCBvbmx5IHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYWxyZWFkeSBiZWVuIGNvbm5lY3RlZCBvbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbGRWYWwgLSBPbGQgYXR0cmlidXRlIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdWYWwgLSBOZXcgYXR0cmlidXRlIHZhbHVlXG4gICAqL1xuICBhdHRyaWJ1dGVDaGFuZ2VkV2hlbkNvbm5lY3RlZE9uY2UgKGF0dHIsIG9sZFZhbCwgbmV3VmFsKSB7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHNvbWUgaW5mb3JtYXRpb24gb24gdGhlIHdlYiBjb21wb25lbnQgaW5zdGFuY2UsIGluY2x1ZGluZyBpdHMgaWQgYW5kIGNsYXNzIGlmIHRoZXkgYXJlIGRlZmluZWRcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBJbmZvcyBvbiBjb21wb25lbnQgaW5zdGFuY2VcbiAgICovXG4gIGdldEluZm8gKCkge1xuICAgIGxldCBzdHIgPSAndW5kZWZpbmVkJztcbiAgICBpZiAodGhpcy5lbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIHN0ciA9IHRoaXMuZWxlbWVudC50YWdOYW1lO1xuICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2lkJykpIHtcbiAgICAgICAgc3RyICs9IGBbaWQ6JHt0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpfV1gO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NsYXNzJykpIHtcbiAgICAgICAgc3RyICs9IGBbY2xhc3M6JHt0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpfV1gO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0ciArPSAnIHRoaXMuZWxlbWVudDsnXG4gICAgICBjb25zb2xlLndhcm4oJ2NvbXBvbmVudC5nZXRJbmZvOiB0aGlzLmVsZW1lbnQgaXMgbnVsbC4gU2hvdWxkIG5ldmVyIGhhcHBlbi4gRXhjZXB0ZWQgd2hlbiByZW1vdmVkJyk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgY3NzIGNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjc3NDbGFzcyAtIE5hbWUgb2YgdGhlIENTUyBjbGFzc1xuICAgKi9cbiAgYWRkQ2xhc3MgKGNzc0NsYXNzKSB7XG4gICAgJCh0aGlzLmVsZW1lbnQpLmFkZENsYXNzKGNzc0NsYXNzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjc3MgY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNzc0NsYXNzIC0gTmFtZSBvZiB0aGUgQ1NTIGNsYXNzXG4gICAqL1xuICByZW1vdmVDbGFzcyAoY3NzQ2xhc3MpIHtcbiAgICAkKHRoaXMuZWxlbWVudCkucmVtb3ZlQ2xhc3MoY3NzQ2xhc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0cmFuc2xhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gY29uZmlnIEtleSAoZXg6ICd0YWcudGhyZXNob2xkJylcbiAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgLSBkZWZhdWx0IHZhbHVlIGluIGNhc2Ugbm90aGluZyBpbiBmb3VuZCBpbiBhdHRyaWJ1dGUgb3IgcHVsc2VDb25maWdcbiAgICogQHJldHVybnMgeyp9IENvbmZpZ3VyYXRpb24gb3IgYXR0cmlidXRlIHZhbHVlXG4gICAqL1xuICBnZXRUcmFuc2xhdGlvbiAoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAvLyBUT0RPIDogQ2F0Y2ggZXhjZXB0aW9uICsgbG9nICsgcmV0dXJuIGRlZmF1bHRcbiAgICBsZXQgdHJhbnNsYXRpb24gPSBQVUxTRV9DT01QT05FTlRfVFJBTlNMQVRJT047XG4gICAgaWYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKHRyYW5zbGF0aW9uKSkge1xuICAgICAgbGV0IG5hbWVUYWcgPSAnJztcbiAgICAgIGlmICghcHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZCh0aGlzLmVsZW1lbnQpKSB7XG4gICAgICAgIG5hbWVUYWcgPSB0aGlzLmVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoMCA9PSBuYW1lVGFnLmluZGV4T2YoJ3gtJykpIHtcbiAgICAgICAgICBuYW1lVGFnID0gbmFtZVRhZy5zdWJzdHJpbmcoMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgocHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChrZXkpKSB8fCAoa2V5ID09PSAnJykpIHtcbiAgICAgICAgdHJhbnNsYXRpb24gPSB0cmFuc2xhdGlvbltuYW1lVGFnXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgbGlzdE9mS2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICAvL3RvRmluZCA9IHRyYW5zbGF0aW9uW25hbWVUYWddW2tleVNdO1xuICAgICAgICB0cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uW25hbWVUYWddO1xuICAgICAgICBpZiAoKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKHRyYW5zbGF0aW9uKSkgJiYgKHRyYW5zbGF0aW9uICE9PSAnJykpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RPZktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uID0gdHJhbnNsYXRpb25bbGlzdE9mS2V5c1tpXV07XG4gICAgICAgICAgICBpZiAoKHB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQodHJhbnNsYXRpb24pKSB8fCAodHJhbnNsYXRpb24gPT09ICcnKSkge1xuICAgICAgICAgICAgICAvL2RlYnVnZ2VyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQodHJhbnNsYXRpb24pKSB7XG4gICAgICAgICAgLy8gdG9GaW5kID0gdHJhbnNsYXRpb25ba2V5U107XG4gICAgICAgICAgdHJhbnNsYXRpb24gPSBQVUxTRV9DT01QT05FTlRfVFJBTlNMQVRJT047XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0T2ZLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uW2xpc3RPZktleXNbaV1dO1xuICAgICAgICAgICAgaWYgKChwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKHRyYW5zbGF0aW9uKSlcbiAgICAgICAgICAgICAgfHwgKHRyYW5zbGF0aW9uID09PSAnJykpIHtcbiAgICAgICAgICAgICAgLy9kZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQodHJhbnNsYXRpb24pKSB7XG4gICAgICAvLyBUT0RPIGFsZXJ0IGlmIGRlYnVnIG1vZGVcbiAgICAgIC8vZGVidWdnZXI7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiB0cmFuc2xhdGlvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbmZpZyBvciBhdHRyaWJ1dGUgKGlmIGFueSBhdHRyaWJ1dGUgb3ZlcmxvYWQgY29uZmlnKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gY29uZmlnIEtleSAoZXg6ICd0YWcudGhyZXNob2xkJylcbiAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgLSBkZWZhdWx0IHZhbHVlIGluIGNhc2Ugbm90aGluZyBpbiBmb3VuZCBpbiBhdHRyaWJ1dGUgb3IgcHVsc2VDb25maWdcbiAgICogQHJldHVybnMgeyp9IENvbmZpZ3VyYXRpb24gb3IgYXR0cmlidXRlIHZhbHVlXG4gICAqL1xuICBnZXRDb25maWdPckF0dHJpYnV0ZSAoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBsZXQgbGlzdE9mS2V5cyA9IGtleS5zcGxpdCgnLicpOyAvLyBFeDogJ0FOWV90YWdOYW1lLnJlYWxLZXknXG5cbiAgICBpZiAobGlzdE9mS2V5cy5sZW5ndGggPCAxKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIGxldCBsYXN0S2V5ID0gbGlzdE9mS2V5c1tsaXN0T2ZLZXlzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKHRoaXMuZWxlbWVudCkpIHsgLy8gVG8gYXZvaWQgZXJyZXVyIHdoZW4gZGVsZXRlZFxuICAgICAgLy8gMS0gQVRUUklCVVRFIDogR2V0IExBU1Qga2V5IG9yIE9OTFkgXG4gICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZShsYXN0S2V5KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShsYXN0S2V5KTtcbiAgICAgIH1cblxuICAgICAgLy8gMi0gQ09ORklHXG4gICAgICBsZXQgZWxlbWVudFNob3J0TmFtZSA9IHRoaXMuZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBlbGVtZW50U2hvcnROYW1lID0gZWxlbWVudFNob3J0TmFtZS5zbGljZSgyKTtcbiAgICAgIC8vIDEtIFNlYXJjaCBmb3IgeHRhZy5yZWZyZXNoaW5nWFhYLlhYWHJhdGUgKGZvciBleGFtcGxlKVxuICAgICAgbGV0IHJldFZhbCA9IHB1bHNlQ29uZmlnLmdldFN0cmluZyhlbGVtZW50U2hvcnROYW1lICsgJy4nICsga2V5LCAndW5kZWZEZWZhdXRWYWx1ZScpO1xuICAgICAgaWYgKCd1bmRlZkRlZmF1dFZhbHVlJyAhPSByZXRWYWwpXG4gICAgICAgIHJldHVybiByZXRWYWw7XG5cbiAgICAgIGlmIChsaXN0T2ZLZXlzLmxlbmd0aCA+PSAyICYmIGxpc3RPZktleXNbMF0gIT0gZWxlbWVudFNob3J0TmFtZSkge1xuICAgICAgICAvL2xldCBsYXN0S2V5ID0gbGlzdE9mS2V5c1tsaXN0T2ZLZXlzLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyAyLSBTZWFyY2ggZm9yIHh0YWcuWFhYcmF0ZSAoZm9yIGV4YW1wbGUpXG4gICAgICAgIHJldFZhbCA9IHB1bHNlQ29uZmlnLmdldFN0cmluZyhlbGVtZW50U2hvcnROYW1lICsgJy4nICsgbGFzdEtleSwgJ3VuZGVmRGVmYXV0VmFsdWUnKTtcbiAgICAgICAgaWYgKCd1bmRlZkRlZmF1dFZhbHVlJyAhPSByZXRWYWwpXG4gICAgICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gMy1TZWFyY2ggZm9yIHJlZnJlc2hpbmdYWFguWFhYcmF0ZSAoZm9yIGV4YW1wbGUpXG4gICAgcmV0dXJuIHB1bHNlQ29uZmlnLmdldFN0cmluZyhrZXksIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNvbmZpZyBvciBhdHRyaWJ1dGUgKGlmIGFueSBhdHRyaWJ1dGUgb3ZlcmxvYWQgY29uZmlnKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gY29uZmlnIEtleSAoZXg6ICd0YWcudGhyZXNob2xkJylcbiAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgLSBkZWZhdWx0IHZhbHVlIGluIGNhc2Ugbm90aGluZyBpbiBmb3VuZCBpbiBhdHRyaWJ1dGUgb3IgcHVsc2VDb25maWdcbiAgICogQHJldHVybnMgeyp9IENvbmZpZ3VyYXRpb24gb3IgYXR0cmlidXRlIHZhbHVlXG4gICAqL1xuICBnZXRDb25maWdPckF0dHJpYnV0ZUZyZWVUeXBlIChrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGxldCBsaXN0T2ZLZXlzID0ga2V5LnNwbGl0KCcuJyk7IC8vIEV4OiAnQU5ZX3RhZ05hbWUucmVhbEtleSdcblxuICAgIGlmIChsaXN0T2ZLZXlzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgbGV0IGVsZW1lbnRTaG9ydE5hbWUgPSB0aGlzLmVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGVsZW1lbnRTaG9ydE5hbWUgPSBlbGVtZW50U2hvcnROYW1lLnNsaWNlKDIpO1xuICAgIC8vIDEtIFNlYXJjaCBmb3IgeHRhZy5yZWZyZXNoaW5nWFhYLlhYWHJhdGUgKGZvciBleGFtcGxlKVxuICAgIGxldCByZXRWYWwgPSBwdWxzZUNvbmZpZy5nZXQoZWxlbWVudFNob3J0TmFtZSArICcuJyArIGtleSk7XG4gICAgaWYgKHVuZGVmaW5lZCAhPSByZXRWYWwpXG4gICAgICByZXR1cm4gcmV0VmFsO1xuXG4gICAgaWYgKGxpc3RPZktleXMubGVuZ3RoID49IDIgJiYgbGlzdE9mS2V5c1swXSAhPSBlbGVtZW50U2hvcnROYW1lKSB7XG4gICAgICBsZXQgbGFzdEtleSA9IGxpc3RPZktleXNbbGlzdE9mS2V5cy5sZW5ndGggLSAxXTtcbiAgICAgIC8vIDItIFNlYXJjaCBmb3IgeHRhZy5YWFhyYXRlIChmb3IgZXhhbXBsZSlcbiAgICAgIHJldFZhbCA9IHB1bHNlQ29uZmlnLmdldChlbGVtZW50U2hvcnROYW1lICsgJy4nICsgbGFzdEtleSk7XG4gICAgICBpZiAodW5kZWZpbmVkICE9IHJldFZhbClcbiAgICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9XG5cbiAgICAvLyAzLVNlYXJjaCBmb3IgcmVmcmVzaGluZ1hYWC5YWFhyYXRlIChmb3IgZXhhbXBsZSlcbiAgICByZXR1cm4gcHVsc2VDb25maWcuZ2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgfVxufVxuXG5cbi8qKlxuICogUHVsc2UgY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyB0aGUgc3RhdGUgbWFjaGluZSBwYXR0ZXJuXG4gKlxuICogQGV4dGVuZHMgbW9kdWxlOnB1bHNlQ29tcG9uZW50flB1bHNlQ29tcG9uZW50XG4gKi9cbmNsYXNzIFB1bHNlU3RhdGVDb21wb25lbnQgZXh0ZW5kcyBQdWxzZUNvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgXG4gICAqL1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgY29uc3Qgc2VsZiA9IHN1cGVyKC4uLmFyZ3MpO1xuICAgIC8vIEJ5IGRlZmF1bHQgdGhlIGNvbXBvbmVudCB3aWxsIGJlIHJlbW92ZWQgZnJvbSBET00gb25seSBvbmNlIEFORCBkaWUgOlxuICAgIHNlbGYuX2Z1bGxEZWxldGVXaGVuRGlzY29ubmVjdCA9IHRydWU7XG4gICAgc2VsZi5fc3RhdGVDb250ZXh0ID0gbnVsbDtcbiAgICBzZWxmLl9zdGF0ZUtleSA9IG51bGw7XG4gICAgc2VsZi5fZ2V0SW5pdGlhbGl6ZWRTdGF0ZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBrZXkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZWxmLl9wZW5kaW5nUG9zdEFjdGlvbiA9IGZ1bmN0aW9uICgpIHsgfVxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGV4dHJhIGNsYXNzZXMgbGlua2VkIHRvIHN0YXRlc1xuICAgKlxuICAgKi9cbiAgY2xlYXJEeW5hbWljU3RhdGVDb250ZW50ICgpIHtcbiAgICBsZXQgY2xhc3NlcyA9IHRoaXMuZWxlbWVudC5jbGFzc05hbWU7XG5cbiAgICBpZiAoY2xhc3NlcyAhPSB1bmRlZmluZWQgJiYgY2xhc3NlcyAhPSAnJykge1xuICAgICAgbGV0IGNsYXNzX25hbWVzID0gY2xhc3Nlcy5zcGxpdCgnICcpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc19uYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdG1wX2NsYXNzID0gY2xhc3NfbmFtZXNbaV07XG4gICAgICAgIGlmICgwID09IHRtcF9jbGFzcy5pbmRleE9mKCdwdWxzZS1jb21wb25lbnQtJykpIHtcbiAgICAgICAgICAvLyAtbG9hZGluZyAtbm90LWFwcGxpY2FibGUgLXdhcm5pbmcgLWVycm9yIFxuICAgICAgICAgICQodGhpcy5lbGVtZW50KS5yZW1vdmVDbGFzcyh0bXBfY2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwID09IHRtcF9jbGFzcy5pbmRleE9mKCdwdWxzZWNvbXBvbmVudC0nKSkge1xuICAgICAgICAgIC8vIHB1bHNlY29tcG9uZW50LWNvbnRleHQtSW5pdGlhbGl6ZWQgLVBhcmFtVmFsaWRhdGlvbiAtTG9hZGVkIC4uLiBcbiAgICAgICAgICAvLyBwdWxzZWNvbXBvbmVudC1rZXktTG9hZGluZyAtVmFsaWRhdGluZyAtRXJyb3IgLi4uXG4gICAgICAgICAgJCh0aGlzLmVsZW1lbnQpLnJlbW92ZUNsYXNzKHRtcF9jbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVG8gYmUgb3ZlcnJpZGRlbiBpZiBuZWNlc3NhcnlcbiAgICogXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBpcyB0aGUgY29tcG9uZW50IHZpc2libGUgP1xuICAgKi9cbiAgZ2V0IGlzVmlzaWJsZSAoKSB7XG4gICAgaWYgKCQodGhpcy5lbGVtZW50KS5oYXNDbGFzcygncHVsc2Utbm9kaXNwbGF5JykpIHsgLy8gJ3gtY2hlY2suLi4nXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoJCh0aGlzLmVsZW1lbnQpLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB4LXRhZyBpcyBpbiBmb3JlaWduT2JqZWN0IGluIHN2ZyA9PiBkZWZpbmUgYXMgdmlzaWJsZSAhXG4gICAgaWYgKCQodGhpcy5lbGVtZW50KS5oYXNDbGFzcygncHVsc2UtYWRkZWQtaW4tc3ZnJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBpcyBhIGxpdHRsZSBiaXQgdHJpY2t5IGJlY2F1c2Ugb24gQ2hyb21lOlxuICAgIC8vIC0gJCh0aGlzLmVsZW1lbnQpLmlzKCc6dmlzaWJsZScpIG9ubHkgd29ya3Mgb24gYmxvY2sgZWxlbWVudHMsIGVsc2UgZmFsc2UgaXMgYWx3YXlzIHJldHVybmVkXG4gICAgLy8gLSB0aGUgeC10YWcgZWxlbWVudCBpcyBhbHdheXMgaW5saW5lXG4gICAgbGV0IGRpc3BsYXkgPSB0aGlzLmVsZW1lbnQuY3VycmVudFN0eWxlXG4gICAgICA/IHRoaXMuZWxlbWVudC5jdXJyZW50U3R5bGUuZGlzcGxheSAvLyBJRVxuICAgICAgOiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnQsIG51bGwpLmRpc3BsYXk7XG4gICAgc3dpdGNoIChkaXNwbGF5KSB7XG4gICAgICBjYXNlICdibG9jayc6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyAtIEJlY2F1c2UgdGhlIHgtdGFnIGVsZW1lbnQgaXMgYWx3YXlzIGlubGluZSBvbiBDaHJvbWUsXG4gICAgLy8gICB2aXNpdCBhbGwgdGhlIGNoaWxkcmVuIGFuZCB0cnkgdG8gZmluZCBhbW9uZyB0aGVtIGEgYmxvY2sgZWxlbWVudFxuICAgIGxldCBibG9ja0VsZW1lbnRGb3VuZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGNoaWxkIG9mIHRoaXMuZWxlbWVudC5jaGlsZHJlbikge1xuICAgICAgbGV0IGNoaWxkRGlzcGxheSA9IGNoaWxkLmN1cnJlbnRTdHlsZVxuICAgICAgICA/IGNoaWxkLmN1cnJlbnRTdHlsZS5kaXNwbGF5IC8vIElFXG4gICAgICAgIDogd2luZG93LmdldENvbXB1dGVkU3R5bGUoY2hpbGQsIG51bGwpLmRpc3BsYXk7XG4gICAgICBzd2l0Y2ggKGNoaWxkRGlzcGxheSkge1xuICAgICAgICBjYXNlICdibG9jayc6XG4gICAgICAgICAgYmxvY2tFbGVtZW50Rm91bmQgPSB0cnVlO1xuICAgICAgICAgIGlmICgkKGNoaWxkKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmxvY2tFbGVtZW50Rm91bmQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdpc1Zpc2libGU6IGZhbGxiYWNrLCBhbGwgdGhlIGJsb2NrIGVsZW1lbnQgY2hpbGRyZW4gYXJlIG5vdCB2aXNpYmxlLCByZXR1cm4gZmFsc2UnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnaXNWaXNpYmxlOiBmYWxsYmFjaywgbm8gYmxvY2sgZWxlbWVudCBpbiBjaGlsZHJlbiwgcmV0dXJuIHRydWUnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCAgd2hlbiB0aGUgY3VzdG9tIGVsZW1lbnQgaXMgY29ubmVjdGVkIHRvIHRoZSBET00gZG9jdW1lbnRcbiAgICovXG4gIGNvbm5lY3RlZENhbGxiYWNrICgpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGN1c3RvbSBlbGVtZW50IGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBET00gZG9jdW1lbnRcbiAgICogcmV0dXJuIHRydWUgaWYgRE9NIHNob3VsZCBiZSBkZXN0cm95ZWQgYW5kIHdpbGwgbmV2ZXIgY29tZSBhZ2FpblxuICAgKi9cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2sgKCkge1xuICAgIHJldHVybiBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB0byB1c2Ugd2hlbiB0aGUgY29tcG9uZW50IGNhbiBiZSByZW1vdmUgLyByZS0gYXBwZW5kIHRvIERPTVxuICAgKiAoZm9yIGV4YW1wbGUgaW4gc2V0dXBtYWNoaW5lKVxuICAgKi9cbiAgZGlzYWJsZURlbGV0ZVdoZW5EaXNjb25uZWN0ICgpIHtcbiAgICB0aGlzLl9mdWxsRGVsZXRlV2hlbkRpc2Nvbm5lY3QgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gdXNlIHdoZW4gZGlzYWJsZURlbGV0ZVdoZW5EaXNjb25uZWN0IGhhdmUgYmVlbiBjYWxsZWRcbiAgICogdG8gcmVzdG9yZSBkZWxldGUgKGZvciBleGFtcGxlIGluIHNldHVwbGlzdCBmb3IgY2hpbGRyZW4pXG4gICAqL1xuICByZXN0b3JlRGVsZXRlV2hlbkRpc2Nvbm5lY3QgKCkge1xuICAgIHRoaXMuX2Z1bGxEZWxldGVXaGVuRGlzY29ubmVjdCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgeyFzdHJpbmd9IGN1cnJlbnQgc3RhdGUgY29udGV4dFxuICAgKi9cbiAgZ2V0IHN0YXRlQ29udGV4dCAoKSB7XG4gICAgaWYgKG51bGwgPT0gdGhpcy5fc3RhdGVDb250ZXh0KSB7XG4gICAgICBkZWJ1Z2dlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1kZWJ1Z2dlclxuICAgICAgdGhyb3cgJ05vIGRlZmluZWQgc3RhdGUgY29udGV4dCc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGF0ZUNvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgeyFzdHJpbmd9IEN1cnJlbnQgc3RhdGUga2V5XG4gICAqL1xuICBnZXQgc3RhdGVLZXkgKCkge1xuICAgIGlmIChudWxsID09IHRoaXMuX3N0YXRlS2V5KSB7XG4gICAgICBkZWJ1Z2dlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1kZWJ1Z2dlclxuICAgICAgdGhyb3cgJ05vIGRlZmluZWQgc3RhdGUga2V5JztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlS2V5O1xuICB9XG5cbiAgLyoqIFxuICAgKiBEZWZpbmUgdGhlIHN0YXRlc1xuICAgKiBcbiAgICogQHBhcmFtIHshc3RyaW5nfSBjb250ZXh0IC0gQ29udGV4dFxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGtleSAtIEtleVxuICAgKiBAcmV0dXJucyB7IVN0YXRlfSBDcmVhdGVkIHN0YXRlc1xuICAgKlxuICAgKiBAZnVuY3Rpb24gZGVmaW5lU3RhdGVcbiAgICovXG5cbiAgLyoqXG4gICAqIERlZmluZSB0aGUgc3RhcnQgY29udGV4dFxuICAgKlxuICAgKiBAcmV0dXJucyB7IXN0cmluZ30gU3RhcnQgY29udGV4dFxuICAgKlxuICAgKiBAZnVuY3Rpb24gc3RhcnRDb250ZXh0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgZm9yIGVhY2ggY29udGV4dCB0aGUgc3RhcnQga2V5XG4gICAqIFxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGNvbnRleHQgLSBDb250ZXh0XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFN0YXJ0IGtleVxuICAgKiBcbiAgICogQGZ1bmN0aW9uIGdldFN0YXJ0S2V5XG4gICAqL1xuXG4gIC8qKlxuICAgKiBEZWZpbmUgd2hpY2ggY29udGV4dCBzaG91bGQgYmUgY29uc2lkZXJlZCBvbmNlIGEgY29udGV4dCBpcyBjb21wbGV0ZWRcbiAgICogXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY29udGV4dCAtIENvbnRleHRcbiAgICogQHJldHVybnMge3N0cmluZ30gTmV4dCBjb250ZXh0XG4gICAqIFxuICAgKiBAZnVuY3Rpb24gZ2V0TmV4dENvbnRleHRcbiAgICovXG5cbiAgLyoqXG4gICAqIEFjdGlvbiBjYWxsYmFja1xuICAgKiBcbiAgICogQGNhbGxiYWNrIGFjdGlvbkNhbGxiYWNrXG4gICAqL1xuXG4gIC8qKlxuICAqIE1ldGhvZCB0byBleGVjdXRlIHdoZW4geW91IGVudGVyIGEgY29udGV4dFxuICAqIFxuICAqIEBwYXJhbSB7IXN0cmluZ30gY29udGV4dCAtIENvbnRleHRcbiAgKiBAcmV0dXJucyB7YWN0aW9uQ2FsbGJhY2t9XG4gICovXG4gIGVudGVyQ29udGV4dCAoY29udGV4dCkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKCkgeyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gZXhlY3V0ZSB3aGVuIHlvdSBleGl0IGEgY29udGV4dFxuICAgKiBcbiAgICogQHBhcmFtIHshc3RyaW5nfSBjb250ZXh0IC0gQ29udGV4dFxuICAgKiBAcmV0dXJucyB7YWN0aW9uQ2FsbGJhY2t9XG4gICAqL1xuICBleGl0Q29udGV4dCAoY29udGV4dCkge1xuICAgIHJldHVybiAoZnVuY3Rpb24gKCkgeyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYXMgYSBzdGF0ZSBiZWVuIGFscmVhZHkgaW5pdGlhbGl6ZWQgdG8gdGhpcyBjb21wb25lbnQgP1xuICAgKiBcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFxuICAgKi9cbiAgZ2V0IGlzU3RhcnRlZCAoKSB7XG4gICAgcmV0dXJuIChudWxsICE9IHRoaXMuX3N0YXRlQ29udGV4dCkgJiYgKG51bGwgIT0gdGhpcy5fc3RhdGVLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHN0YXRlIChpbml0aWFsaXplIGl0IGlmIG5lY2Vzc2FyeSlcbiAgICogXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY29udGV4dCAtIGNvbnRleHQgXG4gICAqIEBwYXJhbSB7IXN0cmluZ30ga2V5IC0ga2V5XG4gICAqIEByZXR1cm5zIHtTdGF0ZX0gc3RhdGVcbiAgICovXG4gIGdldFN0YXRlIChjb250ZXh0LCBrZXkpIHtcbiAgICBsZXQgaW5pdGlhbGl6ZWRTdGF0ZSA9IHRoaXMuX2dldEluaXRpYWxpemVkU3RhdGUoY29udGV4dCwga2V5KTtcbiAgICBpZiAobnVsbCAhPSBpbml0aWFsaXplZFN0YXRlKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbGl6ZWRTdGF0ZTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIG51bGwgPT0gaW5pdGlhbGl6ZWRTdGF0ZVxuICAgICAgbGV0IHN0YXRlID0gdGhpcy5kZWZpbmVTdGF0ZShjb250ZXh0LCBrZXkpO1xuICAgICAgbGV0IHByZXZpb3VzR2V0SW5pdGlhbGl6ZWRTdGF0ZSA9IHRoaXMuX2dldEluaXRpYWxpemVkU3RhdGU7XG4gICAgICBsZXQgbmV3R2V0SW5pdGlhbGl6ZWRTdGF0ZSA9IGZ1bmN0aW9uIChjLCBrKSB7XG4gICAgICAgIGlmICgoYyA9PSBjb250ZXh0KSAmJiAoayA9PSBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwcmV2aW91c0dldEluaXRpYWxpemVkU3RhdGUoYywgayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLl9nZXRJbml0aWFsaXplZFN0YXRlID0gbmV3R2V0SW5pdGlhbGl6ZWRTdGF0ZTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgeyFTdGF0ZX0gY3VycmVudCBzdGF0ZVxuICAgKi9cbiAgZ2V0IHN0YXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSh0aGlzLnN0YXRlQ29udGV4dCwgdGhpcy5zdGF0ZUtleSk7XG4gIH1cblxuICAvKiogXG4gICAqIFN3aXRjaCB0byBzdGF0ZSBtZXRob2QsIHdoZXJlIHRoZSBjb250ZXh0IGFuZCB0aGUga2V5IGNhbm5vdCBiZSBudWxsXG4gICAqIFxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGMgLSBTdGF0ZSBjb250ZXh0XG4gICAqIEBwYXJhbSB7IXN0cmluZ30gayAtIFN0YXRlIGtleVxuICAgKiBAcGFyYW0geyFhY3Rpb25DYWxsYmFja30gcHJlQWN0aW9uIC0gUHJlLWFjdGlvblxuICAgKiBAcGFyYW0geyFhY3Rpb25DYWxsYmFja30gcG9zdEFjdGlvbiAtIFBvc3QtYWN0aW9uXG4gICovXG4gIF9zd2l0Y2hUb1N0YXRlIChjLCBrLCBwcmVBY3Rpb24sIHBvc3RBY3Rpb24pIHtcbiAgICBpZiAoKG51bGwgPT0gdGhpcy5fc3RhdGVDb250ZXh0KSAmJiAobnVsbCA9PSB0aGlzLl9zdGF0ZUtleSkpIHtcbiAgICAgIGxldCBlbnRlckNvbnRleHQgPSB0aGlzLmVudGVyQ29udGV4dChjKTtcbiAgICAgIGVudGVyQ29udGV4dCgpO1xuICAgICAgdGhpcy5fc3RhdGVDb250ZXh0ID0gYztcbiAgICAgIHRoaXMuX3N0YXRlS2V5ID0gaztcbiAgICAgIHByZUFjdGlvbi5iaW5kKHRoaXMpKCk7XG4gICAgICBsZXQgbmV3U3RhdGUgPSB0aGlzLmdldFN0YXRlKGMsIGspO1xuICAgICAgbmV3U3RhdGUuZW50ZXIobnVsbCwgbnVsbCk7XG4gICAgICB0aGlzLl9wZW5kaW5nUG9zdEFjdGlvbiA9IHBvc3RBY3Rpb24uYmluZCh0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKG51bGwgPT0gdGhpcy5fc3RhdGVDb250ZXh0KSB8fCAobnVsbCA9PSB0aGlzLl9zdGF0ZUtleSkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ09ubHkgb25lIGNvbnRleHQva2V5IGRlZmluZWQnKTtcbiAgICAgIGRlYnVnZ2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWRlYnVnZ2VyXG4gICAgICB0aHJvdyAnT25seSBvbmUgY29udGV4dC9rZXkgZGVmaW5lZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKCh0aGlzLnN0YXRlQ29udGV4dCA9PSBjKSAmJiAodGhpcy5zdGF0ZUtleSA9PSBrKSkge1xuICAgICAgdGhpcy5fcGVuZGluZ1Bvc3RBY3Rpb24uYmluZCh0aGlzKSgpO1xuICAgICAgdGhpcy5fcGVuZGluZ1Bvc3RBY3Rpb24gPSBmdW5jdGlvbiAoKSB7IH1cbiAgICAgIHByZUFjdGlvbi5iaW5kKHRoaXMpKCk7XG4gICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGMsIGspO1xuICAgICAgc3RhdGUuc3RheSgpO1xuICAgICAgdGhpcy5fcGVuZGluZ1Bvc3RBY3Rpb24gPSBwb3N0QWN0aW9uLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZS5leGl0KGMsIGspO1xuICAgICAgbGV0IG9sZENvbnRleHQgPSB0aGlzLnN0YXRlQ29udGV4dDtcbiAgICAgIGxldCBvbGRLZXkgPSB0aGlzLnN0YXRlS2V5O1xuICAgICAgdGhpcy5fcGVuZGluZ1Bvc3RBY3Rpb24uYmluZCh0aGlzKSgpO1xuICAgICAgdGhpcy5fcGVuZGluZ1Bvc3RBY3Rpb24gPSBmdW5jdGlvbiAoKSB7IH1cbiAgICAgIGlmIChvbGRDb250ZXh0ICE9IGMpIHtcbiAgICAgICAgbGV0IGV4aXRDb250ZXh0ID0gdGhpcy5leGl0Q29udGV4dChvbGRDb250ZXh0KTtcbiAgICAgICAgZXhpdENvbnRleHQoKTtcbiAgICAgICAgbGV0IGVudGVyQ29udGV4dCA9IHRoaXMuZW50ZXJDb250ZXh0KGMpO1xuICAgICAgICBlbnRlckNvbnRleHQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXRlQ29udGV4dCA9IGM7XG4gICAgICB0aGlzLl9zdGF0ZUtleSA9IGs7XG4gICAgICBwcmVBY3Rpb24uYmluZCh0aGlzKSgpO1xuICAgICAgbGV0IG5ld1N0YXRlID0gdGhpcy5nZXRTdGF0ZShjLCBrKTtcbiAgICAgIG5ld1N0YXRlLmVudGVyKG9sZENvbnRleHQsIG9sZEtleSk7XG4gICAgICB0aGlzLl9wZW5kaW5nUG9zdEFjdGlvbiA9IHBvc3RBY3Rpb24uYmluZCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKiogUmVtYWluIGluIHRoZSBzYW1lIGNvbnRleHQsIGJ1dCBzd2l0Y2ggdG8gdGhlIHN0YXRlIHdpdGggdGhlIHNwZWNpZmllZCBrZXlcbiAgICogXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gayAtIE5ldyBzdGF0ZSBrZXlcbiAgICogQHBhcmFtIHshYWN0aW9uQ2FsbGJhY2t9IHByZUFjdGlvbiAtIFByZS1hY3Rpb25cbiAgICogQHBhcmFtIHshYWN0aW9uQ2FsbGJhY2t9IHBvc3RBY3Rpb24gLSBQb3N0LWFjdGlvblxuICAgKi9cbiAgX3N3aXRjaFRvS2V5IChrLCBwcmVBY3Rpb24sIHBvc3RBY3Rpb24pIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLl9zdGF0ZUNvbnRleHQpIHtcbiAgICAgIHRoaXMuX3N3aXRjaFRvU3RhdGUodGhpcy5zdGFydENvbnRleHQsIGssIHByZUFjdGlvbiwgcG9zdEFjdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fc3dpdGNoVG9TdGF0ZSh0aGlzLnN0YXRlQ29udGV4dCwgaywgcHJlQWN0aW9uLCBwb3N0QWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3dpdGNoIHRvIGEgbmV4dCBzdGF0ZVxuICAgKlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNvbnRleHQgLSBDb250ZXh0IG9mIHRoZSBuZXcgc3RhdGUgb3IgbnVsbC91bmRlZmluZWRcbiAgICogQHBhcmFtIHs/c3RyaW5nfSBrZXkgLSBLZXkgb2YgdGhlIG5ldyBzdGF0ZSBvciBudWxsL3VuZGVmaW5lZFxuICAgKiBAcGFyYW0gez9hY3Rpb25DYWxsYmFja30gcHJlQWN0aW9uUGFyYW0gLSBQcmUtYWN0aW9uXG4gICAqIEBwYXJhbSB7P2FjdGlvbkNhbGxiYWNrfSBwb3N0QWN0aW9uUGFyYW0gLSBQb3N0LWFjdGlvblxuICAgKi9cbiAgc3dpdGNoVG9TdGF0ZSAoY29udGV4dCwga2V5LCBwcmVBY3Rpb25QYXJhbSwgcG9zdEFjdGlvblBhcmFtKSB7XG4gICAgbGV0IHByZUFjdGlvbjtcbiAgICBpZiAobnVsbCA9PSBwcmVBY3Rpb25QYXJhbSkge1xuICAgICAgcHJlQWN0aW9uID0gZnVuY3Rpb24gKCkgeyB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcHJlQWN0aW9uID0gcHJlQWN0aW9uUGFyYW07XG4gICAgfVxuICAgIGxldCBwb3N0QWN0aW9uO1xuICAgIGlmIChudWxsID09IHBvc3RBY3Rpb25QYXJhbSkge1xuICAgICAgcG9zdEFjdGlvbiA9IGZ1bmN0aW9uICgpIHsgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHBvc3RBY3Rpb24gPSBwb3N0QWN0aW9uUGFyYW07XG4gICAgfVxuICAgIGlmICgobnVsbCA9PSBjb250ZXh0KSAmJiAobnVsbCA9PSBrZXkpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdzd2l0Y2hUb1N0YXRlIGNhbGxlZCB3aXRoIG5vIGNvbnRleHQgYW5kIG5vIGtleScpO1xuICAgICAgZGVidWdnZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZGVidWdnZXJcbiAgICAgIHRocm93ICdzd2l0Y2hUb1N0YXRlIHdpdGggbm8gY29udGV4dC9rZXknO1xuICAgIH1cbiAgICBlbHNlIGlmIChudWxsID09IGtleSkgeyAvLyAmJiAobnVsbCAhPSBjb250ZXh0KVxuICAgICAgbGV0IGsgPSB0aGlzLmdldFN0YXJ0S2V5KGNvbnRleHQpO1xuICAgICAgdGhpcy5fc3dpdGNoVG9TdGF0ZShjb250ZXh0LCBrLCBwcmVBY3Rpb24sIHBvc3RBY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChudWxsID09IGNvbnRleHQpIHsgLy8gJiYgKG51bGwgIT0ga2V5KVxuICAgICAgdGhpcy5fc3dpdGNoVG9LZXkoa2V5LCBwcmVBY3Rpb24sIHBvc3RBY3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gKG51bGwgIT0gY29udGV4dCkgJiYgKG51bGwgIT0ga2V5KVxuICAgICAgdGhpcy5fc3dpdGNoVG9TdGF0ZShjb250ZXh0LCBrZXksIHByZUFjdGlvbiwgcG9zdEFjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaCB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHRcbiAgICogXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY29udGV4dCAtIE5ldyBjb250ZXh0IHRvIHN3aXRjaCB0b1xuICAgKiBAcGFyYW0gez9hY3Rpb25DYWxsYmFja30gcHJlQWN0aW9uUGFyYW0gLSBQcmUtYWN0aW9uXG4gICAqIEBwYXJhbSB7P2FjdGlvbkNhbGxiYWNrfSBwb3N0QWN0aW9uUGFyYW0gLSBQb3N0LWFjdGlvblxuICAgKi9cbiAgc3dpdGNoVG9Db250ZXh0IChjb250ZXh0LCBwcmVBY3Rpb25QYXJhbSwgcG9zdEFjdGlvblBhcmFtKSB7XG4gICAgdGhpcy5zd2l0Y2hUb1N0YXRlKGNvbnRleHQsIG51bGwsIHByZUFjdGlvblBhcmFtLCBwb3N0QWN0aW9uUGFyYW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaCB0byB0aGUgc3RhdGUgb2YgdGhlIHNwZWNpZmllZCBrZXkgd2hpbGUgcmVtYWluaW5nIGluIHRoZSBzYW1lIGNvbnRleHRcbiAgICogXG4gICAqIEBwYXJhbSB7IXN0cmluZ30ga2V5IC0gTmV3IHN0YXRlIGtleVxuICAgKiBAcGFyYW0gez9hY3Rpb25DYWxsYmFja30gcHJlQWN0aW9uUGFyYW0gLSBQcmUtYWN0aW9uXG4gICAqIEBwYXJhbSB7P2FjdGlvbkNhbGxiYWNrfSBwb3N0QWN0aW9uUGFyYW0gLSBQb3N0LWFjdGlvblxuICAgKi9cbiAgc3dpdGNoVG9LZXkgKGtleSwgcHJlQWN0aW9uUGFyYW0sIHBvc3RBY3Rpb25QYXJhbSkge1xuICAgIHRoaXMuc3dpdGNoVG9TdGF0ZShudWxsLCBrZXksIHByZUFjdGlvblBhcmFtLCBwb3N0QWN0aW9uUGFyYW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnNpZGVyIHRoZSBjdXJyZW50IGNvbnRleHQgaXMgY29tcGxldGVkLCBzd2l0Y2ggdG8gdGhlIG5leHQgb25lXG4gICAqIFxuICAgKiBAcGFyYW0gez9hY3Rpb25DYWxsYmFja30gcHJlQWN0aW9uUGFyYW0gLSBQcmUtYWN0aW9uXG4gICAqIEBwYXJhbSB7P2FjdGlvbkNhbGxiYWNrfSBwb3N0QWN0aW9uUGFyYW0gLSBQb3N0LWFjdGlvblxuICAgKi9cbiAgc3dpdGNoVG9OZXh0Q29udGV4dCAocHJlQWN0aW9uUGFyYW0sIHBvc3RBY3Rpb25QYXJhbSkge1xuICAgIGxldCBuZXh0Q29udGV4dDtcbiAgICBpZiAobnVsbCA9PSB0aGlzLl9zdGF0ZUNvbnRleHQpIHtcbiAgICAgIG5leHRDb250ZXh0ID0gdGhpcy5zdGFydENvbnRleHQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbmV4dENvbnRleHQgPSB0aGlzLmdldE5leHRDb250ZXh0KHRoaXMuc3RhdGVDb250ZXh0KTtcbiAgICB9XG4gICAgdGhpcy5zd2l0Y2hUb0NvbnRleHQobmV4dENvbnRleHQsIHByZUFjdGlvblBhcmFtLCBwb3N0QWN0aW9uUGFyYW0pO1xuICB9XG59XG5cblxuLyoqXG4gKiBBYnN0cmFjdCBwdWxzZSBjb21wb25lbnQgd2l0aCBhbiBpbml0aWFsaXphdGlvbiBwaGFzZVxuICpcbiAqIEF2YWlsYWJsZSBjb250ZXh0czogSW5pdGlhbGl6YXRpb24sIFJlc2V0LCBJbml0aWFsaXplZFxuICpcbiAqIFNvbWUgc3RhdGUgZmxvd3M6XG4gKiBEZWZhdWx0IGZsb3c6IEluaXRpYWxpemF0aW9uOkluaXRpYWxpemluZyAtPiBJbml0aWFsaXplZDpTdGFuZGFyZFxuICogSW5pdGlhbGl6YXRpb24gZXJyb3IgZmxvdzogSW5pdGlhbGl6YXRpb246SW5pdGlhbGl6aW5nIC0+IEluaXRpYWxpemF0aW9uOkVycm9yXG4gKiBSZXNldCBmbG93OiBJbml0aWFsaXplZDpTdGFuZGFyZCAtPiBSZXNldDpJbml0aWFsaXppbmcgLT4gSW5pdGlhbGl6ZWQ6U3RhbmRhcmRcbiAqXG4gKiBTdGF0ZSBpbXBsZW1lbnRhdGlvbnM6XG4gKiAtIEluaXRpYWxpemF0aW9uOkluaXRpYWxpemluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+SW5pdGlhbFN0YXRlfVxuICogLSBSZXNldDpJbml0aWFsaXppbmcgLSB7QGxpbmsgbW9kdWxlOnN0YXRlflJlc2V0U3RhdGV9XG4gKiAtIEluaXRpYWxpemVkOlN0YW5kYXJkIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5TdGF0aWNTdGF0ZX1cbiAqIC0gKjpFcnJvciAtIHtAbGluayBtb2R1bGU6c3RhdGV+RXJyb3JTdGF0ZX1cbiAqIFxuICogQGV4dGVuZHMgbW9kdWxlOnB1bHNlQ29tcG9uZW50flB1bHNlU3RhdGVDb21wb25lbnRcbiAqIFxuKiBAZ3JhcGggSW5pdGlhbGl6ZWRfQ29udGV4dEZsb3dcbkBnIFxuQGcgICAgICBJbml0aWFsaXplZCBjb21wb25lbnQ6IGNvbnRleHQgZmxvd1xuQGcgXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0rXG5AZyAgICAgPT0+IHwgSW5pdGlhbGl6YXRpb24gfCA9PT4gfCBJbml0aWFsaXplZCB8XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgICBIXG5AZyAgICAgLi4+IHwgICAgIFJlc2V0ICAgICAgfCA9PT09PT0jXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tK1xuKiBAZ3JhcGggSW5pdGlhbGl6YXRpb25fU3RhdGVGbG93XG5AZyBcbkBnICBJbml0aWFsaXphdGlvbiBjb250ZXh0OiBzdGF0ZSBmbG93XG5AZyBcbkBnICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICA9PT4gfCBJbml0aWFsaXppbmcgfCA9PT5cbkBnICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICB2XG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgIHwgICAgRXJyb3IgICAgIHxcbkBnICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0rXG4gKi9cbmNsYXNzIFB1bHNlSW5pdGlhbGl6ZWRDb21wb25lbnQgZXh0ZW5kcyBQdWxzZVN0YXRlQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIFxuICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgXG4gICAqL1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgY29uc3Qgc2VsZiA9IHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgc2VsZi5fZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXQgc3RhcnRDb250ZXh0ICgpIHtcbiAgICByZXR1cm4gJ0luaXRpYWxpemF0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY29udGV4dCAtIENvbnRleHRcbiAgICogQHJldHVybiB7IXN0cmluZ30ga2V5XG4gICAqL1xuICBnZXRTdGFydEtleSAoY29udGV4dCkge1xuICAgIHN3aXRjaCAoY29udGV4dCkge1xuICAgICAgY2FzZSAnSW5pdGlhbGl6YXRpb24nOlxuICAgICAgY2FzZSAnUmVzZXQnOlxuICAgICAgICByZXR1cm4gJ0luaXRpYWxpemluZyc7XG4gICAgICBjYXNlICdJbml0aWFsaXplZCc6XG4gICAgICAgIHJldHVybiAnU3RhbmRhcmQnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldE5leHRDb250ZXh0IChjb250ZXh0KSB7XG4gICAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgICBjYXNlICdJbml0aWFsaXphdGlvbic6XG4gICAgICBjYXNlICdSZXNldCc6XG4gICAgICAgIHJldHVybiAnSW5pdGlhbGl6ZWQnO1xuICAgICAgY2FzZSAnSW5pdGlhbGl6ZWQnOlxuICAgICAgICBjb25zb2xlLmxvZyhgTm8gbmV4dCBjb250ZXh0IGZvciAke2NvbnRleHR9YCk7XG4gICAgICAgIGRlYnVnZ2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWRlYnVnZ2VyXG4gICAgICAgIHRocm93ICdObyBuZXh0IGNvbnRleHQnO1xuICAgIH1cbiAgfVxuXG4gIGRlZmluZVN0YXRlIChjb250ZXh0LCBrZXkpIHtcbiAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgIGNhc2UgJ0JlZm9yZURlc3RydWN0aW9uU3RhdGUnOlxuICAgICAgICByZXR1cm4gbmV3IHN0YXRlLkJlZm9yZURlc3RydWN0aW9uU3RhdGUoY29udGV4dCwga2V5LCB0aGlzKTtcbiAgICAgIGNhc2UgJ0luaXRpYWxpemVkJzpcbiAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5TdGF0aWNTdGF0ZShjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ0luaXRpYWxpemluZyc6XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAnSW5pdGlhbGl6YXRpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3RhdGUuSW5pdGlhbFN0YXRlKGNvbnRleHQsIGtleSwgdGhpcyk7XG4gICAgICAgICAgICAgIGNhc2UgJ1Jlc2V0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN0YXRlLlJlc2V0U3RhdGUoY29udGV4dCwga2V5LCB0aGlzKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBTdGF0ZSBub3QgZGVmaW5lZCBmb3IgY29udGV4dD0ke2NvbnRleHR9IGFuZCBrZXk9JHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgZGVidWdnZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZGVidWdnZXJcbiAgICAgICAgICAgICAgICB0aHJvdyAnU3RhdGUgbm90IGRlZmluZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ0Vycm9yJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3RhdGUuRXJyb3JTdGF0ZShjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBTdGF0ZSBub3QgZGVmaW5lZCBmb3IgY29udGV4dD0ke2NvbnRleHR9IGFuZCBrZXk9JHtrZXl9YCk7XG4gICAgICAgICAgICBkZWJ1Z2dlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1kZWJ1Z2dlclxuICAgICAgICAgICAgdGhyb3cgJ1N0YXRlIG5vdCBkZWZpbmVkJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gb3ZlcnJpZGUgYnkgdGhlIGluaGVyaXRlZCBjbGFzc1xuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGluaXRpYWxpemUgKCkgeyAvLyBUbyBvdmVycmlkZVxuICAgIGlmIChuZXcudGFyZ2V0ID09PSBQdWxzZVNpbmdsZVJlcXVlc3RDb21wb25lbnQpIHRocm93IFR5cGVFcnJvcignaW5pdGlhbGl6ZSBvZiBhYnN0cmFjdCBjbGFzcyBQdWxzZUluaXRpYWxpemVkQ29tcG9uZW50Jyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYW55dGhpbmcgdGhhdCB3YXMgZG9uZSBkdXJpbmcgaW50aWFsaXphdGlvbiwgc28gdGhhdCBpbml0aWFsaXplIGNhbiBiZSBjYWxsZWQgb25jZSBhZ2Fpbi5cbiAgICogUmVtb3ZlIGFsbCB0aGUgZGlzcGF0Y2hlcnMgYW5kIGxpc3RlbmVycy5cbiAgICogUGxlYXNlIG5vdGUgdGhhdCBubyBzdGF0ZSBzd2l0Y2ggaXMgZG9uZSBoZXJlXG4gICAqL1xuICBjbGVhckluaXRpYWxpemF0aW9uICgpIHtcbiAgICAvLyBSZW1vdmUgYWxsIHRoZSBsaXN0ZW5lcnMgXG4gICAgZXZlbnRCdXMuRXZlbnRCdXMucmVtb3ZlRXZlbnRMaXN0ZW5lckJ5U2NvcGUodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsaXplZCwgbWVhbmluZyBpdHMgc3RhdGUgaXMgZGVmaW5lZCBhbmQgbm90ICdpbml0aWFsJyBvciAnaW5pdF9lcnJvcicgLSBtZWFucyBpbml0aWFsaXplICgpIGhhcyBiZWVuIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIGNvbXBvbmVudCBpcyBpbml0aWFsaXplZFxuICAgKi9cbiAgaXNJbml0aWFsaXplZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTdGFydGVkICYmICh0aGlzLnN0YXRlQ29udGV4dCAhPSAnSW5pdGlhbGl6YXRpb24nKSAmJiAodGhpcy5zdGF0ZUNvbnRleHQgIT0gJ1Jlc2V0Jyk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBjb25uZWN0ZWRDYWxsYmFjayAoKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICBpZiAoIXRoaXMuaXNTdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGN1c3RvbSBlbGVtZW50IGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBET00gZG9jdW1lbnRcbiAgICogcmV0dXJuIHRydWUgaWYgRE9NIHNob3VsZCBiZSBkZXN0cm95ZWQgYW5kIHdpbGwgbmV2ZXIgY29tZSBhZ2FpblxuICAgKi9cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2sgKCkge1xuICAgIGlmICh0aGlzLmlzU3RhcnRlZCkge1xuICAgICAgbGV0IGRpc2FibGVEZWxldGVFbGVtZW50cyA9ICQodGhpcy5lbGVtZW50KS5oYXNDbGFzcygnZGlzYWJsZURlbGV0ZVdoZW5EaXNjb25uZWN0Jyk7XG4gICAgICAvL2lmIChkaXNhYmxlRGVsZXRlRWxlbWVudHMubGVuZ3RoID09IDApIHtcbiAgICAgIGlmICghZGlzYWJsZURlbGV0ZUVsZW1lbnRzKSB7XG4gICAgICAgIGlmICh0aGlzLl9mdWxsRGVsZXRlV2hlbkRpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAvLyBCVUcgT04gQ2hyb21lXG4gICAgICAgICAgLy8gY291bGQgYmUgaWYgKCFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdDaHJvbWUnKSkgeyAvLyBCdWcgb24gQ2hyb21lIC0gcmVtb3ZlXG4gICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFySW5pdGlhbGl6YXRpb24oKTsgLy8gVG8gcmVzZXQgbGlzdGVuZXJzXG5cbiAgICAgICAgICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG5cbiAgICAgICAgICAgIHRoaXMuc3dpdGNoVG9TdGF0ZSgnQmVmb3JlRGVzdHJ1Y3Rpb25TdGF0ZScsICdCZWZvcmVEZXN0cnVjdGlvblN0YXRlJyk7XG5cbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsOyAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIGNsYXNzIHRvIGhlbHAgZ2FyYmFnZSBjb2xsZWN0b3JcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIHJldHVybiBmYWxzZTsgLy8gY2FuIGNvbWUgYmFjayBpbiBET00gKHJlLW9yZGVyIGxpc3QuLi4pXG4gIH1cblxuICAvKipcbiAgICogQWRkIHRoZSBjbGFzcyAncHVsc2UtY29tcG9uZW50LWVycm9yJyB0byB0aGUgY29tcG9uZW50LlxuICAgKiBVc2VkIGJ5IHRoZSBlcnJvciBzdGF0ZVxuICAgKi9cbiAgZW50ZXJFcnJvclN0YXRlICgpIHtcbiAgICB0aGlzLmFkZENsYXNzKCdwdWxzZS1jb21wb25lbnQtZXJyb3InKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIGRpc3BsYXkgbWVzc2FnZSBhbmQgcmVtb3ZlIHRoZSAncHVsc2UtY29tcG9uZW50LWVycm9yJyBjbGFzcyBmcm9tIHRoZSBjb21wb25lbnQuXG4gICAqIFVzZWQgYnkgdGhlIGVycm9yIHN0YXRlXG4gICAqL1xuICBleGl0RXJyb3JTdGF0ZSAoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygncHVsc2UtY29tcG9uZW50LWVycm9yJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgdGhlIGNvbXBvbmVudCBpdHNlbGYuIFNldCB0aGUgbmV4dCBzdGF0ZSBhdCB0aGUgZW5kIG9mIHRoZSBtZXRob2RcbiAgICovXG4gIHJlc2V0ICgpIHtcbiAgICB0aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcnJvciBtZXNzYWdlIHRoYXQgaXMgc2V0IGJ5IHRoZSBzZXRFcnJvciBtZXRob2RcbiAgICogXG4gICAqIEByZXR1cm4ge3N0cmluZ30gZXJyb3IgbWVzc2FnZVxuICAgKi9cbiAgZ2V0IGVycm9yTWVzc2FnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Vycm9yTWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAqIFNldCBhbiBlcnJvciBvbiB0aGUgY29tcG9uZW50IHdpdGhvdXQgZGlzcGxheWluZyBpdFxuICAqIFxuICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBzZXRcbiAgKi9cbiAgc2V0RXJyb3IgKG1lc3NhZ2UpIHtcbiAgICB0aGlzLl9lcnJvck1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGVycm9yIHRoYXQgaGFzIGJlZW4gcHJldmlvdXNseSBzdG9yZWRcbiAgICovXG4gIHNob3dFcnJvciAoKSB7XG4gICAgdGhpcy5kaXNwbGF5RXJyb3IodGhpcy5lcnJvck1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgdGhlIGVycm9yIG1lc3NhZ2VcbiAgICogVG8gYmUgb3ZlcnJpZGRlbiBieSB0aGUgc3ViLWNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gRXJyb3IgbWVzc2FnZSB0byBkaXNwbGF5XG4gICAqL1xuICBkaXNwbGF5RXJyb3IgKG1lc3NhZ2UpIHsgLy8gVG8gb3ZlcnJpZGVcbiAgICBpZiAobmV3LnRhcmdldCA9PT0gUHVsc2VJbml0aWFsaXplZENvbXBvbmVudCkgdGhyb3cgVHlwZUVycm9yKCdkaXNwbGF5RXJyb3Igb2YgYWJzdHJhY3QgY2xhc3MgUHVsc2VJbml0aWFsaXplZENvbXBvbmVudCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgZGlzcGxheWluZyB0aGUgZXJyb3IgbWVzc2FnZVxuICAgKiBUbyBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdWItY2xhc3NcbiAgICovXG4gIHJlbW92ZUVycm9yICgpIHsgLy8gVG8gb3ZlcnJpZGVcbiAgICBpZiAobmV3LnRhcmdldCA9PT0gUHVsc2VJbml0aWFsaXplZENvbXBvbmVudCkgdGhyb3cgVHlwZUVycm9yKCdyZW1vdmVFcnJvciBvZiBhYnN0cmFjdCBjbGFzcyBQdWxzZUluaXRpYWxpemVkQ29tcG9uZW50Jyk7XG4gIH1cblxuICAvKipcbiAgICogKFJlLSlzdGFydCBsb2FkaW5nIHRoZSBjb21wb25lbnQuXG4gICAqIFN3aXRjaCB0byBzdGF0ZSAncmVzZXQnIG9yICdpbml0aWFsJyBvciAncmVsb2FkJ1xuICAgKiB3aGV0aGVyIHRoZSBjb21wb25lbnQgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZCBvciBub3RcbiAgICovXG4gIHN0YXJ0ICgpIHtcbiAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKCkpIHsgLy8gaW5jbHVkaW5nICdTdG9wJyBDb250ZXh0XG4gICAgICB0aGlzLnN3aXRjaFRvQ29udGV4dCgnUmVzZXQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnN3aXRjaFRvQ29udGV4dCh0aGlzLnN0YXJ0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgY2FsbGJhY2sgaW4gY2FzZSBhIGNvbmZpZyBpcyB1cGRhdGVkOiAocmUtKXN0YXJ0IHRoZSBjb21wb25lbnRcbiAgICogXG4gICAqIEBwYXJhbSB7Kn0gZXZlbnQgXG4gICAqL1xuICBvbkNvbmZpZ0NoYW5nZSAoZXZlbnQpIHtcbiAgICAvLyBEZWZhdWx0ID0gZG8gbm90aGluZ1xuICAgIC8vIEV4YW1wbGUgOlxuICAgIC8vaWYgKCBldmVudC50YXJnZXQuY29uZmlnID09ICdteUNvbmZpZycpXG4gICAgLy8gIHRoaXMuc3RhcnQoKTtcbiAgfVxufVxuXG4vKipcbiAqIEFic3RyYWN0IHB1bHNlIGNvbXBvbmVudCBmb3IgY29tcG9uZW50cyB0aGF0IHBvdGVudGlhbGx5IHJ1biBBamF4IHJlcXVlc3RzXG4gKlxuICogQGV4dGVuZHMgbW9kdWxlOnB1bHNlQ29tcG9uZW50flB1bHNlSW5pdGlhbGl6ZWRDb21wb25lbnRcbiAqIFxuKiBAZ3JhcGggUmVxdWVzdF9TdGF0ZUZsb3dcbkBnIFxuQGcgICAgICAgIFJlcXVlc3QgKExvYWQsIE5vcm1hbCwgUmVsb2FkLCBOb3RBdmFpbGFibGUuLi4pIGNvbnRleHQ6IHN0YXRlIGZsb3dcbkBnIFxuQGcgXG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgfCAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgfCAgICB8ICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICB2ICAgIHYgICAgfCAgICAgICAgICAgICAgICAgICAgICAgdiAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICArLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICB8XG5AZyAgICAgPT0+IHwgICAgICAgICAgICAgfCAtLT4gfCAgICAgICB8IC0tPiB8ICAgICAgICAgICB8IC0tPiB8IFRyYW5zaWVudEVycm9yIHwgIHxcbkBnICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICB8ICAgICAgIHwgICAgIHwgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgfFxuQGcgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgIHwgICAgICAgfCAgICAgfCAgICAgICAgICAgfCAgICAgICBeICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgIHwgICBMb2FkaW5nICAgfCA8LS0gfCBEZWxheSB8IDwtLSB8IFRlbXBvcmFyeSB8ICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICB8ICAgICAgIHwgICAgIHwgICAgICAgICAgIHwgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgIHwgICAgICAgfCAgICAgfCAgICAgICAgICAgfCAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgfCAgICAgICB8IC0rICB8ICAgICAgICAgICB8IC0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLSsgIHwgICstLS0tLS0tLS0tLSsgICAgICAgfFxuQGcgICAgICAgICAgIEggICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgSCAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICB2XG4gKi9cbmNsYXNzIFB1bHNlUmVxdWVzdENvbXBvbmVudCBleHRlbmRzIFB1bHNlSW5pdGlhbGl6ZWRDb21wb25lbnQge1xuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogXG4gICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBzZWxmID0gc3VwZXIoLi4uYXJncyk7XG4gICAgc2VsZi5zdGF0ZXMgPSB1bmRlZmluZWQ7IC8vIEFic3RyYWN0XG4gICAgc2VsZi5fdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICBzZWxmLl9kZWZhdWx0RGVsYXlSYXRlID0gMTAwMDA7IC8vIDEwc1xuICAgIHNlbGYuX2RlZmF1bHRUcmFuc2llbnRFcnJvckRlbGF5ID0gMyAqIDYwICogMTAwMDsgLy8gMyBtaW51dGVzXG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogVGltZW91dCBmb3IgdGhlIGFqYXggcmVxdWVzdHMuIERlZmF1bHQgaXMgdW5kZWZpbmVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRpbWVvdXQgaW4gbXNcbiAgICovXG4gIGdldCB0aW1lb3V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSB0aW1lb3V0IG9mIHRoZSBhamF4IHJlcXVlc3RzXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IC0gVGltZW91dCBpbiBtc1xuICAgKi9cbiAgc2V0IHRpbWVvdXQgKHRpbWVvdXQpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gdGltZW91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxheSBpbiBtcyB0byB3YWl0IGluIGNhc2Ugb2YgYSBkZWxheSBlcnJvci5cbiAgICogRGVmYXVsdCBpcyAxMHMuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gRGVsYXkgcmF0ZSBpbiBtc1xuICAgKi9cbiAgZ2V0IGRlbGF5UmF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHREZWxheVJhdGU7XG4gIH1cblxuICAvKipcbiAgICogRGVsYXkgaW4gbXMgYmVmb3JlIHN3aXRjaGluZyB0byBhIHRyYW5zaWVudCBlcnJvci5cbiAgICogRGVmYXVsdCBpcyA1IG1pbnV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gRGVsYXkgaW4gbXNcbiAgICovXG4gIGdldCB0cmFuc2llbnRFcnJvckRlbGF5ICgpIHtcbiAgICByZXR1cm4gTnVtYmVyKHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ3N0b3BSZWZyZXNoaW5nUmF0ZS5mcmVlemVNaW51dGVzJywgdGhpcy5fZGVmYXVsdFRyYW5zaWVudEVycm9yRGVsYXkgLyA2MCAvIDEwMDApKSAqIDYwICogMTAwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcmwgdG8gdXNlIGJ5IHRoZSBBamF4IHJlcXVlc3QuXG4gICAqIFRvIGJlIG92ZXJyaWRkZW5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBVcmwgdG8gdXNlIGluIHRoZSBhamF4IHJlcXVlc3RcbiAgICovXG4gIGdldCB1cmwgKCkgeyAvLyBUbyBvdmVycmlkZVxuICAgIGlmIChuZXcudGFyZ2V0ID09PSBQdWxzZVJlcXVlc3RDb21wb25lbnQpIHRocm93IFR5cGVFcnJvcigndXJsIG9mIGFic3RyYWN0IGNsYXNzIFB1bHNlUmVxdWVzdENvbXBvbmVudCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgQ1NTIGNsYXNzICdwdWxzZS1jb21wb25lbnQtd2FybmluZycgaW4gY2FzZSB0aGUgY29tcG9uZW50IGVudGVycyBhIFRyYW5zaWVudEVycm9yU3RhdGVcbiAgICovXG4gIGVudGVyVHJhbnNpZW50RXJyb3JTdGF0ZSAoKSB7XG4gICAgdGhpcy5hZGRDbGFzcygncHVsc2UtY29tcG9uZW50LXdhcm5pbmcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIENTUyBjbGFzcyAncHVsc2UtY29tcG9uZW50LXdhcm5pbmcnIGFuZCB0aGUgZXJyb3IgbWVzc2FnZSBpbiBjYXNlIHRoZSBjb21wb25lbnQgZXhpdHMgYSBUcmFuc2llbnRFcnJvclN0YXRlXG4gICAqL1xuICBleGl0VHJhbnNpZW50RXJyb3JTdGF0ZSAoKSB7XG4gICAgdGhpcy5yZW1vdmVDbGFzcygncHVsc2UtY29tcG9uZW50LXdhcm5pbmcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEbyBub3RoaW5nIHNwZWNpYWwgaW4gY2FzZSBvZiByZWxvYWQuXG4gICAqIFRvIGJlIG92ZXJyaWRkZW4gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgYmVmb3JlUmVsb2FkICgpIHtcbiAgICAvLyBEZWZhdWx0OiBkbyBub3RoaW5nIHNwZWNpYWxcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbmV4dCBjb250ZXh0IGlzIGxvYWRlZC5cbiAgICogVG8gYmUgb3ZlcnJpZGRlblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIEFqYXggcmVxdWVzdCByZXNwb25zZVxuICAgKi9cbiAgcmVmcmVzaCAoZGF0YSkgeyAvLyBUbyBvdmVycmlkZVxuICAgIGlmIChuZXcudGFyZ2V0ID09PSBQdWxzZVJlcXVlc3RDb21wb25lbnQpIHRocm93IFR5cGVFcnJvcigncmVmcmVzaCBvZiBhYnN0cmFjdCBjbGFzcyBQdWxzZVJlcXVlc3RDb21wb25lbnQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdGhhdCBpcyBjYWxsZWQgaW4gY2FzZSBvZiBBamF4IHJlcXVlc3Qgc3VjY2Vzcy5cbiAgICogXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFxuICAgKi9cbiAgbWFuYWdlU3VjY2VzcyAoZGF0YSkge1xuICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgoKSA9PiB0aGlzLnJlZnJlc2goZGF0YSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB0aGF0IGlzIGNhbGxlZCBpbiBjYXNlIHRoZSBBamF4IHJlcXVlc3QgcmV0dXJucyBhbiBlcnJvci5cbiAgICogVGhlIFN0YXR1cyBwcm9wZXJ0eSBvZiB0aGUgcmV0dXJuZWQgYW5zd2VyIGlzIHByb2Nlc3NlZCBieSB0aGUgbWFuYWdlRXJyb3JTdGF0dXMgbWV0aG9kcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBBamF4IGVycm9yIHJlc3BvbnNlXG4gICAqL1xuICBtYW5hZ2VFcnJvciAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ21hbmFnZUVycm9yOiBkYXRhIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgdGhpcy5zd2l0Y2hUb0tleSgnRXJyb3InLCAoKSA9PiB0aGlzLmRpc3BsYXlFcnJvcigndW5kZWZpbmVkIGVycm9yIGRhdGEnKSwgKCkgPT4gdGhpcy5yZW1vdmVFcnJvcigpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN0YXR1cyA9IGRhdGEuU3RhdHVzO1xuICAgIGlmICh0eXBlb2Ygc3RhdHVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcignbWFuYWdlRXJyb3I6IGRhdGEuU3RhdHVzIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgdGhpcy5zd2l0Y2hUb0tleSgnRXJyb3InLCAoKSA9PiB0aGlzLmRpc3BsYXlFcnJvcigndW5kZWZpbmVkIGVycm9yIGRhdGEgc3RhdHVzJyksICgpID0+IHRoaXMucmVtb3ZlRXJyb3IoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTmV3IGVycm9yIHN0YXR1c1xuICAgIGlmICh0aGlzLm1hbmFnZUVycm9yU3RhdHVzKHN0YXR1cywgZGF0YS5FcnJvck1lc3NhZ2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5lcnJvcihgbWFuYWdlRXJyb3I6IGRhdGEgc3RhdHVzICR7c3RhdHVzfSBpcyB1bmtub3duLCBtZXNzYWdlPSR7ZGF0YS5FcnJvck1lc3NhZ2V9YCk7XG4gICAgbGV0IGVycm9yTWVzc2FnZTtcbiAgICBpZiAodHlwZW9mIChzdGF0dXMpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBgdW5rbm93biBzdGF0dXMgJHtzdGF0dXN9LCAke2RhdGEuRXJyb3JNZXNzYWdlfWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZXJyb3JNZXNzYWdlID0gZGF0YS5FcnJvck1lc3NhZ2U7XG4gICAgfVxuICAgIHRoaXMuc3dpdGNoVG9LZXkoJ0Vycm9yJywgKCkgPT4gdGhpcy5kaXNwbGF5RXJyb3IoZXJyb3JNZXNzYWdlLCAoKSA9PiB0aGlzLnJlbW92ZUVycm9yKCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyeSBpbW1lZGlhdGVseSB0aGUgQWpheCByZXF1ZXN0LlxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlXG4gICAqL1xuICByZXRyeUltbWVkaWF0ZWx5IChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVLZXkgPT0gJ1RyYW5zaWVudEVycm9yJykge1xuICAgICAgdGhpcy5zd2l0Y2hUb0tleSgnVHJhbnNpZW50RXJyb3InLCAoKSA9PiB0aGlzLmRpc3BsYXlFcnJvcihtZXNzYWdlKSwgKCkgPT4gdGhpcy5yZW1vdmVFcnJvcigpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnN3aXRjaFRvS2V5KCdUZW1wb3JhcnknLCAoKSA9PiB0aGlzLnNldEVycm9yKG1lc3NhZ2UpLCAoKSA9PiB0aGlzLnNldEVycm9yKCcnKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJ5IHdpdGggYSBkZWxheSB0aGUgQWpheCByZXF1ZXN0LlxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlXG4gICAqL1xuICByZXRyeVdpdGhEZWxheSAobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLnN0YXRlS2V5ID09ICdUcmFuc2llbnRFcnJvcicpIHtcbiAgICAgIHRoaXMuc3dpdGNoVG9LZXkoJ1RyYW5zaWVudEVycm9yJywgKCkgPT4gdGhpcy5kaXNwbGF5RXJyb3IobWVzc2FnZSksICgpID0+IHRoaXMucmVtb3ZlRXJyb3IoKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5zd2l0Y2hUb0tleSgnRGVsYXknLCAoKSA9PiB0aGlzLnNldEVycm9yKG1lc3NhZ2UpLCAoKSA9PiB0aGlzLnNldEVycm9yKCcnKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgbWV0aG9kIHRvIG1hbmFnZSB0aGUgbmV3IGVycm9yIHN0YXR1c1xuICAgKiBUbyBiZSBvdmVycmlkZGVuIGluIGNhc2Ugb2YgYSBub24tc3RhbmRhcmQgYmVoYXZpb3Igb2YgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1cyAtIEVycm9yIHJlc3BvbnNlIHN0YXR1c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEVycm9yIHJlc3BvbnNlIG1lc3NhZ2VcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHN0YXR1cyB3YXMgcHJvY2Vzc2VkXG4gICAqL1xuICBtYW5hZ2VFcnJvclN0YXR1cyAoc3RhdHVzLCBtZXNzYWdlKSB7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgJ0F1dGhvcml6YXRpb25FcnJvcic6IHtcbiAgICAgICAgaWYgKHB1bHNlTG9naW4udG9rZW5OZWVkUmVmcmVzaCgpKSB7XG4gICAgICAgICAgcHVsc2VMb2dpbi5yZWZyZXNoVG9rZW4oKTtcblxuICAgICAgICAgIC8vIERlbGF5ZWQgZGlzcGxheSA6IChzaG91bGQgbmV2ZXIgaGFwcGVuIGV4Y2VwdGVkIG1heWJlIGluIGNoZWNrbG9naW4pXG4gICAgICAgICAgdGhpcy5yZXRyeVdpdGhEZWxheSgnQXV0aGVudGljYXRpb24gRXJyb3IuIFBsZWFzZSByZXRyeScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHB1bHNlQ29uZmlnLnNldEdsb2JhbCgnbG9naW5FcnJvcicsICdBdXRoZW50aWNhdGlvbiBFcnJvci4gUGxlYXNlIHJldHJ5Jyk7XG4gICAgICAgICAgLy8gQ2xlYW4gYWxsIGNvb2tpZXMgbGlua2VkIHRvIGxvZ2luXG4gICAgICAgICAgcHVsc2VMb2dpbi5jbGVhbkxvZ2luUm9sZSgpO1xuXG4gICAgICAgICAgLy8gR290byBwYWdlIGxvZ2luIHdpdGggYW4gZXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWRcbiAgICAgICAgICBpZiAoIXB1bHNlQ29uZmlnLmlzTG9naW5QYWdlKCkpIHsgLy8gSWYgbm90IGluIHBhZ2UgbG9naW5cbiAgICAgICAgICAgIHB1bHNlQ29uZmlnLmdvVG9QYWdlTG9naW4oKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBicmVhaztcbiAgICAgIGNhc2UgJ01pc3NpbmdDb25maWd1cmF0aW9uJzoge1xuICAgICAgICAvLyBTZW5kIE1lc3NhZ2UgdG8gZGlzcGxheSBvbiB0b3BcbiAgICAgICAgbGV0IG1lc3NhZ2VJbmZvID0ge1xuICAgICAgICAgICdpZCc6ICdXQVJOSU5HX01JU1NJTkdfSU5GTycsXG4gICAgICAgICAgJ2xldmVsJzogJ3dhcm5pbmcnLFxuICAgICAgICAgICdjbGlja1RvQ2xvc2UnOiB0cnVlLFxuICAgICAgICAgICd0aW1lJzogNDUsIC8vIHNlY29uZHMgdG8gZGlzcGxheSBtZXNzYWdlXG4gICAgICAgICAgJ21lc3NhZ2UnOiBwdWxzZUNvbmZpZy5wdWxzZVRyYW5zbGF0ZSgnbWlzc2luZ2NvbmZpZ3VyYXRpb24nLCAnTWlzc2luZyBjb25maWd1cmF0aW9uJylcbiAgICAgICAgICAgICsgJzogJyArIG1lc3NhZ2UgKyAnIFxcclxcbidcbiAgICAgICAgICAgICsgcHVsc2VDb25maWcucHVsc2VUcmFuc2xhdGUoJ2NvbnRhY3RzdXBwb3J0JyxcbiAgICAgICAgICAgICAgJ1BsZWFzZSBjb250YWN0IHRoZSBzdXBwb3J0IHRlYW0nKSxcbiAgICAgICAgICAnaW50ZXJuYWxMQVQnOiAnc3RhdHVzOicgKyBzdGF0dXMgKyAnLiBGdWxsIG1lc3NhZ2U6ICcgKyBtZXNzYWdlXG4gICAgICAgICAgICArICcoJyArIHRoaXMuZWxlbWVudC50YWdOYW1lICsgJyknXG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ3Nob3dNZXNzYWdlU2lnbmFsJywgbWVzc2FnZUluZm8pO1xuXG4gICAgICAgIHRoaXMuc3dpdGNoVG9LZXkoJ0Vycm9yJywgKCkgPT4gdGhpcy5kaXNwbGF5RXJyb3IobWVzc2FnZSksICgpID0+IHRoaXMucmVtb3ZlRXJyb3IoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY2FzZSAnV3JvbmdSZXF1ZXN0UGFyYW1ldGVyJzpcbiAgICAgIGNhc2UgJ1VuZXhwZWN0ZWRFcnJvcic6IHtcbiAgICAgICAgLy8gU2VuZCBNZXNzYWdlIHRvIGRpc3BsYXkgb24gdG9wXG4gICAgICAgIGxldCBtZXNzYWdlSW5mbyA9IHtcbiAgICAgICAgICAnaWQnOiAnRVJST1JfQ0FMTF9TVVBQT1JUJyxcbiAgICAgICAgICAnbGV2ZWwnOiAnZXJyb3InLCAvLyBvciAnd2FybmluZycsID9cbiAgICAgICAgICAnY2xpY2tUb0Nsb3NlJzogdHJ1ZSxcbiAgICAgICAgICAndGltZSc6IDQ1LCAvLyBzZWNvbmRzIHRvIGRpc3BsYXkgbWVzc2FnZVxuICAgICAgICAgICdtZXNzYWdlJzogJ0VSUk9SIDogJyArIHB1bHNlQ29uZmlnLnB1bHNlVHJhbnNsYXRlKCdjb250YWN0c3VwcG9ydCcsXG4gICAgICAgICAgICAncGxlYXNlIGNvbnRhY3QgdGhlIHN1cHBvcnQgdGVhbScpLFxuICAgICAgICAgICdpbnRlcm5hbExBVCc6ICdzdGF0dXM6JyArIHN0YXR1cyArICcuIEZ1bGwgbWVzc2FnZSA6ICcgKyBtZXNzYWdlXG4gICAgICAgICAgICArICcoJyArIHRoaXMuZWxlbWVudC50YWdOYW1lICsgJyknXG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ3Nob3dNZXNzYWdlU2lnbmFsJywgbWVzc2FnZUluZm8pO1xuXG4gICAgICAgIHRoaXMuc3dpdGNoVG9LZXkoJ0Vycm9yJywgKCkgPT4gdGhpcy5kaXNwbGF5RXJyb3IobWVzc2FnZSksICgpID0+IHRoaXMucmVtb3ZlRXJyb3IoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY2FzZSAnTm90QXBwbGljYWJsZSc6XG4gICAgICAgIHRoaXMubWFuYWdlTm90QXBwbGljYWJsZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ1Byb2Nlc3NpbmdEZWxheSc6XG4gICAgICAgIHRoaXMucmV0cnlXaXRoRGVsYXkobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnVHJhbnNpZW50UHJvY2Vzc0Vycm9yJzpcbiAgICAgIGNhc2UgJ1N0YWxlJzpcbiAgICAgICAgdGhpcy5yZXRyeUltbWVkaWF0ZWx5KG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ0RhdGFiYXNlQ29ubmVjdGlvbkVycm9yJzogeyAvLyA9IGRhdGFiYXNlIHVuYXZhaWxhYmxlXG4gICAgICAgIC8vIFN0b3AgYWxsIHJlZnJlc2ggOlxuICAgICAgICBsZXQgdGFyZ2V0ID0ge1xuICAgICAgICAgIC8vdXJsOiB1cmwsXG4gICAgICAgICAgc291cmNlOiB0aGlzLmVsZW1lbnQudGFnTmFtZSxcbiAgICAgICAgICB3aGVuOiBuZXcgRGF0ZSgpXG4gICAgICAgIH07XG4gICAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ2RhdGFiYXNlUHJvYmFibHlEaXNjb25uZWN0ZWQnLCB0YXJnZXQpO1xuXG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50LnRhZ05hbWUudG9VcHBlckNhc2UoKS5pbmNsdWRlcygnWC1DSEVDSycpIC8vIGlmICgodGhpcy5lbGVtZW50LnRhZ05hbWUgIT0gJ1gtQ0hFQ0tTRVJWRVJBQ0NFU1MnKVxuICAgICAgICAgICYmICh0aGlzLmVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9ICdYLU1FU1NBR0UnKSkge1xuICAgICAgICAgIHRoaXMuc3dpdGNoVG9LZXkoJ0Vycm9yJywgKCkgPT4gdGhpcy5kaXNwbGF5RXJyb3IobWVzc2FnZSksICgpID0+IHRoaXMucmVtb3ZlRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gRE8gTk9UIERPIHRoaXMgISEhIE5leHQgY29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGlmIGNvbnRleHQgPSBzdG9wXG4gICAgICAgICAgLy90aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKCkgPT4gdGhpcy5yZWZyZXNoKCkpO1xuICAgICAgICAgIHRoaXMuc3dpdGNoVG9Db250ZXh0KCdOb3JtYWwnKTsgLy8gRG8gbm90IHVzZSBcInN0YXJ0XCIgYmVjYXVzZSBpdCBjb3VsZCBub3QgZXhpdCBsb2FkaW5nIHN0YXRlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjYXNlICdQdWxzZU1haW50ZW5hbmNlJzogeyAvLyA9IG1haW50ZW5hbmNlIGlzIHN0YXJ0ZWQgKHNlcnZlciBtYXkgYmUgb2ZmIHNvb24pXG4gICAgICAgIC8vIFN0b3AgYWxsIHJlZnJlc2ggOlxuICAgICAgICBsZXQgdGFyZ2V0ID0ge1xuICAgICAgICAgIC8vdXJsOiB1cmwsXG4gICAgICAgICAgc291cmNlOiB0aGlzLmVsZW1lbnQudGFnTmFtZSxcbiAgICAgICAgICB3aGVuOiBuZXcgRGF0ZSgpXG4gICAgICAgIH07XG5cbiAgICAgICAgZXZlbnRCdXMuRXZlbnRCdXMuZGlzcGF0Y2hUb0FsbCgncHVsc2VNYWludGVuYW5jZScsIHRhcmdldCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKCdYLUNIRUNLJykgLy8gaWYgKCh0aGlzLmVsZW1lbnQudGFnTmFtZSAhPSAnWC1DSEVDS1NFUlZFUkFDQ0VTUycpXG4gICAgICAgICAgJiYgKHRoaXMuZWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT0gJ1gtTUVTU0FHRScpKSB7XG4gICAgICAgICAgLy8gV2l0aCBlbXB0eSBtZXNzYWdlXG4gICAgICAgICAgdGhpcy5zd2l0Y2hUb0tleSgnRXJyb3InLCAoKSA9PiB0aGlzLmRpc3BsYXlFcnJvcignJyksICgpID0+IHRoaXMucmVtb3ZlRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vID09IElnbm9yZSA/Pz9cbiAgICAgICAgICAvLyBETyBOT1QgRE8gdGhpcyAhISEgTmV4dCBjb250ZXh0IGlzIG5vdCBhdmFpbGFibGUgaWYgY29udGV4dCA9IHN0b3BcbiAgICAgICAgICAvL3RoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgoKSA9PiB0aGlzLnJlZnJlc2goKSk7XG4gICAgICAgICAgLy9pZiAodGhpcy5lbGVtZW50LnRhZ05hbWUgPT0gJ1gtQ0hFQ0tTRVJWRVJBQ0NFU1MnKSB7XG4gICAgICAgICAgICB0aGlzLnN3aXRjaFRvQ29udGV4dCgnTm9ybWFsJyk7IC8vIEVsc2UgY2FuIHN0YXkgaW4gTG9hZGluZyBjb250ZXh0IGFuZCBuZXZlciBjaGVjayBhZ2FpblxuICAgICAgICAgIC8vfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYW5hZ2UgdGhlIGNhc2Ugd2hlbiB0aGUgY29tcG9uZW50IGRhdGEgZG9lcyBub3QgYXBwbHlcbiAgICogU3dpdGNoIGJ5IGRlZmF1bHQgdG8gdGhlIHN0YXRlICdOb3RBcHBsaWNhYmxlJyBhbmQgYWRkIHRoZSBjbGFzcyBwdWxzZS1jb21wb25lbnQtbm90LWFwcGxpY2FibGVcbiAgICovXG4gIG1hbmFnZU5vdEFwcGxpY2FibGUgKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3B1bHNlLWNvbXBvbmVudC1ub3QtYXBwbGljYWJsZScpO1xuICAgIHRoaXMuc3dpdGNoVG9Db250ZXh0KCdOb3RBcHBsaWNhYmxlJyk7XG4gIH1cblxuICAvKipcbiAgICogTWFuYWdlIGFuIE9sZCBOT19EQVRBIGVycm9yIHN0YXR1cy5cbiAgICogQnkgZGVmYXVsdCwgcnVuIHRoZSByZXRyeVdpdGhEZWxheSBtZXRob2QsIGJ1dCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpbiBjYXNlIG9uZSB0aGUgZm9sbG93aW5nIHNlcnZpY2VzIGlzIHVzZWQ6XG4gICAqIEdldExpc3RPZlNoaWZ0U2xvdFNlcnZpY2UsIEdldE1hY2hpbmVTdGF0dXNCeUlXUCwgR2V0U2hpZnRBcm91bmQvQWZ0ZXIvQmVmb3JlLCBHZXRGaWVsZExlZ2VuZHNGb3JNYWNoaW5lLFxuICAgKiBHZXRNYWNoaW5lUGVyZm9ybWFuY2VEYXkoVjIpLCBHZXRNb2RlQ29sb3IsIEdldE1hY2hpbmVTdGF0dXMsIEdldFJlYXNvblNsb3RzKFYzKVxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFcnJvciBtZXNzYWdlXG4gICAqL1xuICBtYW5hZ2VPbGROb0RhdGEgKG1lc3NhZ2UpIHtcbiAgICAvLyBEZWZhdWx0OiBkZWxheVxuICAgIHRoaXMucmV0cnlXaXRoRGVsYXkobWVzc2FnZSk7XG4gICAgLy8gQnV0OlxuICAgIC8vIC0gR2V0TGlzdE9mU2hpZnRTbG90U2VydmljZTogbm90IGFwcGxpY2FibGVcbiAgICAvLyAtIEdldE1hY2hpbmVTdGF0dXNCeUlXUDogbm90IGFwcGxpY2FibGVcbiAgICAvLyAtIEdldFNoaWZ0QXJvdW5kL0FmdGVyL0JlZm9yZTogbm90IGFwcGxpY2FibGVcbiAgICAvLyAtIEdldEZpZWxkTGVnZW5kc0Zvck1hY2hpbmU6IG5vdCBhcHBsaWNhYmxlXG4gICAgLy8gLSBHZXRNYWNoaW5lUGVyZm9ybWFuY2VEYXkoVjIpOiBkZWxheSBvciBwZXJtYW5lbnRcbiAgICAvLyAtIEdldE1vZGVDb2xvcjogZGVsYXkgb3IgcGVybWFuZW50XG4gICAgLy8gLSBHZXRNYWNoaW5lU3RhdHVzOiBkZWxheSBvciBwZXJtYW1lbnRcbiAgICAvLyAtIEdldFJlYXNvblNsb3RzKFYzKTogZGVsYXkgb3IgcGVybWFuZW50XG4gIH1cblxuICAvKipcbiAgICogTWFuYWdlIGFuIEFqYXggZmFpbHVyZS5cbiAgICogRWl0aGVyIHJldHJ5IHdpdGggZGVsYXkgaW4gY2FzZSBvZiBhIHRpbWUgb3V0IG9yIHN3aXRjaCB0byBhbiAnZXJyb3InIHN0YXRlIGVsc2VcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1RpbWVvdXQgLSBUaW1lIG91dFxuICAgKiBAcGFyYW0ge251bWJlcn0geGhyU3RhdHVzIC0gWE1MSHR0cFJlcXVlc3Quc3RhdHVzIG9mIHRoZSBBamF4IHJlcXVlc3RcbiAgICovXG4gIG1hbmFnZUZhaWx1cmUgKGlzVGltZW91dCwgeGhyU3RhdHVzKSB7XG4gICAgaWYgKGlzVGltZW91dCkge1xuICAgICAgdGhpcy5yZXRyeVdpdGhEZWxheSgndGltZSBvdXQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsZXQgbWVzc2FnZSA9IHB1bHNlU2VydmljZS5nZXRBamF4RXJyb3JNZXNzYWdlKHhoclN0YXR1cyk7XG4gICAgICBpZiAoKHhoclN0YXR1cyA9PSAnMCcpIHx8ICh4aHJTdGF0dXMgPT0gJzUwMCcpIHx8ICh4aHJTdGF0dXMgPT0gJzUwNCcpKSB7XG4gICAgICAgIHRoaXMucmV0cnlXaXRoRGVsYXkobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5zd2l0Y2hUb0tleSgnRXJyb3InLCAoKSA9PiB0aGlzLmRpc3BsYXlFcnJvcihtZXNzYWdlKSwgKCkgPT4gdGhpcy5yZW1vdmVFcnJvcigpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlICdsb2FkaW5nJyBzdGF0ZSBpcyBlbnRlcmVkLlxuICAgKiBCeSBkZWZhdWx0IGFkZCB0aGUgY3NzIGNsYXNzICdwdWxzZS1jb21wb25lbnQtbG9hZGluZycuXG4gICAqL1xuICBzdGFydExvYWRpbmcgKCkge1xuICAgIHRoaXMuYWRkQ2xhc3MoJ3B1bHNlLWNvbXBvbmVudC1sb2FkaW5nJyk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlICdsb2FkaW5nJyBzdGF0ZSBpcyBleGl0ZWQuXG4gICAqIEJ5IGRlZmF1bHQgcmVtb3ZlIHRoZSBjc3MgY2xhc3MgJ3B1bHNlLWNvbXBvbmVudC1sb2FkaW5nJy5cbiAgICovXG4gIGVuZExvYWRpbmcgKCkge1xuICAgIHRoaXMucmVtb3ZlQ2xhc3MoJ3B1bHNlLWNvbXBvbmVudC1sb2FkaW5nJyk7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBldmVudCBjYWxsYmFjayBpbiBjYXNlIHNlcnZlciBpcyBvZmYgOiBTVE9QIHRoZSBjb21wb25lbnRcbiAgICogXG4gICAqIEBwYXJhbSB7Kn0gZXZlbnQgXG4gICAqL1xuICBvblNlcnZlck9mZlN0b3BSZWZyZXNoIChldmVudCkge1xuICAgIGlmICghdGhpcy5lbGVtZW50LnRhZ05hbWUudG9VcHBlckNhc2UoKS5pbmNsdWRlcygnWC1DSEVDSycpKSB7Ly8gaWYgKHRoaXMuZWxlbWVudC50YWdOYW1lICE9ICdYLUNIRUNLU0VSVkVSQUNDRVNTJykge1xuICAgICAgLy9pZiAodGhpcy5zdGF0ZUNvbnRleHQgIT0gJ0xvYWRlZCcpIHtcbiAgICAgIHRoaXMuZGlzcGxheUVycm9yKCcnKTsgLy8gRW1wdHkgdG8gaGlkZSBhbGwgdGV4dHNcbiAgICAgIHRoaXMuX3NlcnZlcklzT2ZmID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3dpdGNoVG9Db250ZXh0KCdTdG9wJyk7XG4gICAgICAvL31cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBldmVudCBjYWxsYmFjayBpbiBjYXNlIHNlcnZlciBpcyBhdmFpbGFibGU6IChyZS0pc3RhcnQgdGhlIGNvbXBvbmVudFxuICAgKiBcbiAgICogQHBhcmFtIHsqfSBldmVudCBcbiAgICovXG4gIG9uU2VydmVyQXZhaWxhYmxlQ2hhbmdlIChldmVudCkge1xuICAgIC8vIE5PVCBORUVERUQgYmVjYXVzZSBvZiBfc2VydmVySXNPZmYgXG4gICAgLy9pZiAoIXRoaXMuZWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoJ1gtQ0hFQ0snKSkgeyAvLyBpZiAodGhpcy5lbGVtZW50LnRhZ05hbWUgIT0gJ1gtQ0hFQ0tTRVJWRVJBQ0NFU1MnKSB7XG4gICAgaWYgKHRydWUgPT0gdGhpcy5fc2VydmVySXNPZmYpIHtcbiAgICAgIHRoaXMuX3NlcnZlcklzT2ZmID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICAgIC8vfVxuICB9XG5cbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyBmb3IgUHVsc2UgY29tcG9uZW50cyB0aGF0IHJ1biBhIHNpbmdsZSBBamF4IHJlcXVlc3QgZHVyaW5nIHRoZSBsb2FkaW5nIHBoYXNlXG4gKlxuICogQXZhaWxhYmxlIGNvbnRleHRzOiBJbml0aWFsaXphdGlvbiwgUmVzZXQsIExvYWQsIExvYWRlZCwgUmVsb2FkLCBTdG9wLCBOb3RBcHBsaWNhYmxlXG4gKlxuICogQXZhaWxhYmxlIHN0YXRlczogSW5pdGlhbGl6aW5nLCBFcnJvciwgTG9hZGluZywgU3RhbmRhcmQsIFRlbXBvcmFyeSwgRGVsYXksIFRyYW5zaWVudEVycm9yLCBFcnJvclxuICpcbiAqIFNvbWUgc3RhdGUgZmxvd3M6XG4gKiBEZWZhdWx0IGZsb3c6IEluaXRpYWxpemF0aW9uOkluaXRpYWxpemluZyAtPiBMb2FkOkxvYWRpbmcgLT4gTG9hZGVkOlN0YW5kYXJkXG4gKiBJbml0aWFsaXphdGlvbiBlcnJvciBmbG93OiBJbml0aWFsaXphdGlvbjpJbml0aWFsaXppbmcgLT4gSW5pdGlhbGl6YXRpb246RXJyb3JcbiAqIEFqYXggdHJhbnNpZW50IGVycm9yIGZsb3c6IEluaXRpYWxpemF0aW9uOkluaXRpYWxpemluZyAtPiBMb2FkOkxvYWRpbmcgLT4gTG9hZDpUZW1wb3JhcnkgLT4gLi4uIC0+IExvYWQ6VHJhbnNpZW50RXJyb3JcbiAqXG4gKiBTdGF0ZSBpbXBsZW1lbnRhdGlvbnM6XG4gKiAtIEluaXRpYWxpemF0aW9uOkluaXRpYWxpemluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+SW5pdGlhbFN0YXRlfVxuICogLSBSZXNldDpJbml0aWFsaXppbmcgLSB7QGxpbmsgbW9kdWxlOnN0YXRlflJlc2V0U3RhdGV9XG4gKiAtIExvYWRlZDpTdGFuZGFyZCAtIHtAbGluayBtb2R1bGU6c3RhdGV+U3RhdGljU3RhdGV9XG4gKiAtIFN0b3A6U3RhbmRhcmQgLSB7QGxpbmsgbW9kdWxlOnN0YXRlflN0b3BTdGF0ZX1cbiAqIC0gTG9hZDpMb2FkaW5nIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5Mb2FkU3RhdGV9XG4gKiAtIFJlbG9hZDpMb2FkaW5nIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5SZWxvYWRTdGF0ZX1cbiAqIC0gKjpUZW1wb3JhcnkgLSB7QGxpbmsgbW9kdWxlOnN0YXRlflRlbXBvcmFyeVN0YXRlfVxuICogLSAqOkRlbGF5IC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5EZWxheVN0YXRlfVxuICogLSAqOlRyYW5zaWVudEVycm9yIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5UcmFuc2llbnRFcnJvclN0YXRlfVxuICogLSBOb3RBcHBsaWNhYmxlOlN0YW5kYXJkIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5Ob3RBcHBsaWNhYmxlU3RhdGV9XG4gKiAtICo6RXJyb3IgLSB7QGxpbmsgbW9kdWxlOnN0YXRlfkVycm9yU3RhdGV9XG4gKiBcbiAqIEBleHRlbmRzIG1vZHVsZTpwdWxzZUNvbXBvbmVudH5QdWxzZVJlcXVlc3RDb21wb25lbnRcbiAqIFxuKiBAZ3JhcGggU2luZ2xlUmVxdWVzdF9Db250ZXh0Rmxvd1xuQGcgXG5AZyAgICAgICAgICAgICBTaW5nbGUgcmVxdWVzdCBjb21wb25lbnQ6IGNvbnRleHQgZmxvd1xuQGcgXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IE5vdEFwcGxpY2FibGUgfFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLStcbkBnICAgICA9PT4gfCBJbml0aWFsaXphdGlvbiB8ID09PiB8ICAgICBMb2FkICAgICAgfCA9PT4gfCBMb2FkZWQgfFxuQGcgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgXlxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSCAgICAgICAgICAgICAgICAgICAgIEhcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEggICAgICAgICAgICAgICAgICAgICBIXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgICBIICAgICAgICAgICAgICAgICAgICAgSFxuQGcgICAgIC4uPiB8ICAgICBSZXNldCAgICAgIHwgPT09PT09IyAgICAgICAgICAgICAgICAgICAgIEhcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICAgICAgSFxuQGcgICAgIC4uPiB8ICAgICAgU3RvcCAgICAgIHwgLS0+IHwgICAgUmVsb2FkICAgICB8ID09PT09PSNcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXlxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOlxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOlxuKiBAZ3JhcGggSW5pdGlhbGl6YXRpb25fU3RhdGVGbG93XG5AZyBcbkBnICBJbml0aWFsaXphdGlvbiBjb250ZXh0OiBzdGF0ZSBmbG93XG5AZyBcbkBnICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICA9PT4gfCBJbml0aWFsaXppbmcgfCA9PT5cbkBnICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICB2XG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgIHwgICAgRXJyb3IgICAgIHxcbkBnICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0rXG4qIEBncmFwaCBSZXF1ZXN0X1N0YXRlRmxvd1xuQGcgXG5AZyAgICAgICAgUmVxdWVzdCAoTG9hZCwgTm9ybWFsLCBSZWxvYWQsIE5vdEF2YWlsYWJsZS4uLikgY29udGV4dDogc3RhdGUgZmxvd1xuQGcgXG5AZyBcbkBnICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICB8ICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICB8ICAgIHwgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIHYgICAgdiAgICB8ICAgICAgICAgICAgICAgICAgICAgICB2ICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0tLS0tLSsgIHxcbkBnICAgICA9PT4gfCAgICAgICAgICAgICB8IC0tPiB8ICAgICAgIHwgLS0+IHwgICAgICAgICAgIHwgLS0+IHwgVHJhbnNpZW50RXJyb3IgfCAgfFxuQGcgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgIHwgICAgICAgfCAgICAgfCAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICB8XG5AZyAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgfCAgICAgICB8ICAgICB8ICAgICAgICAgICB8ICAgICAgIF4gICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgfCAgIExvYWRpbmcgICB8IDwtLSB8IERlbGF5IHwgPC0tIHwgVGVtcG9yYXJ5IHwgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgIHwgICAgICAgfCAgICAgfCAgICAgICAgICAgfCAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgfCAgICAgICB8ICAgICB8ICAgICAgICAgICB8ICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICB8ICAgICAgIHwgLSsgIHwgICAgICAgICAgIHwgLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICArLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tKyAgfCAgKy0tLS0tLS0tLS0tKyAgICAgICB8XG5AZyAgICAgICAgICAgSCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICBIICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgIHZcbiAqL1xuY2xhc3MgUHVsc2VTaW5nbGVSZXF1ZXN0Q29tcG9uZW50IGV4dGVuZHMgUHVsc2VSZXF1ZXN0Q29tcG9uZW50IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBzZWxmID0gc3VwZXIoLi4uYXJncyk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqIFxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGNvbnRleHQgLSBDb250ZXh0XG4gICAqIEByZXR1cm4geyFzdHJpbmd9IGtleVxuICAgKi9cbiAgZ2V0U3RhcnRLZXkgKGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgIGNhc2UgJ0luaXRpYWxpemF0aW9uJzpcbiAgICAgIGNhc2UgJ1Jlc2V0JzpcbiAgICAgICAgcmV0dXJuICdJbml0aWFsaXppbmcnO1xuICAgICAgY2FzZSAnTG9hZCc6XG4gICAgICBjYXNlICdSZWxvYWQnOlxuICAgICAgICByZXR1cm4gJ0xvYWRpbmcnO1xuICAgICAgY2FzZSAnTG9hZGVkJzpcbiAgICAgIGNhc2UgJ1N0b3AnOlxuICAgICAgY2FzZSAnTm90QXBwbGljYWJsZSc6XG4gICAgICAgIHJldHVybiAnU3RhbmRhcmQnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldE5leHRDb250ZXh0IChjb250ZXh0KSB7XG4gICAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgICBjYXNlICdJbml0aWFsaXphdGlvbic6XG4gICAgICBjYXNlICdSZXNldCc6XG4gICAgICAgIHJldHVybiAnTG9hZCc7XG4gICAgICBjYXNlICdMb2FkJzpcbiAgICAgIGNhc2UgJ1JlbG9hZCc6XG4gICAgICAgIHJldHVybiAnTG9hZGVkJztcbiAgICAgIGNhc2UgJ0xvYWRlZCc6XG4gICAgICBjYXNlICdTdG9wJzpcbiAgICAgIGNhc2UgJ05vdEFwcGxpY2FibGUnOlxuICAgICAgICBjb25zb2xlLmVycm9yKGBObyBuZXh0IGNvbnRleHQgZm9yICR7Y29udGV4dH1gKTtcbiAgICAgICAgZGVidWdnZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZGVidWdnZXJcbiAgICAgICAgdGhyb3cgJ05vIG5leHQgY29udGV4dCc7XG4gICAgfVxuICB9XG5cbiAgZGVmaW5lU3RhdGUgKGNvbnRleHQsIGtleSkge1xuICAgIHN3aXRjaCAoY29udGV4dCkge1xuICAgICAgY2FzZSAnQmVmb3JlRGVzdHJ1Y3Rpb25TdGF0ZSc6XG4gICAgICAgIHJldHVybiBuZXcgc3RhdGUuQmVmb3JlRGVzdHJ1Y3Rpb25TdGF0ZShjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgY2FzZSAnTG9hZGVkJzpcbiAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5TdGF0aWNTdGF0ZShjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgY2FzZSAnU3RvcCc6XG4gICAgICAgIHJldHVybiBuZXcgc3RhdGUuU3RvcFN0YXRlKGNvbnRleHQsIGtleSwgdGhpcyk7XG4gICAgICBjYXNlICdOb3RBcHBsaWNhYmxlJzpcbiAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5Ob3RBcHBsaWNhYmxlU3RhdGUoY29udGV4dCwga2V5LCB0aGlzKTtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdJbml0aWFsaXppbmcnOlxuICAgICAgICAgICAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ0luaXRpYWxpemF0aW9uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN0YXRlLkluaXRpYWxTdGF0ZShjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgICAgICAgICBjYXNlICdSZXNldCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5SZXNldFN0YXRlKGNvbnRleHQsIGtleSwgdGhpcyk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgU3RhdGUgbm90IGRlZmluZWQgZm9yIGNvbnRleHQ9JHtjb250ZXh0fSBhbmQga2V5PSR7a2V5fWApO1xuICAgICAgICAgICAgICAgIGRlYnVnZ2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWRlYnVnZ2VyXG4gICAgICAgICAgICAgICAgdGhyb3cgJ1N0YXRlIG5vdCBkZWZpbmVkJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdFcnJvcic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN0YXRlLkVycm9yU3RhdGUoY29udGV4dCwga2V5LCB0aGlzKTtcbiAgICAgICAgICBjYXNlICdMb2FkaW5nJzpcbiAgICAgICAgICAgIHN3aXRjaCAoY29udGV4dCkge1xuICAgICAgICAgICAgICBjYXNlICdMb2FkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN0YXRlLkxvYWRTdGF0ZShjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgICAgICAgICBjYXNlICdSZWxvYWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3RhdGUuUmVsb2FkU3RhdGUoY29udGV4dCwga2V5LCB0aGlzKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBTdGF0ZSBub3QgZGVmaW5lZCBmb3IgY29udGV4dD0ke2NvbnRleHR9IGFuZCBrZXk9JHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgZGVidWdnZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZGVidWdnZXJcbiAgICAgICAgICAgICAgICB0aHJvdyAnU3RhdGUgbm90IGRlZmluZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ1RlbXBvcmFyeSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN0YXRlLlRlbXBvcmFyeVN0YXRlKGMgPT4gMTAwMC4sIGNvbnRleHQsIGtleSwgdGhpcyk7XG4gICAgICAgICAgY2FzZSAnRGVsYXknOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5EZWxheVN0YXRlKGMgPT4gYy5kZWxheVJhdGUsIGNvbnRleHQsIGtleSwgdGhpcyk7XG4gICAgICAgICAgY2FzZSAnVHJhbnNpZW50RXJyb3InOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5UcmFuc2llbnRFcnJvclN0YXRlKGMgPT4gYy5kZWxheVJhdGUsIGNvbnRleHQsIGtleSwgdGhpcyk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFN0YXRlIG5vdCBkZWZpbmVkIGZvciBjb250ZXh0PSR7Y29udGV4dH0gYW5kIGtleT0ke2tleX1gKTtcbiAgICAgICAgICAgIGRlYnVnZ2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWRlYnVnZ2VyXG4gICAgICAgICAgICB0aHJvdyAnU3RhdGUgbm90IGRlZmluZWQ6ICcgKyBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbnRlckNvbnRleHQgKGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgIGNhc2UgJ0xvYWQnOlxuICAgICAgY2FzZSAnUmVsb2FkJzpcbiAgICAgICAgdGhpcy5zdGFydExvYWRpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmVudGVyQ29udGV4dChjb250ZXh0KTtcbiAgfVxuXG4gIGV4aXRDb250ZXh0IChjb250ZXh0KSB7XG4gICAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgICBjYXNlICdMb2FkJzpcbiAgICAgIGNhc2UgJ1JlbG9hZCc6XG4gICAgICAgIHRoaXMuZW5kTG9hZGluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZXhpdENvbnRleHQoY29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyBmb3IgUHVsc2UgY29tcG9uZW50cyB0aGF0IHJ1biBhbiBhamF4IHJlcXVlc3QgcmVndWxhcmx5LCBlYWNoIHRpbWUgaXQgbmVlZHMgdG8gYmUgcmVmcmVzaGVkXG4gKlxuICogQXZhaWxhYmxlIGNvbnRleHRzOiBJbml0aWFsaXphdGlvbiwgUmVzZXQsIExvYWQsIE5vcm1hbCwgUmVsb2FkLCBTdG9wLCBOb3RBdmFpbGFibGUsIE5vdEFwcGxpY2FibGVcbiAqXG4gKiBBdmFpbGFibGUgc3RhdGVzOiBJbml0aWFsaXppbmcsIEVycm9yLCBMb2FkaW5nLCBTdGFuZGFyZCwgVGVtcG9yYXJ5LCBEZWxheSwgVHJhbnNpZW50RXJyb3IsIEVycm9yXG4gKlxuICogU29tZSBzdGF0ZSBmbG93czpcbiAqIERlZmF1bHQgZmxvdzogSW5pdGlhbGl6YXRpb246SW5pdGlhbGl6aW5nIC0+IExvYWQ6TG9hZGluZyAtPiBOb3JtYWw6TG9hZGluZyAtPiBOb3JtYWw6TG9hZGluZyAtPiAuLi5cbiAqIEluaXRpYWxpemF0aW9uIGVycm9yIGZsb3c6IEluaXRpYWxpemF0aW9uOkluaXRpYWxpemluZyAtPiBJbml0aWFsaXphdGlvbjpFcnJvclxuICogQWpheCB0cmFuc2llbnQgZXJyb3IgZmxvdzogTm9ybWFsOkxvYWRpbmcgLT4gTm9ybWFsOlRlbXBvcmFyeSAtPiBOb3JtYWw6VGVtcG9yYXJ5IC0+IC4uLiAtPiBOb3JtYWw6VHJhbnNpZW50RXJyb3JcbiAqIEFqYXggZGVsYXkgZXJyb3IgZmxvdzogTm9ybWFsOkxvYWRpbmcgLT4gTm9ybWFsOkRlbGF5IC0+IE5vcm1hbDpEZWxheSAtPiAuLi4gLT4gTm9ybWFsOlRyYW5zaWVudEVycm9yXG4gKiBOb3QgYXZhaWxhYmxlIGZsb3c6IE5vcm1hbDpMb2FkaW5nIC0+IE5vdEF2YWlsYWJsZTpMb2FkaW5nIC0+IC4uLiAtPiBOb3JtYWw6TG9hZGluZ1xuICpcbiAqIFN0YXRlIGltcGxlbWVudGF0aW9uczpcbiAqIC0gSW5pdGlhbGl6YXRpb246SW5pdGlhbGl6aW5nIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5Jbml0aWFsU3RhdGV9XG4gKiAtIFJlc2V0OkluaXRpYWxpemluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+UmVzZXRTdGF0ZX1cbiAqIC0gU3RvcDpTdGFuZGFyZCAtIHtAbGluayBtb2R1bGU6c3RhdGV+U3RvcFN0YXRlfVxuICogLSBOb3JtYWw6TG9hZGluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+Tm9ybWFsUmVxdWVzdFN0YXRlfVxuICogLSBOb3RBdmFpbGFibGU6TG9hZGluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+Tm90QXZhaWxhYmxlU3RhdGV9XG4gKiAtIExvYWQ6TG9hZGluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+TG9hZFN0YXRlfVxuICogLSBSZWxvYWQ6TG9hZGluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+UmVsb2FkU3RhdGV9XG4gKiAtICo6VGVtcG9yYXJ5IC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5UZW1wb3JhcnlTdGF0ZX1cbiAqIC0gKjpEZWxheSAtIHtAbGluayBtb2R1bGU6c3RhdGV+RGVsYXlTdGF0ZX1cbiAqIC0gKjpUcmFuc2llbnRFcnJvciAtIHtAbGluayBtb2R1bGU6c3RhdGV+VHJhbnNpZW50RXJyb3JTdGF0ZX1cbiAqIC0gTm90QXBwbGljYWJsZTpTdGFuZGFyZCAtIHtAbGluayBtb2R1bGU6c3RhdGV+Tm90QXBwbGljYWJsZVN0YXRlfVxuICogLSAqOkVycm9yIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5FcnJvclN0YXRlfVxuICogXG4gKiBAZXh0ZW5kcyBtb2R1bGU6cHVsc2VDb21wb25lbnR+UHVsc2VSZXF1ZXN0Q29tcG9uZW50XG4gKiBcbiogQGdyYXBoIFJlZnJlc2hpbmdfQ29udGV4dEZsb3dcbkBnIFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlZnJlc2hpbmcgY29tcG9uZW50OiBjb250ZXh0IGZsb3dcbkBnIFxuQGcgXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICM9PT09IyAgICAgICAgICstLS0tLS0tLS0tKyAgICAgICAgIHxcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgdiAgICBIICAgICAgICAgdiAgICAgICAgICB8ICAgICAgICAgdlxuQGcgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tKyAgICAgKy0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgID09PiB8IEluaXRpYWxpemF0aW9uIHwgPT0+IHwgICAgICAgIHwgPT0+IHwgICAgICAgIHwgLS0+IHwgICAgICAgICAgICAgIHwgLS0+IHwgTm90QXBwbGljYWJsZSB8XG5AZyAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICB8ICAgICAgICB8ICAgICB8ICAgICAgICB8ICAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfCAgICAgfCAgICAgICAgfCAgICAgfCAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgTG9hZCAgfCAgICAgfCBOb3JtYWwgfCA8PT0gfCBOb3RBdmFpbGFibGUgfFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfCAgICAgfCAgICAgICAgfCAgICAgfCAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgfCAgICAgICAgfCAgICAgfCAgICAgICAgfCAgICAgfCAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgLi4+IHwgICAgIFJlc2V0ICAgICAgfCA9PT4gfCAgICAgICAgfCAgICAgfCAgICAgICAgfCAgICAgfCAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tKyAgICAgKy0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICBeICAgICAgICAgICAgICBeXG5AZyAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgIEggICAgICAgICAgICAgIHxcbkBnICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSCAgICAgICAgICAgICAgfFxuQGcgICB8ICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tKyAgICAgICBIICAgICAgICAgICAgICB8XG5AZyAgIHwgICAgICAuLj4gfCAgICAgIFN0b3AgICAgICB8IC0tPiB8IFJlbG9hZCB8ID09PT09PSMgICAgICAgICAgICAgIHxcbkBnICAgfCAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbkBnICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbkBnICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiogQGdyYXBoIEluaXRpYWxpemF0aW9uX1N0YXRlRmxvd1xuQGcgXG5AZyAgSW5pdGlhbGl6YXRpb24gY29udGV4dDogc3RhdGUgZmxvd1xuQGcgXG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgPT0+IHwgSW5pdGlhbGl6aW5nIHwgPT0+XG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgdlxuQGcgICAgICAgICAgICstLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICB8ICAgIEVycm9yICAgICB8XG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuKiBAZ3JhcGggUmVxdWVzdF9TdGF0ZUZsb3dcbkBnIFxuQGcgICAgICAgIFJlcXVlc3QgKExvYWQsIE5vcm1hbCwgUmVsb2FkLCBOb3RBdmFpbGFibGUuLi4pIGNvbnRleHQ6IHN0YXRlIGZsb3dcbkBnIFxuQGcgXG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgfCAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgfCAgICB8ICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICB2ICAgIHYgICAgfCAgICAgICAgICAgICAgICAgICAgICAgdiAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICArLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICB8XG5AZyAgICAgPT0+IHwgICAgICAgICAgICAgfCAtLT4gfCAgICAgICB8IC0tPiB8ICAgICAgICAgICB8IC0tPiB8IFRyYW5zaWVudEVycm9yIHwgIHxcbkBnICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICB8ICAgICAgIHwgICAgIHwgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgfFxuQGcgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgIHwgICAgICAgfCAgICAgfCAgICAgICAgICAgfCAgICAgICBeICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgIHwgICBMb2FkaW5nICAgfCA8LS0gfCBEZWxheSB8IDwtLSB8IFRlbXBvcmFyeSB8ICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICB8ICAgICAgIHwgICAgIHwgICAgICAgICAgIHwgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgIHwgICAgICAgfCAgICAgfCAgICAgICAgICAgfCAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgfCAgICAgICB8IC0rICB8ICAgICAgICAgICB8IC0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLSsgIHwgICstLS0tLS0tLS0tLSsgICAgICAgfFxuQGcgICAgICAgICAgIEggICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgSCAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICB2XG4gKi9cbmNsYXNzIFB1bHNlUmVmcmVzaGluZ0NvbXBvbmVudCBleHRlbmRzIFB1bHNlUmVxdWVzdENvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBcbiAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIGNvbnN0IHNlbGYgPSBzdXBlciguLi5hcmdzKTtcbiAgICBzZWxmLl9yZWZyZXNoUmF0ZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY29udGV4dCAtIENvbnRleHRcbiAgICogQHJldHVybiB7IXN0cmluZ30ga2V5XG4gICAqL1xuICBnZXRTdGFydEtleSAoY29udGV4dCkge1xuICAgIHN3aXRjaCAoY29udGV4dCkge1xuICAgICAgY2FzZSAnSW5pdGlhbGl6YXRpb24nOlxuICAgICAgY2FzZSAnUmVzZXQnOlxuICAgICAgICByZXR1cm4gJ0luaXRpYWxpemluZyc7XG4gICAgICBjYXNlICdMb2FkJzpcbiAgICAgIGNhc2UgJ1JlbG9hZCc6XG4gICAgICBjYXNlICdOb3JtYWwnOlxuICAgICAgY2FzZSAnTm90QXZhaWxhYmxlJzpcbiAgICAgICAgcmV0dXJuICdMb2FkaW5nJztcbiAgICAgIGNhc2UgJ1N0b3AnOlxuICAgICAgY2FzZSAnTm90QXBwbGljYWJsZSc6XG4gICAgICAgIHJldHVybiAnU3RhbmRhcmQnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldE5leHRDb250ZXh0IChjb250ZXh0KSB7XG4gICAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgICBjYXNlICdJbml0aWFsaXphdGlvbic6XG4gICAgICBjYXNlICdSZXNldCc6XG4gICAgICAgIHJldHVybiAnTG9hZCc7XG4gICAgICBjYXNlICdMb2FkJzpcbiAgICAgIGNhc2UgJ1JlbG9hZCc6XG4gICAgICBjYXNlICdOb3JtYWwnOlxuICAgICAgY2FzZSAnTm90QXZhaWxhYmxlJzpcbiAgICAgICAgcmV0dXJuICdOb3JtYWwnO1xuICAgICAgY2FzZSAnU3RvcCc6XG4gICAgICBjYXNlICdOb3RBcHBsaWNhYmxlJzpcbiAgICAgICAgY29uc29sZS5lcnJvcihgTm8gbmV4dCBjb250ZXh0IGZvciAke2NvbnRleHR9YCk7XG4gICAgICAgIGRlYnVnZ2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWRlYnVnZ2VyXG4gICAgICAgIHRocm93ICdObyBuZXh0IGNvbnRleHQnO1xuICAgIH1cbiAgfVxuXG4gIGRlZmluZVN0YXRlIChjb250ZXh0LCBrZXkpIHtcbiAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgIGNhc2UgJ0JlZm9yZURlc3RydWN0aW9uU3RhdGUnOlxuICAgICAgICByZXR1cm4gbmV3IHN0YXRlLkJlZm9yZURlc3RydWN0aW9uU3RhdGUoY29udGV4dCwga2V5LCB0aGlzKTtcbiAgICAgIGNhc2UgJ1N0b3AnOlxuICAgICAgICByZXR1cm4gbmV3IHN0YXRlLlN0b3BTdGF0ZShjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgY2FzZSAnTm90QXBwbGljYWJsZSc6XG4gICAgICAgIHJldHVybiBuZXcgc3RhdGUuTm90QXBwbGljYWJsZVN0YXRlKGNvbnRleHQsIGtleSwgdGhpcyk7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAnSW5pdGlhbGl6aW5nJzpcbiAgICAgICAgICAgIHN3aXRjaCAoY29udGV4dCkge1xuICAgICAgICAgICAgICBjYXNlICdJbml0aWFsaXphdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5Jbml0aWFsU3RhdGUoY29udGV4dCwga2V5LCB0aGlzKTtcbiAgICAgICAgICAgICAgY2FzZSAnUmVzZXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3RhdGUuUmVzZXRTdGF0ZShjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFN0YXRlIG5vdCBkZWZpbmVkIGZvciBjb250ZXh0PSR7Y29udGV4dH0gYW5kIGtleT0ke2tleX1gKTtcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1kZWJ1Z2dlclxuICAgICAgICAgICAgICAgIHRocm93ICdTdGF0ZSBub3QgZGVmaW5lZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnRXJyb3InOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5FcnJvclN0YXRlKGNvbnRleHQsIGtleSwgdGhpcyk7XG4gICAgICAgICAgY2FzZSAnTG9hZGluZyc6XG4gICAgICAgICAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAnTG9hZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5Mb2FkU3RhdGUoY29udGV4dCwga2V5LCB0aGlzKTtcbiAgICAgICAgICAgICAgY2FzZSAnUmVsb2FkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN0YXRlLlJlbG9hZFN0YXRlKGNvbnRleHQsIGtleSwgdGhpcyk7XG4gICAgICAgICAgICAgIGNhc2UgJ05vcm1hbCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5Ob3JtYWxSZXF1ZXN0U3RhdGUoYyA9PiBjLnJlZnJlc2hSYXRlLCBjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgICAgICAgICBjYXNlICdOb3RBdmFpbGFibGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3RhdGUuTm90QXZhaWxhYmxlU3RhdGUoYyA9PiBjLnJlZnJlc2hSYXRlLCBjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFN0YXRlIG5vdCBkZWZpbmVkIGZvciBjb250ZXh0PSR7Y29udGV4dH0gYW5kIGtleT0ke2tleX1gKTtcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1kZWJ1Z2dlclxuICAgICAgICAgICAgICAgIHRocm93ICdTdGF0ZSBub3QgZGVmaW5lZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnVGVtcG9yYXJ5JzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3RhdGUuVGVtcG9yYXJ5U3RhdGUoYyA9PiAxMDAwLiwgY29udGV4dCwga2V5LCB0aGlzKTtcbiAgICAgICAgICBjYXNlICdEZWxheSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN0YXRlLkRlbGF5U3RhdGUoYyA9PiBjLmRlbGF5UmF0ZSwgY29udGV4dCwga2V5LCB0aGlzKTtcbiAgICAgICAgICBjYXNlICdUcmFuc2llbnRFcnJvcic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN0YXRlLlRyYW5zaWVudEVycm9yU3RhdGUoYyA9PiBjLmRlbGF5UmF0ZSwgY29udGV4dCwga2V5LCB0aGlzKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgU3RhdGUgbm90IGRlZmluZWQgZm9yIGNvbnRleHQ9JHtjb250ZXh0fSBhbmQga2V5PSR7a2V5fWApO1xuICAgICAgICAgICAgZGVidWdnZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZGVidWdnZXJcbiAgICAgICAgICAgIHRocm93ICdTdGF0ZSBub3QgZGVmaW5lZCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbnRlckNvbnRleHQgKGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgIGNhc2UgJ0xvYWQnOlxuICAgICAgY2FzZSAnUmVsb2FkJzpcbiAgICAgICAgdGhpcy5zdGFydExvYWRpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmVudGVyQ29udGV4dChjb250ZXh0KTtcbiAgfVxuXG4gIGV4aXRDb250ZXh0IChjb250ZXh0KSB7XG4gICAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgICBjYXNlICdMb2FkJzpcbiAgICAgIGNhc2UgJ1JlbG9hZCc6XG4gICAgICAgIHRoaXMuZW5kTG9hZGluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZXhpdENvbnRleHQoY29udGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCByYXRlIGluIG1zXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gUmVmcmVzaCByYXRlIGluIG1zXG4gICAqL1xuICBnZXQgcmVmcmVzaFJhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWZyZXNoUmF0ZTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSByZWZyZXNoIHJhdGVcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJlZnJlc2hSYXRlIC0gUmVmcmVzaCByYXRlIGluIG1zXG4gICAqL1xuICBzZXQgcmVmcmVzaFJhdGUgKHJlZnJlc2hSYXRlKSB7XG4gICAgdGhpcy5fcmVmcmVzaFJhdGUgPSByZWZyZXNoUmF0ZTtcbiAgfVxuXG59XG5cbi8qKlxuICogQWJzdHJhY3QgcHVsc2UgY29tcG9uZW50IHdpdGggYW4gaW5pdGlhbGl6YXRpb24gcGhhc2UgYW5kIGEgcGFyYW1ldGVyIHZhbGlkYXRpb24gcGhhc2VcbiAqXG4gKiBBdmFpbGFibGUgY29udGV4dHM6IEluaXRpYWxpemF0aW9uLCBQYXJhbVZhbGlkYXRpb24sIFJlc2V0LCBJbml0aWFsaXplZFxuICogQXZhaWxhYmxlIHN0YXRlczogSW5pdGlhbGl6aW5nLCBWYWxpZGF0aW5nLCBFcnJvciwgU3RhbmRhcmRcbiAqXG4gKiBTb21lIHN0YXRlIGZsb3dzOlxuICogRGVmYXVsdCBmbG93OiBJbml0aWFsaXphdGlvbjpJbml0aWFsaXppbmcgLT4gUGFyYW1WYWxpZGF0aW9uOlZhbGlkYXRpbmcgLT4gSW5pdGlhbGl6ZWQ6U3RhbmRhcmRcbiAqIEluaXRpYWxpemF0aW9uIGVycm9yIGZsb3c6IEluaXRpYWxpemF0aW9uOkluaXRpYWxpemluZyAtPiBJbml0aWFsaXphdGlvbjpFcnJvclxuICogUmVzZXQgZmxvdzogSW5pdGlhbGl6ZWQ6U3RhbmRhcmQgLT4gUmVzZXQ6SW5pdGlhbGl6aW5nIC0+IFBhcmFtVmFsaWRhdGlvbjpWYWxpZGF0aW5nIC0+IEluaXRpYWxpemVkOlN0YW5kYXJkXG4gKlxuICogU3RhdGUgaW1wbGVtZW50YXRpb25zOlxuICogLSBJbml0aWFsaXphdGlvbjpJbml0aWFsaXppbmcgLSB7QGxpbmsgbW9kdWxlOnN0YXRlfkluaXRpYWxTdGF0ZX1cbiAqIC0gUmVzZXQ6SW5pdGlhbGl6aW5nIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5SZXNldFN0YXRlfVxuICogLSBQYXJhbVZhbGlkYXRpb246VmFsaWRhdGluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+UGFyYW1WYWxpZGF0aW9uVGltZW91dFN0YXRlfVxuICogLSBJbml0aWFsaXplZDpTdGFuZGFyZCAtIHtAbGluayBtb2R1bGU6c3RhdGV+U3RhdGljU3RhdGV9XG4gKiAtICo6RXJyb3IgLSB7QGxpbmsgbW9kdWxlOnN0YXRlfkVycm9yU3RhdGV9XG4gKiBcbiAqIEBleHRlbmRzIG1vZHVsZTpwdWxzZUNvbXBvbmVudH5QdWxzZUluaXRpYWxpemVkQ29tcG9uZW50XG4gKiBcbiogQGdyYXBoIFBhcmFtSW5pdGlhbGl6ZWRfQ29udGV4dEZsb3dcbkBnIFxuQGcgICAgICAgICAgICAgICAgICBJbml0aWFsaXplZCBjb21wb25lbnQ6IGNvbnRleHQgZmxvd1xuQGcgXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0rXG5AZyAgICAgPT0+IHwgSW5pdGlhbGl6YXRpb24gfCA9PT4gfCBQYXJhbVZhbGlkYXRpb24gfCA9PT4gfCBJbml0aWFsaXplZCB8XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgICBIXG5AZyAgICAgLi4+IHwgICAgIFJlc2V0ICAgICAgfCA9PT09PT0jXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tK1xuKiBAZ3JhcGggSW5pdGlhbGl6YXRpb25fU3RhdGVGbG93XG5AZyBcbkBnICBJbml0aWFsaXphdGlvbiBjb250ZXh0OiBzdGF0ZSBmbG93XG5AZyBcbkBnICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICA9PT4gfCBJbml0aWFsaXppbmcgfCA9PT5cbkBnICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICB2XG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgIHwgICAgRXJyb3IgICAgIHxcbkBnICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0rXG4qIEBncmFwaCBQYXJhbVZhbGlkYXRpb25fU3RhdGVGbG93XG5AZyBcbkBnICBQYXJhbVZhbGlkYXRpb24gY29udGV4dDogc3RhdGUgZmxvd1xuQGcgXG5AZyAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICA9PT4gfCBWYWxpZGF0aW5nIHwgPT0+XG5AZyAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICAgICAgdlxuQGcgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICAgIHwgICBFcnJvciAgICB8XG5AZyAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICovXG5jbGFzcyBQdWxzZVBhcmFtSW5pdGlhbGl6ZWRDb21wb25lbnQgZXh0ZW5kcyBQdWxzZUluaXRpYWxpemVkQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBzZWxmID0gc3VwZXIoLi4uYXJncyk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqIFxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGNvbnRleHQgLSBDb250ZXh0XG4gICAqIEByZXR1cm4geyFzdHJpbmd9IGtleVxuICAgKi9cbiAgZ2V0U3RhcnRLZXkgKGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgIGNhc2UgJ1BhcmFtVmFsaWRhdGlvbic6XG4gICAgICAgIHJldHVybiAnVmFsaWRhdGluZyc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0U3RhcnRLZXkoY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0TmV4dENvbnRleHQgKGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgIGNhc2UgJ0luaXRpYWxpemF0aW9uJzpcbiAgICAgIGNhc2UgJ1Jlc2V0JzpcbiAgICAgICAgcmV0dXJuICdQYXJhbVZhbGlkYXRpb24nO1xuICAgICAgY2FzZSAnUGFyYW1WYWxpZGF0aW9uJzpcbiAgICAgICAgcmV0dXJuICdJbml0aWFsaXplZCc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0TmV4dENvbnRleHQoY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgZGVmaW5lU3RhdGUgKGNvbnRleHQsIGtleSkge1xuICAgIHN3aXRjaCAoY29udGV4dCkge1xuICAgICAgY2FzZSAnQmVmb3JlRGVzdHJ1Y3Rpb25TdGF0ZSc6XG4gICAgICAgIHJldHVybiBuZXcgc3RhdGUuQmVmb3JlRGVzdHJ1Y3Rpb25TdGF0ZShjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgY2FzZSAnUGFyYW1WYWxpZGF0aW9uJzpcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdWYWxpZGF0aW5nJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3RhdGUuUGFyYW1WYWxpZGF0aW9uVGltZW91dFN0YXRlKGMgPT4gMzAwMDAuLCBjb250ZXh0LCBrZXksIHRoaXMpOyAvLyB0aW1lb3V0ID0gMzBzXG4gICAgICAgICAgY2FzZSAnRXJyb3InOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5FcnJvclN0YXRlKGNvbnRleHQsIGtleSwgdGhpcyk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFN0YXRlIG5vdCBkZWZpbmVkIGZvciBjb250ZXh0PSR7Y29udGV4dH0gYW5kIGtleT0ke2tleX1gKTtcbiAgICAgICAgICAgIGRlYnVnZ2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWRlYnVnZ2VyXG4gICAgICAgICAgICB0aHJvdyAnU3RhdGUgbm90IGRlZmluZWQnO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIuZGVmaW5lU3RhdGUoY29udGV4dCwga2V5KTtcbiAgICB9XG4gIH1cblxuICBlbnRlckNvbnRleHQgKGNvbnRleHQpIHtcbiAgICBpZiAoKGNvbnRleHQgPT0gJ1BhcmFtVmFsaWRhdGlvbicpICYmIHRoaXMuc3RhcnRMb2FkaW5nKSB7XG4gICAgICB0aGlzLnN0YXJ0TG9hZGluZygpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZW50ZXJDb250ZXh0KGNvbnRleHQpO1xuICB9XG5cbiAgZXhpdENvbnRleHQgKGNvbnRleHQpIHtcbiAgICBpZiAoKGNvbnRleHQgPT0gJ1BhcmFtVmFsaWRhdGlvbicpICYmIHRoaXMuZW5kTG9hZGluZykge1xuICAgICAgdGhpcy5lbmRMb2FkaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5leGl0Q29udGV4dChjb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIGZvciBQdWxzZSBjb21wb25lbnRzIHdpdGggYSAoZXZlbnQpIHBhcmFtZXRlciB2YWxpZGF0aW9uIHBoYXNlXG4gKiB0aGF0IHJ1biBhIHNpbmdsZSBBamF4IHJlcXVlc3QgZHVyaW5nIHRoZSBsb2FkaW5nIHBoYXNlXG4gKlxuICogQXZhaWxhYmxlIGNvbnRleHRzOiBJbml0aWFsaXphdGlvbiwgUGFyYW1WYWxpZGF0aW9uLCBSZXNldCwgTG9hZCwgTG9hZGVkLCBSZWxvYWQsIFN0b3AsIE5vdEFwcGxpY2FibGVcbiAqXG4gKiBBdmFpbGFibGUgc3RhdGVzOiBJbml0aWFsaXppbmcsIEVycm9yLCBWYWxpZGF0aW5nLCBMb2FkaW5nLCBTdGFuZGFyZCwgVGVtcG9yYXJ5LCBEZWxheSwgVHJhbnNpZW50RXJyb3IsIEVycm9yXG4gKlxuICogU29tZSBzdGF0ZSBmbG93czpcbiAqIERlZmF1bHQgZmxvdzogSW5pdGlhbGl6YXRpb246SW5pdGlhbGl6aW5nIC0+IFBhcmFtVmFsaWRhdGlvbjpWYWxpZGF0aW5nIC0+IExvYWQ6TG9hZGluZyAtPiBMb2FkZWQ6U3RhbmRhcmRcbiAqIEluaXRpYWxpemF0aW9uIGVycm9yIGZsb3c6IEluaXRpYWxpemF0aW9uOkluaXRpYWxpemluZyAtPiBJbml0aWFsaXphdGlvbjpFcnJvclxuICogQWpheCB0cmFuc2llbnQgZXJyb3IgZmxvdzogSW5pdGlhbGl6YXRpb246SW5pdGlhbGl6aW5nIC0+IExvYWQ6TG9hZGluZyAtPiBMb2FkOlRlbXBvcmFyeSAtPiAuLi4gLT4gTG9hZDpUcmFuc2llbnRFcnJvclxuICpcbiAqIFN0YXRlIGltcGxlbWVudGF0aW9uczpcbiAqIC0gSW5pdGlhbGl6YXRpb246SW5pdGlhbGl6aW5nIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5Jbml0aWFsU3RhdGV9XG4gKiAtIFJlc2V0OkluaXRpYWxpemluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+UmVzZXRTdGF0ZX1cbiAqIC0gUGFyYW1WYWxpZGF0aW9uOlZhbGlkYXRpbmcgLSB7QGxpbmsgbW9kdWxlOnN0YXRlflBhcmFtVmFsaWRhdGlvblRpbWVvdXRTdGF0ZX1cbiAqIC0gTG9hZGVkOlN0YW5kYXJkIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5TdGF0aWNTdGF0ZX1cbiAqIC0gU3RvcDpTdGFuZGFyZCAtIHtAbGluayBtb2R1bGU6c3RhdGV+U3RvcFN0YXRlfVxuICogLSBMb2FkOkxvYWRpbmcgLSB7QGxpbmsgbW9kdWxlOnN0YXRlfkxvYWRTdGF0ZX1cbiAqIC0gUmVsb2FkOkxvYWRpbmcgLSB7QGxpbmsgbW9kdWxlOnN0YXRlflJlbG9hZFN0YXRlfVxuICogLSAqOlRlbXBvcmFyeSAtIHtAbGluayBtb2R1bGU6c3RhdGV+VGVtcG9yYXJ5U3RhdGV9XG4gKiAtICo6RGVsYXkgLSB7QGxpbmsgbW9kdWxlOnN0YXRlfkRlbGF5U3RhdGV9XG4gKiAtICo6VHJhbnNpZW50RXJyb3IgLSB7QGxpbmsgbW9kdWxlOnN0YXRlflRyYW5zaWVudEVycm9yU3RhdGV9XG4gKiAtIE5vdEFwcGxpY2FibGU6U3RhbmRhcmQgLSB7QGxpbmsgbW9kdWxlOnN0YXRlfk5vdEFwcGxpY2FibGVTdGF0ZX1cbiAqIC0gKjpFcnJvciAtIHtAbGluayBtb2R1bGU6c3RhdGV+RXJyb3JTdGF0ZX1cbiAqIFxuICogQGV4dGVuZHMgbW9kdWxlOnB1bHNlQ29tcG9uZW50flB1bHNlU2luZ2xlUmVxdWVzdENvbXBvbmVudFxuICogXG4qIEBncmFwaCBQYXJhbVNpbmdsZVJlcXVlc3RfQ29udGV4dEZsb3dcbkBnIFxuQGcgICAgICAgIFNpbmdsZSByZXF1ZXN0IGFuZCBwYXJhbSBhdXRvUGF0aCBzaW5nbGUgcmVxdWVzdCBjb21wb25lbnQ6IGNvbnRleHQgZmxvd1xuQGcgXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLStcbkBnICAgICA9PT4gfCBJbml0aWFsaXphdGlvbiB8ID09PiB8IFBhcmFtVmFsaWRhdGlvbiB8ID09PiB8ICAgICBMb2FkICAgICAgfCA9PT4gfCBMb2FkZWQgfFxuQGcgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgXlxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSCAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIEhcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEggICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICAgICAgICAgICAgICBIXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgICBIICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICAgICAgSFxuQGcgICAgIC4uPiB8ICAgICBSZXNldCAgICAgIHwgPT09PT09IyAgICAgICAgICAgICAgICAgICAgIHwgTm90QXBwbGljYWJsZSB8ICAgICAgIEhcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tKyAgICAgICBIXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSFxuQGcgICAgIC4uPiB8ICAgICAgU3RvcCAgICAgIHwgLS0+IHwgICAgIFJlbG9hZCAgICAgIHwgPT09PT09PT09PT09PT09PT09PT09PT09PT09PSNcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6XG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6XG4qIEBncmFwaCBJbml0aWFsaXphdGlvbl9TdGF0ZUZsb3dcbkBnIFxuQGcgIEluaXRpYWxpemF0aW9uIGNvbnRleHQ6IHN0YXRlIGZsb3dcbkBnIFxuQGcgICAgICAgICAgICstLS0tLS0tLS0tLS0tLStcbkBnICAgICAgID09PiB8IEluaXRpYWxpemluZyB8ID09PlxuQGcgICAgICAgICAgICstLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICAgIHZcbkBnICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgfCAgICBFcnJvciAgICAgfFxuQGcgICAgICAgICAgICstLS0tLS0tLS0tLS0tLStcbiogQGdyYXBoIFBhcmFtVmFsaWRhdGlvbl9TdGF0ZUZsb3dcbkBnIFxuQGcgIFBhcmFtVmFsaWRhdGlvbiBjb250ZXh0OiBzdGF0ZSBmbG93XG5AZyBcbkBnICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgID09PiB8IFZhbGlkYXRpbmcgfCA9PT5cbkBnICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgICB2XG5AZyAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgICAgfCAgIEVycm9yICAgIHxcbkBnICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4qIEBncmFwaCBSZXF1ZXN0X1N0YXRlRmxvd1xuQGcgXG5AZyAgICAgICAgUmVxdWVzdCAoTG9hZCwgTm9ybWFsLCBSZWxvYWQsIE5vdEF2YWlsYWJsZS4uLikgY29udGV4dDogc3RhdGUgZmxvd1xuQGcgXG5AZyBcbkBnICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICB8ICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICB8ICAgIHwgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIHYgICAgdiAgICB8ICAgICAgICAgICAgICAgICAgICAgICB2ICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0tLS0tLSsgIHxcbkBnICAgICA9PT4gfCAgICAgICAgICAgICB8IC0tPiB8ICAgICAgIHwgLS0+IHwgICAgICAgICAgIHwgLS0+IHwgVHJhbnNpZW50RXJyb3IgfCAgfFxuQGcgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgIHwgICAgICAgfCAgICAgfCAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICB8XG5AZyAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgfCAgICAgICB8ICAgICB8ICAgICAgICAgICB8ICAgICAgIF4gICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgfCAgIExvYWRpbmcgICB8IDwtLSB8IERlbGF5IHwgPC0tIHwgVGVtcG9yYXJ5IHwgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgIHwgICAgICAgfCAgICAgfCAgICAgICAgICAgfCAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgfCAgICAgICB8ICAgICB8ICAgICAgICAgICB8ICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICB8ICAgICAgIHwgLSsgIHwgICAgICAgICAgIHwgLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICArLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tKyAgfCAgKy0tLS0tLS0tLS0tKyAgICAgICB8XG5AZyAgICAgICAgICAgSCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICBIICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgIHZcbiAqL1xuY2xhc3MgUHVsc2VQYXJhbVNpbmdsZVJlcXVlc3RDb21wb25lbnQgZXh0ZW5kcyBQdWxzZVNpbmdsZVJlcXVlc3RDb21wb25lbnQge1xuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIGNvbnN0IHNlbGYgPSBzdXBlciguLi5hcmdzKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY29udGV4dCAtIENvbnRleHRcbiAgICogQHJldHVybiB7IXN0cmluZ30ga2V5XG4gICAqL1xuICBnZXRTdGFydEtleSAoY29udGV4dCkge1xuICAgIHN3aXRjaCAoY29udGV4dCkge1xuICAgICAgY2FzZSAnUGFyYW1WYWxpZGF0aW9uJzpcbiAgICAgICAgcmV0dXJuICdWYWxpZGF0aW5nJztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRTdGFydEtleShjb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXROZXh0Q29udGV4dCAoY29udGV4dCkge1xuICAgIHN3aXRjaCAoY29udGV4dCkge1xuICAgICAgY2FzZSAnSW5pdGlhbGl6YXRpb24nOlxuICAgICAgY2FzZSAnUmVzZXQnOlxuICAgICAgICByZXR1cm4gJ1BhcmFtVmFsaWRhdGlvbic7XG4gICAgICBjYXNlICdQYXJhbVZhbGlkYXRpb24nOlxuICAgICAgICByZXR1cm4gJ0xvYWQnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldE5leHRDb250ZXh0KGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY29udGV4dCAtIENvbnRleHRcbiAgICogQHBhcmFtIHshc3RyaW5nfSBrZXkgLSBLZXlcbiAgICogQHJldHVybnMgeyFTdGF0ZX0gQ3JlYXRlZCBzdGF0ZXNcbiAgICovXG4gIGRlZmluZVN0YXRlIChjb250ZXh0LCBrZXkpIHtcbiAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgIGNhc2UgJ1BhcmFtVmFsaWRhdGlvbic6XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAnVmFsaWRhdGluZyc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN0YXRlLlBhcmFtVmFsaWRhdGlvblRpbWVvdXRTdGF0ZShjID0+IDMwMDAwLiwgY29udGV4dCwga2V5LCB0aGlzKTsgLy8gdGltZW91dCA9IDMwc1xuICAgICAgICAgIGNhc2UgJ0Vycm9yJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3RhdGUuRXJyb3JTdGF0ZShjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBTdGF0ZSBub3QgZGVmaW5lZCBmb3IgY29udGV4dD0ke2NvbnRleHR9IGFuZCBrZXk9JHtrZXl9YCk7XG4gICAgICAgICAgICBkZWJ1Z2dlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1kZWJ1Z2dlclxuICAgICAgICAgICAgdGhyb3cgJ1N0YXRlIG5vdCBkZWZpbmVkJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRlZmluZVN0YXRlKGNvbnRleHQsIGtleSk7XG4gICAgfVxuICB9XG5cbiAgZW50ZXJDb250ZXh0IChjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT0gJ1BhcmFtVmFsaWRhdGlvbicpIHtcbiAgICAgIHRoaXMuc3RhcnRMb2FkaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5lbnRlckNvbnRleHQoY29udGV4dCk7XG4gIH1cblxuICBleGl0Q29udGV4dCAoY29udGV4dCkge1xuICAgIGlmICgoY29udGV4dCA9PSAnUGFyYW1WYWxpZGF0aW9uJykgJiYgdGhpcy5lbmRMb2FkaW5nKSB7XG4gICAgICB0aGlzLmVuZExvYWRpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmV4aXRDb250ZXh0KGNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgZm9yIFB1bHNlIGNvbXBvbmVudHMgd2l0aCBhIChldmVudCkgcGFyYW1ldGVyIHZhbGlkYXRpb24gcGhhc2UgKyBQYXRoIHZhbGlkYXRpb24gaXMgYXV0b21hdGljXG4gKiB0aGF0IHJ1biBhIHNpbmdsZSBBamF4IHJlcXVlc3QgZHVyaW5nIHRoZSBsb2FkaW5nIHBoYXNlXG4gKlxuICogQXZhaWxhYmxlIGNvbnRleHRzOiBJbml0aWFsaXphdGlvbiwgUGFyYW1WYWxpZGF0aW9uLCBSZXNldCwgTG9hZCwgTG9hZGVkLCBSZWxvYWQsIFN0b3AsIE5vdEFwcGxpY2FibGVcbiAqXG4gKiBBdmFpbGFibGUgc3RhdGVzOiBJbml0aWFsaXppbmcsIEVycm9yLCBWYWxpZGF0aW5nLCBMb2FkaW5nLCBTdGFuZGFyZCwgVGVtcG9yYXJ5LCBEZWxheSwgVHJhbnNpZW50RXJyb3IsIEVycm9yXG4gKlxuICogU29tZSBzdGF0ZSBmbG93czpcbiAqIERlZmF1bHQgZmxvdzogSW5pdGlhbGl6YXRpb246SW5pdGlhbGl6aW5nIC0+IFBhcmFtVmFsaWRhdGlvbjpWYWxpZGF0aW5nIC0+IExvYWQ6TG9hZGluZyAtPiBMb2FkZWQ6U3RhbmRhcmRcbiAqIEluaXRpYWxpemF0aW9uIGVycm9yIGZsb3c6IEluaXRpYWxpemF0aW9uOkluaXRpYWxpemluZyAtPiBJbml0aWFsaXphdGlvbjpFcnJvclxuICogQWpheCB0cmFuc2llbnQgZXJyb3IgZmxvdzogSW5pdGlhbGl6YXRpb246SW5pdGlhbGl6aW5nIC0+IExvYWQ6TG9hZGluZyAtPiBMb2FkOlRlbXBvcmFyeSAtPiAuLi4gLT4gTG9hZDpUcmFuc2llbnRFcnJvclxuICpcbiAqIFN0YXRlIGltcGxlbWVudGF0aW9uczpcbiAqIC0gSW5pdGlhbGl6YXRpb246SW5pdGlhbGl6aW5nIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5Jbml0aWFsU3RhdGV9XG4gKiAtIFJlc2V0OkluaXRpYWxpemluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+UmVzZXRTdGF0ZX1cbiAqIC0gUGFyYW1WYWxpZGF0aW9uOlZhbGlkYXRpbmcgLSB7QGxpbmsgbW9kdWxlOnN0YXRlflBhcmFtVmFsaWRhdGlvblRpbWVvdXRTdGF0ZX1cbiAqIC0gTG9hZGVkOlN0YW5kYXJkIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5TdGF0aWNTdGF0ZX1cbiAqIC0gU3RvcDpTdGFuZGFyZCAtIHtAbGluayBtb2R1bGU6c3RhdGV+U3RvcFN0YXRlfVxuICogLSBMb2FkOkxvYWRpbmcgLSB7QGxpbmsgbW9kdWxlOnN0YXRlfkxvYWRTdGF0ZX1cbiAqIC0gUmVsb2FkOkxvYWRpbmcgLSB7QGxpbmsgbW9kdWxlOnN0YXRlflJlbG9hZFN0YXRlfVxuICogLSAqOlRlbXBvcmFyeSAtIHtAbGluayBtb2R1bGU6c3RhdGV+VGVtcG9yYXJ5U3RhdGV9XG4gKiAtICo6RGVsYXkgLSB7QGxpbmsgbW9kdWxlOnN0YXRlfkRlbGF5U3RhdGV9XG4gKiAtICo6VHJhbnNpZW50RXJyb3IgLSB7QGxpbmsgbW9kdWxlOnN0YXRlflRyYW5zaWVudEVycm9yU3RhdGV9XG4gKiAtIE5vdEFwcGxpY2FibGU6U3RhbmRhcmQgLSB7QGxpbmsgbW9kdWxlOnN0YXRlfk5vdEFwcGxpY2FibGVTdGF0ZX1cbiAqIC0gKjpFcnJvciAtIHtAbGluayBtb2R1bGU6c3RhdGV+RXJyb3JTdGF0ZX1cbiAqIFxuICogQGV4dGVuZHMgbW9kdWxlOnB1bHNlQ29tcG9uZW50flB1bHNlUGFyYW1TaW5nbGVSZXF1ZXN0Q29tcG9uZW50XG4gKiBcbiogQGdyYXBoIFBhcmFtU2luZ2xlUmVxdWVzdF9Db250ZXh0Rmxvd1xuQGcgXG5AZyAgICAgICAgU2luZ2xlIHJlcXVlc3QgYW5kIHBhcmFtIGF1dG9QYXRoIHNpbmdsZSByZXF1ZXN0IGNvbXBvbmVudDogY29udGV4dCBmbG93XG5AZyBcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tK1xuQGcgICAgID09PiB8IEluaXRpYWxpemF0aW9uIHwgPT0+IHwgUGFyYW1WYWxpZGF0aW9uIHwgPT0+IHwgICAgIExvYWQgICAgICB8ID09PiB8IExvYWRlZCB8XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLStcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF4gICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICBeXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgSFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSCAgICAgICAgICAgICAgICAgICAgICAgdiAgICAgICAgICAgICAgICAgICAgIEhcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICAgIEggICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tKyAgICAgICBIXG5AZyAgICAgLi4+IHwgICAgIFJlc2V0ICAgICAgfCA9PT09PT0jICAgICAgICAgICAgICAgICAgICAgfCBOb3RBcHBsaWNhYmxlIHwgICAgICAgSFxuQGcgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0rICAgICAgIEhcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICAgICAgICAgICBIXG5AZyAgICAgLi4+IHwgICAgICBTdG9wICAgICAgfCAtLT4gfCAgICAgUmVsb2FkICAgICAgfCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09I1xuQGcgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5cbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpcbiogQGdyYXBoIEluaXRpYWxpemF0aW9uX1N0YXRlRmxvd1xuQGcgXG5AZyAgSW5pdGlhbGl6YXRpb24gY29udGV4dDogc3RhdGUgZmxvd1xuQGcgXG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgPT0+IHwgSW5pdGlhbGl6aW5nIHwgPT0+XG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgdlxuQGcgICAgICAgICAgICstLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICB8ICAgIEVycm9yICAgICB8XG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuKiBAZ3JhcGggUGFyYW1WYWxpZGF0aW9uX1N0YXRlRmxvd1xuQGcgXG5AZyAgUGFyYW1WYWxpZGF0aW9uIGNvbnRleHQ6IHN0YXRlIGZsb3dcbkBnIFxuQGcgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgPT0+IHwgVmFsaWRhdGluZyB8ID09PlxuQGcgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICAgIHZcbkBnICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICB8ICAgRXJyb3IgICAgfFxuQGcgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiogQGdyYXBoIFJlcXVlc3RfU3RhdGVGbG93XG5AZyBcbkBnICAgICAgICBSZXF1ZXN0IChMb2FkLCBOb3JtYWwsIFJlbG9hZCwgTm90QXZhaWxhYmxlLi4uKSBjb250ZXh0OiBzdGF0ZSBmbG93XG5AZyBcbkBnIFxuQGcgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIHwgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIHwgICAgfCAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgdiAgICB2ICAgIHwgICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgfFxuQGcgICAgID09PiB8ICAgICAgICAgICAgIHwgLS0+IHwgICAgICAgfCAtLT4gfCAgICAgICAgICAgfCAtLT4gfCBUcmFuc2llbnRFcnJvciB8ICB8XG5AZyAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgfCAgICAgICB8ICAgICB8ICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0tLS0tLSsgIHxcbkBnICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICB8ICAgICAgIHwgICAgIHwgICAgICAgICAgIHwgICAgICAgXiAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICB8ICAgTG9hZGluZyAgIHwgPC0tIHwgRGVsYXkgfCA8LS0gfCBUZW1wb3JhcnkgfCAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgfCAgICAgICB8ICAgICB8ICAgICAgICAgICB8ICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICB8ICAgICAgIHwgICAgIHwgICAgICAgICAgIHwgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgIHwgICAgICAgfCAtKyAgfCAgICAgICAgICAgfCAtLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0rICB8ICArLS0tLS0tLS0tLS0rICAgICAgIHxcbkBnICAgICAgICAgICBIICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIEggICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgdlxuICovXG5jbGFzcyBQdWxzZVBhcmFtQXV0b1BhdGhTaW5nbGVSZXF1ZXN0Q29tcG9uZW50IGV4dGVuZHMgUHVsc2VQYXJhbVNpbmdsZVJlcXVlc3RDb21wb25lbnQge1xuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogXG4gICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBzZWxmID0gc3VwZXIoLi4uYXJncyk7XG4gICAgc2VsZi5fcGF0aCA9ICcnO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZWQgcGF0aFxuICAgKiBcbiAgICogQHJldHVybnMgeyFzdHJpbmd9IHBhdGhcbiAgICovXG4gIGdldCBwYXRoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBhdGggZnJvbSB0aGUgY29uZmlndXJhdGlvbiBvciB0aGUgYXR0cmlidXRlXG4gICAqIFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdGhlIHBhdGggaXMgZGVmaW5lZCAobm90IGVtcHR5IGFuZCBub3QgbnVsbClcbiAgICovXG4gIHVwZGF0ZVBhdGhGcm9tQ29uZmlnT3JBdHRyaWJ1dGUgKCkge1xuICAgIHRoaXMuX3BhdGggPSB0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdwYXRoJywgJycpO1xuICAgIHJldHVybiAodHlwZW9mICh0aGlzLnBhdGgpICE9ICd1bmRlZmluZWQnKSAmJiAoJycgIT0gdGhpcy5wYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY29udGV4dCAtIENvbnRleHRcbiAgICogQHBhcmFtIHshc3RyaW5nfSBrZXkgLSBLZXlcbiAgICogQHJldHVybnMgeyFTdGF0ZX0gQ3JlYXRlZCBzdGF0ZXNcbiAgICovXG4gIGRlZmluZVN0YXRlIChjb250ZXh0LCBrZXkpIHtcbiAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgIGNhc2UgJ1BhcmFtVmFsaWRhdGlvbic6XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAnVmFsaWRhdGluZyc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN0YXRlLlBhcmFtQW5kUGF0aFZhbGlkYXRpb25UaW1lb3V0U3RhdGUoYyA9PiAzMDAwMC4sIGNvbnRleHQsIGtleSwgdGhpcyk7IC8vIHRpbWVvdXQgPSAzMHNcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmRlZmluZVN0YXRlKGNvbnRleHQsIGtleSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ0luaXRpYWxpemF0aW9uJzpcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdJbml0aWFsaXppbmcnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5BdXRvUGF0aEluaXRpYWxTdGF0ZShjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZGVmaW5lU3RhdGUoY29udGV4dCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRlZmluZVN0YXRlKGNvbnRleHQsIGtleSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0IFVybCAod2l0aCB0aGUgcGF0aCkgdG8gdXNlIGluIHRoZSBBamF4IHJlcXVlc3QuXG4gICAqIFRvIGJlIG92ZXJyaWRkZW5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBVcmwgdG8gdXNlIGluIHRoZSBhamF4IHJlcXVlc3RcbiAgICovXG4gIGdldFNob3J0VXJsICgpIHsgLy8gVG8gb3ZlcnJpZGVcbiAgICBpZiAobmV3LnRhcmdldCA9PT0gUHVsc2VQYXJhbUF1dG9QYXRoU2luZ2xlUmVxdWVzdENvbXBvbmVudClcbiAgICAgIHRocm93IFR5cGVFcnJvcigndXJsIG9mIGFic3RyYWN0IGNsYXNzIFB1bHNlUGFyYW1BdXRvUGF0aFNpbmdsZVJlcXVlc3RDb21wb25lbnQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcmwgdG8gdXNlIGJ5IHRoZSBBamF4IHJlcXVlc3QuXG4gICAqXG4gICAqIEByZXR1cm4geyFzdHJpbmd9IFVybCB0byB1c2UgaW4gdGhlIGFqYXggcmVxdWVzdFxuICAgKi9cbiAgZ2V0IHVybCAoKSB7XG4gICAgY29uc29sZS5hc3NlcnQoKHR5cGVvZiAodGhpcy5wYXRoKSAhPSAndW5kZWZpbmVkJykgJiYgKCcnICE9IHRoaXMucGF0aCkpO1xuICAgIGlmICgodHlwZW9mICh0aGlzLnBhdGgpID09ICd1bmRlZmluZWQnKSB8fCAoJycgPT0gdGhpcy5wYXRoKSkgeyAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuOiB0aGUgcGF0aCBzaG91bGQgYmUgbm90IGVtcHR5IGFmdGVyIHRoZSBwYXJhbSB2YWxpZGF0aW9uIGNvbnRleHRcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2VtcHR5IHBhdGgnKTtcbiAgICAgIGRlYnVnZ2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWRlYnVnZ2VyXG4gICAgICB0aHJvdyAnZW1wdHkgcGF0aCc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhdGggKyB0aGlzLmdldFNob3J0VXJsKCk7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBldmVudCBjYWxsYmFjayBpbiBjYXNlIGEgcGF0aCBpcyB1cGRhdGVkOiAocmUtKXN0YXJ0IHRoZSBjb21wb25lbnRcbiAgICogKHRvIGdvIHRocm91Z2ggdGhlIHBhcmFtIHZhbGlkYXRpb24gc3RhdGUgYWdhaW4pXG4gICAqIFxuICAgKiBAcGFyYW0geyp9IGV2ZW50IFxuICAgKi9cbiAgb25QYXRoQ2hhbmdlIChldmVudCkge1xuICAgIHRoaXMuc3RhcnQoKTtcbiAgfVxuXG59XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgZm9yIFB1bHNlIGNvbXBvbmVudHMgd2l0aCBhIChldmVudCkgcGFyYW1ldGVyIHZhbGlkYXRpb24gcGhhc2VcbiAqIHRoYXQgcnVuIGFuIGFqYXggcmVxdWVzdCByZWd1bGFybHksIGVhY2ggdGltZSBpdCBuZWVkcyB0byBiZSByZWZyZXNoZWRcbiAqXG4gKiBBdmFpbGFibGUgY29udGV4dHM6IEluaXRpYWxpemF0aW9uLCBQYXJhbVZhbGlkYXRpb24sIFJlc2V0LCBMb2FkLCBOb3JtYWwsIFJlbG9hZCwgU3RvcCwgTm90QXZhaWxhYmxlLCBcbiAqXG4gKiBBdmFpbGFibGUgc3RhdGVzOiBJbml0aWFsaXppbmcsIEVycm9yLCBWYWxpZGF0aW5nLCBMb2FkaW5nLCBTdGFuZGFyZCwgVGVtcG9yYXJ5LCBEZWxheSwgVHJhbnNpZW50RXJyb3IsIEVycm9yXG4gKlxuICogU29tZSBzdGF0ZSBmbG93czpcbiAqIERlZmF1bHQgZmxvdzogSW5pdGlhbGl6YXRpb246SW5pdGlhbGl6aW5nIC0+IFBhcmFtVmFsaWRhdGlvbjpWYWxpZGF0aW5nIC0+IExvYWQ6TG9hZGluZyAtPiBOb3JtYWw6TG9hZGluZyAtPiBOb3JtYWw6TG9hZGluZyAtPiAuLi5cbiAqIEluaXRpYWxpemF0aW9uIGVycm9yIGZsb3c6IEluaXRpYWxpemF0aW9uOkluaXRpYWxpemluZyAtPiBJbml0aWFsaXphdGlvbjpFcnJvclxuICogQWpheCB0cmFuc2llbnQgZXJyb3IgZmxvdzogTm9ybWFsOkxvYWRpbmcgLT4gTm9ybWFsOlRlbXBvcmFyeSAtPiBOb3JtYWw6VGVtcG9yYXJ5IC0+IC4uLiAtPiBOb3JtYWw6VHJhbnNpZW50RXJyb3JcbiAqIEFqYXggZGVsYXkgZXJyb3IgZmxvdzogTm9ybWFsOkxvYWRpbmcgLT4gTm9ybWFsOkRlbGF5IC0+IE5vcm1hbDpEZWxheSAtPiAuLi4gLT4gTm9ybWFsOlRyYW5zaWVudEVycm9yXG4gKiBOb3QgYXZhaWxhYmxlIGZsb3c6IE5vcm1hbDpMb2FkaW5nIC0+IE5vdEF2YWlsYWJsZTpMb2FkaW5nIC0+IC4uLiAtPiBOb3JtYWw6TG9hZGluZ1xuICpcbiAqIFN0YXRlIGltcGxlbWVudGF0aW9uczpcbiAqIC0gSW5pdGlhbGl6YXRpb246SW5pdGlhbGl6aW5nIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5Jbml0aWFsU3RhdGV9XG4gKiAtIFJlc2V0OkluaXRpYWxpemluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+UmVzZXRTdGF0ZX1cbiAqIC0gUGFyYW1WYWxpZGF0aW9uOlZhbGlkYXRpbmcgLSB7QGxpbmsgbW9kdWxlOnN0YXRlflBhcmFtVmFsaWRhdGlvblRpbWVvdXRTdGF0ZX1cbiAqIC0gU3RvcDpTdGFuZGFyZCAtIHtAbGluayBtb2R1bGU6c3RhdGV+U3RvcFN0YXRlfVxuICogLSBOb3JtYWw6TG9hZGluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+Tm9ybWFsUmVxdWVzdFN0YXRlfVxuICogLSBOb3RBdmFpbGFibGU6TG9hZGluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+Tm90QXZhaWxhYmxlU3RhdGV9XG4gKiAtIExvYWQ6TG9hZGluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+TG9hZFN0YXRlfVxuICogLSBSZWxvYWQ6TG9hZGluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+UmVsb2FkU3RhdGV9XG4gKiAtICo6VGVtcG9yYXJ5IC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5UZW1wb3JhcnlTdGF0ZX1cbiAqIC0gKjpEZWxheSAtIHtAbGluayBtb2R1bGU6c3RhdGV+RGVsYXlTdGF0ZX1cbiAqIC0gKjpUcmFuc2llbnRFcnJvciAtIHtAbGluayBtb2R1bGU6c3RhdGV+VHJhbnNpZW50RXJyb3JTdGF0ZX1cbiAqIC0gTm90QXBwbGljYWJsZTpTdGFuZGFyZCAtIHtAbGluayBtb2R1bGU6c3RhdGV+Tm90QXBwbGljYWJsZVN0YXRlfVxuICogLSAqOkVycm9yIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5FcnJvclN0YXRlfVxuICpcbiAqIEBleHRlbmRzIG1vZHVsZTpwdWxzZUNvbXBvbmVudH5QdWxzZVJlZnJlc2hpbmdDb21wb25lbnRcbiAqIFxuKiBAZ3JhcGggUGFyYW1SZWZyZXNoaW5nX0NvbnRleHRGbG93XG5AZyBcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWZyZXNoaW5nIGFuZCBwYXJhbSBhdXRvUGF0aCByZWZyZXNoaW5nIGNvbXBvbmVudDogY29udGV4dCBmbG93XG5AZyBcbkBnIFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICM9PT09IyAgICAgICAgICstLS0tLS0tLS0tKyAgICAgICAgIHxcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICB2ICAgIEggICAgICAgICB2ICAgICAgICAgIHwgICAgICAgICB2XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLSsgICAgICstLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgPT0+IHwgSW5pdGlhbGl6YXRpb24gfCA9PT4gfCBQYXJhbVZhbGlkYXRpb24gfCA9PT4gfCBMb2FkIHwgPT0+IHwgICAgICAgIHwgLS0+IHwgICAgICAgICAgICAgIHwgLS0+IHwgTm90QXBwbGljYWJsZSB8XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLSsgICAgIHwgICAgICAgIHwgICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgIHwgICAgIHwgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEggICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBOb3JtYWwgfCA8PT0gfCBOb3RBdmFpbGFibGUgfFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSCAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICB8ICAgICB8ICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgICBIICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgIHwgICAgIHwgICAgICAgICAgICAgIHxcbkBnICAgICAuLj4gfCAgICAgUmVzZXQgICAgICB8ID09PT09PSMgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgfCAgICAgfCAgICAgICAgICAgICAgfFxuQGcgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICArLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgXiAgICAgICAgICAgICAgXlxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgIEggICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICBIICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLS0tKyAgICAgICB8ICAgICAgICAgICAgSCAgICAgICAgICAgICAgfFxuQGcgICAgIC4uPiB8ICAgICAgU3RvcCAgICAgIHwgLS0+IHwgICAgIFJlbG9hZCAgICAgIHwgPT09PT09Kz09PT09PT09PT09PSMgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0tLS0tLS0rICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpcbiogQGdyYXBoIEluaXRpYWxpemF0aW9uX1N0YXRlRmxvd1xuQGcgXG5AZyAgSW5pdGlhbGl6YXRpb24gY29udGV4dDogc3RhdGUgZmxvd1xuQGcgXG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgPT0+IHwgSW5pdGlhbGl6aW5nIHwgPT0+XG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgdlxuQGcgICAgICAgICAgICstLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICB8ICAgIEVycm9yICAgICB8XG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuKiBAZ3JhcGggUGFyYW1WYWxpZGF0aW9uX1N0YXRlRmxvd1xuQGcgXG5AZyAgUGFyYW1WYWxpZGF0aW9uIGNvbnRleHQ6IHN0YXRlIGZsb3dcbkBnIFxuQGcgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgPT0+IHwgVmFsaWRhdGluZyB8ID09PlxuQGcgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICAgIHZcbkBnICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICB8ICAgRXJyb3IgICAgfFxuQGcgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiogQGdyYXBoIFJlcXVlc3RfU3RhdGVGbG93XG5AZyBcbkBnICAgICAgICBSZXF1ZXN0IChMb2FkLCBOb3JtYWwsIFJlbG9hZCwgTm90QXZhaWxhYmxlLi4uKSBjb250ZXh0OiBzdGF0ZSBmbG93XG5AZyBcbkBnIFxuQGcgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIHwgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIHwgICAgfCAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgdiAgICB2ICAgIHwgICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgfFxuQGcgICAgID09PiB8ICAgICAgICAgICAgIHwgLS0+IHwgICAgICAgfCAtLT4gfCAgICAgICAgICAgfCAtLT4gfCBUcmFuc2llbnRFcnJvciB8ICB8XG5AZyAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgfCAgICAgICB8ICAgICB8ICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0tLS0tLSsgIHxcbkBnICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICB8ICAgICAgIHwgICAgIHwgICAgICAgICAgIHwgICAgICAgXiAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICB8ICAgTG9hZGluZyAgIHwgPC0tIHwgRGVsYXkgfCA8LS0gfCBUZW1wb3JhcnkgfCAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgfCAgICAgICB8ICAgICB8ICAgICAgICAgICB8ICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICB8ICAgICAgIHwgICAgIHwgICAgICAgICAgIHwgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgIHwgICAgICAgfCAtKyAgfCAgICAgICAgICAgfCAtLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0rICB8ICArLS0tLS0tLS0tLS0rICAgICAgIHxcbkBnICAgICAgICAgICBIICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIEggICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgdlxuICovXG5jbGFzcyBQdWxzZVBhcmFtUmVmcmVzaGluZ0NvbXBvbmVudCBleHRlbmRzIFB1bHNlUmVmcmVzaGluZ0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgXG4gICAqL1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgY29uc3Qgc2VsZiA9IHN1cGVyKC4uLmFyZ3MpO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiBcbiAgICogQHBhcmFtIHshc3RyaW5nfSBjb250ZXh0IC0gQ29udGV4dFxuICAgKiBAcmV0dXJuIHshc3RyaW5nfSBrZXlcbiAgICovXG4gIGdldFN0YXJ0S2V5IChjb250ZXh0KSB7XG4gICAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgICBjYXNlICdQYXJhbVZhbGlkYXRpb24nOlxuICAgICAgICByZXR1cm4gJ1ZhbGlkYXRpbmcnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldFN0YXJ0S2V5KGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldE5leHRDb250ZXh0IChjb250ZXh0KSB7XG4gICAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgICBjYXNlICdJbml0aWFsaXphdGlvbic6XG4gICAgICBjYXNlICdSZXNldCc6XG4gICAgICAgIHJldHVybiAnUGFyYW1WYWxpZGF0aW9uJztcbiAgICAgIGNhc2UgJ1BhcmFtVmFsaWRhdGlvbic6XG4gICAgICAgIHJldHVybiAnTG9hZCc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0TmV4dENvbnRleHQoY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiBcbiAgICogQHBhcmFtIHshc3RyaW5nfSBjb250ZXh0IC0gQ29udGV4dFxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGtleSAtIEtleVxuICAgKiBAcmV0dXJucyB7IVN0YXRlfSBDcmVhdGVkIHN0YXRlc1xuICAgKi9cbiAgZGVmaW5lU3RhdGUgKGNvbnRleHQsIGtleSkge1xuICAgIHN3aXRjaCAoY29udGV4dCkge1xuICAgICAgY2FzZSAnUGFyYW1WYWxpZGF0aW9uJzpcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdWYWxpZGF0aW5nJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgc3RhdGUuUGFyYW1WYWxpZGF0aW9uVGltZW91dFN0YXRlKGMgPT4gMzAwMDAuLCBjb250ZXh0LCBrZXksIHRoaXMpOyAvLyB0aW1lb3V0ID0gMzBzXG4gICAgICAgICAgY2FzZSAnRXJyb3InOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5FcnJvclN0YXRlKGNvbnRleHQsIGtleSwgdGhpcyk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFN0YXRlIG5vdCBkZWZpbmVkIGZvciBjb250ZXh0PSR7Y29udGV4dH0gYW5kIGtleT0ke2tleX1gKTtcbiAgICAgICAgICAgIGRlYnVnZ2VyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWRlYnVnZ2VyXG4gICAgICAgICAgICB0aHJvdyAnU3RhdGUgbm90IGRlZmluZWQnO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIuZGVmaW5lU3RhdGUoY29udGV4dCwga2V5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBlbnRlckNvbnRleHQgKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PSAnUGFyYW1WYWxpZGF0aW9uJykge1xuICAgICAgdGhpcy5zdGFydExvYWRpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmVudGVyQ29udGV4dChjb250ZXh0KTtcbiAgfVxuXG4gIGV4aXRDb250ZXh0IChjb250ZXh0KSB7XG4gICAgaWYgKChjb250ZXh0ID09ICdQYXJhbVZhbGlkYXRpb24nKSAmJiB0aGlzLmVuZExvYWRpbmcpIHtcbiAgICAgIHRoaXMuZW5kTG9hZGluZygpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZXhpdENvbnRleHQoY29udGV4dCk7XG4gIH1cbn1cblxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIGZvciBQdWxzZSBjb21wb25lbnRzIHdpdGggYSAoZXZlbnQpIHBhcmFtZXRlciB2YWxpZGF0aW9uIHBoYXNlICsgUGF0aCB2YWxpZGF0aW9uIGlzIGF1dG9tYXRpY1xuICogdGhhdCBydW4gYW4gYWpheCByZXF1ZXN0IHJlZ3VsYXJseSwgZWFjaCB0aW1lIGl0IG5lZWRzIHRvIGJlIHJlZnJlc2hlZFxuICpcbiAqIEF2YWlsYWJsZSBjb250ZXh0czogSW5pdGlhbGl6YXRpb24sIFBhcmFtVmFsaWRhdGlvbiwgUmVzZXQsIExvYWQsIE5vcm1hbCwgUmVsb2FkLCBTdG9wLCBOb3RBdmFpbGFibGUsIE5vdEFwcGxpY2FibGVcbiAqXG4gKiBBdmFpbGFibGUgc3RhdGVzOiBJbml0aWFsaXppbmcsIEVycm9yLCBWYWxpZGF0aW5nLCBMb2FkaW5nLCBTdGFuZGFyZCwgVGVtcG9yYXJ5LCBEZWxheSwgVHJhbnNpZW50RXJyb3IsIEVycm9yXG4gKlxuICogU29tZSBzdGF0ZSBmbG93czpcbiAqIERlZmF1bHQgZmxvdzogSW5pdGlhbGl6YXRpb246SW5pdGlhbGl6aW5nIC0+IFBhcmFtVmFsaWRhdGlvbjpWYWxpZGF0aW5nIC0+IExvYWQ6TG9hZGluZyAtPiBOb3JtYWw6TG9hZGluZyAtPiBOb3JtYWw6TG9hZGluZyAtPiAuLi5cbiAqIEluaXRpYWxpemF0aW9uIGVycm9yIGZsb3c6IEluaXRpYWxpemF0aW9uOkluaXRpYWxpemluZyAtPiBJbml0aWFsaXphdGlvbjpFcnJvclxuICogQWpheCB0cmFuc2llbnQgZXJyb3IgZmxvdzogTm9ybWFsOkxvYWRpbmcgLT4gTm9ybWFsOlRlbXBvcmFyeSAtPiBOb3JtYWw6VGVtcG9yYXJ5IC0+IC4uLiAtPiBOb3JtYWw6VHJhbnNpZW50RXJyb3JcbiAqIEFqYXggZGVsYXkgZXJyb3IgZmxvdzogTm9ybWFsOkxvYWRpbmcgLT4gTm9ybWFsOkRlbGF5IC0+IE5vcm1hbDpEZWxheSAtPiAuLi4gLT4gTm9ybWFsOlRyYW5zaWVudEVycm9yXG4gKiBOb3QgYXZhaWxhYmxlIGZsb3c6IE5vcm1hbDpMb2FkaW5nIC0+IE5vdEF2YWlsYWJsZTpMb2FkaW5nIC0+IC4uLiAtPiBOb3JtYWw6TG9hZGluZ1xuICpcbiAqIFN0YXRlIGltcGxlbWVudGF0aW9uczpcbiAqIC0gSW5pdGlhbGl6YXRpb246SW5pdGlhbGl6aW5nIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5Jbml0aWFsU3RhdGV9XG4gKiAtIFJlc2V0OkluaXRpYWxpemluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+UmVzZXRTdGF0ZX1cbiAqIC0gUGFyYW1WYWxpZGF0aW9uOlZhbGlkYXRpbmcgLSB7QGxpbmsgbW9kdWxlOnN0YXRlflBhcmFtVmFsaWRhdGlvblRpbWVvdXRTdGF0ZX1cbiAqIC0gU3RvcDpTdGFuZGFyZCAtIHtAbGluayBtb2R1bGU6c3RhdGV+U3RvcFN0YXRlfVxuICogLSBOb3JtYWw6TG9hZGluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+Tm9ybWFsUmVxdWVzdFN0YXRlfVxuICogLSBOb3RBdmFpbGFibGU6TG9hZGluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+Tm90QXZhaWxhYmxlU3RhdGV9XG4gKiAtIExvYWQ6TG9hZGluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+TG9hZFN0YXRlfVxuICogLSBSZWxvYWQ6TG9hZGluZyAtIHtAbGluayBtb2R1bGU6c3RhdGV+UmVsb2FkU3RhdGV9XG4gKiAtICo6VGVtcG9yYXJ5IC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5UZW1wb3JhcnlTdGF0ZX1cbiAqIC0gKjpEZWxheSAtIHtAbGluayBtb2R1bGU6c3RhdGV+RGVsYXlTdGF0ZX1cbiAqIC0gKjpUcmFuc2llbnRFcnJvciAtIHtAbGluayBtb2R1bGU6c3RhdGV+VHJhbnNpZW50RXJyb3JTdGF0ZX1cbiAqIC0gTm90QXBwbGljYWJsZTpTdGFuZGFyZCAtIHtAbGluayBtb2R1bGU6c3RhdGV+Tm90QXBwbGljYWJsZVN0YXRlfVxuICogLSAqOkVycm9yIC0ge0BsaW5rIG1vZHVsZTpzdGF0ZX5FcnJvclN0YXRlfVxuICpcbiAqIEBleHRlbmRzIG1vZHVsZTpwdWxzZUNvbXBvbmVudH5QdWxzZVJlZnJlc2hpbmdDb21wb25lbnRcbiAqIFxuKiBAZ3JhcGggUGFyYW1SZWZyZXNoaW5nX0NvbnRleHRGbG93XG5AZyBcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWZyZXNoaW5nIGFuZCBwYXJhbSBhdXRvUGF0aCByZWZyZXNoaW5nIGNvbXBvbmVudDogY29udGV4dCBmbG93XG5AZyBcbkBnIFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICM9PT09IyAgICAgICAgICstLS0tLS0tLS0tKyAgICAgICAgIHxcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICB2ICAgIEggICAgICAgICB2ICAgICAgICAgIHwgICAgICAgICB2XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLSsgICAgICstLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgPT0+IHwgSW5pdGlhbGl6YXRpb24gfCA9PT4gfCBQYXJhbVZhbGlkYXRpb24gfCA9PT4gfCBMb2FkIHwgPT0+IHwgICAgICAgIHwgLS0+IHwgICAgICAgICAgICAgIHwgLS0+IHwgTm90QXBwbGljYWJsZSB8XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLSsgICAgIHwgICAgICAgIHwgICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgIHwgICAgIHwgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEggICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCBOb3JtYWwgfCA8PT0gfCBOb3RBdmFpbGFibGUgfFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSCAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICB8ICAgICB8ICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgICBIICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgIHwgICAgICAgIHwgICAgIHwgICAgICAgICAgICAgIHxcbkBnICAgICAuLj4gfCAgICAgUmVzZXQgICAgICB8ID09PT09PSMgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgfCAgICAgfCAgICAgICAgICAgICAgfFxuQGcgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICArLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgXiAgICAgICAgICAgICAgXlxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgIEggICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICBIICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0tLS0tLS0tLS0tKyAgICAgICB8ICAgICAgICAgICAgSCAgICAgICAgICAgICAgfFxuQGcgICAgIC4uPiB8ICAgICAgU3RvcCAgICAgIHwgLS0+IHwgICAgIFJlbG9hZCAgICAgIHwgPT09PT09Kz09PT09PT09PT09PSMgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLS0tLS0tLS0tLS0rICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpcbiogQGdyYXBoIEluaXRpYWxpemF0aW9uX1N0YXRlRmxvd1xuQGcgXG5AZyAgSW5pdGlhbGl6YXRpb24gY29udGV4dDogc3RhdGUgZmxvd1xuQGcgXG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgPT0+IHwgSW5pdGlhbGl6aW5nIHwgPT0+XG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuQGcgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgdlxuQGcgICAgICAgICAgICstLS0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICB8ICAgIEVycm9yICAgICB8XG5AZyAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tK1xuKiBAZ3JhcGggUGFyYW1WYWxpZGF0aW9uX1N0YXRlRmxvd1xuQGcgXG5AZyAgUGFyYW1WYWxpZGF0aW9uIGNvbnRleHQ6IHN0YXRlIGZsb3dcbkBnIFxuQGcgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgPT0+IHwgVmFsaWRhdGluZyB8ID09PlxuQGcgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbkBnICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgICAgIHZcbkBnICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgICB8ICAgRXJyb3IgICAgfFxuQGcgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiogQGdyYXBoIFJlcXVlc3RfU3RhdGVGbG93XG5AZyBcbkBnICAgICAgICBSZXF1ZXN0IChMb2FkLCBOb3JtYWwsIFJlbG9hZCwgTm90QXZhaWxhYmxlLi4uKSBjb250ZXh0OiBzdGF0ZSBmbG93XG5AZyBcbkBnIFxuQGcgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIHwgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgfCAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIHwgICAgfCAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgICAgdiAgICB2ICAgIHwgICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICAgICArLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLSsgICAgICstLS0tLS0tLS0tLS0tLS0tKyAgfFxuQGcgICAgID09PiB8ICAgICAgICAgICAgIHwgLS0+IHwgICAgICAgfCAtLT4gfCAgICAgICAgICAgfCAtLT4gfCBUcmFuc2llbnRFcnJvciB8ICB8XG5AZyAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgfCAgICAgICB8ICAgICB8ICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0tLS0tLSsgIHxcbkBnICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICB8ICAgICAgIHwgICAgIHwgICAgICAgICAgIHwgICAgICAgXiAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICB8ICAgTG9hZGluZyAgIHwgPC0tIHwgRGVsYXkgfCA8LS0gfCBUZW1wb3JhcnkgfCAgICAgICB8ICAgICAgICAgICAgICAgICB8XG5AZyAgICAgICAgIHwgICAgICAgICAgICAgfCAgICAgfCAgICAgICB8ICAgICB8ICAgICAgICAgICB8ICAgICAgIHwgICAgICAgICAgICAgICAgIHxcbkBnICAgICAgICAgfCAgICAgICAgICAgICB8ICAgICB8ICAgICAgIHwgICAgIHwgICAgICAgICAgIHwgICAgICAgfCAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICB8ICAgICAgICAgICAgIHwgICAgIHwgICAgICAgfCAtKyAgfCAgICAgICAgICAgfCAtLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgICAgKy0tLS0tLS0rICB8ICArLS0tLS0tLS0tLS0rICAgICAgIHxcbkBnICAgICAgICAgICBIICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgfFxuQGcgICAgICAgICAgIEggICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG5AZyAgICAgICAgICAgdlxuICovXG5jbGFzcyBQdWxzZVBhcmFtQXV0b1BhdGhSZWZyZXNoaW5nQ29tcG9uZW50IGV4dGVuZHMgUHVsc2VQYXJhbVJlZnJlc2hpbmdDb21wb25lbnQge1xuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogXG4gICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBzZWxmID0gc3VwZXIoLi4uYXJncyk7XG4gICAgc2VsZi5fcGF0aCA9ICcnO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZWQgcGF0aFxuICAgKiBcbiAgICogQHJldHVybnMgeyFzdHJpbmd9IHBhdGhcbiAgICovXG4gIGdldCBwYXRoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBhdGggZnJvbSB0aGUgY29uZmlndXJhdGlvbiBvciB0aGUgYXR0cmlidXRlXG4gICAqIFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdGhlIHBhdGggaXMgZGVmaW5lZCAobm90IGVtcHR5IGFuZCBub3QgbnVsbClcbiAgICovXG4gIHVwZGF0ZVBhdGhGcm9tQ29uZmlnT3JBdHRyaWJ1dGUgKCkge1xuICAgIHRoaXMuX3BhdGggPSB0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdwYXRoJywgJycpO1xuICAgIHJldHVybiAodHlwZW9mICh0aGlzLnBhdGgpICE9ICd1bmRlZmluZWQnKSAmJiAoJycgIT0gdGhpcy5wYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICogXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gY29udGV4dCAtIENvbnRleHRcbiAgICogQHBhcmFtIHshc3RyaW5nfSBrZXkgLSBLZXlcbiAgICogQHJldHVybnMgeyFTdGF0ZX0gQ3JlYXRlZCBzdGF0ZXNcbiAgICovXG4gIGRlZmluZVN0YXRlIChjb250ZXh0LCBrZXkpIHtcbiAgICBzd2l0Y2ggKGNvbnRleHQpIHtcbiAgICAgIGNhc2UgJ1BhcmFtVmFsaWRhdGlvbic6XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgY2FzZSAnVmFsaWRhdGluZyc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN0YXRlLlBhcmFtQW5kUGF0aFZhbGlkYXRpb25UaW1lb3V0U3RhdGUoYyA9PiAzMDAwMC4sIGNvbnRleHQsIGtleSwgdGhpcyk7IC8vIHRpbWVvdXQgPSAzMHNcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLmRlZmluZVN0YXRlKGNvbnRleHQsIGtleSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ0luaXRpYWxpemF0aW9uJzpcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlICdJbml0aWFsaXppbmcnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBzdGF0ZS5BdXRvUGF0aEluaXRpYWxTdGF0ZShjb250ZXh0LCBrZXksIHRoaXMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZGVmaW5lU3RhdGUoY29udGV4dCwga2V5KTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRlZmluZVN0YXRlKGNvbnRleHQsIGtleSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVybCB0byB1c2UgYnkgdGhlIEFqYXggcmVxdWVzdC5cbiAgICogVG8gYmUgb3ZlcnJpZGRlblxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFVybCB0byB1c2UgaW4gdGhlIGFqYXggcmVxdWVzdFxuICAgKi9cbiAgZ2V0U2hvcnRVcmwgKCkgeyAvLyBUbyBvdmVycmlkZVxuICAgIGlmIChuZXcudGFyZ2V0ID09PSBQdWxzZVBhcmFtQXV0b1BhdGhSZWZyZXNoaW5nQ29tcG9uZW50KVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCd1cmwgb2YgYWJzdHJhY3QgY2xhc3MgUHVsc2VQYXJhbUF1dG9QYXRoUmVmcmVzaGluZ0NvbXBvbmVudCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVybCB0byB1c2UgYnkgdGhlIEFqYXggcmVxdWVzdC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBVcmwgdG8gdXNlIGluIHRoZSBhamF4IHJlcXVlc3RcbiAgICovXG4gIGdldCB1cmwgKCkge1xuICAgIGNvbnNvbGUuYXNzZXJ0KCh0eXBlb2YgKHRoaXMucGF0aCkgIT0gJ3VuZGVmaW5lZCcpICYmICgnJyAhPSB0aGlzLnBhdGgpKTtcbiAgICBpZiAoKHR5cGVvZiAodGhpcy5wYXRoKSA9PSAndW5kZWZpbmVkJykgfHwgKCcnID09IHRoaXMucGF0aCkpIHsgLy8gVGhpcyBzaG91bGQgbm90IGhhcHBlbjogdGhlIHBhdGggc2hvdWxkIGJlIG5vdCBlbXB0eSBhZnRlciB0aGUgcGFyYW0gdmFsaWRhdGlvbiBjb250ZXh0XG4gICAgICBjb25zb2xlLmVycm9yKCdlbXB0eSBwYXRoJyk7XG4gICAgICBkZWJ1Z2dlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1kZWJ1Z2dlclxuICAgICAgdGhyb3cgJ2VtcHR5IHBhdGgnO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXRoICsgdGhpcy5nZXRTaG9ydFVybCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgZXZlbnQgY2FsbGJhY2sgaW4gY2FzZSBhIHBhdGggaXMgdXBkYXRlZDogKHJlLSlzdGFydCB0aGUgY29tcG9uZW50XG4gICAqICh0byBnbyB0aHJvdWdoIHRoZSBwYXJhbSB2YWxpZGF0aW9uIHN0YXRlIGFnYWluKVxuICAgKiBcbiAgICogQHBhcmFtIHsqfSBldmVudCBcbiAgICovXG4gIG9uUGF0aENoYW5nZSAoZXZlbnQpIHtcbiAgICB0aGlzLnN0YXJ0KCk7XG4gIH1cbn1cblxuZXhwb3J0cy5QdWxzZUNvbXBvbmVudCA9IFB1bHNlQ29tcG9uZW50O1xuZXhwb3J0cy5QdWxzZUluaXRpYWxpemVkQ29tcG9uZW50ID0gUHVsc2VJbml0aWFsaXplZENvbXBvbmVudDtcbmV4cG9ydHMuUHVsc2VTaW5nbGVSZXF1ZXN0Q29tcG9uZW50ID0gUHVsc2VTaW5nbGVSZXF1ZXN0Q29tcG9uZW50O1xuZXhwb3J0cy5QdWxzZVJlZnJlc2hpbmdDb21wb25lbnQgPSBQdWxzZVJlZnJlc2hpbmdDb21wb25lbnQ7XG5leHBvcnRzLlB1bHNlUGFyYW1Jbml0aWFsaXplZENvbXBvbmVudCA9IFB1bHNlUGFyYW1Jbml0aWFsaXplZENvbXBvbmVudDtcbmV4cG9ydHMuUHVsc2VQYXJhbVNpbmdsZVJlcXVlc3RDb21wb25lbnQgPSBQdWxzZVBhcmFtU2luZ2xlUmVxdWVzdENvbXBvbmVudDtcbmV4cG9ydHMuUHVsc2VQYXJhbUF1dG9QYXRoU2luZ2xlUmVxdWVzdENvbXBvbmVudCA9IFB1bHNlUGFyYW1BdXRvUGF0aFNpbmdsZVJlcXVlc3RDb21wb25lbnQ7XG5leHBvcnRzLlB1bHNlUGFyYW1SZWZyZXNoaW5nQ29tcG9uZW50ID0gUHVsc2VQYXJhbVJlZnJlc2hpbmdDb21wb25lbnQ7XG5leHBvcnRzLlB1bHNlUGFyYW1BdXRvUGF0aFJlZnJlc2hpbmdDb21wb25lbnQgPSBQdWxzZVBhcmFtQXV0b1BhdGhSZWZyZXNoaW5nQ29tcG9uZW50O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgY3VzdG9tIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSAtIEVsZW1lbnQgdGFnIG5hbWVcbiAqIEBwYXJhbSB7Y2xhc3N9IGNvbXBvbmVudENsYXNzIC0gU3ViLWNsYXNzIG9mIFB1bHNlQ29tcG9uZW50IHRvIHVzZVxuICogQHBhcmFtIHs/c3RyaW5nW119IGF0dHJpYnV0ZXMgLSBbT3B0aW9uYWxdIE9ic2VydmVkIGF0dHJpYnV0ZXNcbiAqL1xuZXhwb3J0cy5yZWdpc3RlckVsZW1lbnQgPSBmdW5jdGlvbiAodGFnTmFtZSwgY29tcG9uZW50Q2xhc3MsIGF0dHJpYnV0ZXMpIHtcbiAgbGV0IGF0dHJzID0gKHR5cGVvZiBhdHRyaWJ1dGVzICE9PSAndW5kZWZpbmVkJykgPyBhdHRyaWJ1dGVzIDogW107XG5cbiAgY2xhc3MgQyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBjb25zdCBzZWxmID0gc3VwZXIoKTtcbiAgICAgIHNlbGYuX3dlYkNvbXBvbmVudCA9IG5ldyBjb21wb25lbnRDbGFzcyhzZWxmKTtcbiAgICAgIGxldCBjb21wb25lbnRNZXRob2RzID0gc2VsZi5fd2ViQ29tcG9uZW50Lm1ldGhvZHM7XG4gICAgICBmb3IgKGxldCBtZXRob2RLZXkgaW4gY29tcG9uZW50TWV0aG9kcykge1xuICAgICAgICBpZiAoY29tcG9uZW50TWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShtZXRob2RLZXkpKSB7XG4gICAgICAgICAgdGhpc1ttZXRob2RLZXldID0gY29tcG9uZW50TWV0aG9kc1ttZXRob2RLZXldLmJpbmQoc2VsZi5fd2ViQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlZCB3ZWIgY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBhc3NvY2lhdGVkIHdlYiBjb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgd2ViQ29tcG9uZW50ICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93ZWJDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgY29ubmVjdGVkQ2FsbGJhY2sgKCkge1xuICAgICAgdGhpcy5fd2ViQ29tcG9uZW50LmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2sgKCkge1xuICAgICAgaWYgKHRoaXMuX3dlYkNvbXBvbmVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWJDb21wb25lbnQuZGlzY29ubmVjdGVkQ2FsbGJhY2soKSkge1xuICAgICAgICAgIC8vIHN3aXRjaCB0byBjb250ZXh0IGRlc3Ryb3lcbiAgICAgICAgICB0aGlzLl93ZWJDb21wb25lbnQgPSBudWxsOyAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIGhlbHAgZ2FyZ2FiZSBjb2xsZWN0b3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayAoYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgIGlmICh0aGlzLl93ZWJDb21wb25lbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3dlYkNvbXBvbmVudC5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLl93ZWJDb21wb25lbnQuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIG9sZFZhbCwgbmV3VmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzICgpIHtcbiAgICAgIHJldHVybiBhdHRycztcbiAgICB9XG4gIH1cbiAgLy8gIE5vdGU6IHRoZXJlIGlzIGEgcG9seWZpbGwgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBjdXN0b21FbGVtZW50cy5kZWZpbmUgZnJvbSB3M2NcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIEMpO1xufVxuIiwiLy8gQ29weXJpZ2h0IChDKSAyMDA5LTIwMjMgTGVtb2luZSBBdXRvbWF0aW9uIFRlY2hub2xvZ2llc1xuLy9cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5cbi8qKlxuICogQG1vZHVsZSBzdGF0ZVxuICogQHJlcXVpcmVzIG1vZHVsZTpwdWxzZVNlcnZpY2VcbiAqL1xudmFyIHB1bHNlU2VydmljZSA9IHJlcXVpcmUoJ3B1bHNlU2VydmljZScpOyAvLyBmb3IgcnVuQWpheCBvbmx5IC0+IHRvIHJlbW92ZSA/XG52YXIgcHVsc2VDb25maWcgPSByZXF1aXJlKCdwdWxzZUNvbmZpZycpOyAvLyBWZXJpZnkgdXNlTG9naW5cbnZhciBldmVudEJ1cyA9IHJlcXVpcmUoJ2V2ZW50QnVzJyk7IC8vIHRvIGNyZWF0ZSBwYXRoIGxpc3RlbmVyXG52YXIgcHVsc2VMb2dpbiA9IHJlcXVpcmUoJ3B1bHNlTG9naW4nKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciB0aGUgc3RhdGVzIHRoYXQgYXJlIHVzZWQgYnkgYSBQdWxzZVN0YXRlQ29tcG9uZW50IHRvIGltcGxlbWVudCB0aGUgc3RhdGUgbWFjaGluZSBwYXR0ZXJuXG4gKlxuICogQHNlZSBtb2R1bGU6cHVsc2VDb21wb25lbnR+UHVsc2VTdGF0ZUNvbXBvbmVudFxuICovXG5jbGFzcyBTdGF0ZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQgLSBTdGF0ZSBjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBTdGF0ZSBrZXlcbiAgICogQHBhcmFtIHtQdWxzZVN0YXRlQ29tcG9uZW50fSBjb21wb25lbnQgLSBBc3NvY2lhdGVkIFB1bHNlIHN0YXRlIGNvbXBvbmVudFxuICAgKi9cbiAgY29uc3RydWN0b3IoY29udGV4dCwga2V5LCBjb21wb25lbnQpIHtcbiAgICBpZiAobmV3LnRhcmdldCA9PT0gU3RhdGUpIHRocm93IFR5cGVFcnJvcignbmV3IG9mIGFic3RyYWN0IGNsYXNzIFN0YXRlJyk7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIHRoaXMuX2NvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB0aGlzLl9wcmV2aW91c1N0YXRlQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wcmV2aW91c1N0YXRlS2V5ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZWQgY29udGV4dFxuICAgKiBcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldCBjb250ZXh0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NvY2lhdGVkIGtleSBcbiAgICogXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXQga2V5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fa2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc29jaWF0ZWQgcHVsc2Ugc3RhdGUgY29tcG9uZW50XG4gICAqXG4gICAqIEByZXR1cm4ge1B1bHNlU3RhdGVDb21wb25lbnR9XG4gICAqL1xuICBnZXQgY29tcG9uZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXZpb3VzIHN0YXRlIGNvbnRleHQsIGJlZm9yZSB0aGlzIHN0YXRlIGlzIGFjdGl2ZSAoYWZ0ZXIgZW50ZXIoKSBpcyBjYWxsZWQpXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gcHJldmlvdXMgc3RhdGUgY29udGV4dFxuICAgKi9cbiAgZ2V0IHByZXZpb3VzU3RhdGVDb250ZXh0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNTdGF0ZUNvbnRleHQ7XG4gIH1cblxuICAvKipcbiAqIFByZXZpb3VzIHN0YXRlIGtleSwgYmVmb3JlIHRoaXMgc3RhdGUgaXMgYWN0aXZlIChhZnRlciBlbnRlcigpIGlzIGNhbGxlZClcbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHByZXZpb3VzIHN0YXRlIGtleVxuICovXG4gIGdldCBwcmV2aW91c1N0YXRlS2V5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNTdGF0ZUtleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgZW50ZXJzIHRoaXMgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByZXZpb3VzU3RhdGVDb250ZXh0IC0gUHJldmlvdXMgc3RhdGUgY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJldmlvdXNTdGF0ZUtleSAtIFByZXZpb3VzIHN0YXRlIGtleVxuICAgKi9cbiAgZW50ZXIgKHByZXZpb3VzU3RhdGVDb250ZXh0LCBwcmV2aW91c1N0YXRlS2V5KSB7XG4gICAgdGhpcy5fcHJldmlvdXNTdGF0ZUNvbnRleHQgPSBwcmV2aW91c1N0YXRlQ29udGV4dDtcbiAgICB0aGlzLl9wcmV2aW91c1N0YXRlS2V5ID0gcHJldmlvdXNTdGF0ZUtleTtcbiAgICB0aGlzLmNvbXBvbmVudC5hZGRDbGFzcygncHVsc2Vjb21wb25lbnQtY29udGV4dC0nICsgdGhpcy5jb250ZXh0KTtcbiAgICB0aGlzLmNvbXBvbmVudC5hZGRDbGFzcygncHVsc2Vjb21wb25lbnQta2V5LScgKyB0aGlzLmtleSk7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGV4aXN0cyB0aGlzIHN0YXRlXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dFN0YXRlQ29udGV4dCAtIE5leHQgc3RhdGUgY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dFN0YXRlS2V5IC0gTmV4dCBzdGF0ZSBrZXlcbiAgICovXG4gIGV4aXQgKG5leHRTdGF0ZUNvbnRleHQsIG5leHRTdGF0ZUtleSkge1xuICAgIHRoaXMuY29tcG9uZW50LnJlbW92ZUNsYXNzKCdwdWxzZWNvbXBvbmVudC1jb250ZXh0LScgKyB0aGlzLmNvbnRleHQpO1xuICAgIHRoaXMuY29tcG9uZW50LnJlbW92ZUNsYXNzKCdwdWxzZWNvbXBvbmVudC1rZXktJyArIHRoaXMua2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgc3RheXMgaW4gdGhpcyBzdGF0ZVxuICAgKi9cbiAgc3RheSAoKSB7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGFzcyBmb3IgdGhlIExBU1Qgc3RhdGUgYmVmb3JlIGRlc3RydWN0aW9uIHVzZWQgYnkgYWxsIFB1bHNlU3RhdGVDb21wb25lbnRcbiAqL1xuY2xhc3MgQmVmb3JlRGVzdHJ1Y3Rpb25TdGF0ZSBleHRlbmRzIFN0YXRlIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dCAtIFN0YXRlIGNvbnRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFN0YXRlIGtleVxuICAgKiBAcGFyYW0ge1B1bHNlU3RhdGVDb21wb25lbnR9IGNvbXBvbmVudCAtIEFzc29jaWF0ZWQgUHVsc2Ugc3RhdGUgY29tcG9uZW50XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBrZXksIGNvbXBvbmVudCkge1xuICAgIHN1cGVyKGNvbnRleHQsIGtleSwgY29tcG9uZW50KTtcbiAgICB0aGlzLl9jb21wb25lbnQgPSBudWxsOyAvLyBObyByZWZlcmVuY2VcbiAgfVxuXG4gIGVudGVyIChwcmV2aW91c1N0YXRlQ29udGV4dCwgcHJldmlvdXNTdGF0ZUtleSkge1xuICAgIHRoaXMuX3ByZXZpb3VzU3RhdGVDb250ZXh0ID0gcHJldmlvdXNTdGF0ZUNvbnRleHQ7XG4gICAgdGhpcy5fcHJldmlvdXNTdGF0ZUtleSA9IHByZXZpb3VzU3RhdGVLZXk7XG4gICAgLy8gRG8gbm90aGluZyBtb3JlID0gbm8gY2FsbCB0byBzdXBlclxuICB9XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBleGlzdHMgdGhpcyBzdGF0ZVxuICAgKiBcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRTdGF0ZUNvbnRleHQgLSBOZXh0IHN0YXRlIGNvbnRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRTdGF0ZUtleSAtIE5leHQgc3RhdGUga2V5XG4gICAqL1xuICBleGl0IChuZXh0U3RhdGVDb250ZXh0LCBuZXh0U3RhdGVLZXkpIHtcbiAgICAvLyBEbyBub3RoaW5nID0gbm8gY2FsbCB0byBzdXBlclxuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbCBzdGF0ZS4gVGhlIG5leHQgc3RhdGUgaXMgZWl0aGVyIHRoZSBuZXh0IGNvbnRleHQgb3IgdGhlIEVycm9yIHN0YXRlXG4gKiBcbiAqIFdoZW4gdGhpcyBzdGF0ZSBpcyBlbnRlcmVkOlxuICogLSBpZiB7QGxpbmsgbW9kdWxlOnB1bHNlQ29tcG9uZW50flB1bHNlSW5pdGlhbGl6ZWRDb21wb25lbnQjaXNJbml0aWFsaXplZH0gcmV0dXJucyB0cnVlLCB7QGxpbmsgbW9kdWxlOnB1bHNlQ29tcG9uZW50flB1bHNlSW5pdGlhbGl6ZWRDb21wb25lbnQjY2xlYXJJbml0aWFsaXphdGlvbn0gaXMgY2FsbGVkIGZpcnN0LlxuICogLSB0aGVuIHtAbGluayBtb2R1bGU6cHVsc2VDb21wb25lbnR+UHVsc2VJbml0aWFsaXplZENvbXBvbmVudCNpbml0aWFsaXplfSBpcyBjYWxsZWQuXG4gKlxuICogQGV4dGVuZHMgbW9kdWxlOnN0YXRlflN0YXRlXG4gKi9cbmNsYXNzIEluaXRpYWxTdGF0ZSBleHRlbmRzIFN0YXRlIHtcbiAgLyoqXG4gICAqIFN3aXRjaCB0byB0aGUgbmV4dCBjb250ZXh0IG9yIHRvIHRoZSBFcnJvciAgc3RhdGVcbiAgICogXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZW50ZXIgKHByZXZpb3VzU3RhdGVDb250ZXh0LCBwcmV2aW91c1N0YXRlS2V5KSB7XG4gICAgdGhpcy5jb21wb25lbnQuY2xlYXJEeW5hbWljU3RhdGVDb250ZW50KCk7IC8vIFRvIGNsZWFyIHN0YXRlIGNsYXNzZXMgaW4gY2FzZSBvZiBjbG9uZVxuXG4gICAgc3VwZXIuZW50ZXIocHJldmlvdXNTdGF0ZUNvbnRleHQsIHByZXZpb3VzU3RhdGVLZXkpO1xuICAgIGlmICh0aGlzLmNvbXBvbmVudC5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50LmNsZWFySW5pdGlhbGl6YXRpb24oKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvbmVudC5pbml0aWFsaXplKCk7XG5cbiAgICAvLyBQcmVwYXJlIGxpc3RlbmVyIHRvIGNoZWNrIGNvbmZpZyBjaGFuZ2UgLSBBZnRlciBpbml0aWFsaXplXG4gICAgZXZlbnRCdXMuRXZlbnRCdXMuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0aGlzLmNvbXBvbmVudCxcbiAgICAgICdjb25maWdDaGFuZ2VFdmVudCcsXG4gICAgICB0aGlzLmNvbXBvbmVudC5vbkNvbmZpZ0NoYW5nZS5iaW5kKHRoaXMuY29tcG9uZW50KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsIHN0YXRlIGZvciBhdXRvIHBhdGggY29tcG9uZW50cy4gKGNyZWF0ZSBsaXN0ZW5lcilcbiAqIFRoZSBuZXh0IHN0YXRlIGlzIGVpdGhlciB0aGUgbmV4dCBjb250ZXh0IG9yIHRoZSBFcnJvciBzdGF0ZVxuICogXG4gKiBXaGVuIHRoaXMgc3RhdGUgaXMgZW50ZXJlZDpcbiAqIC0gaWYge0BsaW5rIG1vZHVsZTpwdWxzZUNvbXBvbmVudH5QdWxzZUluaXRpYWxpemVkQ29tcG9uZW50I2lzSW5pdGlhbGl6ZWR9IHJldHVybnMgdHJ1ZSwge0BsaW5rIG1vZHVsZTpwdWxzZUNvbXBvbmVudH5QdWxzZUluaXRpYWxpemVkQ29tcG9uZW50I2NsZWFySW5pdGlhbGl6YXRpb259IGlzIGNhbGxlZCBmaXJzdC5cbiAqIC0gdGhlbiB7QGxpbmsgbW9kdWxlOnB1bHNlQ29tcG9uZW50flB1bHNlSW5pdGlhbGl6ZWRDb21wb25lbnQjaW5pdGlhbGl6ZX0gaXMgY2FsbGVkLlxuICpcbiAqIEBleHRlbmRzIG1vZHVsZTpzdGF0ZX5TdGF0ZVxuICovXG5jbGFzcyBBdXRvUGF0aEluaXRpYWxTdGF0ZSBleHRlbmRzIFN0YXRlIHsgLy8gKy8tIGlkZW0gSW5pdGlhbCBTdGF0ZVxuICAvKipcbiAgICogU3dpdGNoIHRvIHRoZSBuZXh0IGNvbnRleHQgb3IgdG8gdGhlIEVycm9yICBzdGF0ZVxuICAgKiBcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBlbnRlciAocHJldmlvdXNTdGF0ZUNvbnRleHQsIHByZXZpb3VzU3RhdGVLZXkpIHtcbiAgICB0aGlzLmNvbXBvbmVudC5jbGVhckR5bmFtaWNTdGF0ZUNvbnRlbnQoKTsgLy8gVG8gY2xlYXIgc3RhdGUgY2xhc3NlcyBpbiBjYXNlIG9mIGNsb25lXG5cbiAgICBzdXBlci5lbnRlcihwcmV2aW91c1N0YXRlQ29udGV4dCwgcHJldmlvdXNTdGF0ZUtleSk7XG4gICAgaWYgKHRoaXMuY29tcG9uZW50LmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgdGhpcy5jb21wb25lbnQuY2xlYXJJbml0aWFsaXphdGlvbigpO1xuICAgIH1cblxuICAgIHRoaXMuY29tcG9uZW50LmluaXRpYWxpemUoKTtcblxuICAgIC8vIExpc3RlbmVyIHRvIGNoZWNrIHNlcnZlciBhY2Nlc3MgPT0gQUZURVIgaW5pdGlhbGl6ZVxuICAgIGV2ZW50QnVzLkV2ZW50QnVzLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIodGhpcy5jb21wb25lbnQsXG4gICAgICAnc2VydmVyUHJvYmFibHlPZmZTdG9wUmVmcmVzaCcsXG4gICAgICB0aGlzLmNvbXBvbmVudC5vblNlcnZlck9mZlN0b3BSZWZyZXNoLmJpbmQodGhpcy5jb21wb25lbnQpKTtcbiAgICBldmVudEJ1cy5FdmVudEJ1cy5hZGRHbG9iYWxFdmVudExpc3RlbmVyKHRoaXMuY29tcG9uZW50LFxuICAgICAgJ3NlcnZlclByb2JhYmx5QXZhaWxhYmxlJyxcbiAgICAgIHRoaXMuY29tcG9uZW50Lm9uU2VydmVyQXZhaWxhYmxlQ2hhbmdlLmJpbmQodGhpcy5jb21wb25lbnQpKTtcblxuICAgIC8vIFByZXBhcmUgbGlzdGVuZXIgdG8gY2hlY2sgcGF0aCBjaGFuZ2VcbiAgICBldmVudEJ1cy5FdmVudEJ1cy5hZGRHbG9iYWxFdmVudExpc3RlbmVyKHRoaXMuY29tcG9uZW50LFxuICAgICAgJ3BhdGhDaGFuZ2VFdmVudCcsXG4gICAgICB0aGlzLmNvbXBvbmVudC5vblBhdGhDaGFuZ2UuYmluZCh0aGlzLmNvbXBvbmVudCkpO1xuXG4gICAgLy8gUHJlcGFyZSBsaXN0ZW5lciB0byBjaGVjayBjb25maWcgY2hhbmdlXG4gICAgZXZlbnRCdXMuRXZlbnRCdXMuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0aGlzLmNvbXBvbmVudCxcbiAgICAgICdjb25maWdDaGFuZ2VFdmVudCcsXG4gICAgICB0aGlzLmNvbXBvbmVudC5vbkNvbmZpZ0NoYW5nZS5iaW5kKHRoaXMuY29tcG9uZW50KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldCBzdGF0ZS4gU3RhdGUgd2hlbiB0aGUgcHVsc2UgY29tcG9uZW50IG11c3QgYmUgcmVzZXQuXG4gKiBUaGUgbmV4dCBzdGF0ZSBpcyBlaXRoZXIgdGhlIG5leHQgY29udGV4dCBvciB0aGUgRXJyb3Igc3RhdGVcbiAqIFxuICogV2hlbiB0aGlzIHN0YXRlIGlzIGVudGVyZWQge0BsaW5rIG1vZHVsZTpwdWxzZUNvbXBvbmVudH5QdWxzZUluaXRpYWxpemVkQ29tcG9uZW50I3Jlc2V0fSBpcyBjYWxsZWQuXG4gKiBcbiAqIEBleHRlbmRzIG1vZHVsZTpzdGF0ZX5TdGF0ZVxuICovXG5jbGFzcyBSZXNldFN0YXRlIGV4dGVuZHMgU3RhdGUge1xuICAvKipcbiAgICogU3dpdGNoIHRvIHRoZSBuZXh0IGNvbnRleHQgb3IgdG8gdGhlIEVycm9yIHN0YXRlXG4gICAqIFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGVudGVyIChwcmV2aW91c1N0YXRlQ29udGV4dCwgcHJldmlvdXNTdGF0ZUtleSkge1xuICAgIHN1cGVyLmVudGVyKHByZXZpb3VzU3RhdGVDb250ZXh0LCBwcmV2aW91c1N0YXRlS2V5KTtcbiAgICB0aGlzLmNvbXBvbmVudC5yZXNldCgpO1xuICB9XG59XG5cbi8qKlxuICogU3RhdGljIHN0YXRlLlxuICogSXQgZG9lcyBub3Qgc3dpdGNoIGF1dG9tYXRpY2FsbHkgdG8gYW55IG90aGVyIHN0YXRlXG4gKlxuICogQGV4dGVuZHMgbW9kdWxlOnN0YXRlflN0YXRlXG4gKi9cbmNsYXNzIFN0YXRpY1N0YXRlIGV4dGVuZHMgU3RhdGUge1xufVxuXG4vKipcbiAqIE5vIGFjdGlvbiBzdGF0ZS5cbiAqIFRoZSBuZXh0IHN0YXRlIGlzIGRpcmVjdGx5IHRoZSBzdGF0ZSB0aGF0IGlzIGdpdmVuIGluIHRoZSBhcmd1bWVudCBvZiB0aGUgY29uc3RydWN0b3IuIE5vdGhpbmcgZWxzZSBzcGVjaWFsIGlzIGRvbmUuXG4gKlxuICogQGV4dGVuZHMgbW9kdWxlOnN0YXRlflN0YXRlXG4gKi9cbmNsYXNzIE5vQWN0aW9uU3RhdGUgZXh0ZW5kcyBTdGF0ZSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIFxuICAgKiBAcGFyYW0gez9zdHJpbmd9IG5leHRDb250ZXh0IC0gQ29udGV4dCBvZiB0aGUgbmV4dCBzdGF0ZVxuICAgKiBAcGFyYW0gez9zdHJpbmd9IG5leHRLZXkgLSBLZXkgb2YgdGhlIG5leHQgc3RhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQgLSBTdGF0ZSBjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBTdGF0ZSBrZXlcbiAgICogQHBhcmFtIHtQdWxzZVN0YXRlQ29tcG9uZW50fSBjb21wb25lbnQgLSBQdWxzZSBzdGF0ZSBjb21wb25lbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG5leHRDb250ZXh0LCBuZXh0S2V5LCBjb250ZXh0LCBrZXksIGNvbXBvbmVudCkge1xuICAgIHN1cGVyKGNvbnRleHQsIGtleSwgY29tcG9uZW50KTtcbiAgICB0aGlzLl9uZXh0Q29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIHRoaXMuX25leHRLZXkgPSBuZXh0S2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaCB0byB0aGUgc3RhdGUgdGhhdCB3YXMgZ2l2ZW4gdG8gdGhlIGFyZ3VtZW50IG9mIHRoZSBjb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGVudGVyIChwcmV2aW91c1N0YXRlQ29udGV4dCwgcHJldmlvdXNTdGF0ZUtleSkge1xuICAgIHN1cGVyLmVudGVyKHByZXZpb3VzU3RhdGVDb250ZXh0LCBwcmV2aW91c1N0YXRlS2V5KTtcbiAgICBpZiAoKG51bGwgPT0gdGhpcy5fbmV4dENvbnRleHQpICYmIChudWxsID09IHRoaXMuX25leHRLZXkpKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudC5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5jb21wb25lbnQuc3dpdGNoVG9TdGF0ZSh0aGlzLl9uZXh0Q29udGV4dCwgdGhpcy5fbmV4dEtleSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgdGhhdCByZXR1cm5zIGEgbnVtYmVyIG9mIG1zIHRvIHdhaXRcbiAqIFxuICogQGNhbGxiYWNrIGRlbGF5Q2FsbGJhY2tcbiAqIEBwYXJhbSB7UHVsc2VTdGF0ZUNvbXBvbmVudH0gY29tcG9uZW50IC0gUHVsc2Ugc3RhdGUgY29tcG9uZW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9IGRlbGF5IGluIG1zXG4gKi9cblxuLyoqXG4gKiBXYWl0IHN0YXRlLlxuICogU3dpdGNoIHRvIHRoZSBuZXh0IHN0YXRlIGFmdGVyIGEgc3BlY2lmaWVkIHRpbWVcbiAqXG4gKiBAZXh0ZW5kcyBtb2R1bGU6c3RhdGV+U3RhdGVcbiAqL1xuY2xhc3MgV2FpdFN0YXRlIGV4dGVuZHMgU3RhdGUge1xuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICogXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gbmV4dENvbnRleHQgLSBDb250ZXh0IG9mIHRoZSBuZXh0IHN0YXRlXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gbmV4dEtleSAtIEtleSBvZiB0aGUgbmV4dCBzdGF0ZVxuICAgKiBAcGFyYW0gez9hY3Rpb25DYWxsYmFja30gcHJlQWN0aW9uIC0gUHJlLWFjdGlvblxuICAgKiBAcGFyYW0gez9hY3Rpb25DYWxsYmFja30gcG9zdEFjdGlvbiAtIFBvc3QtYWN0aW9uXG4gICAqIEBwYXJhbSB7ZGVsYXlDYWxsYmFja30gZGVsYXlDYWxsYmFjayAtIENhbGxiYWNrIHRvIGdldCB0aGUgZGVsYXkgYmVmb3JlIHN3aXRjaGluZyB0byB0aGUgc3BlY2lmaWVkIG5leHQgc3RhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQgLSBTdGF0ZSBjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBTdGF0ZSBrZXlcbiAgICogQHBhcmFtIHtQdWxzZVN0YXRlQ29tcG9uZW50fSBjb21wb25lbnQgLSBQdWxzZSBzdGF0ZSBjb21wb25lbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKG5leHRDb250ZXh0LCBuZXh0S2V5LCBwcmVBY3Rpb24sIHBvc3RBY3Rpb24sIGRlbGF5Q2FsbGJhY2ssIGNvbnRleHQsIGtleSwgY29tcG9uZW50KSB7XG4gICAgc3VwZXIoY29udGV4dCwga2V5LCBjb21wb25lbnQpO1xuICAgIHRoaXMuX25leHRDb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgdGhpcy5fbmV4dEtleSA9IG5leHRLZXk7XG4gICAgdGhpcy5fcHJlQWN0aW9uID0gcHJlQWN0aW9uO1xuICAgIHRoaXMuX3Bvc3RBY3Rpb24gPSBwb3N0QWN0aW9uO1xuICAgIHRoaXMuZGVsYXlDYWxsYmFjayA9IGRlbGF5Q2FsbGJhY2s7IC8vIGluIG1zXG4gICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5fdGltZW91dElkID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgc3RhdGUgc3RpbGwgYWN0aXZlID9cbiAgICogKGV4aXQgaGFzIG5vdCBiZWVuIGNhbGxlZCB5ZXQpXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBzdGF0ZSBpcyBhY3RpdmVcbiAgICovXG4gIGdldCBhY3RpdmUgKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBlbnRlciAocHJldmlvdXNTdGF0ZUNvbnRleHQsIHByZXZpb3VzU3RhdGVLZXkpIHtcbiAgICBzdXBlci5lbnRlcihwcmV2aW91c1N0YXRlQ29udGV4dCwgcHJldmlvdXNTdGF0ZUtleSk7XG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICBsZXQgZGVsYXkgPSB0aGlzLmRlbGF5Q2FsbGJhY2sodGhpcy5jb21wb25lbnQpO1xuICAgIHRoaXMuX3RpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fc3dpdGNoLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGV4aXQgKG5leHRTdGF0ZUNvbnRleHQsIG5leHRTdGF0ZUtleSkge1xuICAgIHN1cGVyLmV4aXQobmV4dFN0YXRlQ29udGV4dCwgbmV4dFN0YXRlS2V5KTtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHN0YXkgKCkge1xuICAgIHN1cGVyLnN0YXkoKTtcbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgIGxldCBkZWxheSA9IHRoaXMuZGVsYXlDYWxsYmFjayh0aGlzLmNvbXBvbmVudCk7XG4gICAgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl9zd2l0Y2guYmluZCh0aGlzKSwgZGVsYXkpO1xuICB9XG5cbiAgX2NsZWFyVGltZW91dCAoKSB7XG4gICAgaWYgKG51bGwgIT0gdGhpcy5fdGltZW91dElkKSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCk7XG4gICAgICB0aGlzLl90aW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbmNlIHRoZSB0aW1lIGlzIGNvbXBsZXRlZCwgc3dpdGNoIHRvIHRoZSBuZXh0IHN0YXRlXG4gICAqL1xuICBfc3dpdGNoICgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIGlmICgobnVsbCA9PSB0aGlzLl9uZXh0Q29udGV4dCkgJiYgKG51bGwgPT0gdGhpcy5fbmV4dEtleSkpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuc3dpdGNoVG9OZXh0Q29udGV4dCh0aGlzLl9wcmVBY3Rpb24sIHRoaXMuX3Bvc3RBY3Rpb24pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LnN3aXRjaFRvU3RhdGUodGhpcy5fbmV4dENvbnRleHQsIHRoaXMuX25leHRLZXksIHRoaXMuX3ByZUFjdGlvbiwgdGhpcy5fcG9zdEFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogKEV2ZW50KSBQYXJhbWV0ZXIgdmFsaWRhdGlvbiBzdGF0ZSB3aXRoIGEgdGltZW91dC5cbiAqIFRoZSBldmVudC9saXZlIHBhcmFtZXRlcnMgYXJlIGNoZWNrZWQgYnkgdGhlIFZhbGlkYXRlUGFyYW1ldGVycyBtZXRob2RzIG9mIHRoZSB3ZWIgY29tcG9uZW50LlxuICogXG4gKiBJbiBjYXNlIHRoZXkgYXJlIG9rLCBzd2l0Y2ggdG8gdGhlIG5leHQgY29udGV4dC5cbiAqIFxuICogQWZ0ZXIgc29tZSB0aW1lLCBpZiB0aGUgcGFyYW1ldGVycyBjb3VsZCBub3QgYmUgdmFsaWRhdGVkLFxuICogdGhlIHdlYiBjb21wb25lbnQgaXMgYXV0b21hdGljYWxseSBzd2l0Y2hlZCB0byBhbiBlcnJvciBzdGF0ZVxuICogXG4gKiBJZiB0aGUgd2ViIGNvbXBvbmVudCBkb2VzIG5vdCBjb250YWluIGFueSBWYWxpZGF0ZVBhcmFtZXRlcnMgbWV0aG9kLCBzd2l0Y2ggdG8gdGhlIG5leHQgY29udGV4dCBhdCBvbmNlLlxuICpcbiAqIFdoZW4gdGhpcyBzdGF0ZSBpcyBlbnRlcmVkIHtAbGluayBtb2R1bGU6cHVsc2VDb21wb25lbnR+UHVsc2VQYXJhbUluaXRpYWxpemVkQ29tcG9uZW50I3ZhbGlkYXRlUGFyYW1ldGVyc30gaXMgY2FsbGVkLlxuICogXG4gKiBAZXh0ZW5kcyBtb2R1bGU6c3RhdGV+V2FpdFN0YXRlXG4gKi9cbmNsYXNzIFBhcmFtVmFsaWRhdGlvblRpbWVvdXRTdGF0ZSBleHRlbmRzIFdhaXRTdGF0ZSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqIFxuICAgKiBAcGFyYW0ge2RlbGF5Q2FsbGJhY2t9IGRlbGF5Q2FsbGJhY2sgLSBDYWxsYmFjayB0byBnZXQgdGhlIGRlbGF5IGJlZm9yZSBzd2l0Y2hpbmcgdG8gdGhlIGVycm9yIHN0YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0IC0gU3RhdGUgY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gU3RhdGUga2V5XG4gICAqIEBwYXJhbSB7UHVsc2VTdGF0ZUNvbXBvbmVudH0gY29tcG9uZW50IC0gUHVsc2Ugc3RhdGUgY29tcG9uZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihkZWxheUNhbGxiYWNrLCBjb250ZXh0LCBrZXksIGNvbXBvbmVudCkge1xuICAgIHN1cGVyKG51bGwsICdFcnJvcicsICgpID0+IHRoaXMuY29tcG9uZW50LnNob3dFcnJvcigpLCAoKSA9PiB0aGlzLmNvbXBvbmVudC5yZW1vdmVFcnJvcigpLCBkZWxheUNhbGxiYWNrLCBjb250ZXh0LCBrZXksIGNvbXBvbmVudCk7XG4gIH1cblxuICAvKipcbiAgICogSWYgdmFsaWRhdGVQYXJhbWV0ZXJzIGlzIGEgbWV0aG9kIG9mIHRoZSBjb21wb25lbnQsIHJ1biBpdC5cbiAgICogRWxzZSBzd2l0Y2ggdG8gdGhlIG5leHQgY29udGV4dC5cbiAgICogXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZW50ZXIgKHByZXZpb3VzU3RhdGVDb250ZXh0LCBwcmV2aW91c1N0YXRlS2V5KSB7XG4gICAgc3VwZXIuZW50ZXIocHJldmlvdXNTdGF0ZUNvbnRleHQsIHByZXZpb3VzU3RhdGVLZXkpO1xuICAgIHRoaXMuX3ZhbGlkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBleGl0IChuZXh0U3RhdGVDb250ZXh0LCBuZXh0U3RhdGVLZXkpIHtcbiAgICBzdXBlci5leGl0KG5leHRTdGF0ZUNvbnRleHQsIG5leHRTdGF0ZUtleSk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF5ICgpIHtcbiAgICBzdXBlci5zdGF5KCk7XG4gICAgdGhpcy5fdmFsaWRhdGUoKTtcbiAgfVxuXG4gIF92YWxpZGF0ZSAoKSB7XG4gICAgaWYgKHRoaXMuY29tcG9uZW50LnVwZGF0ZVBhdGhGcm9tQ29uZmlnT3JBdHRyaWJ1dGUpIHsgLy8gSGVyZSB0aGlzIGlzIG9wdGlvbmFsLCB0byBtYWtlIGl0IG1hbmRhdG9yeSB1c2Ugc3RhdGUgUGFyYW1BbmRQYXRoVmFsaWRhdGlvblRpbWVvdXRTdGF0ZVxuICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudC51cGRhdGVQYXRoRnJvbUNvbmZpZ09yQXR0cmlidXRlKCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3dhaXRpbmcgYXR0cmlidXRlIHBhdGgnKTtcbiAgICAgICAgdGhpcy5jb21wb25lbnQuc2V0RXJyb3IoJ1dhaXRpbmcgZm9yIHBhdGgnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5jb21wb25lbnQudmFsaWRhdGVQYXJhbWV0ZXJzKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudC52YWxpZGF0ZVBhcmFtZXRlcnMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oYCR7dGhpcy5jb21wb25lbnQuZ2V0SW5mbyA/IHRoaXMuY29tcG9uZW50LmdldEluZm8oKSA6ICcnfTogdmFsaWRhdGVQYXJhbWV0ZXJzIGlzIG5vdCBkZWZpbmVkLCBpdCBzaG91bGQgcHJvYmFibHkgaW5oZXJpdCBmcm9tIGJhc2UgY29tcG9uZW50IHdpdGggbm8gcGFyYW1ldGVyIHZhbGlkYXRpb24gaW5zdGVhZGApO1xuICAgICAgdGhpcy5jb21wb25lbnQuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIChFdmVudCkgUGFyYW1ldGVyIHZhbGlkYXRpb24gc3RhdGUgd2l0aCBhIHRpbWVvdXQgKyB3YWl0IGZvciB1cmwgcGF0aFxuICogVGhlIGV2ZW50L2xpdmUgcGFyYW1ldGVycyBhcmUgY2hlY2tlZCBieSB0aGUgVmFsaWRhdGVQYXJhbWV0ZXJzIG1ldGhvZHMgb2YgdGhlIHdlYiBjb21wb25lbnQuXG4gKiBcbiAqIEluIGNhc2UgdGhleSBhcmUgb2ssIHN3aXRjaCB0byB0aGUgbmV4dCBjb250ZXh0LlxuICogXG4gKiBBZnRlciBzb21lIHRpbWUsIGlmIHRoZSBwYXJhbWV0ZXJzIGNvdWxkIG5vdCBiZSB2YWxpZGF0ZWQsXG4gKiB0aGUgd2ViIGNvbXBvbmVudCBpcyBhdXRvbWF0aWNhbGx5IHN3aXRjaGVkIHRvIGFuIGVycm9yIHN0YXRlXG4gKiBcbiAqIElmIHRoZSB3ZWIgY29tcG9uZW50IGRvZXMgbm90IGNvbnRhaW4gYW55IFZhbGlkYXRlUGFyYW1ldGVycyBtZXRob2QsIHN3aXRjaCB0byB0aGUgbmV4dCBjb250ZXh0IGF0IG9uY2UuXG4gKlxuICogV2hlbiB0aGlzIHN0YXRlIGlzIGVudGVyZWQge0BsaW5rIG1vZHVsZTpwdWxzZUNvbXBvbmVudH5QdWxzZVBhcmFtSW5pdGlhbGl6ZWRDb21wb25lbnQjdmFsaWRhdGVQYXJhbWV0ZXJzfSBpcyBjYWxsZWQuXG4gKiBcbiAqIEBleHRlbmRzIG1vZHVsZTpzdGF0ZX5QYXJhbVZhbGlkYXRpb25UaW1lb3V0U3RhdGVcbiAqL1xuY2xhc3MgUGFyYW1BbmRQYXRoVmFsaWRhdGlvblRpbWVvdXRTdGF0ZSBleHRlbmRzIFBhcmFtVmFsaWRhdGlvblRpbWVvdXRTdGF0ZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBcbiAgICogQHBhcmFtIHtkZWxheUNhbGxiYWNrfSBkZWxheUNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gZ2V0IHRoZSBkZWxheSBiZWZvcmUgc3dpdGNoaW5nIHRvIHRoZSBlcnJvciBzdGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dCAtIFN0YXRlIGNvbnRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFN0YXRlIGtleVxuICAgKiBAcGFyYW0ge1B1bHNlU3RhdGVDb21wb25lbnR9IGNvbXBvbmVudCAtIFB1bHNlIHN0YXRlIGNvbXBvbmVudFxuICAgKi9cbiAgY29uc3RydWN0b3IoZGVsYXlDYWxsYmFjaywgY29udGV4dCwga2V5LCBjb21wb25lbnQpIHtcbiAgICBzdXBlcihkZWxheUNhbGxiYWNrLCBjb250ZXh0LCBrZXksIGNvbXBvbmVudCk7XG4gIH1cblxuICBfdmFsaWRhdGUgKCkge1xuICAgIC8vIENoZWNrIHRoZSBwYXRoIGlzIHZhbGlkXG4gICAgaWYgKHRoaXMuY29tcG9uZW50LnVwZGF0ZVBhdGhGcm9tQ29uZmlnT3JBdHRyaWJ1dGUpIHtcbiAgICAgIGlmICghdGhpcy5jb21wb25lbnQudXBkYXRlUGF0aEZyb21Db25maWdPckF0dHJpYnV0ZSgpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCd3YWl0aW5nIGF0dHJpYnV0ZSBwYXRoJyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LnNldEVycm9yKCdXYWl0aW5nIGZvciBwYXRoJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7IC8vICF0aGlzLmNvbXBvbmVudC51cGRhdGVQYXRoRnJvbUNvbmZpZ09yQXR0cmlidXRlXG4gICAgICBjb25zb2xlLmVycm9yKCdtaXNzaW5nIG1ldGhvZCB1cGRhdGVQYXRoRnJvbUNvbmZpZ09yQXR0cmlidXRlIGluIGNvbXBvbmVudCcpO1xuICAgICAgZGVidWdnZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZGVidWdnZXJcbiAgICAgIHRocm93ICdtaXNzaW5nIG1ldGhvZCB1cGRhdGVQYXRoRnJvbUNvbmZpZ09yQXR0cmlidXRlJztcbiAgICB9XG4gICAgaWYgKHRoaXMuY29tcG9uZW50LnZhbGlkYXRlUGFyYW1ldGVycykge1xuICAgICAgdGhpcy5jb21wb25lbnQudmFsaWRhdGVQYXJhbWV0ZXJzKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKGAke3RoaXMuY29tcG9uZW50LmdldEluZm8gPyB0aGlzLmNvbXBvbmVudC5nZXRJbmZvKCkgOiAnJ306IHZhbGlkYXRlUGFyYW1ldGVycyBpcyBub3QgZGVmaW5lZCwgaXQgc2hvdWxkIHByb2JhYmx5IGluaGVyaXQgZnJvbSBiYXNlIGNvbXBvbmVudCB3aXRoIG5vIHBhcmFtZXRlciB2YWxpZGF0aW9uIGluc3RlYWRgKTtcbiAgICAgIHRoaXMuY29tcG9uZW50LnN3aXRjaFRvTmV4dENvbnRleHQoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXF1ZXN0IHN0YXRlXG4gKiBcbiAqIEFmdGVyIGEgc3BlY2lmaWVkIGRlbGF5LCBhbiBBamF4IG1ldGhvZCBpcyBjYWxsZWQgdG8gcmVmcmVzaCB0aGUgY29tcG9uZW50LlxuICogVGhlIFVSTCB1c2VkIGJ5IHRoZSBBamF4IHJlcXVlc3QgKCkgaXMgdGhlIHByb3BlcnR5IHVybCBvZiB0aGUgcHVsc2UgY29tcG9uZW50LlxuICpcbiAqIEBleHRlbmRzIG1vZHVsZTpzdGF0ZX5TdGF0ZVxuICovXG5jbGFzcyBSZXF1ZXN0U3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBcbiAgICogQHBhcmFtIHtkZWxheUNhbGxiYWNrfSBkZWxheUNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gZ2V0IHRoZSBpbml0aWFsIGRlbGF5IGJlZm9yZSB0aGUgQWpheCBtZXRob2QgaXMgY2FsbGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0IC0gU3RhdGUgY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gU3RhdGUga2V5XG4gICAqIEBwYXJhbSB7UHVsc2VTdGF0ZUNvbXBvbmVudH0gY29tcG9uZW50IC0gUHVsc2Ugc3RhdGUgY29tcG9uZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihkZWxheUNhbGxiYWNrLCBjb250ZXh0LCBrZXksIGNvbXBvbmVudCkge1xuICAgIGlmIChuZXcudGFyZ2V0ID09PSBSZXF1ZXN0U3RhdGUpIHRocm93IFR5cGVFcnJvcignbmV3IG9mIGFic3RyYWN0IGNsYXNzIFJlcXVlc3RTdGF0ZScpO1xuICAgIHN1cGVyKGNvbnRleHQsIGtleSwgY29tcG9uZW50KTtcbiAgICB0aGlzLmRlbGF5Q2FsbGJhY2sgPSBkZWxheUNhbGxiYWNrOyAvLyBpbiBtc1xuICAgIHRoaXMuX3Rva2VuID0gMDtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl90aW1lb3V0SWQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRva2VuIHRoYXQgaXMgaW5jcmVtZW50ZWQgZWFjaCB0aW1lIHRoZSBlbnRlciBvciBzdGF5IG1ldGhvZCBpcyBjYWxsZWRcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHRva2VuICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdG9rZW47XG4gIH1cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgdG9rZW5cbiAgICogQHNlZSB0b2tlblxuICAgKi9cbiAgaW5jcmVtZW50VG9rZW4gKCkge1xuICAgIHRoaXMuX3Rva2VuICs9IDE7XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIHN0YXRlIHN0aWxsIGFjdGl2ZSA/XG4gICAqIChleGl0IGhhcyBub3QgYmVlbiBjYWxsZWQgeWV0KVxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgc3RhdGUgaXMgYWN0aXZlXG4gICAqL1xuICBnZXQgYWN0aXZlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVybCB0byB1c2UgYnkgdGhlIEFqYXggcmVxdWVzdC5cbiAgICogRGVmYXVsdCBpcyB1cmwgb2YgdGhlIGNvbXBvbmVudC5cbiAgICogSXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHJlbG9hZF91cmwgb2YgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBVcmwgdG8gdXNlIGluIHRoZSBhamF4IHJlcXVlc3RcbiAgICovXG4gIGdldCB1cmwgKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC51cmw7XG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgYW4gaW5pdGlhbCBkZWxheSwgcmV0dXJuZWQgYnkgdGhlIGRlbGF5IGNhbGxiYWNrLCBpbml0aWF0ZSB0aGUgQWpheCByZXF1ZXN0XG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZW50ZXIgKHByZXZpb3VzU3RhdGVDb250ZXh0LCBwcmV2aW91c1N0YXRlS2V5KSB7XG4gICAgc3VwZXIuZW50ZXIocHJldmlvdXNTdGF0ZUNvbnRleHQsIHByZXZpb3VzU3RhdGVLZXkpO1xuICAgIHRoaXMuaW5jcmVtZW50VG9rZW4oKTtcbiAgICB0aGlzLl9hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgIGxldCBkZWxheSA9IHRoaXMuZGVsYXlDYWxsYmFjayh0aGlzLmNvbXBvbmVudCk7XG4gICAgdGhpcy5fdGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl9ydW5HZXREYXRhLmJpbmQodGhpcyksIGRlbGF5LCB0aGlzLnRva2VuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGV4aXQgKG5leHRTdGF0ZUNvbnRleHQsIG5leHRTdGF0ZUtleSkge1xuICAgIHN1cGVyLmV4aXQobmV4dFN0YXRlQ29udGV4dCwgbmV4dFN0YXRlS2V5KTtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBhbiBpbml0aWFsIGRlbGF5LCByZXR1cm5lZCBieSB0aGUgZGVsYXkgY2FsbGJhY2ssIGluaXRpYXRlIHRoZSBBamF4IHJlcXVlc3RcbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBzdGF5ICgpIHtcbiAgICBzdXBlci5zdGF5KCk7XG4gICAgdGhpcy5pbmNyZW1lbnRUb2tlbigpO1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgbGV0IGRlbGF5ID0gdGhpcy5kZWxheUNhbGxiYWNrKHRoaXMuY29tcG9uZW50KTtcbiAgICB0aGlzLl90aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3J1bkdldERhdGEuYmluZCh0aGlzKSwgZGVsYXksIHRoaXMudG9rZW4pO1xuICB9XG5cbiAgX2NsZWFyVGltZW91dCAoKSB7XG4gICAgaWYgKG51bGwgIT0gdGhpcy5fdGltZW91dElkKSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJZCk7XG4gICAgICB0aGlzLl90aW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPbmNlIHRoZSB0aW1lIGlzIGNvbXBsZXRlZCBhbmQgdGhlIGNvbXBvbmVudCBpcyB2aXNpYmxlLCBydW4gdGhlIGFqYXggcmVxdWVzdFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVxdWVzdFRva2VuIC0gVG9rZW4gbnVtYmVyIHRvIGJlIHJldHVybmVkIGJ5IHRoZSBhamF4IHJlcXVlc3RcbiAgICovXG4gIF9ydW5BamF4V2hlbklzVmlzaWJsZSAocmVxdWVzdFRva2VuKSB7XG4gICAgLy8gTm9ybWFsIGJlaGF2aW9yXG4gICAgaWYgKHRoaXMuYWN0aXZlICYmIHRoaXMuX2NoZWNrVG9rZW4ocmVxdWVzdFRva2VuKSkge1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50LmlzVmlzaWJsZSkge1xuICAgICAgICBsZXQgdXNlTG9naW4gPSBwdWxzZUNvbmZpZy5nZXRCb29sKCd1c2VMb2dpbicsIGZhbHNlKTtcbiAgICAgICAgaWYgKHVzZUxvZ2luKSB7XG4gICAgICAgICAgcHVsc2VMb2dpbi5yZWZyZXNoVG9rZW5JZk5lZWRlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50LnBvc3REYXRhKSB7IC8vIHNhdmVyZWFzb24gZm9yIGV4YW1wbGUgb2YgdXNlXG4gICAgICAgICAgbGV0IGpzb25kYXRhID0gdGhpcy5jb21wb25lbnQucG9zdERhdGEoKTtcbiAgICAgICAgICBwdWxzZVNlcnZpY2UucG9zdEFqYXgodGhpcy50b2tlbiwgdGhpcy51cmwsIGpzb25kYXRhLCB0aGlzLmNvbXBvbmVudC50aW1lb3V0LCB0aGlzLl9zdWNjZXNzLmJpbmQodGhpcyksIHRoaXMuX2Vycm9yLmJpbmQodGhpcyksIHRoaXMuX2ZhaWwuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIE5vcm1hbCBiZWhhdmlvclxuICAgICAgICAgIHB1bHNlU2VydmljZS5ydW5BamF4KHRoaXMudG9rZW4sIHRoaXMudXJsLCB0aGlzLmNvbXBvbmVudC50aW1lb3V0LCB0aGlzLl9zdWNjZXNzLmJpbmQodGhpcyksIHRoaXMuX2Vycm9yLmJpbmQodGhpcyksIHRoaXMuX2ZhaWwuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgeyAvLyBOb3QgdmlzaWJsZTogcG9zdHBvbmUgaXQgd2hlbiBpdCBpcyB2aXNpYmxlIGFnYWluXG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgICB0aGlzLl90aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3J1bkdldERhdGEuYmluZCh0aGlzKSwgMjAwLCB0aGlzLnRva2VuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT25jZSB0aGUgdGltZSBpcyBjb21wbGV0ZWQgYW5kIHRoZSBjb21wb25lbnQgaXMgdmlzaWJsZSwgZ2V0IGRhdGFcbiAgICogKHJ1bm5pbmcgYWpheCByZXF1ZXN0IG9yIGNvbXBvbmVudC5fcnVuQWx0ZXJuYXRlR2V0RGF0YSBpZiBkZWZpbmVkKVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gcmVxdWVzdFRva2VuIC0gVG9rZW4gbnVtYmVyIHRvIGJlIHJldHVybmVkIGJ5IHRoZSBhamF4IHJlcXVlc3RcbiAgICovXG4gIF9ydW5HZXREYXRhIChyZXF1ZXN0VG9rZW4pIHtcbiAgICAvLyBTcGVjaWFsIGJlaGF2aW9yIHRvIGdldCBkYXRhIHdpdGhvdXQgdXNpbmcgdXJsIChleCA6IHBlcmlvZG1hbmFnZXIsIHBlcmlvZHRvb2xiYXIpXG4gICAgaWYgKHR5cGVvZiAodGhpcy5jb21wb25lbnQuX3J1bkFsdGVybmF0ZUdldERhdGEpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQuX3J1bkFsdGVybmF0ZUdldERhdGEoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE5vcm1hbCBiZWhhdmlvclxuICAgIHRoaXMuX3J1bkFqYXhXaGVuSXNWaXNpYmxlKHJlcXVlc3RUb2tlbik7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdGhhdCBpcyBydW4gb25jZSB0aGUgQWpheCByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuXG4gICAqIFRoZSByZWZyZXNoIG1ldGhvZCBvZiB0aGUgUHVsc2UgY29tcG9uZW50IGlzIHJ1biBpZiB0aGUgdG9rZW4gbWF0Y2hlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFqYXhUb2tlbiAtIFRva2VuIHRoYXQgaXMgYXNzb2NpYXRlZCB0byB0aGUgYWpheCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRGF0YSByZXR1cm5lZCBieSB0aGUgYWpheCByZXF1ZXN0XG4gICAqL1xuICBfc3VjY2VzcyAoYWpheFRva2VuLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlICYmIHRoaXMuX2NoZWNrVG9rZW4oYWpheFRva2VuKSkge1xuICAgICAgdGhpcy5jb21wb25lbnQubWFuYWdlU3VjY2VzcyhkYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1N1Y2Nlc3MgYnV0IHRva2VuIGNoYW5nZWQsIGlnbm9yZSBpdCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0aGF0IGlzIHJ1biBpZiB0aGUgYWpheCByZXF1ZXN0IHJldHVybnMgYW4gZXJyb3IgZGF0YS5cbiAgICogVGhlIG1hbmFnZUVycm9yIG1ldGhvZCBvZiB0aGUgUHVsc2UgY29tcG9uZW50IGlzIHJ1biBpZiB0aGUgdG9rZW4gbWF0Y2hlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFqYXhUb2tlbiAtIFRva2VuIHRoYXQgaXMgYXNzb2NpYXRlZCB0byB0aGUgYWpheCByZXF1ZXN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gRXJyb3IgZGF0YSB0aGF0IGlzIHJldHVybmVkIGJ5IHRoZSBhamF4IHJlcXVlc3RcbiAgICovXG4gIF9lcnJvciAoYWpheFRva2VuLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlICYmIHRoaXMuX2NoZWNrVG9rZW4oYWpheFRva2VuKSkge1xuICAgICAgdGhpcy5jb21wb25lbnQubWFuYWdlRXJyb3IoZGF0YSk7XG4gICAgICAvLyBTdG9wIGFsbCByZWZyZXNoIDogIGRhdGFiYXNlUHJvYmFibHlEaXNjb25uZWN0ZWQgLT4gZG9uZSBpbiBtYW5hZ2VFcnJvclN0YXR1c1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignRXJyb3IgYnV0IHRva2VuIGNoYW5nZWQsIGlnbm9yZSBpdCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0aGF0IGlzIHJ1biBpZiB0aGUgYWpheCByZXF1ZXN0IGZhaWxzLlxuICAgKiBUaGUgbWFuYWdlRmFpbHVyZSBtZXRob2Qgb2YgdGhlIFB1bHNlIGNvbXBvbmVudCBpcyBydW4gaWYgdGhlIHRva2VuIG1hdGNoZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhamF4VG9rZW4gLSBUb2tlbiB0aGF0IGlzIGFzc29jaWF0ZWQgdG8gdGhlIGFqYXggcmVxdWVzdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVVJMIHVzZWQgaW4gdGhlIGFqYXggcmVxdWVzdFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVGltZW91dCAtIFRoZSBhamF4IHJlcXVlc3QgZW5kZWQgaW4gdGltZSBvdXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHhoclN0YXR1cyAtIFhNTEh0dHBSZXF1ZXN0LnN0YXR1cyBvZiB0aGUgQWpheCByZXF1ZXN0XG4gICAqL1xuICBfZmFpbCAoYWpheFRva2VuLCB1cmwsIGlzVGltZW91dCwgeGhyU3RhdHVzKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlICYmIHRoaXMuX2NoZWNrVG9rZW4oYWpheFRva2VuKSkge1xuICAgICAgdGhpcy5jb21wb25lbnQubWFuYWdlRmFpbHVyZShpc1RpbWVvdXQsIHhoclN0YXR1cyk7XG4gICAgICAvLyBTdG9wIGFsbCByZWZyZXNoIDpcbiAgICAgIGxldCB0YXJnZXQgPSB7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBzb3VyY2U6IHRoaXMuY29tcG9uZW50LmVsZW1lbnQudGFnTmFtZSxcbiAgICAgICAgd2hlbjogbmV3IERhdGUoKVxuICAgICAgfTtcblxuICAgICAgLy8gTk8gRmlsdGVyID09IEFsd2F5cyAhXG4gICAgICAvL2lmICghdGhpcy5jb21wb25lbnQuZWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCkuaW5jbHVkZXMoJ1gtQ0hFQ0snKSApIHsgLy8gIT0gJ1gtQ0hFQ0tTRVJWRVJBQ0NFU1MnKSB7XG4gICAgICBldmVudEJ1cy5FdmVudEJ1cy5kaXNwYXRjaFRvQWxsKCdzZXJ2ZXJQcm9iYWJseURpc2Nvbm5lY3RlZCcsIHRhcmdldCk7XG4gICAgICAvL31cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWx1cmUgYnV0IHRva2VuIGNoYW5nZWQsIGlnbm9yZSBpdCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgdG9rZW4gaXMgc3RpbGwgdmFsaWRcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFqYXhUb2tlbiAtIFRva2VuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB0b2tlbiBpcyBzdGlsbCB2YWxpZFxuICAgKi9cbiAgX2NoZWNrVG9rZW4gKGFqYXhUb2tlbikge1xuICAgIHJldHVybiBhamF4VG9rZW4gPT09IHRoaXMudG9rZW47XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIHN0YXRlLiBUaGUgaW5pdGlhbCBhamF4IHJlcXVlc3Qgd2FzIHNlbnQsIGJ1dCBubyBub3JtYWwgZGF0YSBoYXMgYmVlbiBsb2FkZWQgeWV0LlxuICogVGhlIGFqYXggcmVxdWVzdCBpcyBzZW50IHJpZ2h0IG5vdy5cbiAqXG4gKiBAZXh0ZW5kcyBtb2R1bGU6c3RhdGV+UmVxdWVzdFN0YXRlXG4gKi9cbmNsYXNzIExvYWRTdGF0ZSBleHRlbmRzIFJlcXVlc3RTdGF0ZSB7XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHQgLSBTdGF0ZSBjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBTdGF0ZSBrZXlcbiAgICogQHBhcmFtIHtQdWxzZVN0YXRlQ29tcG9uZW50fSBjb21wb25lbnQgLSBQdWxzZSBzdGF0ZSBjb21wb25lbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbnRleHQsIGtleSwgY29tcG9uZW50KSB7XG4gICAgc3VwZXIoYyA9PiAwLiwgY29udGV4dCwga2V5LCBjb21wb25lbnQpOyAvLyBUT0RPOiBhZGFwdCB0aGUgcmVmcmVzaCByYXRlIGluIGNhc2UgaXQgcmVtYWlucyBpbiB0aGUgbG9hZGluZyBzdGF0ZVxuICB9XG59XG5cbi8qKlxuICogTm9ybWFsIHJlZnJlc2hpbmcgc3RhdGUuU1xuICogXG4gKiBAZXh0ZW5kcyBtb2R1bGU6c3RhdGV+UmVxdWVzdFN0YXRlXG4gKi9cbmNsYXNzIE5vcm1hbFJlcXVlc3RTdGF0ZSBleHRlbmRzIFJlcXVlc3RTdGF0ZSB7XG59XG5cbi8qKlxuICogUmVsb2FkIHN0YXRlLiBUaGUgY29tcG9uZW50IGlzIGluIGEgc3RhdGUgd2hlbiB0aGUgZGF0YSBtdXN0IGJlIHJlbG9hZGVkIHJpZ2h0IG5vdy5cbiAqIFRoZSBkZWZhdWx0IGRlbGF5IGlzIDBtcyBoZXJlLlxuICpcbiAqIEBleHRlbmRzIG1vZHVsZTpzdGF0ZX5SZXF1ZXN0U3RhdGVcbiAqL1xuY2xhc3MgUmVsb2FkU3RhdGUgZXh0ZW5kcyBSZXF1ZXN0U3RhdGUge1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0IC0gU3RhdGUgY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gU3RhdGUga2V5XG4gICAqIEBwYXJhbSB7UHVsc2VTdGF0ZUNvbXBvbmVudH0gY29tcG9uZW50IC0gUHVsc2Ugc3RhdGUgY29tcG9uZW50XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBrZXksIGNvbXBvbmVudCkge1xuICAgIHN1cGVyKGMgPT4gMC4sIGNvbnRleHQsIGtleSwgY29tcG9uZW50KTsgLy8gVE9ETzogYWRhcHQgdGhlIHJlZnJlc2ggcmF0ZSBpbiBjYXNlIGl0IHJlbWFpbnMgaW4gcmVsb2FkIHN0YXRlXG4gIH1cblxuICAvKipcbiAgICogVGhlIGJlZm9yZVJlbG9hZCBtZXRob2Qgb2YgdGhlIFB1bHNlIGNvbXBvbmVudCBpcyBmaXJzdCBydW4gaWYgZGVmaW5lZFxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGVudGVyIChwcmV2aW91c1N0YXRlQ29udGV4dCwgcHJldmlvdXNTdGF0ZUtleSkge1xuICAgIGlmICh0aGlzLmNvbXBvbmVudC5iZWZvcmVSZWxvYWQpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50LmJlZm9yZVJlbG9hZCgpO1xuICAgIH1cbiAgICBzdXBlci5lbnRlcihwcmV2aW91c1N0YXRlQ29udGV4dCwgcHJldmlvdXNTdGF0ZUtleSk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3QgYXZhaWxhYmxlIHN0YXRlLiBUaGUgZGF0YSBpcyBub3QgYXZhaWxhYmxlIHJpZ2h0IG5vdyAoaXQgbWF5IGJlIGluIHRoZSBmdXR1cmUpXG4gKlxuICogQGV4dGVuZHMgbW9kdWxlOnN0YXRlflJlcXVlc3RTdGF0ZVxuICovXG5jbGFzcyBOb3RBdmFpbGFibGVTdGF0ZSBleHRlbmRzIFJlcXVlc3RTdGF0ZSB7XG59XG5cbi8qKlxuICogVGVtcG9yYXJ5IGVycm9yIHN0YXRlLiBBIHRlbXBvcmFyeSBlcnJvciBoYXBwZW5lZC5cbiAqXG4gKiBAZXh0ZW5kcyBtb2R1bGU6c3RhdGV+UmVxdWVzdFN0YXRlXG4gKi9cbmNsYXNzIFRlbXBvcmFyeVN0YXRlIGV4dGVuZHMgUmVxdWVzdFN0YXRlIHtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZW50ZXIgKHByZXZpb3VzU3RhdGVDb250ZXh0LCBwcmV2aW91c1N0YXRlS2V5KSB7XG4gICAgdGhpcy5fZW50ZXJfZGF0ZV90aW1lID0gbmV3IERhdGUoKTtcbiAgICBzdXBlci5lbnRlcihwcmV2aW91c1N0YXRlQ29udGV4dCwgcHJldmlvdXNTdGF0ZUtleSk7XG4gIH1cblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBleGl0IChuZXh0U3RhdGVDb250ZXh0LCBuZXh0U3RhdGVLZXkpIHtcbiAgICB0aGlzLl9lbnRlcl9kYXRlX3RpbWUgPSB1bmRlZmluZWQ7XG4gICAgc3VwZXIuZXhpdChuZXh0U3RhdGVDb250ZXh0LCBuZXh0U3RhdGVLZXkpO1xuICB9XG5cbiAgc3RheSAoKSB7XG4gICAgY29uc29sZS5hc3NlcnQodHlwZW9mICh0aGlzLl9lbnRlcl9kYXRlX3RpbWUpICE9ICd1bmRlZmluZWQnKTtcbiAgICBsZXQgYWdlID0gbmV3IERhdGUoKSAtIHRoaXMuX2VudGVyX2RhdGVfdGltZTtcbiAgICBpZiAodGhpcy5jb21wb25lbnQudHJhbnNpZW50RXJyb3JEZWxheSA8IGFnZSkge1xuICAgICAgdGhpcy5jb21wb25lbnQuc3dpdGNoVG9LZXkoJ1RyYW5zaWVudEVycm9yJywgdGhpcy5jb21wb25lbnQuc2hvd0Vycm9yLCB0aGlzLmNvbXBvbmVudC5yZW1vdmVFcnJvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3VwZXIuc3RheSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERlbGF5IGVycm9yIHN0YXRlLiBBIHRlbXBvcmFyeSBlcnJvciB0aGF0IGNhbiByZW1haW4gYWN0aXZlIHBvdGVudGlhbGx5IGEgbG9uZyB0aW1lIGhhcHBlbmVkLlxuICpcbiAqIEBleHRlbmRzIG1vZHVsZTpzdGF0ZX5SZXF1ZXN0U3RhdGVcbiAqL1xuY2xhc3MgRGVsYXlTdGF0ZSBleHRlbmRzIFJlcXVlc3RTdGF0ZSB7XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGVudGVyIChwcmV2aW91c1N0YXRlQ29udGV4dCwgcHJldmlvdXNTdGF0ZUtleSkge1xuICAgIHRoaXMuX2VudGVyX2RhdGVfdGltZSA9IG5ldyBEYXRlKCk7XG4gICAgc3VwZXIuZW50ZXIocHJldmlvdXNTdGF0ZUNvbnRleHQsIHByZXZpb3VzU3RhdGVLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZXhpdCAobmV4dFN0YXRlQ29udGV4dCwgbmV4dFN0YXRlS2V5KSB7XG4gICAgdGhpcy5fZW50ZXJfZGF0ZV90aW1lID0gdW5kZWZpbmVkO1xuICAgIHN1cGVyLmV4aXQobmV4dFN0YXRlQ29udGV4dCwgbmV4dFN0YXRlS2V5KTtcbiAgfVxuXG4gIHN0YXkgKCkge1xuICAgIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiAodGhpcy5fZW50ZXJfZGF0ZV90aW1lKSAhPSAndW5kZWZpbmVkJyk7XG4gICAgbGV0IGFnZSA9IG5ldyBEYXRlKCkgLSB0aGlzLl9lbnRlcl9kYXRlX3RpbWU7XG4gICAgaWYgKHRoaXMuY29tcG9uZW50LnRyYW5zaWVudEVycm9yRGVsYXkgPCBhZ2UpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50LnN3aXRjaFRvS2V5KCdUcmFuc2llbnRFcnJvcicsIHRoaXMuY29tcG9uZW50LnNob3dFcnJvciwgdGhpcy5jb21wb25lbnQucmVtb3ZlRXJyb3IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN1cGVyLnN0YXkoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2llbnQgZXJyb3Igc3RhdGUuIFN0YXRlIHRvIHVzZSB3aGVuIG1hbnkgdGVtcG9yYXJ5IG9yIGRlbGF5IHN0YXRlcyBhbHJlYWR5IG9jY3VycmVkLlxuICogVGhlbiB0aGUgcHVsc2UgY29tcG9uZW50IGNhbiBiZSBzd2l0Y2ggdG8gYSB3YXJuaW5nIHN0YXRlLlxuICpcbiAqIEBleHRlbmRzIG1vZHVsZTpzdGF0ZX5SZXF1ZXN0U3RhdGVcbiAqL1xuY2xhc3MgVHJhbnNpZW50RXJyb3JTdGF0ZSBleHRlbmRzIFJlcXVlc3RTdGF0ZSB7XG4gIC8qKlxuICAgKiBJZiBkZWZpbmVkLCB0aGUgZW50ZXJUcmFuc2llbnRFcnJvclN0YXRlIG1ldGhvZCBvZiB0aGUgUHVsc2UgY29tcG9uZW50IGlzIHJ1blxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGVudGVyIChwcmV2aW91c1N0YXRlQ29udGV4dCwgcHJldmlvdXNTdGF0ZUtleSkge1xuICAgIHN1cGVyLmVudGVyKHByZXZpb3VzU3RhdGVDb250ZXh0LCBwcmV2aW91c1N0YXRlS2V5KTtcbiAgICBpZiAodGhpcy5jb21wb25lbnQuZW50ZXJUcmFuc2llbnRFcnJvclN0YXRlKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudC5lbnRlclRyYW5zaWVudEVycm9yU3RhdGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgZGVmaW5lZCwgdGhlIGV4aXRUcmFuc2llbnRFcnJvclN0YXRlIG1ldGhvZCBvZiB0aGUgUHVsc2UgY29tcG9uZW50IGlzIHJ1blxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGV4aXQgKG5leHRTdGF0ZUNvbnRleHQsIG5leHRTdGF0ZUtleSkge1xuICAgIGlmICh0aGlzLmNvbXBvbmVudC5leGl0VHJhbnNpZW50RXJyb3JTdGF0ZSkge1xuICAgICAgdGhpcy5jb21wb25lbnQuZXhpdFRyYW5zaWVudEVycm9yU3RhdGUoKTtcbiAgICB9XG4gICAgc3VwZXIuZXhpdChuZXh0U3RhdGVDb250ZXh0LCBuZXh0U3RhdGVLZXkpO1xuICB9XG59XG5cbi8qKlxuICogRXJyb3Igc3RhdGUuXG4gKlxuICogQGV4dGVuZHMgbW9kdWxlOnN0YXRlflN0YXRlXG4gKi9cbmNsYXNzIEVycm9yU3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG4gIC8qKlxuICAgKiBJZiBkZWZpbmVkLCB0aGUgZW50ZXJFcnJvclN0YXRlIG1ldGhvZCBvZiB0aGUgUHVsc2UgY29tcG9uZW50IGlzIHJ1blxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGVudGVyIChwcmV2aW91c1N0YXRlQ29udGV4dCwgcHJldmlvdXNTdGF0ZUtleSkge1xuICAgIHN1cGVyLmVudGVyKHByZXZpb3VzU3RhdGVDb250ZXh0LCBwcmV2aW91c1N0YXRlS2V5KTtcbiAgICBpZiAodGhpcy5jb21wb25lbnQuZW50ZXJFcnJvclN0YXRlKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudC5lbnRlckVycm9yU3RhdGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgZGVmaW5lZCwgdGhlIGV4aXRFcnJvclN0YXRlIG1ldGhvZCBvZiB0aGUgUHVsc2UgY29tcG9uZW50IGlzIHJ1blxuICAgKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGV4aXQgKG5leHRTdGF0ZUNvbnRleHQsIG5leHRTdGF0ZUtleSkge1xuICAgIGlmICh0aGlzLmNvbXBvbmVudC5leGl0RXJyb3JTdGF0ZSkge1xuICAgICAgdGhpcy5jb21wb25lbnQuZXhpdEVycm9yU3RhdGUoKTtcbiAgICB9XG4gICAgc3VwZXIuZXhpdChuZXh0U3RhdGVDb250ZXh0LCBuZXh0U3RhdGVLZXkpO1xuICB9XG59XG5cbi8qKlxuICogTm90IGFwcGxpY2FibGUgc3RhdGUuIFxuICpcbiAqIEBleHRlbmRzIG1vZHVsZTpzdGF0ZX5TdGF0ZVxuICovXG5jbGFzcyBOb3RBcHBsaWNhYmxlU3RhdGUgZXh0ZW5kcyBTdGF0ZSB7XG59XG5cbi8qKlxuICogU3RvcCBzdGF0ZS4gU3RhdGUgdG8gdXNlIHdoZW4gYSBjb21wb25lbnQgc2hvdWxkIHN0b3AgcmVmcmVzaC4gXG4gKiBGb3IgZXhhbXBsZSwgd2hlbiB3ZWIgc2VydmljZXMgYXJlIG5vdCBhdmFpbGFibGUuXG4gKlxuICogQGV4dGVuZHMgbW9kdWxlOnN0YXRlflN0YXRlXG4gKi9cbmNsYXNzIFN0b3BTdGF0ZSBleHRlbmRzIFN0YXRlIHtcbn1cblxuXG5leHBvcnRzLlN0YXRlID0gU3RhdGU7XG5leHBvcnRzLkJlZm9yZURlc3RydWN0aW9uU3RhdGUgPSBCZWZvcmVEZXN0cnVjdGlvblN0YXRlO1xuZXhwb3J0cy5Jbml0aWFsU3RhdGUgPSBJbml0aWFsU3RhdGU7XG5leHBvcnRzLkF1dG9QYXRoSW5pdGlhbFN0YXRlID0gQXV0b1BhdGhJbml0aWFsU3RhdGU7XG5leHBvcnRzLlBhcmFtQW5kUGF0aFZhbGlkYXRpb25UaW1lb3V0U3RhdGUgPSBQYXJhbUFuZFBhdGhWYWxpZGF0aW9uVGltZW91dFN0YXRlO1xuZXhwb3J0cy5SZXNldFN0YXRlID0gUmVzZXRTdGF0ZTtcbmV4cG9ydHMuU3RhdGljU3RhdGUgPSBTdGF0aWNTdGF0ZTtcbmV4cG9ydHMuTm9BY3Rpb25TdGF0ZSA9IE5vQWN0aW9uU3RhdGU7XG5leHBvcnRzLldhaXRTdGF0ZSA9IFdhaXRTdGF0ZTtcbmV4cG9ydHMuUGFyYW1WYWxpZGF0aW9uVGltZW91dFN0YXRlID0gUGFyYW1WYWxpZGF0aW9uVGltZW91dFN0YXRlO1xuZXhwb3J0cy5SZXF1ZXN0U3RhdGUgPSBSZXF1ZXN0U3RhdGU7XG5leHBvcnRzLkxvYWRTdGF0ZSA9IExvYWRTdGF0ZTtcbmV4cG9ydHMuTm9ybWFsUmVxdWVzdFN0YXRlID0gTm9ybWFsUmVxdWVzdFN0YXRlO1xuZXhwb3J0cy5SZWxvYWRTdGF0ZSA9IFJlbG9hZFN0YXRlO1xuZXhwb3J0cy5Ob3RBdmFpbGFibGVTdGF0ZSA9IE5vdEF2YWlsYWJsZVN0YXRlO1xuZXhwb3J0cy5UZW1wb3JhcnlTdGF0ZSA9IFRlbXBvcmFyeVN0YXRlO1xuZXhwb3J0cy5EZWxheVN0YXRlID0gRGVsYXlTdGF0ZTtcbmV4cG9ydHMuVHJhbnNpZW50RXJyb3JTdGF0ZSA9IFRyYW5zaWVudEVycm9yU3RhdGU7XG5leHBvcnRzLkVycm9yU3RhdGUgPSBFcnJvclN0YXRlO1xuZXhwb3J0cy5Ob3RBcHBsaWNhYmxlU3RhdGUgPSBOb3RBcHBsaWNhYmxlU3RhdGU7XG5leHBvcnRzLlN0b3BTdGF0ZSA9IFN0b3BTdGF0ZTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcIkFhY3V0ZVwiOlwiw4FcIixcImFhY3V0ZVwiOlwiw6FcIixcIkFicmV2ZVwiOlwixIJcIixcImFicmV2ZVwiOlwixINcIixcImFjXCI6XCLiiL5cIixcImFjZFwiOlwi4oi/XCIsXCJhY0VcIjpcIuKIvsyzXCIsXCJBY2lyY1wiOlwiw4JcIixcImFjaXJjXCI6XCLDolwiLFwiYWN1dGVcIjpcIsK0XCIsXCJBY3lcIjpcItCQXCIsXCJhY3lcIjpcItCwXCIsXCJBRWxpZ1wiOlwiw4ZcIixcImFlbGlnXCI6XCLDplwiLFwiYWZcIjpcIuKBoVwiLFwiQWZyXCI6XCLwnZSEXCIsXCJhZnJcIjpcIvCdlJ5cIixcIkFncmF2ZVwiOlwiw4BcIixcImFncmF2ZVwiOlwiw6BcIixcImFsZWZzeW1cIjpcIuKEtVwiLFwiYWxlcGhcIjpcIuKEtVwiLFwiQWxwaGFcIjpcIs6RXCIsXCJhbHBoYVwiOlwizrFcIixcIkFtYWNyXCI6XCLEgFwiLFwiYW1hY3JcIjpcIsSBXCIsXCJhbWFsZ1wiOlwi4qi/XCIsXCJhbXBcIjpcIiZcIixcIkFNUFwiOlwiJlwiLFwiYW5kYW5kXCI6XCLiqZVcIixcIkFuZFwiOlwi4qmTXCIsXCJhbmRcIjpcIuKIp1wiLFwiYW5kZFwiOlwi4qmcXCIsXCJhbmRzbG9wZVwiOlwi4qmYXCIsXCJhbmR2XCI6XCLiqZpcIixcImFuZ1wiOlwi4oigXCIsXCJhbmdlXCI6XCLipqRcIixcImFuZ2xlXCI6XCLiiKBcIixcImFuZ21zZGFhXCI6XCLipqhcIixcImFuZ21zZGFiXCI6XCLipqlcIixcImFuZ21zZGFjXCI6XCLipqpcIixcImFuZ21zZGFkXCI6XCLipqtcIixcImFuZ21zZGFlXCI6XCLipqxcIixcImFuZ21zZGFmXCI6XCLipq1cIixcImFuZ21zZGFnXCI6XCLipq5cIixcImFuZ21zZGFoXCI6XCLipq9cIixcImFuZ21zZFwiOlwi4oihXCIsXCJhbmdydFwiOlwi4oifXCIsXCJhbmdydHZiXCI6XCLiir5cIixcImFuZ3J0dmJkXCI6XCLipp1cIixcImFuZ3NwaFwiOlwi4oiiXCIsXCJhbmdzdFwiOlwiw4VcIixcImFuZ3phcnJcIjpcIuKNvFwiLFwiQW9nb25cIjpcIsSEXCIsXCJhb2dvblwiOlwixIVcIixcIkFvcGZcIjpcIvCdlLhcIixcImFvcGZcIjpcIvCdlZJcIixcImFwYWNpclwiOlwi4qmvXCIsXCJhcFwiOlwi4omIXCIsXCJhcEVcIjpcIuKpsFwiLFwiYXBlXCI6XCLiiYpcIixcImFwaWRcIjpcIuKJi1wiLFwiYXBvc1wiOlwiJ1wiLFwiQXBwbHlGdW5jdGlvblwiOlwi4oGhXCIsXCJhcHByb3hcIjpcIuKJiFwiLFwiYXBwcm94ZXFcIjpcIuKJilwiLFwiQXJpbmdcIjpcIsOFXCIsXCJhcmluZ1wiOlwiw6VcIixcIkFzY3JcIjpcIvCdkpxcIixcImFzY3JcIjpcIvCdkrZcIixcIkFzc2lnblwiOlwi4omUXCIsXCJhc3RcIjpcIipcIixcImFzeW1wXCI6XCLiiYhcIixcImFzeW1wZXFcIjpcIuKJjVwiLFwiQXRpbGRlXCI6XCLDg1wiLFwiYXRpbGRlXCI6XCLDo1wiLFwiQXVtbFwiOlwiw4RcIixcImF1bWxcIjpcIsOkXCIsXCJhd2NvbmludFwiOlwi4oizXCIsXCJhd2ludFwiOlwi4qiRXCIsXCJiYWNrY29uZ1wiOlwi4omMXCIsXCJiYWNrZXBzaWxvblwiOlwiz7ZcIixcImJhY2twcmltZVwiOlwi4oC1XCIsXCJiYWNrc2ltXCI6XCLiiL1cIixcImJhY2tzaW1lcVwiOlwi4ouNXCIsXCJCYWNrc2xhc2hcIjpcIuKIllwiLFwiQmFydlwiOlwi4qunXCIsXCJiYXJ2ZWVcIjpcIuKKvVwiLFwiYmFyd2VkXCI6XCLijIVcIixcIkJhcndlZFwiOlwi4oyGXCIsXCJiYXJ3ZWRnZVwiOlwi4oyFXCIsXCJiYnJrXCI6XCLijrVcIixcImJicmt0YnJrXCI6XCLijrZcIixcImJjb25nXCI6XCLiiYxcIixcIkJjeVwiOlwi0JFcIixcImJjeVwiOlwi0LFcIixcImJkcXVvXCI6XCLigJ5cIixcImJlY2F1c1wiOlwi4oi1XCIsXCJiZWNhdXNlXCI6XCLiiLVcIixcIkJlY2F1c2VcIjpcIuKItVwiLFwiYmVtcHR5dlwiOlwi4qawXCIsXCJiZXBzaVwiOlwiz7ZcIixcImJlcm5vdVwiOlwi4oSsXCIsXCJCZXJub3VsbGlzXCI6XCLihKxcIixcIkJldGFcIjpcIs6SXCIsXCJiZXRhXCI6XCLOslwiLFwiYmV0aFwiOlwi4oS2XCIsXCJiZXR3ZWVuXCI6XCLiiaxcIixcIkJmclwiOlwi8J2UhVwiLFwiYmZyXCI6XCLwnZSfXCIsXCJiaWdjYXBcIjpcIuKLglwiLFwiYmlnY2lyY1wiOlwi4pevXCIsXCJiaWdjdXBcIjpcIuKLg1wiLFwiYmlnb2RvdFwiOlwi4qiAXCIsXCJiaWdvcGx1c1wiOlwi4qiBXCIsXCJiaWdvdGltZXNcIjpcIuKoglwiLFwiYmlnc3FjdXBcIjpcIuKohlwiLFwiYmlnc3RhclwiOlwi4piFXCIsXCJiaWd0cmlhbmdsZWRvd25cIjpcIuKWvVwiLFwiYmlndHJpYW5nbGV1cFwiOlwi4pazXCIsXCJiaWd1cGx1c1wiOlwi4qiEXCIsXCJiaWd2ZWVcIjpcIuKLgVwiLFwiYmlnd2VkZ2VcIjpcIuKLgFwiLFwiYmthcm93XCI6XCLipI1cIixcImJsYWNrbG96ZW5nZVwiOlwi4qerXCIsXCJibGFja3NxdWFyZVwiOlwi4paqXCIsXCJibGFja3RyaWFuZ2xlXCI6XCLilrRcIixcImJsYWNrdHJpYW5nbGVkb3duXCI6XCLilr5cIixcImJsYWNrdHJpYW5nbGVsZWZ0XCI6XCLil4JcIixcImJsYWNrdHJpYW5nbGVyaWdodFwiOlwi4pa4XCIsXCJibGFua1wiOlwi4pCjXCIsXCJibGsxMlwiOlwi4paSXCIsXCJibGsxNFwiOlwi4paRXCIsXCJibGszNFwiOlwi4paTXCIsXCJibG9ja1wiOlwi4paIXCIsXCJibmVcIjpcIj3ig6VcIixcImJuZXF1aXZcIjpcIuKJoeKDpVwiLFwiYk5vdFwiOlwi4qutXCIsXCJibm90XCI6XCLijJBcIixcIkJvcGZcIjpcIvCdlLlcIixcImJvcGZcIjpcIvCdlZNcIixcImJvdFwiOlwi4oqlXCIsXCJib3R0b21cIjpcIuKKpVwiLFwiYm93dGllXCI6XCLii4hcIixcImJveGJveFwiOlwi4qeJXCIsXCJib3hkbFwiOlwi4pSQXCIsXCJib3hkTFwiOlwi4pWVXCIsXCJib3hEbFwiOlwi4pWWXCIsXCJib3hETFwiOlwi4pWXXCIsXCJib3hkclwiOlwi4pSMXCIsXCJib3hkUlwiOlwi4pWSXCIsXCJib3hEclwiOlwi4pWTXCIsXCJib3hEUlwiOlwi4pWUXCIsXCJib3hoXCI6XCLilIBcIixcImJveEhcIjpcIuKVkFwiLFwiYm94aGRcIjpcIuKUrFwiLFwiYm94SGRcIjpcIuKVpFwiLFwiYm94aERcIjpcIuKVpVwiLFwiYm94SERcIjpcIuKVplwiLFwiYm94aHVcIjpcIuKUtFwiLFwiYm94SHVcIjpcIuKVp1wiLFwiYm94aFVcIjpcIuKVqFwiLFwiYm94SFVcIjpcIuKVqVwiLFwiYm94bWludXNcIjpcIuKKn1wiLFwiYm94cGx1c1wiOlwi4oqeXCIsXCJib3h0aW1lc1wiOlwi4oqgXCIsXCJib3h1bFwiOlwi4pSYXCIsXCJib3h1TFwiOlwi4pWbXCIsXCJib3hVbFwiOlwi4pWcXCIsXCJib3hVTFwiOlwi4pWdXCIsXCJib3h1clwiOlwi4pSUXCIsXCJib3h1UlwiOlwi4pWYXCIsXCJib3hVclwiOlwi4pWZXCIsXCJib3hVUlwiOlwi4pWaXCIsXCJib3h2XCI6XCLilIJcIixcImJveFZcIjpcIuKVkVwiLFwiYm94dmhcIjpcIuKUvFwiLFwiYm94dkhcIjpcIuKVqlwiLFwiYm94VmhcIjpcIuKVq1wiLFwiYm94VkhcIjpcIuKVrFwiLFwiYm94dmxcIjpcIuKUpFwiLFwiYm94dkxcIjpcIuKVoVwiLFwiYm94VmxcIjpcIuKVolwiLFwiYm94VkxcIjpcIuKVo1wiLFwiYm94dnJcIjpcIuKUnFwiLFwiYm94dlJcIjpcIuKVnlwiLFwiYm94VnJcIjpcIuKVn1wiLFwiYm94VlJcIjpcIuKVoFwiLFwiYnByaW1lXCI6XCLigLVcIixcImJyZXZlXCI6XCLLmFwiLFwiQnJldmVcIjpcIsuYXCIsXCJicnZiYXJcIjpcIsKmXCIsXCJic2NyXCI6XCLwnZK3XCIsXCJCc2NyXCI6XCLihKxcIixcImJzZW1pXCI6XCLigY9cIixcImJzaW1cIjpcIuKIvVwiLFwiYnNpbWVcIjpcIuKLjVwiLFwiYnNvbGJcIjpcIuKnhVwiLFwiYnNvbFwiOlwiXFxcXFwiLFwiYnNvbGhzdWJcIjpcIuKfiFwiLFwiYnVsbFwiOlwi4oCiXCIsXCJidWxsZXRcIjpcIuKAolwiLFwiYnVtcFwiOlwi4omOXCIsXCJidW1wRVwiOlwi4qquXCIsXCJidW1wZVwiOlwi4omPXCIsXCJCdW1wZXFcIjpcIuKJjlwiLFwiYnVtcGVxXCI6XCLiiY9cIixcIkNhY3V0ZVwiOlwixIZcIixcImNhY3V0ZVwiOlwixIdcIixcImNhcGFuZFwiOlwi4qmEXCIsXCJjYXBicmN1cFwiOlwi4qmJXCIsXCJjYXBjYXBcIjpcIuKpi1wiLFwiY2FwXCI6XCLiiKlcIixcIkNhcFwiOlwi4ouSXCIsXCJjYXBjdXBcIjpcIuKph1wiLFwiY2FwZG90XCI6XCLiqYBcIixcIkNhcGl0YWxEaWZmZXJlbnRpYWxEXCI6XCLihYVcIixcImNhcHNcIjpcIuKIqe+4gFwiLFwiY2FyZXRcIjpcIuKBgVwiLFwiY2Fyb25cIjpcIsuHXCIsXCJDYXlsZXlzXCI6XCLihK1cIixcImNjYXBzXCI6XCLiqY1cIixcIkNjYXJvblwiOlwixIxcIixcImNjYXJvblwiOlwixI1cIixcIkNjZWRpbFwiOlwiw4dcIixcImNjZWRpbFwiOlwiw6dcIixcIkNjaXJjXCI6XCLEiFwiLFwiY2NpcmNcIjpcIsSJXCIsXCJDY29uaW50XCI6XCLiiLBcIixcImNjdXBzXCI6XCLiqYxcIixcImNjdXBzc21cIjpcIuKpkFwiLFwiQ2RvdFwiOlwixIpcIixcImNkb3RcIjpcIsSLXCIsXCJjZWRpbFwiOlwiwrhcIixcIkNlZGlsbGFcIjpcIsK4XCIsXCJjZW1wdHl2XCI6XCLiprJcIixcImNlbnRcIjpcIsKiXCIsXCJjZW50ZXJkb3RcIjpcIsK3XCIsXCJDZW50ZXJEb3RcIjpcIsK3XCIsXCJjZnJcIjpcIvCdlKBcIixcIkNmclwiOlwi4oStXCIsXCJDSGN5XCI6XCLQp1wiLFwiY2hjeVwiOlwi0YdcIixcImNoZWNrXCI6XCLinJNcIixcImNoZWNrbWFya1wiOlwi4pyTXCIsXCJDaGlcIjpcIs6nXCIsXCJjaGlcIjpcIs+HXCIsXCJjaXJjXCI6XCLLhlwiLFwiY2lyY2VxXCI6XCLiiZdcIixcImNpcmNsZWFycm93bGVmdFwiOlwi4oa6XCIsXCJjaXJjbGVhcnJvd3JpZ2h0XCI6XCLihrtcIixcImNpcmNsZWRhc3RcIjpcIuKKm1wiLFwiY2lyY2xlZGNpcmNcIjpcIuKKmlwiLFwiY2lyY2xlZGRhc2hcIjpcIuKKnVwiLFwiQ2lyY2xlRG90XCI6XCLiiplcIixcImNpcmNsZWRSXCI6XCLCrlwiLFwiY2lyY2xlZFNcIjpcIuKTiFwiLFwiQ2lyY2xlTWludXNcIjpcIuKKllwiLFwiQ2lyY2xlUGx1c1wiOlwi4oqVXCIsXCJDaXJjbGVUaW1lc1wiOlwi4oqXXCIsXCJjaXJcIjpcIuKXi1wiLFwiY2lyRVwiOlwi4qeDXCIsXCJjaXJlXCI6XCLiiZdcIixcImNpcmZuaW50XCI6XCLiqJBcIixcImNpcm1pZFwiOlwi4quvXCIsXCJjaXJzY2lyXCI6XCLip4JcIixcIkNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oiyXCIsXCJDbG9zZUN1cmx5RG91YmxlUXVvdGVcIjpcIuKAnVwiLFwiQ2xvc2VDdXJseVF1b3RlXCI6XCLigJlcIixcImNsdWJzXCI6XCLimaNcIixcImNsdWJzdWl0XCI6XCLimaNcIixcImNvbG9uXCI6XCI6XCIsXCJDb2xvblwiOlwi4oi3XCIsXCJDb2xvbmVcIjpcIuKptFwiLFwiY29sb25lXCI6XCLiiZRcIixcImNvbG9uZXFcIjpcIuKJlFwiLFwiY29tbWFcIjpcIixcIixcImNvbW1hdFwiOlwiQFwiLFwiY29tcFwiOlwi4oiBXCIsXCJjb21wZm5cIjpcIuKImFwiLFwiY29tcGxlbWVudFwiOlwi4oiBXCIsXCJjb21wbGV4ZXNcIjpcIuKEglwiLFwiY29uZ1wiOlwi4omFXCIsXCJjb25nZG90XCI6XCLiqa1cIixcIkNvbmdydWVudFwiOlwi4omhXCIsXCJjb25pbnRcIjpcIuKIrlwiLFwiQ29uaW50XCI6XCLiiK9cIixcIkNvbnRvdXJJbnRlZ3JhbFwiOlwi4oiuXCIsXCJjb3BmXCI6XCLwnZWUXCIsXCJDb3BmXCI6XCLihIJcIixcImNvcHJvZFwiOlwi4oiQXCIsXCJDb3Byb2R1Y3RcIjpcIuKIkFwiLFwiY29weVwiOlwiwqlcIixcIkNPUFlcIjpcIsKpXCIsXCJjb3B5c3JcIjpcIuKEl1wiLFwiQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oizXCIsXCJjcmFyclwiOlwi4oa1XCIsXCJjcm9zc1wiOlwi4pyXXCIsXCJDcm9zc1wiOlwi4qivXCIsXCJDc2NyXCI6XCLwnZKeXCIsXCJjc2NyXCI6XCLwnZK4XCIsXCJjc3ViXCI6XCLiq49cIixcImNzdWJlXCI6XCLiq5FcIixcImNzdXBcIjpcIuKrkFwiLFwiY3N1cGVcIjpcIuKrklwiLFwiY3Rkb3RcIjpcIuKLr1wiLFwiY3VkYXJybFwiOlwi4qS4XCIsXCJjdWRhcnJyXCI6XCLipLVcIixcImN1ZXByXCI6XCLii55cIixcImN1ZXNjXCI6XCLii59cIixcImN1bGFyclwiOlwi4oa2XCIsXCJjdWxhcnJwXCI6XCLipL1cIixcImN1cGJyY2FwXCI6XCLiqYhcIixcImN1cGNhcFwiOlwi4qmGXCIsXCJDdXBDYXBcIjpcIuKJjVwiLFwiY3VwXCI6XCLiiKpcIixcIkN1cFwiOlwi4ouTXCIsXCJjdXBjdXBcIjpcIuKpilwiLFwiY3VwZG90XCI6XCLiio1cIixcImN1cG9yXCI6XCLiqYVcIixcImN1cHNcIjpcIuKIqu+4gFwiLFwiY3VyYXJyXCI6XCLihrdcIixcImN1cmFycm1cIjpcIuKkvFwiLFwiY3VybHllcXByZWNcIjpcIuKLnlwiLFwiY3VybHllcXN1Y2NcIjpcIuKLn1wiLFwiY3VybHl2ZWVcIjpcIuKLjlwiLFwiY3VybHl3ZWRnZVwiOlwi4ouPXCIsXCJjdXJyZW5cIjpcIsKkXCIsXCJjdXJ2ZWFycm93bGVmdFwiOlwi4oa2XCIsXCJjdXJ2ZWFycm93cmlnaHRcIjpcIuKGt1wiLFwiY3V2ZWVcIjpcIuKLjlwiLFwiY3V3ZWRcIjpcIuKLj1wiLFwiY3djb25pbnRcIjpcIuKIslwiLFwiY3dpbnRcIjpcIuKIsVwiLFwiY3lsY3R5XCI6XCLijK1cIixcImRhZ2dlclwiOlwi4oCgXCIsXCJEYWdnZXJcIjpcIuKAoVwiLFwiZGFsZXRoXCI6XCLihLhcIixcImRhcnJcIjpcIuKGk1wiLFwiRGFyclwiOlwi4oahXCIsXCJkQXJyXCI6XCLih5NcIixcImRhc2hcIjpcIuKAkFwiLFwiRGFzaHZcIjpcIuKrpFwiLFwiZGFzaHZcIjpcIuKKo1wiLFwiZGJrYXJvd1wiOlwi4qSPXCIsXCJkYmxhY1wiOlwiy51cIixcIkRjYXJvblwiOlwixI5cIixcImRjYXJvblwiOlwixI9cIixcIkRjeVwiOlwi0JRcIixcImRjeVwiOlwi0LRcIixcImRkYWdnZXJcIjpcIuKAoVwiLFwiZGRhcnJcIjpcIuKHilwiLFwiRERcIjpcIuKFhVwiLFwiZGRcIjpcIuKFhlwiLFwiRERvdHJhaGRcIjpcIuKkkVwiLFwiZGRvdHNlcVwiOlwi4qm3XCIsXCJkZWdcIjpcIsKwXCIsXCJEZWxcIjpcIuKIh1wiLFwiRGVsdGFcIjpcIs6UXCIsXCJkZWx0YVwiOlwizrRcIixcImRlbXB0eXZcIjpcIuKmsVwiLFwiZGZpc2h0XCI6XCLipb9cIixcIkRmclwiOlwi8J2Uh1wiLFwiZGZyXCI6XCLwnZShXCIsXCJkSGFyXCI6XCLipaVcIixcImRoYXJsXCI6XCLih4NcIixcImRoYXJyXCI6XCLih4JcIixcIkRpYWNyaXRpY2FsQWN1dGVcIjpcIsK0XCIsXCJEaWFjcml0aWNhbERvdFwiOlwiy5lcIixcIkRpYWNyaXRpY2FsRG91YmxlQWN1dGVcIjpcIsudXCIsXCJEaWFjcml0aWNhbEdyYXZlXCI6XCJgXCIsXCJEaWFjcml0aWNhbFRpbGRlXCI6XCLLnFwiLFwiZGlhbVwiOlwi4ouEXCIsXCJkaWFtb25kXCI6XCLii4RcIixcIkRpYW1vbmRcIjpcIuKLhFwiLFwiZGlhbW9uZHN1aXRcIjpcIuKZplwiLFwiZGlhbXNcIjpcIuKZplwiLFwiZGllXCI6XCLCqFwiLFwiRGlmZmVyZW50aWFsRFwiOlwi4oWGXCIsXCJkaWdhbW1hXCI6XCLPnVwiLFwiZGlzaW5cIjpcIuKLslwiLFwiZGl2XCI6XCLDt1wiLFwiZGl2aWRlXCI6XCLDt1wiLFwiZGl2aWRlb250aW1lc1wiOlwi4ouHXCIsXCJkaXZvbnhcIjpcIuKLh1wiLFwiREpjeVwiOlwi0IJcIixcImRqY3lcIjpcItGSXCIsXCJkbGNvcm5cIjpcIuKMnlwiLFwiZGxjcm9wXCI6XCLijI1cIixcImRvbGxhclwiOlwiJFwiLFwiRG9wZlwiOlwi8J2Uu1wiLFwiZG9wZlwiOlwi8J2VlVwiLFwiRG90XCI6XCLCqFwiLFwiZG90XCI6XCLLmVwiLFwiRG90RG90XCI6XCLig5xcIixcImRvdGVxXCI6XCLiiZBcIixcImRvdGVxZG90XCI6XCLiiZFcIixcIkRvdEVxdWFsXCI6XCLiiZBcIixcImRvdG1pbnVzXCI6XCLiiLhcIixcImRvdHBsdXNcIjpcIuKIlFwiLFwiZG90c3F1YXJlXCI6XCLiiqFcIixcImRvdWJsZWJhcndlZGdlXCI6XCLijIZcIixcIkRvdWJsZUNvbnRvdXJJbnRlZ3JhbFwiOlwi4oivXCIsXCJEb3VibGVEb3RcIjpcIsKoXCIsXCJEb3VibGVEb3duQXJyb3dcIjpcIuKHk1wiLFwiRG91YmxlTGVmdEFycm93XCI6XCLih5BcIixcIkRvdWJsZUxlZnRSaWdodEFycm93XCI6XCLih5RcIixcIkRvdWJsZUxlZnRUZWVcIjpcIuKrpFwiLFwiRG91YmxlTG9uZ0xlZnRBcnJvd1wiOlwi4p+4XCIsXCJEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3dcIjpcIuKfulwiLFwiRG91YmxlTG9uZ1JpZ2h0QXJyb3dcIjpcIuKfuVwiLFwiRG91YmxlUmlnaHRBcnJvd1wiOlwi4oeSXCIsXCJEb3VibGVSaWdodFRlZVwiOlwi4oqoXCIsXCJEb3VibGVVcEFycm93XCI6XCLih5FcIixcIkRvdWJsZVVwRG93bkFycm93XCI6XCLih5VcIixcIkRvdWJsZVZlcnRpY2FsQmFyXCI6XCLiiKVcIixcIkRvd25BcnJvd0JhclwiOlwi4qSTXCIsXCJkb3duYXJyb3dcIjpcIuKGk1wiLFwiRG93bkFycm93XCI6XCLihpNcIixcIkRvd25hcnJvd1wiOlwi4oeTXCIsXCJEb3duQXJyb3dVcEFycm93XCI6XCLih7VcIixcIkRvd25CcmV2ZVwiOlwizJFcIixcImRvd25kb3duYXJyb3dzXCI6XCLih4pcIixcImRvd25oYXJwb29ubGVmdFwiOlwi4oeDXCIsXCJkb3duaGFycG9vbnJpZ2h0XCI6XCLih4JcIixcIkRvd25MZWZ0UmlnaHRWZWN0b3JcIjpcIuKlkFwiLFwiRG93bkxlZnRUZWVWZWN0b3JcIjpcIuKlnlwiLFwiRG93bkxlZnRWZWN0b3JCYXJcIjpcIuKlllwiLFwiRG93bkxlZnRWZWN0b3JcIjpcIuKGvVwiLFwiRG93blJpZ2h0VGVlVmVjdG9yXCI6XCLipZ9cIixcIkRvd25SaWdodFZlY3RvckJhclwiOlwi4qWXXCIsXCJEb3duUmlnaHRWZWN0b3JcIjpcIuKHgVwiLFwiRG93blRlZUFycm93XCI6XCLihqdcIixcIkRvd25UZWVcIjpcIuKKpFwiLFwiZHJia2Fyb3dcIjpcIuKkkFwiLFwiZHJjb3JuXCI6XCLijJ9cIixcImRyY3JvcFwiOlwi4oyMXCIsXCJEc2NyXCI6XCLwnZKfXCIsXCJkc2NyXCI6XCLwnZK5XCIsXCJEU2N5XCI6XCLQhVwiLFwiZHNjeVwiOlwi0ZVcIixcImRzb2xcIjpcIuKntlwiLFwiRHN0cm9rXCI6XCLEkFwiLFwiZHN0cm9rXCI6XCLEkVwiLFwiZHRkb3RcIjpcIuKLsVwiLFwiZHRyaVwiOlwi4pa/XCIsXCJkdHJpZlwiOlwi4pa+XCIsXCJkdWFyclwiOlwi4oe1XCIsXCJkdWhhclwiOlwi4qWvXCIsXCJkd2FuZ2xlXCI6XCLipqZcIixcIkRaY3lcIjpcItCPXCIsXCJkemN5XCI6XCLRn1wiLFwiZHppZ3JhcnJcIjpcIuKfv1wiLFwiRWFjdXRlXCI6XCLDiVwiLFwiZWFjdXRlXCI6XCLDqVwiLFwiZWFzdGVyXCI6XCLiqa5cIixcIkVjYXJvblwiOlwixJpcIixcImVjYXJvblwiOlwixJtcIixcIkVjaXJjXCI6XCLDilwiLFwiZWNpcmNcIjpcIsOqXCIsXCJlY2lyXCI6XCLiiZZcIixcImVjb2xvblwiOlwi4omVXCIsXCJFY3lcIjpcItCtXCIsXCJlY3lcIjpcItGNXCIsXCJlRERvdFwiOlwi4qm3XCIsXCJFZG90XCI6XCLEllwiLFwiZWRvdFwiOlwixJdcIixcImVEb3RcIjpcIuKJkVwiLFwiZWVcIjpcIuKFh1wiLFwiZWZEb3RcIjpcIuKJklwiLFwiRWZyXCI6XCLwnZSIXCIsXCJlZnJcIjpcIvCdlKJcIixcImVnXCI6XCLiqppcIixcIkVncmF2ZVwiOlwiw4hcIixcImVncmF2ZVwiOlwiw6hcIixcImVnc1wiOlwi4qqWXCIsXCJlZ3Nkb3RcIjpcIuKqmFwiLFwiZWxcIjpcIuKqmVwiLFwiRWxlbWVudFwiOlwi4oiIXCIsXCJlbGludGVyc1wiOlwi4o+nXCIsXCJlbGxcIjpcIuKEk1wiLFwiZWxzXCI6XCLiqpVcIixcImVsc2RvdFwiOlwi4qqXXCIsXCJFbWFjclwiOlwixJJcIixcImVtYWNyXCI6XCLEk1wiLFwiZW1wdHlcIjpcIuKIhVwiLFwiZW1wdHlzZXRcIjpcIuKIhVwiLFwiRW1wdHlTbWFsbFNxdWFyZVwiOlwi4pe7XCIsXCJlbXB0eXZcIjpcIuKIhVwiLFwiRW1wdHlWZXJ5U21hbGxTcXVhcmVcIjpcIuKWq1wiLFwiZW1zcDEzXCI6XCLigIRcIixcImVtc3AxNFwiOlwi4oCFXCIsXCJlbXNwXCI6XCLigINcIixcIkVOR1wiOlwixYpcIixcImVuZ1wiOlwixYtcIixcImVuc3BcIjpcIuKAglwiLFwiRW9nb25cIjpcIsSYXCIsXCJlb2dvblwiOlwixJlcIixcIkVvcGZcIjpcIvCdlLxcIixcImVvcGZcIjpcIvCdlZZcIixcImVwYXJcIjpcIuKLlVwiLFwiZXBhcnNsXCI6XCLip6NcIixcImVwbHVzXCI6XCLiqbFcIixcImVwc2lcIjpcIs61XCIsXCJFcHNpbG9uXCI6XCLOlVwiLFwiZXBzaWxvblwiOlwizrVcIixcImVwc2l2XCI6XCLPtVwiLFwiZXFjaXJjXCI6XCLiiZZcIixcImVxY29sb25cIjpcIuKJlVwiLFwiZXFzaW1cIjpcIuKJglwiLFwiZXFzbGFudGd0clwiOlwi4qqWXCIsXCJlcXNsYW50bGVzc1wiOlwi4qqVXCIsXCJFcXVhbFwiOlwi4qm1XCIsXCJlcXVhbHNcIjpcIj1cIixcIkVxdWFsVGlsZGVcIjpcIuKJglwiLFwiZXF1ZXN0XCI6XCLiiZ9cIixcIkVxdWlsaWJyaXVtXCI6XCLih4xcIixcImVxdWl2XCI6XCLiiaFcIixcImVxdWl2RERcIjpcIuKpuFwiLFwiZXF2cGFyc2xcIjpcIuKnpVwiLFwiZXJhcnJcIjpcIuKlsVwiLFwiZXJEb3RcIjpcIuKJk1wiLFwiZXNjclwiOlwi4oSvXCIsXCJFc2NyXCI6XCLihLBcIixcImVzZG90XCI6XCLiiZBcIixcIkVzaW1cIjpcIuKps1wiLFwiZXNpbVwiOlwi4omCXCIsXCJFdGFcIjpcIs6XXCIsXCJldGFcIjpcIs63XCIsXCJFVEhcIjpcIsOQXCIsXCJldGhcIjpcIsOwXCIsXCJFdW1sXCI6XCLDi1wiLFwiZXVtbFwiOlwiw6tcIixcImV1cm9cIjpcIuKCrFwiLFwiZXhjbFwiOlwiIVwiLFwiZXhpc3RcIjpcIuKIg1wiLFwiRXhpc3RzXCI6XCLiiINcIixcImV4cGVjdGF0aW9uXCI6XCLihLBcIixcImV4cG9uZW50aWFsZVwiOlwi4oWHXCIsXCJFeHBvbmVudGlhbEVcIjpcIuKFh1wiLFwiZmFsbGluZ2RvdHNlcVwiOlwi4omSXCIsXCJGY3lcIjpcItCkXCIsXCJmY3lcIjpcItGEXCIsXCJmZW1hbGVcIjpcIuKZgFwiLFwiZmZpbGlnXCI6XCLvrINcIixcImZmbGlnXCI6XCLvrIBcIixcImZmbGxpZ1wiOlwi76yEXCIsXCJGZnJcIjpcIvCdlIlcIixcImZmclwiOlwi8J2Uo1wiLFwiZmlsaWdcIjpcIu+sgVwiLFwiRmlsbGVkU21hbGxTcXVhcmVcIjpcIuKXvFwiLFwiRmlsbGVkVmVyeVNtYWxsU3F1YXJlXCI6XCLilqpcIixcImZqbGlnXCI6XCJmalwiLFwiZmxhdFwiOlwi4pmtXCIsXCJmbGxpZ1wiOlwi76yCXCIsXCJmbHRuc1wiOlwi4paxXCIsXCJmbm9mXCI6XCLGklwiLFwiRm9wZlwiOlwi8J2UvVwiLFwiZm9wZlwiOlwi8J2Vl1wiLFwiZm9yYWxsXCI6XCLiiIBcIixcIkZvckFsbFwiOlwi4oiAXCIsXCJmb3JrXCI6XCLii5RcIixcImZvcmt2XCI6XCLiq5lcIixcIkZvdXJpZXJ0cmZcIjpcIuKEsVwiLFwiZnBhcnRpbnRcIjpcIuKojVwiLFwiZnJhYzEyXCI6XCLCvVwiLFwiZnJhYzEzXCI6XCLihZNcIixcImZyYWMxNFwiOlwiwrxcIixcImZyYWMxNVwiOlwi4oWVXCIsXCJmcmFjMTZcIjpcIuKFmVwiLFwiZnJhYzE4XCI6XCLihZtcIixcImZyYWMyM1wiOlwi4oWUXCIsXCJmcmFjMjVcIjpcIuKFllwiLFwiZnJhYzM0XCI6XCLCvlwiLFwiZnJhYzM1XCI6XCLihZdcIixcImZyYWMzOFwiOlwi4oWcXCIsXCJmcmFjNDVcIjpcIuKFmFwiLFwiZnJhYzU2XCI6XCLihZpcIixcImZyYWM1OFwiOlwi4oWdXCIsXCJmcmFjNzhcIjpcIuKFnlwiLFwiZnJhc2xcIjpcIuKBhFwiLFwiZnJvd25cIjpcIuKMolwiLFwiZnNjclwiOlwi8J2Su1wiLFwiRnNjclwiOlwi4oSxXCIsXCJnYWN1dGVcIjpcIse1XCIsXCJHYW1tYVwiOlwizpNcIixcImdhbW1hXCI6XCLOs1wiLFwiR2FtbWFkXCI6XCLPnFwiLFwiZ2FtbWFkXCI6XCLPnVwiLFwiZ2FwXCI6XCLiqoZcIixcIkdicmV2ZVwiOlwixJ5cIixcImdicmV2ZVwiOlwixJ9cIixcIkdjZWRpbFwiOlwixKJcIixcIkdjaXJjXCI6XCLEnFwiLFwiZ2NpcmNcIjpcIsSdXCIsXCJHY3lcIjpcItCTXCIsXCJnY3lcIjpcItCzXCIsXCJHZG90XCI6XCLEoFwiLFwiZ2RvdFwiOlwixKFcIixcImdlXCI6XCLiiaVcIixcImdFXCI6XCLiiadcIixcImdFbFwiOlwi4qqMXCIsXCJnZWxcIjpcIuKLm1wiLFwiZ2VxXCI6XCLiiaVcIixcImdlcXFcIjpcIuKJp1wiLFwiZ2Vxc2xhbnRcIjpcIuKpvlwiLFwiZ2VzY2NcIjpcIuKqqVwiLFwiZ2VzXCI6XCLiqb5cIixcImdlc2RvdFwiOlwi4qqAXCIsXCJnZXNkb3RvXCI6XCLiqoJcIixcImdlc2RvdG9sXCI6XCLiqoRcIixcImdlc2xcIjpcIuKLm++4gFwiLFwiZ2VzbGVzXCI6XCLiqpRcIixcIkdmclwiOlwi8J2UilwiLFwiZ2ZyXCI6XCLwnZSkXCIsXCJnZ1wiOlwi4omrXCIsXCJHZ1wiOlwi4ouZXCIsXCJnZ2dcIjpcIuKLmVwiLFwiZ2ltZWxcIjpcIuKEt1wiLFwiR0pjeVwiOlwi0INcIixcImdqY3lcIjpcItGTXCIsXCJnbGFcIjpcIuKqpVwiLFwiZ2xcIjpcIuKJt1wiLFwiZ2xFXCI6XCLiqpJcIixcImdsalwiOlwi4qqkXCIsXCJnbmFwXCI6XCLiqopcIixcImduYXBwcm94XCI6XCLiqopcIixcImduZVwiOlwi4qqIXCIsXCJnbkVcIjpcIuKJqVwiLFwiZ25lcVwiOlwi4qqIXCIsXCJnbmVxcVwiOlwi4ompXCIsXCJnbnNpbVwiOlwi4ounXCIsXCJHb3BmXCI6XCLwnZS+XCIsXCJnb3BmXCI6XCLwnZWYXCIsXCJncmF2ZVwiOlwiYFwiLFwiR3JlYXRlckVxdWFsXCI6XCLiiaVcIixcIkdyZWF0ZXJFcXVhbExlc3NcIjpcIuKLm1wiLFwiR3JlYXRlckZ1bGxFcXVhbFwiOlwi4omnXCIsXCJHcmVhdGVyR3JlYXRlclwiOlwi4qqiXCIsXCJHcmVhdGVyTGVzc1wiOlwi4om3XCIsXCJHcmVhdGVyU2xhbnRFcXVhbFwiOlwi4qm+XCIsXCJHcmVhdGVyVGlsZGVcIjpcIuKJs1wiLFwiR3NjclwiOlwi8J2SolwiLFwiZ3NjclwiOlwi4oSKXCIsXCJnc2ltXCI6XCLiibNcIixcImdzaW1lXCI6XCLiqo5cIixcImdzaW1sXCI6XCLiqpBcIixcImd0Y2NcIjpcIuKqp1wiLFwiZ3RjaXJcIjpcIuKpulwiLFwiZ3RcIjpcIj5cIixcIkdUXCI6XCI+XCIsXCJHdFwiOlwi4omrXCIsXCJndGRvdFwiOlwi4ouXXCIsXCJndGxQYXJcIjpcIuKmlVwiLFwiZ3RxdWVzdFwiOlwi4qm8XCIsXCJndHJhcHByb3hcIjpcIuKqhlwiLFwiZ3RyYXJyXCI6XCLipbhcIixcImd0cmRvdFwiOlwi4ouXXCIsXCJndHJlcWxlc3NcIjpcIuKLm1wiLFwiZ3RyZXFxbGVzc1wiOlwi4qqMXCIsXCJndHJsZXNzXCI6XCLiibdcIixcImd0cnNpbVwiOlwi4omzXCIsXCJndmVydG5lcXFcIjpcIuKJqe+4gFwiLFwiZ3ZuRVwiOlwi4omp77iAXCIsXCJIYWNla1wiOlwiy4dcIixcImhhaXJzcFwiOlwi4oCKXCIsXCJoYWxmXCI6XCLCvVwiLFwiaGFtaWx0XCI6XCLihItcIixcIkhBUkRjeVwiOlwi0KpcIixcImhhcmRjeVwiOlwi0YpcIixcImhhcnJjaXJcIjpcIuKliFwiLFwiaGFyclwiOlwi4oaUXCIsXCJoQXJyXCI6XCLih5RcIixcImhhcnJ3XCI6XCLihq1cIixcIkhhdFwiOlwiXlwiLFwiaGJhclwiOlwi4oSPXCIsXCJIY2lyY1wiOlwixKRcIixcImhjaXJjXCI6XCLEpVwiLFwiaGVhcnRzXCI6XCLimaVcIixcImhlYXJ0c3VpdFwiOlwi4pmlXCIsXCJoZWxsaXBcIjpcIuKAplwiLFwiaGVyY29uXCI6XCLiirlcIixcImhmclwiOlwi8J2UpVwiLFwiSGZyXCI6XCLihIxcIixcIkhpbGJlcnRTcGFjZVwiOlwi4oSLXCIsXCJoa3NlYXJvd1wiOlwi4qSlXCIsXCJoa3N3YXJvd1wiOlwi4qSmXCIsXCJob2FyclwiOlwi4oe/XCIsXCJob210aHRcIjpcIuKIu1wiLFwiaG9va2xlZnRhcnJvd1wiOlwi4oapXCIsXCJob29rcmlnaHRhcnJvd1wiOlwi4oaqXCIsXCJob3BmXCI6XCLwnZWZXCIsXCJIb3BmXCI6XCLihI1cIixcImhvcmJhclwiOlwi4oCVXCIsXCJIb3Jpem9udGFsTGluZVwiOlwi4pSAXCIsXCJoc2NyXCI6XCLwnZK9XCIsXCJIc2NyXCI6XCLihItcIixcImhzbGFzaFwiOlwi4oSPXCIsXCJIc3Ryb2tcIjpcIsSmXCIsXCJoc3Ryb2tcIjpcIsSnXCIsXCJIdW1wRG93bkh1bXBcIjpcIuKJjlwiLFwiSHVtcEVxdWFsXCI6XCLiiY9cIixcImh5YnVsbFwiOlwi4oGDXCIsXCJoeXBoZW5cIjpcIuKAkFwiLFwiSWFjdXRlXCI6XCLDjVwiLFwiaWFjdXRlXCI6XCLDrVwiLFwiaWNcIjpcIuKBo1wiLFwiSWNpcmNcIjpcIsOOXCIsXCJpY2lyY1wiOlwiw65cIixcIkljeVwiOlwi0JhcIixcImljeVwiOlwi0LhcIixcIklkb3RcIjpcIsSwXCIsXCJJRWN5XCI6XCLQlVwiLFwiaWVjeVwiOlwi0LVcIixcImlleGNsXCI6XCLCoVwiLFwiaWZmXCI6XCLih5RcIixcImlmclwiOlwi8J2UplwiLFwiSWZyXCI6XCLihJFcIixcIklncmF2ZVwiOlwiw4xcIixcImlncmF2ZVwiOlwiw6xcIixcImlpXCI6XCLihYhcIixcImlpaWludFwiOlwi4qiMXCIsXCJpaWludFwiOlwi4oitXCIsXCJpaW5maW5cIjpcIuKnnFwiLFwiaWlvdGFcIjpcIuKEqVwiLFwiSUpsaWdcIjpcIsSyXCIsXCJpamxpZ1wiOlwixLNcIixcIkltYWNyXCI6XCLEqlwiLFwiaW1hY3JcIjpcIsSrXCIsXCJpbWFnZVwiOlwi4oSRXCIsXCJJbWFnaW5hcnlJXCI6XCLihYhcIixcImltYWdsaW5lXCI6XCLihJBcIixcImltYWdwYXJ0XCI6XCLihJFcIixcImltYXRoXCI6XCLEsVwiLFwiSW1cIjpcIuKEkVwiLFwiaW1vZlwiOlwi4oq3XCIsXCJpbXBlZFwiOlwixrVcIixcIkltcGxpZXNcIjpcIuKHklwiLFwiaW5jYXJlXCI6XCLihIVcIixcImluXCI6XCLiiIhcIixcImluZmluXCI6XCLiiJ5cIixcImluZmludGllXCI6XCLip51cIixcImlub2RvdFwiOlwixLFcIixcImludGNhbFwiOlwi4oq6XCIsXCJpbnRcIjpcIuKIq1wiLFwiSW50XCI6XCLiiKxcIixcImludGVnZXJzXCI6XCLihKRcIixcIkludGVncmFsXCI6XCLiiKtcIixcImludGVyY2FsXCI6XCLiirpcIixcIkludGVyc2VjdGlvblwiOlwi4ouCXCIsXCJpbnRsYXJoa1wiOlwi4qiXXCIsXCJpbnRwcm9kXCI6XCLiqLxcIixcIkludmlzaWJsZUNvbW1hXCI6XCLigaNcIixcIkludmlzaWJsZVRpbWVzXCI6XCLigaJcIixcIklPY3lcIjpcItCBXCIsXCJpb2N5XCI6XCLRkVwiLFwiSW9nb25cIjpcIsSuXCIsXCJpb2dvblwiOlwixK9cIixcIklvcGZcIjpcIvCdlYBcIixcImlvcGZcIjpcIvCdlZpcIixcIklvdGFcIjpcIs6ZXCIsXCJpb3RhXCI6XCLOuVwiLFwiaXByb2RcIjpcIuKovFwiLFwiaXF1ZXN0XCI6XCLCv1wiLFwiaXNjclwiOlwi8J2SvlwiLFwiSXNjclwiOlwi4oSQXCIsXCJpc2luXCI6XCLiiIhcIixcImlzaW5kb3RcIjpcIuKLtVwiLFwiaXNpbkVcIjpcIuKLuVwiLFwiaXNpbnNcIjpcIuKLtFwiLFwiaXNpbnN2XCI6XCLii7NcIixcImlzaW52XCI6XCLiiIhcIixcIml0XCI6XCLigaJcIixcIkl0aWxkZVwiOlwixKhcIixcIml0aWxkZVwiOlwixKlcIixcIkl1a2N5XCI6XCLQhlwiLFwiaXVrY3lcIjpcItGWXCIsXCJJdW1sXCI6XCLDj1wiLFwiaXVtbFwiOlwiw69cIixcIkpjaXJjXCI6XCLEtFwiLFwiamNpcmNcIjpcIsS1XCIsXCJKY3lcIjpcItCZXCIsXCJqY3lcIjpcItC5XCIsXCJKZnJcIjpcIvCdlI1cIixcImpmclwiOlwi8J2Up1wiLFwiam1hdGhcIjpcIsi3XCIsXCJKb3BmXCI6XCLwnZWBXCIsXCJqb3BmXCI6XCLwnZWbXCIsXCJKc2NyXCI6XCLwnZKlXCIsXCJqc2NyXCI6XCLwnZK/XCIsXCJKc2VyY3lcIjpcItCIXCIsXCJqc2VyY3lcIjpcItGYXCIsXCJKdWtjeVwiOlwi0IRcIixcImp1a2N5XCI6XCLRlFwiLFwiS2FwcGFcIjpcIs6aXCIsXCJrYXBwYVwiOlwizrpcIixcImthcHBhdlwiOlwiz7BcIixcIktjZWRpbFwiOlwixLZcIixcImtjZWRpbFwiOlwixLdcIixcIktjeVwiOlwi0JpcIixcImtjeVwiOlwi0LpcIixcIktmclwiOlwi8J2UjlwiLFwia2ZyXCI6XCLwnZSoXCIsXCJrZ3JlZW5cIjpcIsS4XCIsXCJLSGN5XCI6XCLQpVwiLFwia2hjeVwiOlwi0YVcIixcIktKY3lcIjpcItCMXCIsXCJramN5XCI6XCLRnFwiLFwiS29wZlwiOlwi8J2VglwiLFwia29wZlwiOlwi8J2VnFwiLFwiS3NjclwiOlwi8J2SplwiLFwia3NjclwiOlwi8J2TgFwiLFwibEFhcnJcIjpcIuKHmlwiLFwiTGFjdXRlXCI6XCLEuVwiLFwibGFjdXRlXCI6XCLEulwiLFwibGFlbXB0eXZcIjpcIuKmtFwiLFwibGFncmFuXCI6XCLihJJcIixcIkxhbWJkYVwiOlwizptcIixcImxhbWJkYVwiOlwizrtcIixcImxhbmdcIjpcIuKfqFwiLFwiTGFuZ1wiOlwi4p+qXCIsXCJsYW5nZFwiOlwi4qaRXCIsXCJsYW5nbGVcIjpcIuKfqFwiLFwibGFwXCI6XCLiqoVcIixcIkxhcGxhY2V0cmZcIjpcIuKEklwiLFwibGFxdW9cIjpcIsKrXCIsXCJsYXJyYlwiOlwi4oekXCIsXCJsYXJyYmZzXCI6XCLipJ9cIixcImxhcnJcIjpcIuKGkFwiLFwiTGFyclwiOlwi4oaeXCIsXCJsQXJyXCI6XCLih5BcIixcImxhcnJmc1wiOlwi4qSdXCIsXCJsYXJyaGtcIjpcIuKGqVwiLFwibGFycmxwXCI6XCLihqtcIixcImxhcnJwbFwiOlwi4qS5XCIsXCJsYXJyc2ltXCI6XCLipbNcIixcImxhcnJ0bFwiOlwi4oaiXCIsXCJsYXRhaWxcIjpcIuKkmVwiLFwibEF0YWlsXCI6XCLipJtcIixcImxhdFwiOlwi4qqrXCIsXCJsYXRlXCI6XCLiqq1cIixcImxhdGVzXCI6XCLiqq3vuIBcIixcImxiYXJyXCI6XCLipIxcIixcImxCYXJyXCI6XCLipI5cIixcImxiYnJrXCI6XCLinbJcIixcImxicmFjZVwiOlwie1wiLFwibGJyYWNrXCI6XCJbXCIsXCJsYnJrZVwiOlwi4qaLXCIsXCJsYnJrc2xkXCI6XCLipo9cIixcImxicmtzbHVcIjpcIuKmjVwiLFwiTGNhcm9uXCI6XCLEvVwiLFwibGNhcm9uXCI6XCLEvlwiLFwiTGNlZGlsXCI6XCLEu1wiLFwibGNlZGlsXCI6XCLEvFwiLFwibGNlaWxcIjpcIuKMiFwiLFwibGN1YlwiOlwie1wiLFwiTGN5XCI6XCLQm1wiLFwibGN5XCI6XCLQu1wiLFwibGRjYVwiOlwi4qS2XCIsXCJsZHF1b1wiOlwi4oCcXCIsXCJsZHF1b3JcIjpcIuKAnlwiLFwibGRyZGhhclwiOlwi4qWnXCIsXCJsZHJ1c2hhclwiOlwi4qWLXCIsXCJsZHNoXCI6XCLihrJcIixcImxlXCI6XCLiiaRcIixcImxFXCI6XCLiiaZcIixcIkxlZnRBbmdsZUJyYWNrZXRcIjpcIuKfqFwiLFwiTGVmdEFycm93QmFyXCI6XCLih6RcIixcImxlZnRhcnJvd1wiOlwi4oaQXCIsXCJMZWZ0QXJyb3dcIjpcIuKGkFwiLFwiTGVmdGFycm93XCI6XCLih5BcIixcIkxlZnRBcnJvd1JpZ2h0QXJyb3dcIjpcIuKHhlwiLFwibGVmdGFycm93dGFpbFwiOlwi4oaiXCIsXCJMZWZ0Q2VpbGluZ1wiOlwi4oyIXCIsXCJMZWZ0RG91YmxlQnJhY2tldFwiOlwi4p+mXCIsXCJMZWZ0RG93blRlZVZlY3RvclwiOlwi4qWhXCIsXCJMZWZ0RG93blZlY3RvckJhclwiOlwi4qWZXCIsXCJMZWZ0RG93blZlY3RvclwiOlwi4oeDXCIsXCJMZWZ0Rmxvb3JcIjpcIuKMilwiLFwibGVmdGhhcnBvb25kb3duXCI6XCLihr1cIixcImxlZnRoYXJwb29udXBcIjpcIuKGvFwiLFwibGVmdGxlZnRhcnJvd3NcIjpcIuKHh1wiLFwibGVmdHJpZ2h0YXJyb3dcIjpcIuKGlFwiLFwiTGVmdFJpZ2h0QXJyb3dcIjpcIuKGlFwiLFwiTGVmdHJpZ2h0YXJyb3dcIjpcIuKHlFwiLFwibGVmdHJpZ2h0YXJyb3dzXCI6XCLih4ZcIixcImxlZnRyaWdodGhhcnBvb25zXCI6XCLih4tcIixcImxlZnRyaWdodHNxdWlnYXJyb3dcIjpcIuKGrVwiLFwiTGVmdFJpZ2h0VmVjdG9yXCI6XCLipY5cIixcIkxlZnRUZWVBcnJvd1wiOlwi4oakXCIsXCJMZWZ0VGVlXCI6XCLiiqNcIixcIkxlZnRUZWVWZWN0b3JcIjpcIuKlmlwiLFwibGVmdHRocmVldGltZXNcIjpcIuKLi1wiLFwiTGVmdFRyaWFuZ2xlQmFyXCI6XCLip49cIixcIkxlZnRUcmlhbmdsZVwiOlwi4oqyXCIsXCJMZWZ0VHJpYW5nbGVFcXVhbFwiOlwi4oq0XCIsXCJMZWZ0VXBEb3duVmVjdG9yXCI6XCLipZFcIixcIkxlZnRVcFRlZVZlY3RvclwiOlwi4qWgXCIsXCJMZWZ0VXBWZWN0b3JCYXJcIjpcIuKlmFwiLFwiTGVmdFVwVmVjdG9yXCI6XCLihr9cIixcIkxlZnRWZWN0b3JCYXJcIjpcIuKlklwiLFwiTGVmdFZlY3RvclwiOlwi4oa8XCIsXCJsRWdcIjpcIuKqi1wiLFwibGVnXCI6XCLii5pcIixcImxlcVwiOlwi4omkXCIsXCJsZXFxXCI6XCLiiaZcIixcImxlcXNsYW50XCI6XCLiqb1cIixcImxlc2NjXCI6XCLiqqhcIixcImxlc1wiOlwi4qm9XCIsXCJsZXNkb3RcIjpcIuKpv1wiLFwibGVzZG90b1wiOlwi4qqBXCIsXCJsZXNkb3RvclwiOlwi4qqDXCIsXCJsZXNnXCI6XCLii5rvuIBcIixcImxlc2dlc1wiOlwi4qqTXCIsXCJsZXNzYXBwcm94XCI6XCLiqoVcIixcImxlc3Nkb3RcIjpcIuKLllwiLFwibGVzc2VxZ3RyXCI6XCLii5pcIixcImxlc3NlcXFndHJcIjpcIuKqi1wiLFwiTGVzc0VxdWFsR3JlYXRlclwiOlwi4ouaXCIsXCJMZXNzRnVsbEVxdWFsXCI6XCLiiaZcIixcIkxlc3NHcmVhdGVyXCI6XCLiibZcIixcImxlc3NndHJcIjpcIuKJtlwiLFwiTGVzc0xlc3NcIjpcIuKqoVwiLFwibGVzc3NpbVwiOlwi4omyXCIsXCJMZXNzU2xhbnRFcXVhbFwiOlwi4qm9XCIsXCJMZXNzVGlsZGVcIjpcIuKJslwiLFwibGZpc2h0XCI6XCLipbxcIixcImxmbG9vclwiOlwi4oyKXCIsXCJMZnJcIjpcIvCdlI9cIixcImxmclwiOlwi8J2UqVwiLFwibGdcIjpcIuKJtlwiLFwibGdFXCI6XCLiqpFcIixcImxIYXJcIjpcIuKlolwiLFwibGhhcmRcIjpcIuKGvVwiLFwibGhhcnVcIjpcIuKGvFwiLFwibGhhcnVsXCI6XCLipapcIixcImxoYmxrXCI6XCLiloRcIixcIkxKY3lcIjpcItCJXCIsXCJsamN5XCI6XCLRmVwiLFwibGxhcnJcIjpcIuKHh1wiLFwibGxcIjpcIuKJqlwiLFwiTGxcIjpcIuKLmFwiLFwibGxjb3JuZXJcIjpcIuKMnlwiLFwiTGxlZnRhcnJvd1wiOlwi4oeaXCIsXCJsbGhhcmRcIjpcIuKlq1wiLFwibGx0cmlcIjpcIuKXulwiLFwiTG1pZG90XCI6XCLEv1wiLFwibG1pZG90XCI6XCLFgFwiLFwibG1vdXN0YWNoZVwiOlwi4o6wXCIsXCJsbW91c3RcIjpcIuKOsFwiLFwibG5hcFwiOlwi4qqJXCIsXCJsbmFwcHJveFwiOlwi4qqJXCIsXCJsbmVcIjpcIuKqh1wiLFwibG5FXCI6XCLiiahcIixcImxuZXFcIjpcIuKqh1wiLFwibG5lcXFcIjpcIuKJqFwiLFwibG5zaW1cIjpcIuKLplwiLFwibG9hbmdcIjpcIuKfrFwiLFwibG9hcnJcIjpcIuKHvVwiLFwibG9icmtcIjpcIuKfplwiLFwibG9uZ2xlZnRhcnJvd1wiOlwi4p+1XCIsXCJMb25nTGVmdEFycm93XCI6XCLin7VcIixcIkxvbmdsZWZ0YXJyb3dcIjpcIuKfuFwiLFwibG9uZ2xlZnRyaWdodGFycm93XCI6XCLin7dcIixcIkxvbmdMZWZ0UmlnaHRBcnJvd1wiOlwi4p+3XCIsXCJMb25nbGVmdHJpZ2h0YXJyb3dcIjpcIuKfulwiLFwibG9uZ21hcHN0b1wiOlwi4p+8XCIsXCJsb25ncmlnaHRhcnJvd1wiOlwi4p+2XCIsXCJMb25nUmlnaHRBcnJvd1wiOlwi4p+2XCIsXCJMb25ncmlnaHRhcnJvd1wiOlwi4p+5XCIsXCJsb29wYXJyb3dsZWZ0XCI6XCLihqtcIixcImxvb3BhcnJvd3JpZ2h0XCI6XCLihqxcIixcImxvcGFyXCI6XCLipoVcIixcIkxvcGZcIjpcIvCdlYNcIixcImxvcGZcIjpcIvCdlZ1cIixcImxvcGx1c1wiOlwi4qitXCIsXCJsb3RpbWVzXCI6XCLiqLRcIixcImxvd2FzdFwiOlwi4oiXXCIsXCJsb3diYXJcIjpcIl9cIixcIkxvd2VyTGVmdEFycm93XCI6XCLihplcIixcIkxvd2VyUmlnaHRBcnJvd1wiOlwi4oaYXCIsXCJsb3pcIjpcIuKXilwiLFwibG96ZW5nZVwiOlwi4peKXCIsXCJsb3pmXCI6XCLip6tcIixcImxwYXJcIjpcIihcIixcImxwYXJsdFwiOlwi4qaTXCIsXCJscmFyclwiOlwi4oeGXCIsXCJscmNvcm5lclwiOlwi4oyfXCIsXCJscmhhclwiOlwi4oeLXCIsXCJscmhhcmRcIjpcIuKlrVwiLFwibHJtXCI6XCLigI5cIixcImxydHJpXCI6XCLiir9cIixcImxzYXF1b1wiOlwi4oC5XCIsXCJsc2NyXCI6XCLwnZOBXCIsXCJMc2NyXCI6XCLihJJcIixcImxzaFwiOlwi4oawXCIsXCJMc2hcIjpcIuKGsFwiLFwibHNpbVwiOlwi4omyXCIsXCJsc2ltZVwiOlwi4qqNXCIsXCJsc2ltZ1wiOlwi4qqPXCIsXCJsc3FiXCI6XCJbXCIsXCJsc3F1b1wiOlwi4oCYXCIsXCJsc3F1b3JcIjpcIuKAmlwiLFwiTHN0cm9rXCI6XCLFgVwiLFwibHN0cm9rXCI6XCLFglwiLFwibHRjY1wiOlwi4qqmXCIsXCJsdGNpclwiOlwi4qm5XCIsXCJsdFwiOlwiPFwiLFwiTFRcIjpcIjxcIixcIkx0XCI6XCLiiapcIixcImx0ZG90XCI6XCLii5ZcIixcImx0aHJlZVwiOlwi4ouLXCIsXCJsdGltZXNcIjpcIuKLiVwiLFwibHRsYXJyXCI6XCLipbZcIixcImx0cXVlc3RcIjpcIuKpu1wiLFwibHRyaVwiOlwi4peDXCIsXCJsdHJpZVwiOlwi4oq0XCIsXCJsdHJpZlwiOlwi4peCXCIsXCJsdHJQYXJcIjpcIuKmllwiLFwibHVyZHNoYXJcIjpcIuKlilwiLFwibHVydWhhclwiOlwi4qWmXCIsXCJsdmVydG5lcXFcIjpcIuKJqO+4gFwiLFwibHZuRVwiOlwi4omo77iAXCIsXCJtYWNyXCI6XCLCr1wiLFwibWFsZVwiOlwi4pmCXCIsXCJtYWx0XCI6XCLinKBcIixcIm1hbHRlc2VcIjpcIuKcoFwiLFwiTWFwXCI6XCLipIVcIixcIm1hcFwiOlwi4oamXCIsXCJtYXBzdG9cIjpcIuKGplwiLFwibWFwc3RvZG93blwiOlwi4oanXCIsXCJtYXBzdG9sZWZ0XCI6XCLihqRcIixcIm1hcHN0b3VwXCI6XCLihqVcIixcIm1hcmtlclwiOlwi4pauXCIsXCJtY29tbWFcIjpcIuKoqVwiLFwiTWN5XCI6XCLQnFwiLFwibWN5XCI6XCLQvFwiLFwibWRhc2hcIjpcIuKAlFwiLFwibUREb3RcIjpcIuKIulwiLFwibWVhc3VyZWRhbmdsZVwiOlwi4oihXCIsXCJNZWRpdW1TcGFjZVwiOlwi4oGfXCIsXCJNZWxsaW50cmZcIjpcIuKEs1wiLFwiTWZyXCI6XCLwnZSQXCIsXCJtZnJcIjpcIvCdlKpcIixcIm1ob1wiOlwi4oSnXCIsXCJtaWNyb1wiOlwiwrVcIixcIm1pZGFzdFwiOlwiKlwiLFwibWlkY2lyXCI6XCLiq7BcIixcIm1pZFwiOlwi4oijXCIsXCJtaWRkb3RcIjpcIsK3XCIsXCJtaW51c2JcIjpcIuKKn1wiLFwibWludXNcIjpcIuKIklwiLFwibWludXNkXCI6XCLiiLhcIixcIm1pbnVzZHVcIjpcIuKoqlwiLFwiTWludXNQbHVzXCI6XCLiiJNcIixcIm1sY3BcIjpcIuKrm1wiLFwibWxkclwiOlwi4oCmXCIsXCJtbnBsdXNcIjpcIuKIk1wiLFwibW9kZWxzXCI6XCLiiqdcIixcIk1vcGZcIjpcIvCdlYRcIixcIm1vcGZcIjpcIvCdlZ5cIixcIm1wXCI6XCLiiJNcIixcIm1zY3JcIjpcIvCdk4JcIixcIk1zY3JcIjpcIuKEs1wiLFwibXN0cG9zXCI6XCLiiL5cIixcIk11XCI6XCLOnFwiLFwibXVcIjpcIs68XCIsXCJtdWx0aW1hcFwiOlwi4oq4XCIsXCJtdW1hcFwiOlwi4oq4XCIsXCJuYWJsYVwiOlwi4oiHXCIsXCJOYWN1dGVcIjpcIsWDXCIsXCJuYWN1dGVcIjpcIsWEXCIsXCJuYW5nXCI6XCLiiKDig5JcIixcIm5hcFwiOlwi4omJXCIsXCJuYXBFXCI6XCLiqbDMuFwiLFwibmFwaWRcIjpcIuKJi8y4XCIsXCJuYXBvc1wiOlwixYlcIixcIm5hcHByb3hcIjpcIuKJiVwiLFwibmF0dXJhbFwiOlwi4pmuXCIsXCJuYXR1cmFsc1wiOlwi4oSVXCIsXCJuYXR1clwiOlwi4pmuXCIsXCJuYnNwXCI6XCLCoFwiLFwibmJ1bXBcIjpcIuKJjsy4XCIsXCJuYnVtcGVcIjpcIuKJj8y4XCIsXCJuY2FwXCI6XCLiqYNcIixcIk5jYXJvblwiOlwixYdcIixcIm5jYXJvblwiOlwixYhcIixcIk5jZWRpbFwiOlwixYVcIixcIm5jZWRpbFwiOlwixYZcIixcIm5jb25nXCI6XCLiiYdcIixcIm5jb25nZG90XCI6XCLiqa3MuFwiLFwibmN1cFwiOlwi4qmCXCIsXCJOY3lcIjpcItCdXCIsXCJuY3lcIjpcItC9XCIsXCJuZGFzaFwiOlwi4oCTXCIsXCJuZWFyaGtcIjpcIuKkpFwiLFwibmVhcnJcIjpcIuKGl1wiLFwibmVBcnJcIjpcIuKHl1wiLFwibmVhcnJvd1wiOlwi4oaXXCIsXCJuZVwiOlwi4omgXCIsXCJuZWRvdFwiOlwi4omQzLhcIixcIk5lZ2F0aXZlTWVkaXVtU3BhY2VcIjpcIuKAi1wiLFwiTmVnYXRpdmVUaGlja1NwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVGhpblNwYWNlXCI6XCLigItcIixcIk5lZ2F0aXZlVmVyeVRoaW5TcGFjZVwiOlwi4oCLXCIsXCJuZXF1aXZcIjpcIuKJolwiLFwibmVzZWFyXCI6XCLipKhcIixcIm5lc2ltXCI6XCLiiYLMuFwiLFwiTmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIuKJq1wiLFwiTmVzdGVkTGVzc0xlc3NcIjpcIuKJqlwiLFwiTmV3TGluZVwiOlwiXFxuXCIsXCJuZXhpc3RcIjpcIuKIhFwiLFwibmV4aXN0c1wiOlwi4oiEXCIsXCJOZnJcIjpcIvCdlJFcIixcIm5mclwiOlwi8J2Uq1wiLFwibmdFXCI6XCLiiafMuFwiLFwibmdlXCI6XCLiibFcIixcIm5nZXFcIjpcIuKJsVwiLFwibmdlcXFcIjpcIuKJp8y4XCIsXCJuZ2Vxc2xhbnRcIjpcIuKpvsy4XCIsXCJuZ2VzXCI6XCLiqb7MuFwiLFwibkdnXCI6XCLii5nMuFwiLFwibmdzaW1cIjpcIuKJtVwiLFwibkd0XCI6XCLiiavig5JcIixcIm5ndFwiOlwi4omvXCIsXCJuZ3RyXCI6XCLiia9cIixcIm5HdHZcIjpcIuKJq8y4XCIsXCJuaGFyclwiOlwi4oauXCIsXCJuaEFyclwiOlwi4oeOXCIsXCJuaHBhclwiOlwi4quyXCIsXCJuaVwiOlwi4oiLXCIsXCJuaXNcIjpcIuKLvFwiLFwibmlzZFwiOlwi4ou6XCIsXCJuaXZcIjpcIuKIi1wiLFwiTkpjeVwiOlwi0IpcIixcIm5qY3lcIjpcItGaXCIsXCJubGFyclwiOlwi4oaaXCIsXCJubEFyclwiOlwi4oeNXCIsXCJubGRyXCI6XCLigKVcIixcIm5sRVwiOlwi4ommzLhcIixcIm5sZVwiOlwi4omwXCIsXCJubGVmdGFycm93XCI6XCLihppcIixcIm5MZWZ0YXJyb3dcIjpcIuKHjVwiLFwibmxlZnRyaWdodGFycm93XCI6XCLihq5cIixcIm5MZWZ0cmlnaHRhcnJvd1wiOlwi4oeOXCIsXCJubGVxXCI6XCLiibBcIixcIm5sZXFxXCI6XCLiiabMuFwiLFwibmxlcXNsYW50XCI6XCLiqb3MuFwiLFwibmxlc1wiOlwi4qm9zLhcIixcIm5sZXNzXCI6XCLiia5cIixcIm5MbFwiOlwi4ouYzLhcIixcIm5sc2ltXCI6XCLiibRcIixcIm5MdFwiOlwi4omq4oOSXCIsXCJubHRcIjpcIuKJrlwiLFwibmx0cmlcIjpcIuKLqlwiLFwibmx0cmllXCI6XCLii6xcIixcIm5MdHZcIjpcIuKJqsy4XCIsXCJubWlkXCI6XCLiiKRcIixcIk5vQnJlYWtcIjpcIuKBoFwiLFwiTm9uQnJlYWtpbmdTcGFjZVwiOlwiwqBcIixcIm5vcGZcIjpcIvCdlZ9cIixcIk5vcGZcIjpcIuKElVwiLFwiTm90XCI6XCLiq6xcIixcIm5vdFwiOlwiwqxcIixcIk5vdENvbmdydWVudFwiOlwi4omiXCIsXCJOb3RDdXBDYXBcIjpcIuKJrVwiLFwiTm90RG91YmxlVmVydGljYWxCYXJcIjpcIuKIplwiLFwiTm90RWxlbWVudFwiOlwi4oiJXCIsXCJOb3RFcXVhbFwiOlwi4omgXCIsXCJOb3RFcXVhbFRpbGRlXCI6XCLiiYLMuFwiLFwiTm90RXhpc3RzXCI6XCLiiIRcIixcIk5vdEdyZWF0ZXJcIjpcIuKJr1wiLFwiTm90R3JlYXRlckVxdWFsXCI6XCLiibFcIixcIk5vdEdyZWF0ZXJGdWxsRXF1YWxcIjpcIuKJp8y4XCIsXCJOb3RHcmVhdGVyR3JlYXRlclwiOlwi4omrzLhcIixcIk5vdEdyZWF0ZXJMZXNzXCI6XCLiiblcIixcIk5vdEdyZWF0ZXJTbGFudEVxdWFsXCI6XCLiqb7MuFwiLFwiTm90R3JlYXRlclRpbGRlXCI6XCLiibVcIixcIk5vdEh1bXBEb3duSHVtcFwiOlwi4omOzLhcIixcIk5vdEh1bXBFcXVhbFwiOlwi4omPzLhcIixcIm5vdGluXCI6XCLiiIlcIixcIm5vdGluZG90XCI6XCLii7XMuFwiLFwibm90aW5FXCI6XCLii7nMuFwiLFwibm90aW52YVwiOlwi4oiJXCIsXCJub3RpbnZiXCI6XCLii7dcIixcIm5vdGludmNcIjpcIuKLtlwiLFwiTm90TGVmdFRyaWFuZ2xlQmFyXCI6XCLip4/MuFwiLFwiTm90TGVmdFRyaWFuZ2xlXCI6XCLii6pcIixcIk5vdExlZnRUcmlhbmdsZUVxdWFsXCI6XCLii6xcIixcIk5vdExlc3NcIjpcIuKJrlwiLFwiTm90TGVzc0VxdWFsXCI6XCLiibBcIixcIk5vdExlc3NHcmVhdGVyXCI6XCLiibhcIixcIk5vdExlc3NMZXNzXCI6XCLiiarMuFwiLFwiTm90TGVzc1NsYW50RXF1YWxcIjpcIuKpvcy4XCIsXCJOb3RMZXNzVGlsZGVcIjpcIuKJtFwiLFwiTm90TmVzdGVkR3JlYXRlckdyZWF0ZXJcIjpcIuKqosy4XCIsXCJOb3ROZXN0ZWRMZXNzTGVzc1wiOlwi4qqhzLhcIixcIm5vdG5pXCI6XCLiiIxcIixcIm5vdG5pdmFcIjpcIuKIjFwiLFwibm90bml2YlwiOlwi4ou+XCIsXCJub3RuaXZjXCI6XCLii71cIixcIk5vdFByZWNlZGVzXCI6XCLiioBcIixcIk5vdFByZWNlZGVzRXF1YWxcIjpcIuKqr8y4XCIsXCJOb3RQcmVjZWRlc1NsYW50RXF1YWxcIjpcIuKLoFwiLFwiTm90UmV2ZXJzZUVsZW1lbnRcIjpcIuKIjFwiLFwiTm90UmlnaHRUcmlhbmdsZUJhclwiOlwi4qeQzLhcIixcIk5vdFJpZ2h0VHJpYW5nbGVcIjpcIuKLq1wiLFwiTm90UmlnaHRUcmlhbmdsZUVxdWFsXCI6XCLii61cIixcIk5vdFNxdWFyZVN1YnNldFwiOlwi4oqPzLhcIixcIk5vdFNxdWFyZVN1YnNldEVxdWFsXCI6XCLii6JcIixcIk5vdFNxdWFyZVN1cGVyc2V0XCI6XCLiipDMuFwiLFwiTm90U3F1YXJlU3VwZXJzZXRFcXVhbFwiOlwi4oujXCIsXCJOb3RTdWJzZXRcIjpcIuKKguKDklwiLFwiTm90U3Vic2V0RXF1YWxcIjpcIuKKiFwiLFwiTm90U3VjY2VlZHNcIjpcIuKKgVwiLFwiTm90U3VjY2VlZHNFcXVhbFwiOlwi4qqwzLhcIixcIk5vdFN1Y2NlZWRzU2xhbnRFcXVhbFwiOlwi4ouhXCIsXCJOb3RTdWNjZWVkc1RpbGRlXCI6XCLiib/MuFwiLFwiTm90U3VwZXJzZXRcIjpcIuKKg+KDklwiLFwiTm90U3VwZXJzZXRFcXVhbFwiOlwi4oqJXCIsXCJOb3RUaWxkZVwiOlwi4omBXCIsXCJOb3RUaWxkZUVxdWFsXCI6XCLiiYRcIixcIk5vdFRpbGRlRnVsbEVxdWFsXCI6XCLiiYdcIixcIk5vdFRpbGRlVGlsZGVcIjpcIuKJiVwiLFwiTm90VmVydGljYWxCYXJcIjpcIuKIpFwiLFwibnBhcmFsbGVsXCI6XCLiiKZcIixcIm5wYXJcIjpcIuKIplwiLFwibnBhcnNsXCI6XCLiq73ig6VcIixcIm5wYXJ0XCI6XCLiiILMuFwiLFwibnBvbGludFwiOlwi4qiUXCIsXCJucHJcIjpcIuKKgFwiLFwibnByY3VlXCI6XCLii6BcIixcIm5wcmVjXCI6XCLiioBcIixcIm5wcmVjZXFcIjpcIuKqr8y4XCIsXCJucHJlXCI6XCLiqq/MuFwiLFwibnJhcnJjXCI6XCLipLPMuFwiLFwibnJhcnJcIjpcIuKGm1wiLFwibnJBcnJcIjpcIuKHj1wiLFwibnJhcnJ3XCI6XCLihp3MuFwiLFwibnJpZ2h0YXJyb3dcIjpcIuKGm1wiLFwiblJpZ2h0YXJyb3dcIjpcIuKHj1wiLFwibnJ0cmlcIjpcIuKLq1wiLFwibnJ0cmllXCI6XCLii61cIixcIm5zY1wiOlwi4oqBXCIsXCJuc2NjdWVcIjpcIuKLoVwiLFwibnNjZVwiOlwi4qqwzLhcIixcIk5zY3JcIjpcIvCdkqlcIixcIm5zY3JcIjpcIvCdk4NcIixcIm5zaG9ydG1pZFwiOlwi4oikXCIsXCJuc2hvcnRwYXJhbGxlbFwiOlwi4oimXCIsXCJuc2ltXCI6XCLiiYFcIixcIm5zaW1lXCI6XCLiiYRcIixcIm5zaW1lcVwiOlwi4omEXCIsXCJuc21pZFwiOlwi4oikXCIsXCJuc3BhclwiOlwi4oimXCIsXCJuc3FzdWJlXCI6XCLii6JcIixcIm5zcXN1cGVcIjpcIuKLo1wiLFwibnN1YlwiOlwi4oqEXCIsXCJuc3ViRVwiOlwi4quFzLhcIixcIm5zdWJlXCI6XCLiiohcIixcIm5zdWJzZXRcIjpcIuKKguKDklwiLFwibnN1YnNldGVxXCI6XCLiiohcIixcIm5zdWJzZXRlcXFcIjpcIuKrhcy4XCIsXCJuc3VjY1wiOlwi4oqBXCIsXCJuc3VjY2VxXCI6XCLiqrDMuFwiLFwibnN1cFwiOlwi4oqFXCIsXCJuc3VwRVwiOlwi4quGzLhcIixcIm5zdXBlXCI6XCLiiolcIixcIm5zdXBzZXRcIjpcIuKKg+KDklwiLFwibnN1cHNldGVxXCI6XCLiiolcIixcIm5zdXBzZXRlcXFcIjpcIuKrhsy4XCIsXCJudGdsXCI6XCLiiblcIixcIk50aWxkZVwiOlwiw5FcIixcIm50aWxkZVwiOlwiw7FcIixcIm50bGdcIjpcIuKJuFwiLFwibnRyaWFuZ2xlbGVmdFwiOlwi4ouqXCIsXCJudHJpYW5nbGVsZWZ0ZXFcIjpcIuKLrFwiLFwibnRyaWFuZ2xlcmlnaHRcIjpcIuKLq1wiLFwibnRyaWFuZ2xlcmlnaHRlcVwiOlwi4outXCIsXCJOdVwiOlwizp1cIixcIm51XCI6XCLOvVwiLFwibnVtXCI6XCIjXCIsXCJudW1lcm9cIjpcIuKEllwiLFwibnVtc3BcIjpcIuKAh1wiLFwibnZhcFwiOlwi4omN4oOSXCIsXCJudmRhc2hcIjpcIuKKrFwiLFwibnZEYXNoXCI6XCLiiq1cIixcIm5WZGFzaFwiOlwi4oquXCIsXCJuVkRhc2hcIjpcIuKKr1wiLFwibnZnZVwiOlwi4oml4oOSXCIsXCJudmd0XCI6XCI+4oOSXCIsXCJudkhhcnJcIjpcIuKkhFwiLFwibnZpbmZpblwiOlwi4qeeXCIsXCJudmxBcnJcIjpcIuKkglwiLFwibnZsZVwiOlwi4omk4oOSXCIsXCJudmx0XCI6XCI84oOSXCIsXCJudmx0cmllXCI6XCLiirTig5JcIixcIm52ckFyclwiOlwi4qSDXCIsXCJudnJ0cmllXCI6XCLiirXig5JcIixcIm52c2ltXCI6XCLiiLzig5JcIixcIm53YXJoa1wiOlwi4qSjXCIsXCJud2FyclwiOlwi4oaWXCIsXCJud0FyclwiOlwi4oeWXCIsXCJud2Fycm93XCI6XCLihpZcIixcIm53bmVhclwiOlwi4qSnXCIsXCJPYWN1dGVcIjpcIsOTXCIsXCJvYWN1dGVcIjpcIsOzXCIsXCJvYXN0XCI6XCLiiptcIixcIk9jaXJjXCI6XCLDlFwiLFwib2NpcmNcIjpcIsO0XCIsXCJvY2lyXCI6XCLiippcIixcIk9jeVwiOlwi0J5cIixcIm9jeVwiOlwi0L5cIixcIm9kYXNoXCI6XCLiip1cIixcIk9kYmxhY1wiOlwixZBcIixcIm9kYmxhY1wiOlwixZFcIixcIm9kaXZcIjpcIuKouFwiLFwib2RvdFwiOlwi4oqZXCIsXCJvZHNvbGRcIjpcIuKmvFwiLFwiT0VsaWdcIjpcIsWSXCIsXCJvZWxpZ1wiOlwixZNcIixcIm9mY2lyXCI6XCLipr9cIixcIk9mclwiOlwi8J2UklwiLFwib2ZyXCI6XCLwnZSsXCIsXCJvZ29uXCI6XCLLm1wiLFwiT2dyYXZlXCI6XCLDklwiLFwib2dyYXZlXCI6XCLDslwiLFwib2d0XCI6XCLip4FcIixcIm9oYmFyXCI6XCLiprVcIixcIm9obVwiOlwizqlcIixcIm9pbnRcIjpcIuKIrlwiLFwib2xhcnJcIjpcIuKGulwiLFwib2xjaXJcIjpcIuKmvlwiLFwib2xjcm9zc1wiOlwi4qa7XCIsXCJvbGluZVwiOlwi4oC+XCIsXCJvbHRcIjpcIuKngFwiLFwiT21hY3JcIjpcIsWMXCIsXCJvbWFjclwiOlwixY1cIixcIk9tZWdhXCI6XCLOqVwiLFwib21lZ2FcIjpcIs+JXCIsXCJPbWljcm9uXCI6XCLOn1wiLFwib21pY3JvblwiOlwizr9cIixcIm9taWRcIjpcIuKmtlwiLFwib21pbnVzXCI6XCLiipZcIixcIk9vcGZcIjpcIvCdlYZcIixcIm9vcGZcIjpcIvCdlaBcIixcIm9wYXJcIjpcIuKmt1wiLFwiT3BlbkN1cmx5RG91YmxlUXVvdGVcIjpcIuKAnFwiLFwiT3BlbkN1cmx5UXVvdGVcIjpcIuKAmFwiLFwib3BlcnBcIjpcIuKmuVwiLFwib3BsdXNcIjpcIuKKlVwiLFwib3JhcnJcIjpcIuKGu1wiLFwiT3JcIjpcIuKplFwiLFwib3JcIjpcIuKIqFwiLFwib3JkXCI6XCLiqZ1cIixcIm9yZGVyXCI6XCLihLRcIixcIm9yZGVyb2ZcIjpcIuKEtFwiLFwib3JkZlwiOlwiwqpcIixcIm9yZG1cIjpcIsK6XCIsXCJvcmlnb2ZcIjpcIuKKtlwiLFwib3JvclwiOlwi4qmWXCIsXCJvcnNsb3BlXCI6XCLiqZdcIixcIm9ydlwiOlwi4qmbXCIsXCJvU1wiOlwi4pOIXCIsXCJPc2NyXCI6XCLwnZKqXCIsXCJvc2NyXCI6XCLihLRcIixcIk9zbGFzaFwiOlwiw5hcIixcIm9zbGFzaFwiOlwiw7hcIixcIm9zb2xcIjpcIuKKmFwiLFwiT3RpbGRlXCI6XCLDlVwiLFwib3RpbGRlXCI6XCLDtVwiLFwib3RpbWVzYXNcIjpcIuKotlwiLFwiT3RpbWVzXCI6XCLiqLdcIixcIm90aW1lc1wiOlwi4oqXXCIsXCJPdW1sXCI6XCLDllwiLFwib3VtbFwiOlwiw7ZcIixcIm92YmFyXCI6XCLijL1cIixcIk92ZXJCYXJcIjpcIuKAvlwiLFwiT3ZlckJyYWNlXCI6XCLij55cIixcIk92ZXJCcmFja2V0XCI6XCLijrRcIixcIk92ZXJQYXJlbnRoZXNpc1wiOlwi4o+cXCIsXCJwYXJhXCI6XCLCtlwiLFwicGFyYWxsZWxcIjpcIuKIpVwiLFwicGFyXCI6XCLiiKVcIixcInBhcnNpbVwiOlwi4quzXCIsXCJwYXJzbFwiOlwi4qu9XCIsXCJwYXJ0XCI6XCLiiIJcIixcIlBhcnRpYWxEXCI6XCLiiIJcIixcIlBjeVwiOlwi0J9cIixcInBjeVwiOlwi0L9cIixcInBlcmNudFwiOlwiJVwiLFwicGVyaW9kXCI6XCIuXCIsXCJwZXJtaWxcIjpcIuKAsFwiLFwicGVycFwiOlwi4oqlXCIsXCJwZXJ0ZW5rXCI6XCLigLFcIixcIlBmclwiOlwi8J2Uk1wiLFwicGZyXCI6XCLwnZStXCIsXCJQaGlcIjpcIs6mXCIsXCJwaGlcIjpcIs+GXCIsXCJwaGl2XCI6XCLPlVwiLFwicGhtbWF0XCI6XCLihLNcIixcInBob25lXCI6XCLimI5cIixcIlBpXCI6XCLOoFwiLFwicGlcIjpcIs+AXCIsXCJwaXRjaGZvcmtcIjpcIuKLlFwiLFwicGl2XCI6XCLPllwiLFwicGxhbmNrXCI6XCLihI9cIixcInBsYW5ja2hcIjpcIuKEjlwiLFwicGxhbmt2XCI6XCLihI9cIixcInBsdXNhY2lyXCI6XCLiqKNcIixcInBsdXNiXCI6XCLiip5cIixcInBsdXNjaXJcIjpcIuKoolwiLFwicGx1c1wiOlwiK1wiLFwicGx1c2RvXCI6XCLiiJRcIixcInBsdXNkdVwiOlwi4qilXCIsXCJwbHVzZVwiOlwi4qmyXCIsXCJQbHVzTWludXNcIjpcIsKxXCIsXCJwbHVzbW5cIjpcIsKxXCIsXCJwbHVzc2ltXCI6XCLiqKZcIixcInBsdXN0d29cIjpcIuKop1wiLFwicG1cIjpcIsKxXCIsXCJQb2luY2FyZXBsYW5lXCI6XCLihIxcIixcInBvaW50aW50XCI6XCLiqJVcIixcInBvcGZcIjpcIvCdlaFcIixcIlBvcGZcIjpcIuKEmVwiLFwicG91bmRcIjpcIsKjXCIsXCJwcmFwXCI6XCLiqrdcIixcIlByXCI6XCLiqrtcIixcInByXCI6XCLiibpcIixcInByY3VlXCI6XCLiibxcIixcInByZWNhcHByb3hcIjpcIuKqt1wiLFwicHJlY1wiOlwi4om6XCIsXCJwcmVjY3VybHllcVwiOlwi4om8XCIsXCJQcmVjZWRlc1wiOlwi4om6XCIsXCJQcmVjZWRlc0VxdWFsXCI6XCLiqq9cIixcIlByZWNlZGVzU2xhbnRFcXVhbFwiOlwi4om8XCIsXCJQcmVjZWRlc1RpbGRlXCI6XCLiib5cIixcInByZWNlcVwiOlwi4qqvXCIsXCJwcmVjbmFwcHJveFwiOlwi4qq5XCIsXCJwcmVjbmVxcVwiOlwi4qq1XCIsXCJwcmVjbnNpbVwiOlwi4ouoXCIsXCJwcmVcIjpcIuKqr1wiLFwicHJFXCI6XCLiqrNcIixcInByZWNzaW1cIjpcIuKJvlwiLFwicHJpbWVcIjpcIuKAslwiLFwiUHJpbWVcIjpcIuKAs1wiLFwicHJpbWVzXCI6XCLihJlcIixcInBybmFwXCI6XCLiqrlcIixcInBybkVcIjpcIuKqtVwiLFwicHJuc2ltXCI6XCLii6hcIixcInByb2RcIjpcIuKIj1wiLFwiUHJvZHVjdFwiOlwi4oiPXCIsXCJwcm9mYWxhclwiOlwi4oyuXCIsXCJwcm9mbGluZVwiOlwi4oySXCIsXCJwcm9mc3VyZlwiOlwi4oyTXCIsXCJwcm9wXCI6XCLiiJ1cIixcIlByb3BvcnRpb25hbFwiOlwi4oidXCIsXCJQcm9wb3J0aW9uXCI6XCLiiLdcIixcInByb3B0b1wiOlwi4oidXCIsXCJwcnNpbVwiOlwi4om+XCIsXCJwcnVyZWxcIjpcIuKKsFwiLFwiUHNjclwiOlwi8J2Sq1wiLFwicHNjclwiOlwi8J2ThVwiLFwiUHNpXCI6XCLOqFwiLFwicHNpXCI6XCLPiFwiLFwicHVuY3NwXCI6XCLigIhcIixcIlFmclwiOlwi8J2UlFwiLFwicWZyXCI6XCLwnZSuXCIsXCJxaW50XCI6XCLiqIxcIixcInFvcGZcIjpcIvCdlaJcIixcIlFvcGZcIjpcIuKEmlwiLFwicXByaW1lXCI6XCLigZdcIixcIlFzY3JcIjpcIvCdkqxcIixcInFzY3JcIjpcIvCdk4ZcIixcInF1YXRlcm5pb25zXCI6XCLihI1cIixcInF1YXRpbnRcIjpcIuKollwiLFwicXVlc3RcIjpcIj9cIixcInF1ZXN0ZXFcIjpcIuKJn1wiLFwicXVvdFwiOlwiXFxcIlwiLFwiUVVPVFwiOlwiXFxcIlwiLFwickFhcnJcIjpcIuKHm1wiLFwicmFjZVwiOlwi4oi9zLFcIixcIlJhY3V0ZVwiOlwixZRcIixcInJhY3V0ZVwiOlwixZVcIixcInJhZGljXCI6XCLiiJpcIixcInJhZW1wdHl2XCI6XCLiprNcIixcInJhbmdcIjpcIuKfqVwiLFwiUmFuZ1wiOlwi4p+rXCIsXCJyYW5nZFwiOlwi4qaSXCIsXCJyYW5nZVwiOlwi4qalXCIsXCJyYW5nbGVcIjpcIuKfqVwiLFwicmFxdW9cIjpcIsK7XCIsXCJyYXJyYXBcIjpcIuKltVwiLFwicmFycmJcIjpcIuKHpVwiLFwicmFycmJmc1wiOlwi4qSgXCIsXCJyYXJyY1wiOlwi4qSzXCIsXCJyYXJyXCI6XCLihpJcIixcIlJhcnJcIjpcIuKGoFwiLFwickFyclwiOlwi4oeSXCIsXCJyYXJyZnNcIjpcIuKknlwiLFwicmFycmhrXCI6XCLihqpcIixcInJhcnJscFwiOlwi4oasXCIsXCJyYXJycGxcIjpcIuKlhVwiLFwicmFycnNpbVwiOlwi4qW0XCIsXCJSYXJydGxcIjpcIuKkllwiLFwicmFycnRsXCI6XCLihqNcIixcInJhcnJ3XCI6XCLihp1cIixcInJhdGFpbFwiOlwi4qSaXCIsXCJyQXRhaWxcIjpcIuKknFwiLFwicmF0aW9cIjpcIuKItlwiLFwicmF0aW9uYWxzXCI6XCLihJpcIixcInJiYXJyXCI6XCLipI1cIixcInJCYXJyXCI6XCLipI9cIixcIlJCYXJyXCI6XCLipJBcIixcInJiYnJrXCI6XCLinbNcIixcInJicmFjZVwiOlwifVwiLFwicmJyYWNrXCI6XCJdXCIsXCJyYnJrZVwiOlwi4qaMXCIsXCJyYnJrc2xkXCI6XCLipo5cIixcInJicmtzbHVcIjpcIuKmkFwiLFwiUmNhcm9uXCI6XCLFmFwiLFwicmNhcm9uXCI6XCLFmVwiLFwiUmNlZGlsXCI6XCLFllwiLFwicmNlZGlsXCI6XCLFl1wiLFwicmNlaWxcIjpcIuKMiVwiLFwicmN1YlwiOlwifVwiLFwiUmN5XCI6XCLQoFwiLFwicmN5XCI6XCLRgFwiLFwicmRjYVwiOlwi4qS3XCIsXCJyZGxkaGFyXCI6XCLipalcIixcInJkcXVvXCI6XCLigJ1cIixcInJkcXVvclwiOlwi4oCdXCIsXCJyZHNoXCI6XCLihrNcIixcInJlYWxcIjpcIuKEnFwiLFwicmVhbGluZVwiOlwi4oSbXCIsXCJyZWFscGFydFwiOlwi4oScXCIsXCJyZWFsc1wiOlwi4oSdXCIsXCJSZVwiOlwi4oScXCIsXCJyZWN0XCI6XCLilq1cIixcInJlZ1wiOlwiwq5cIixcIlJFR1wiOlwiwq5cIixcIlJldmVyc2VFbGVtZW50XCI6XCLiiItcIixcIlJldmVyc2VFcXVpbGlicml1bVwiOlwi4oeLXCIsXCJSZXZlcnNlVXBFcXVpbGlicml1bVwiOlwi4qWvXCIsXCJyZmlzaHRcIjpcIuKlvVwiLFwicmZsb29yXCI6XCLijItcIixcInJmclwiOlwi8J2Ur1wiLFwiUmZyXCI6XCLihJxcIixcInJIYXJcIjpcIuKlpFwiLFwicmhhcmRcIjpcIuKHgVwiLFwicmhhcnVcIjpcIuKHgFwiLFwicmhhcnVsXCI6XCLipaxcIixcIlJob1wiOlwizqFcIixcInJob1wiOlwiz4FcIixcInJob3ZcIjpcIs+xXCIsXCJSaWdodEFuZ2xlQnJhY2tldFwiOlwi4p+pXCIsXCJSaWdodEFycm93QmFyXCI6XCLih6VcIixcInJpZ2h0YXJyb3dcIjpcIuKGklwiLFwiUmlnaHRBcnJvd1wiOlwi4oaSXCIsXCJSaWdodGFycm93XCI6XCLih5JcIixcIlJpZ2h0QXJyb3dMZWZ0QXJyb3dcIjpcIuKHhFwiLFwicmlnaHRhcnJvd3RhaWxcIjpcIuKGo1wiLFwiUmlnaHRDZWlsaW5nXCI6XCLijIlcIixcIlJpZ2h0RG91YmxlQnJhY2tldFwiOlwi4p+nXCIsXCJSaWdodERvd25UZWVWZWN0b3JcIjpcIuKlnVwiLFwiUmlnaHREb3duVmVjdG9yQmFyXCI6XCLipZVcIixcIlJpZ2h0RG93blZlY3RvclwiOlwi4oeCXCIsXCJSaWdodEZsb29yXCI6XCLijItcIixcInJpZ2h0aGFycG9vbmRvd25cIjpcIuKHgVwiLFwicmlnaHRoYXJwb29udXBcIjpcIuKHgFwiLFwicmlnaHRsZWZ0YXJyb3dzXCI6XCLih4RcIixcInJpZ2h0bGVmdGhhcnBvb25zXCI6XCLih4xcIixcInJpZ2h0cmlnaHRhcnJvd3NcIjpcIuKHiVwiLFwicmlnaHRzcXVpZ2Fycm93XCI6XCLihp1cIixcIlJpZ2h0VGVlQXJyb3dcIjpcIuKGplwiLFwiUmlnaHRUZWVcIjpcIuKKolwiLFwiUmlnaHRUZWVWZWN0b3JcIjpcIuKlm1wiLFwicmlnaHR0aHJlZXRpbWVzXCI6XCLii4xcIixcIlJpZ2h0VHJpYW5nbGVCYXJcIjpcIuKnkFwiLFwiUmlnaHRUcmlhbmdsZVwiOlwi4oqzXCIsXCJSaWdodFRyaWFuZ2xlRXF1YWxcIjpcIuKKtVwiLFwiUmlnaHRVcERvd25WZWN0b3JcIjpcIuKlj1wiLFwiUmlnaHRVcFRlZVZlY3RvclwiOlwi4qWcXCIsXCJSaWdodFVwVmVjdG9yQmFyXCI6XCLipZRcIixcIlJpZ2h0VXBWZWN0b3JcIjpcIuKGvlwiLFwiUmlnaHRWZWN0b3JCYXJcIjpcIuKlk1wiLFwiUmlnaHRWZWN0b3JcIjpcIuKHgFwiLFwicmluZ1wiOlwiy5pcIixcInJpc2luZ2RvdHNlcVwiOlwi4omTXCIsXCJybGFyclwiOlwi4oeEXCIsXCJybGhhclwiOlwi4oeMXCIsXCJybG1cIjpcIuKAj1wiLFwicm1vdXN0YWNoZVwiOlwi4o6xXCIsXCJybW91c3RcIjpcIuKOsVwiLFwicm5taWRcIjpcIuKrrlwiLFwicm9hbmdcIjpcIuKfrVwiLFwicm9hcnJcIjpcIuKHvlwiLFwicm9icmtcIjpcIuKfp1wiLFwicm9wYXJcIjpcIuKmhlwiLFwicm9wZlwiOlwi8J2Vo1wiLFwiUm9wZlwiOlwi4oSdXCIsXCJyb3BsdXNcIjpcIuKorlwiLFwicm90aW1lc1wiOlwi4qi1XCIsXCJSb3VuZEltcGxpZXNcIjpcIuKlsFwiLFwicnBhclwiOlwiKVwiLFwicnBhcmd0XCI6XCLippRcIixcInJwcG9saW50XCI6XCLiqJJcIixcInJyYXJyXCI6XCLih4lcIixcIlJyaWdodGFycm93XCI6XCLih5tcIixcInJzYXF1b1wiOlwi4oC6XCIsXCJyc2NyXCI6XCLwnZOHXCIsXCJSc2NyXCI6XCLihJtcIixcInJzaFwiOlwi4oaxXCIsXCJSc2hcIjpcIuKGsVwiLFwicnNxYlwiOlwiXVwiLFwicnNxdW9cIjpcIuKAmVwiLFwicnNxdW9yXCI6XCLigJlcIixcInJ0aHJlZVwiOlwi4ouMXCIsXCJydGltZXNcIjpcIuKLilwiLFwicnRyaVwiOlwi4pa5XCIsXCJydHJpZVwiOlwi4oq1XCIsXCJydHJpZlwiOlwi4pa4XCIsXCJydHJpbHRyaVwiOlwi4qeOXCIsXCJSdWxlRGVsYXllZFwiOlwi4qe0XCIsXCJydWx1aGFyXCI6XCLipahcIixcInJ4XCI6XCLihJ5cIixcIlNhY3V0ZVwiOlwixZpcIixcInNhY3V0ZVwiOlwixZtcIixcInNicXVvXCI6XCLigJpcIixcInNjYXBcIjpcIuKquFwiLFwiU2Nhcm9uXCI6XCLFoFwiLFwic2Nhcm9uXCI6XCLFoVwiLFwiU2NcIjpcIuKqvFwiLFwic2NcIjpcIuKJu1wiLFwic2NjdWVcIjpcIuKJvVwiLFwic2NlXCI6XCLiqrBcIixcInNjRVwiOlwi4qq0XCIsXCJTY2VkaWxcIjpcIsWeXCIsXCJzY2VkaWxcIjpcIsWfXCIsXCJTY2lyY1wiOlwixZxcIixcInNjaXJjXCI6XCLFnVwiLFwic2NuYXBcIjpcIuKqulwiLFwic2NuRVwiOlwi4qq2XCIsXCJzY25zaW1cIjpcIuKLqVwiLFwic2Nwb2xpbnRcIjpcIuKok1wiLFwic2NzaW1cIjpcIuKJv1wiLFwiU2N5XCI6XCLQoVwiLFwic2N5XCI6XCLRgVwiLFwic2RvdGJcIjpcIuKKoVwiLFwic2RvdFwiOlwi4ouFXCIsXCJzZG90ZVwiOlwi4qmmXCIsXCJzZWFyaGtcIjpcIuKkpVwiLFwic2VhcnJcIjpcIuKGmFwiLFwic2VBcnJcIjpcIuKHmFwiLFwic2VhcnJvd1wiOlwi4oaYXCIsXCJzZWN0XCI6XCLCp1wiLFwic2VtaVwiOlwiO1wiLFwic2Vzd2FyXCI6XCLipKlcIixcInNldG1pbnVzXCI6XCLiiJZcIixcInNldG1uXCI6XCLiiJZcIixcInNleHRcIjpcIuKctlwiLFwiU2ZyXCI6XCLwnZSWXCIsXCJzZnJcIjpcIvCdlLBcIixcInNmcm93blwiOlwi4oyiXCIsXCJzaGFycFwiOlwi4pmvXCIsXCJTSENIY3lcIjpcItCpXCIsXCJzaGNoY3lcIjpcItGJXCIsXCJTSGN5XCI6XCLQqFwiLFwic2hjeVwiOlwi0YhcIixcIlNob3J0RG93bkFycm93XCI6XCLihpNcIixcIlNob3J0TGVmdEFycm93XCI6XCLihpBcIixcInNob3J0bWlkXCI6XCLiiKNcIixcInNob3J0cGFyYWxsZWxcIjpcIuKIpVwiLFwiU2hvcnRSaWdodEFycm93XCI6XCLihpJcIixcIlNob3J0VXBBcnJvd1wiOlwi4oaRXCIsXCJzaHlcIjpcIsKtXCIsXCJTaWdtYVwiOlwizqNcIixcInNpZ21hXCI6XCLPg1wiLFwic2lnbWFmXCI6XCLPglwiLFwic2lnbWF2XCI6XCLPglwiLFwic2ltXCI6XCLiiLxcIixcInNpbWRvdFwiOlwi4qmqXCIsXCJzaW1lXCI6XCLiiYNcIixcInNpbWVxXCI6XCLiiYNcIixcInNpbWdcIjpcIuKqnlwiLFwic2ltZ0VcIjpcIuKqoFwiLFwic2ltbFwiOlwi4qqdXCIsXCJzaW1sRVwiOlwi4qqfXCIsXCJzaW1uZVwiOlwi4omGXCIsXCJzaW1wbHVzXCI6XCLiqKRcIixcInNpbXJhcnJcIjpcIuKlslwiLFwic2xhcnJcIjpcIuKGkFwiLFwiU21hbGxDaXJjbGVcIjpcIuKImFwiLFwic21hbGxzZXRtaW51c1wiOlwi4oiWXCIsXCJzbWFzaHBcIjpcIuKos1wiLFwic21lcGFyc2xcIjpcIuKnpFwiLFwic21pZFwiOlwi4oijXCIsXCJzbWlsZVwiOlwi4oyjXCIsXCJzbXRcIjpcIuKqqlwiLFwic210ZVwiOlwi4qqsXCIsXCJzbXRlc1wiOlwi4qqs77iAXCIsXCJTT0ZUY3lcIjpcItCsXCIsXCJzb2Z0Y3lcIjpcItGMXCIsXCJzb2xiYXJcIjpcIuKMv1wiLFwic29sYlwiOlwi4qeEXCIsXCJzb2xcIjpcIi9cIixcIlNvcGZcIjpcIvCdlYpcIixcInNvcGZcIjpcIvCdlaRcIixcInNwYWRlc1wiOlwi4pmgXCIsXCJzcGFkZXN1aXRcIjpcIuKZoFwiLFwic3BhclwiOlwi4oilXCIsXCJzcWNhcFwiOlwi4oqTXCIsXCJzcWNhcHNcIjpcIuKKk++4gFwiLFwic3FjdXBcIjpcIuKKlFwiLFwic3FjdXBzXCI6XCLiipTvuIBcIixcIlNxcnRcIjpcIuKImlwiLFwic3FzdWJcIjpcIuKKj1wiLFwic3FzdWJlXCI6XCLiipFcIixcInNxc3Vic2V0XCI6XCLiio9cIixcInNxc3Vic2V0ZXFcIjpcIuKKkVwiLFwic3FzdXBcIjpcIuKKkFwiLFwic3FzdXBlXCI6XCLiipJcIixcInNxc3Vwc2V0XCI6XCLiipBcIixcInNxc3Vwc2V0ZXFcIjpcIuKKklwiLFwic3F1YXJlXCI6XCLilqFcIixcIlNxdWFyZVwiOlwi4pahXCIsXCJTcXVhcmVJbnRlcnNlY3Rpb25cIjpcIuKKk1wiLFwiU3F1YXJlU3Vic2V0XCI6XCLiio9cIixcIlNxdWFyZVN1YnNldEVxdWFsXCI6XCLiipFcIixcIlNxdWFyZVN1cGVyc2V0XCI6XCLiipBcIixcIlNxdWFyZVN1cGVyc2V0RXF1YWxcIjpcIuKKklwiLFwiU3F1YXJlVW5pb25cIjpcIuKKlFwiLFwic3F1YXJmXCI6XCLilqpcIixcInNxdVwiOlwi4pahXCIsXCJzcXVmXCI6XCLilqpcIixcInNyYXJyXCI6XCLihpJcIixcIlNzY3JcIjpcIvCdkq5cIixcInNzY3JcIjpcIvCdk4hcIixcInNzZXRtblwiOlwi4oiWXCIsXCJzc21pbGVcIjpcIuKMo1wiLFwic3N0YXJmXCI6XCLii4ZcIixcIlN0YXJcIjpcIuKLhlwiLFwic3RhclwiOlwi4piGXCIsXCJzdGFyZlwiOlwi4piFXCIsXCJzdHJhaWdodGVwc2lsb25cIjpcIs+1XCIsXCJzdHJhaWdodHBoaVwiOlwiz5VcIixcInN0cm5zXCI6XCLCr1wiLFwic3ViXCI6XCLiioJcIixcIlN1YlwiOlwi4ouQXCIsXCJzdWJkb3RcIjpcIuKqvVwiLFwic3ViRVwiOlwi4quFXCIsXCJzdWJlXCI6XCLiioZcIixcInN1YmVkb3RcIjpcIuKrg1wiLFwic3VibXVsdFwiOlwi4quBXCIsXCJzdWJuRVwiOlwi4quLXCIsXCJzdWJuZVwiOlwi4oqKXCIsXCJzdWJwbHVzXCI6XCLiqr9cIixcInN1YnJhcnJcIjpcIuKluVwiLFwic3Vic2V0XCI6XCLiioJcIixcIlN1YnNldFwiOlwi4ouQXCIsXCJzdWJzZXRlcVwiOlwi4oqGXCIsXCJzdWJzZXRlcXFcIjpcIuKrhVwiLFwiU3Vic2V0RXF1YWxcIjpcIuKKhlwiLFwic3Vic2V0bmVxXCI6XCLiiopcIixcInN1YnNldG5lcXFcIjpcIuKri1wiLFwic3Vic2ltXCI6XCLiq4dcIixcInN1YnN1YlwiOlwi4quVXCIsXCJzdWJzdXBcIjpcIuKrk1wiLFwic3VjY2FwcHJveFwiOlwi4qq4XCIsXCJzdWNjXCI6XCLiibtcIixcInN1Y2NjdXJseWVxXCI6XCLiib1cIixcIlN1Y2NlZWRzXCI6XCLiibtcIixcIlN1Y2NlZWRzRXF1YWxcIjpcIuKqsFwiLFwiU3VjY2VlZHNTbGFudEVxdWFsXCI6XCLiib1cIixcIlN1Y2NlZWRzVGlsZGVcIjpcIuKJv1wiLFwic3VjY2VxXCI6XCLiqrBcIixcInN1Y2NuYXBwcm94XCI6XCLiqrpcIixcInN1Y2NuZXFxXCI6XCLiqrZcIixcInN1Y2Nuc2ltXCI6XCLii6lcIixcInN1Y2NzaW1cIjpcIuKJv1wiLFwiU3VjaFRoYXRcIjpcIuKIi1wiLFwic3VtXCI6XCLiiJFcIixcIlN1bVwiOlwi4oiRXCIsXCJzdW5nXCI6XCLimapcIixcInN1cDFcIjpcIsK5XCIsXCJzdXAyXCI6XCLCslwiLFwic3VwM1wiOlwiwrNcIixcInN1cFwiOlwi4oqDXCIsXCJTdXBcIjpcIuKLkVwiLFwic3VwZG90XCI6XCLiqr5cIixcInN1cGRzdWJcIjpcIuKrmFwiLFwic3VwRVwiOlwi4quGXCIsXCJzdXBlXCI6XCLiiodcIixcInN1cGVkb3RcIjpcIuKrhFwiLFwiU3VwZXJzZXRcIjpcIuKKg1wiLFwiU3VwZXJzZXRFcXVhbFwiOlwi4oqHXCIsXCJzdXBoc29sXCI6XCLin4lcIixcInN1cGhzdWJcIjpcIuKrl1wiLFwic3VwbGFyclwiOlwi4qW7XCIsXCJzdXBtdWx0XCI6XCLiq4JcIixcInN1cG5FXCI6XCLiq4xcIixcInN1cG5lXCI6XCLiiotcIixcInN1cHBsdXNcIjpcIuKrgFwiLFwic3Vwc2V0XCI6XCLiioNcIixcIlN1cHNldFwiOlwi4ouRXCIsXCJzdXBzZXRlcVwiOlwi4oqHXCIsXCJzdXBzZXRlcXFcIjpcIuKrhlwiLFwic3Vwc2V0bmVxXCI6XCLiiotcIixcInN1cHNldG5lcXFcIjpcIuKrjFwiLFwic3Vwc2ltXCI6XCLiq4hcIixcInN1cHN1YlwiOlwi4quUXCIsXCJzdXBzdXBcIjpcIuKrllwiLFwic3dhcmhrXCI6XCLipKZcIixcInN3YXJyXCI6XCLihplcIixcInN3QXJyXCI6XCLih5lcIixcInN3YXJyb3dcIjpcIuKGmVwiLFwic3dud2FyXCI6XCLipKpcIixcInN6bGlnXCI6XCLDn1wiLFwiVGFiXCI6XCJcXHRcIixcInRhcmdldFwiOlwi4oyWXCIsXCJUYXVcIjpcIs6kXCIsXCJ0YXVcIjpcIs+EXCIsXCJ0YnJrXCI6XCLijrRcIixcIlRjYXJvblwiOlwixaRcIixcInRjYXJvblwiOlwixaVcIixcIlRjZWRpbFwiOlwixaJcIixcInRjZWRpbFwiOlwixaNcIixcIlRjeVwiOlwi0KJcIixcInRjeVwiOlwi0YJcIixcInRkb3RcIjpcIuKDm1wiLFwidGVscmVjXCI6XCLijJVcIixcIlRmclwiOlwi8J2Ul1wiLFwidGZyXCI6XCLwnZSxXCIsXCJ0aGVyZTRcIjpcIuKItFwiLFwidGhlcmVmb3JlXCI6XCLiiLRcIixcIlRoZXJlZm9yZVwiOlwi4oi0XCIsXCJUaGV0YVwiOlwizphcIixcInRoZXRhXCI6XCLOuFwiLFwidGhldGFzeW1cIjpcIs+RXCIsXCJ0aGV0YXZcIjpcIs+RXCIsXCJ0aGlja2FwcHJveFwiOlwi4omIXCIsXCJ0aGlja3NpbVwiOlwi4oi8XCIsXCJUaGlja1NwYWNlXCI6XCLigZ/igIpcIixcIlRoaW5TcGFjZVwiOlwi4oCJXCIsXCJ0aGluc3BcIjpcIuKAiVwiLFwidGhrYXBcIjpcIuKJiFwiLFwidGhrc2ltXCI6XCLiiLxcIixcIlRIT1JOXCI6XCLDnlwiLFwidGhvcm5cIjpcIsO+XCIsXCJ0aWxkZVwiOlwiy5xcIixcIlRpbGRlXCI6XCLiiLxcIixcIlRpbGRlRXF1YWxcIjpcIuKJg1wiLFwiVGlsZGVGdWxsRXF1YWxcIjpcIuKJhVwiLFwiVGlsZGVUaWxkZVwiOlwi4omIXCIsXCJ0aW1lc2JhclwiOlwi4qixXCIsXCJ0aW1lc2JcIjpcIuKKoFwiLFwidGltZXNcIjpcIsOXXCIsXCJ0aW1lc2RcIjpcIuKosFwiLFwidGludFwiOlwi4oitXCIsXCJ0b2VhXCI6XCLipKhcIixcInRvcGJvdFwiOlwi4oy2XCIsXCJ0b3BjaXJcIjpcIuKrsVwiLFwidG9wXCI6XCLiiqRcIixcIlRvcGZcIjpcIvCdlYtcIixcInRvcGZcIjpcIvCdlaVcIixcInRvcGZvcmtcIjpcIuKrmlwiLFwidG9zYVwiOlwi4qSpXCIsXCJ0cHJpbWVcIjpcIuKAtFwiLFwidHJhZGVcIjpcIuKEolwiLFwiVFJBREVcIjpcIuKEolwiLFwidHJpYW5nbGVcIjpcIuKWtVwiLFwidHJpYW5nbGVkb3duXCI6XCLilr9cIixcInRyaWFuZ2xlbGVmdFwiOlwi4peDXCIsXCJ0cmlhbmdsZWxlZnRlcVwiOlwi4oq0XCIsXCJ0cmlhbmdsZXFcIjpcIuKJnFwiLFwidHJpYW5nbGVyaWdodFwiOlwi4pa5XCIsXCJ0cmlhbmdsZXJpZ2h0ZXFcIjpcIuKKtVwiLFwidHJpZG90XCI6XCLil6xcIixcInRyaWVcIjpcIuKJnFwiLFwidHJpbWludXNcIjpcIuKoulwiLFwiVHJpcGxlRG90XCI6XCLig5tcIixcInRyaXBsdXNcIjpcIuKouVwiLFwidHJpc2JcIjpcIuKnjVwiLFwidHJpdGltZVwiOlwi4qi7XCIsXCJ0cnBleml1bVwiOlwi4o+iXCIsXCJUc2NyXCI6XCLwnZKvXCIsXCJ0c2NyXCI6XCLwnZOJXCIsXCJUU2N5XCI6XCLQplwiLFwidHNjeVwiOlwi0YZcIixcIlRTSGN5XCI6XCLQi1wiLFwidHNoY3lcIjpcItGbXCIsXCJUc3Ryb2tcIjpcIsWmXCIsXCJ0c3Ryb2tcIjpcIsWnXCIsXCJ0d2l4dFwiOlwi4omsXCIsXCJ0d29oZWFkbGVmdGFycm93XCI6XCLihp5cIixcInR3b2hlYWRyaWdodGFycm93XCI6XCLihqBcIixcIlVhY3V0ZVwiOlwiw5pcIixcInVhY3V0ZVwiOlwiw7pcIixcInVhcnJcIjpcIuKGkVwiLFwiVWFyclwiOlwi4oafXCIsXCJ1QXJyXCI6XCLih5FcIixcIlVhcnJvY2lyXCI6XCLipYlcIixcIlVicmN5XCI6XCLQjlwiLFwidWJyY3lcIjpcItGeXCIsXCJVYnJldmVcIjpcIsWsXCIsXCJ1YnJldmVcIjpcIsWtXCIsXCJVY2lyY1wiOlwiw5tcIixcInVjaXJjXCI6XCLDu1wiLFwiVWN5XCI6XCLQo1wiLFwidWN5XCI6XCLRg1wiLFwidWRhcnJcIjpcIuKHhVwiLFwiVWRibGFjXCI6XCLFsFwiLFwidWRibGFjXCI6XCLFsVwiLFwidWRoYXJcIjpcIuKlrlwiLFwidWZpc2h0XCI6XCLipb5cIixcIlVmclwiOlwi8J2UmFwiLFwidWZyXCI6XCLwnZSyXCIsXCJVZ3JhdmVcIjpcIsOZXCIsXCJ1Z3JhdmVcIjpcIsO5XCIsXCJ1SGFyXCI6XCLipaNcIixcInVoYXJsXCI6XCLihr9cIixcInVoYXJyXCI6XCLihr5cIixcInVoYmxrXCI6XCLiloBcIixcInVsY29yblwiOlwi4oycXCIsXCJ1bGNvcm5lclwiOlwi4oycXCIsXCJ1bGNyb3BcIjpcIuKMj1wiLFwidWx0cmlcIjpcIuKXuFwiLFwiVW1hY3JcIjpcIsWqXCIsXCJ1bWFjclwiOlwixatcIixcInVtbFwiOlwiwqhcIixcIlVuZGVyQmFyXCI6XCJfXCIsXCJVbmRlckJyYWNlXCI6XCLij59cIixcIlVuZGVyQnJhY2tldFwiOlwi4o61XCIsXCJVbmRlclBhcmVudGhlc2lzXCI6XCLij51cIixcIlVuaW9uXCI6XCLii4NcIixcIlVuaW9uUGx1c1wiOlwi4oqOXCIsXCJVb2dvblwiOlwixbJcIixcInVvZ29uXCI6XCLFs1wiLFwiVW9wZlwiOlwi8J2VjFwiLFwidW9wZlwiOlwi8J2VplwiLFwiVXBBcnJvd0JhclwiOlwi4qSSXCIsXCJ1cGFycm93XCI6XCLihpFcIixcIlVwQXJyb3dcIjpcIuKGkVwiLFwiVXBhcnJvd1wiOlwi4oeRXCIsXCJVcEFycm93RG93bkFycm93XCI6XCLih4VcIixcInVwZG93bmFycm93XCI6XCLihpVcIixcIlVwRG93bkFycm93XCI6XCLihpVcIixcIlVwZG93bmFycm93XCI6XCLih5VcIixcIlVwRXF1aWxpYnJpdW1cIjpcIuKlrlwiLFwidXBoYXJwb29ubGVmdFwiOlwi4oa/XCIsXCJ1cGhhcnBvb25yaWdodFwiOlwi4oa+XCIsXCJ1cGx1c1wiOlwi4oqOXCIsXCJVcHBlckxlZnRBcnJvd1wiOlwi4oaWXCIsXCJVcHBlclJpZ2h0QXJyb3dcIjpcIuKGl1wiLFwidXBzaVwiOlwiz4VcIixcIlVwc2lcIjpcIs+SXCIsXCJ1cHNpaFwiOlwiz5JcIixcIlVwc2lsb25cIjpcIs6lXCIsXCJ1cHNpbG9uXCI6XCLPhVwiLFwiVXBUZWVBcnJvd1wiOlwi4oalXCIsXCJVcFRlZVwiOlwi4oqlXCIsXCJ1cHVwYXJyb3dzXCI6XCLih4hcIixcInVyY29yblwiOlwi4oydXCIsXCJ1cmNvcm5lclwiOlwi4oydXCIsXCJ1cmNyb3BcIjpcIuKMjlwiLFwiVXJpbmdcIjpcIsWuXCIsXCJ1cmluZ1wiOlwixa9cIixcInVydHJpXCI6XCLil7lcIixcIlVzY3JcIjpcIvCdkrBcIixcInVzY3JcIjpcIvCdk4pcIixcInV0ZG90XCI6XCLii7BcIixcIlV0aWxkZVwiOlwixahcIixcInV0aWxkZVwiOlwixalcIixcInV0cmlcIjpcIuKWtVwiLFwidXRyaWZcIjpcIuKWtFwiLFwidXVhcnJcIjpcIuKHiFwiLFwiVXVtbFwiOlwiw5xcIixcInV1bWxcIjpcIsO8XCIsXCJ1d2FuZ2xlXCI6XCLipqdcIixcInZhbmdydFwiOlwi4qacXCIsXCJ2YXJlcHNpbG9uXCI6XCLPtVwiLFwidmFya2FwcGFcIjpcIs+wXCIsXCJ2YXJub3RoaW5nXCI6XCLiiIVcIixcInZhcnBoaVwiOlwiz5VcIixcInZhcnBpXCI6XCLPllwiLFwidmFycHJvcHRvXCI6XCLiiJ1cIixcInZhcnJcIjpcIuKGlVwiLFwidkFyclwiOlwi4oeVXCIsXCJ2YXJyaG9cIjpcIs+xXCIsXCJ2YXJzaWdtYVwiOlwiz4JcIixcInZhcnN1YnNldG5lcVwiOlwi4oqK77iAXCIsXCJ2YXJzdWJzZXRuZXFxXCI6XCLiq4vvuIBcIixcInZhcnN1cHNldG5lcVwiOlwi4oqL77iAXCIsXCJ2YXJzdXBzZXRuZXFxXCI6XCLiq4zvuIBcIixcInZhcnRoZXRhXCI6XCLPkVwiLFwidmFydHJpYW5nbGVsZWZ0XCI6XCLiirJcIixcInZhcnRyaWFuZ2xlcmlnaHRcIjpcIuKKs1wiLFwidkJhclwiOlwi4quoXCIsXCJWYmFyXCI6XCLiq6tcIixcInZCYXJ2XCI6XCLiq6lcIixcIlZjeVwiOlwi0JJcIixcInZjeVwiOlwi0LJcIixcInZkYXNoXCI6XCLiiqJcIixcInZEYXNoXCI6XCLiiqhcIixcIlZkYXNoXCI6XCLiiqlcIixcIlZEYXNoXCI6XCLiiqtcIixcIlZkYXNobFwiOlwi4qumXCIsXCJ2ZWViYXJcIjpcIuKKu1wiLFwidmVlXCI6XCLiiKhcIixcIlZlZVwiOlwi4ouBXCIsXCJ2ZWVlcVwiOlwi4omaXCIsXCJ2ZWxsaXBcIjpcIuKLrlwiLFwidmVyYmFyXCI6XCJ8XCIsXCJWZXJiYXJcIjpcIuKAllwiLFwidmVydFwiOlwifFwiLFwiVmVydFwiOlwi4oCWXCIsXCJWZXJ0aWNhbEJhclwiOlwi4oijXCIsXCJWZXJ0aWNhbExpbmVcIjpcInxcIixcIlZlcnRpY2FsU2VwYXJhdG9yXCI6XCLinZhcIixcIlZlcnRpY2FsVGlsZGVcIjpcIuKJgFwiLFwiVmVyeVRoaW5TcGFjZVwiOlwi4oCKXCIsXCJWZnJcIjpcIvCdlJlcIixcInZmclwiOlwi8J2Us1wiLFwidmx0cmlcIjpcIuKKslwiLFwidm5zdWJcIjpcIuKKguKDklwiLFwidm5zdXBcIjpcIuKKg+KDklwiLFwiVm9wZlwiOlwi8J2VjVwiLFwidm9wZlwiOlwi8J2Vp1wiLFwidnByb3BcIjpcIuKInVwiLFwidnJ0cmlcIjpcIuKKs1wiLFwiVnNjclwiOlwi8J2SsVwiLFwidnNjclwiOlwi8J2Ti1wiLFwidnN1Ym5FXCI6XCLiq4vvuIBcIixcInZzdWJuZVwiOlwi4oqK77iAXCIsXCJ2c3VwbkVcIjpcIuKrjO+4gFwiLFwidnN1cG5lXCI6XCLiiovvuIBcIixcIlZ2ZGFzaFwiOlwi4oqqXCIsXCJ2emlnemFnXCI6XCLipppcIixcIldjaXJjXCI6XCLFtFwiLFwid2NpcmNcIjpcIsW1XCIsXCJ3ZWRiYXJcIjpcIuKpn1wiLFwid2VkZ2VcIjpcIuKIp1wiLFwiV2VkZ2VcIjpcIuKLgFwiLFwid2VkZ2VxXCI6XCLiiZlcIixcIndlaWVycFwiOlwi4oSYXCIsXCJXZnJcIjpcIvCdlJpcIixcIndmclwiOlwi8J2UtFwiLFwiV29wZlwiOlwi8J2VjlwiLFwid29wZlwiOlwi8J2VqFwiLFwid3BcIjpcIuKEmFwiLFwid3JcIjpcIuKJgFwiLFwid3JlYXRoXCI6XCLiiYBcIixcIldzY3JcIjpcIvCdkrJcIixcIndzY3JcIjpcIvCdk4xcIixcInhjYXBcIjpcIuKLglwiLFwieGNpcmNcIjpcIuKXr1wiLFwieGN1cFwiOlwi4ouDXCIsXCJ4ZHRyaVwiOlwi4pa9XCIsXCJYZnJcIjpcIvCdlJtcIixcInhmclwiOlwi8J2UtVwiLFwieGhhcnJcIjpcIuKft1wiLFwieGhBcnJcIjpcIuKfulwiLFwiWGlcIjpcIs6eXCIsXCJ4aVwiOlwizr5cIixcInhsYXJyXCI6XCLin7VcIixcInhsQXJyXCI6XCLin7hcIixcInhtYXBcIjpcIuKfvFwiLFwieG5pc1wiOlwi4ou7XCIsXCJ4b2RvdFwiOlwi4qiAXCIsXCJYb3BmXCI6XCLwnZWPXCIsXCJ4b3BmXCI6XCLwnZWpXCIsXCJ4b3BsdXNcIjpcIuKogVwiLFwieG90aW1lXCI6XCLiqIJcIixcInhyYXJyXCI6XCLin7ZcIixcInhyQXJyXCI6XCLin7lcIixcIlhzY3JcIjpcIvCdkrNcIixcInhzY3JcIjpcIvCdk41cIixcInhzcWN1cFwiOlwi4qiGXCIsXCJ4dXBsdXNcIjpcIuKohFwiLFwieHV0cmlcIjpcIuKWs1wiLFwieHZlZVwiOlwi4ouBXCIsXCJ4d2VkZ2VcIjpcIuKLgFwiLFwiWWFjdXRlXCI6XCLDnVwiLFwieWFjdXRlXCI6XCLDvVwiLFwiWUFjeVwiOlwi0K9cIixcInlhY3lcIjpcItGPXCIsXCJZY2lyY1wiOlwixbZcIixcInljaXJjXCI6XCLFt1wiLFwiWWN5XCI6XCLQq1wiLFwieWN5XCI6XCLRi1wiLFwieWVuXCI6XCLCpVwiLFwiWWZyXCI6XCLwnZScXCIsXCJ5ZnJcIjpcIvCdlLZcIixcIllJY3lcIjpcItCHXCIsXCJ5aWN5XCI6XCLRl1wiLFwiWW9wZlwiOlwi8J2VkFwiLFwieW9wZlwiOlwi8J2VqlwiLFwiWXNjclwiOlwi8J2StFwiLFwieXNjclwiOlwi8J2TjlwiLFwiWVVjeVwiOlwi0K5cIixcInl1Y3lcIjpcItGOXCIsXCJ5dW1sXCI6XCLDv1wiLFwiWXVtbFwiOlwixbhcIixcIlphY3V0ZVwiOlwixblcIixcInphY3V0ZVwiOlwixbpcIixcIlpjYXJvblwiOlwixb1cIixcInpjYXJvblwiOlwixb5cIixcIlpjeVwiOlwi0JdcIixcInpjeVwiOlwi0LdcIixcIlpkb3RcIjpcIsW7XCIsXCJ6ZG90XCI6XCLFvFwiLFwiemVldHJmXCI6XCLihKhcIixcIlplcm9XaWR0aFNwYWNlXCI6XCLigItcIixcIlpldGFcIjpcIs6WXCIsXCJ6ZXRhXCI6XCLOtlwiLFwiemZyXCI6XCLwnZS3XCIsXCJaZnJcIjpcIuKEqFwiLFwiWkhjeVwiOlwi0JZcIixcInpoY3lcIjpcItC2XCIsXCJ6aWdyYXJyXCI6XCLih51cIixcInpvcGZcIjpcIvCdlatcIixcIlpvcGZcIjpcIuKEpFwiLFwiWnNjclwiOlwi8J2StVwiLFwienNjclwiOlwi8J2Tj1wiLFwiendqXCI6XCLigI1cIixcInp3bmpcIjpcIuKAjFwifVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXJzXG5cbi8vIE1lcmdlIG9iamVjdHNcbi8vXG5mdW5jdGlvbiBhc3NpZ24ob2JqIC8qZnJvbTEsIGZyb20yLCBmcm9tMywgLi4uKi8pIHtcbiAgdmFyIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgaWYgKCFzb3VyY2UpIHsgcmV0dXJuOyB9XG5cbiAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nOyB9XG5mdW5jdGlvbiBpc09iamVjdChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBPYmplY3RdJzsgfVxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7IH1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJzsgfVxuXG5cbmZ1bmN0aW9uIGVzY2FwZVJFKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgJ1xcXFwkJicpOyB9XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICBmdXp6eUxpbms6IHRydWUsXG4gIGZ1enp5RW1haWw6IHRydWUsXG4gIGZ1enp5SVA6IGZhbHNlXG59O1xuXG5cbmZ1bmN0aW9uIGlzT3B0aW9uc09iaihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaiB8fCB7fSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGspIHtcbiAgICByZXR1cm4gYWNjIHx8IGRlZmF1bHRPcHRpb25zLmhhc093blByb3BlcnR5KGspO1xuICB9LCBmYWxzZSk7XG59XG5cblxudmFyIGRlZmF1bHRTY2hlbWFzID0ge1xuICAnaHR0cDonOiB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUuaHR0cCkge1xuICAgICAgICAvLyBjb21waWxlIGxhemlseSwgYmVjYXVzZSBcImhvc3RcIi1jb250YWluaW5nIHZhcmlhYmxlcyBjYW4gY2hhbmdlIG9uIHRsZHMgdXBkYXRlLlxuICAgICAgICBzZWxmLnJlLmh0dHAgPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXlxcXFwvXFxcXC8nICsgc2VsZi5yZS5zcmNfYXV0aCArIHNlbGYucmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgKyBzZWxmLnJlLnNyY19wYXRoLCAnaSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxmLnJlLmh0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLmh0dHApWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSxcbiAgJ2h0dHBzOic6ICAnaHR0cDonLFxuICAnZnRwOic6ICAgICdodHRwOicsXG4gICcvLyc6ICAgICAge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm5vX2h0dHApIHtcbiAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUubm9faHR0cCA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfYXV0aCArXG4gICAgICAgICAgLy8gRG9uJ3QgYWxsb3cgc2luZ2xlLWxldmVsIGRvbWFpbnMsIGJlY2F1c2Ugb2YgZmFsc2UgcG9zaXRpdmVzIGxpa2UgJy8vdGVzdCdcbiAgICAgICAgICAvLyB3aXRoIGNvZGUgY29tbWVudHNcbiAgICAgICAgICAnKD86bG9jYWxob3N0fCg/Oig/OicgKyBzZWxmLnJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsnICsgc2VsZi5yZS5zcmNfZG9tYWluX3Jvb3QgKyAnKScgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX3BvcnQgK1xuICAgICAgICAgIHNlbGYucmUuc3JjX2hvc3RfdGVybWluYXRvciArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcGF0aCxcblxuICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5yZS5ub19odHRwLnRlc3QodGFpbCkpIHtcbiAgICAgICAgLy8gc2hvdWxkIG5vdCBiZSBgOi8vYCAmIGAvLy9gLCB0aGF0IHByb3RlY3RzIGZyb20gZXJyb3JzIGluIHByb3RvY29sIG5hbWVcbiAgICAgICAgaWYgKHBvcyA+PSAzICYmIHRleHRbcG9zIC0gM10gPT09ICc6JykgeyByZXR1cm4gMDsgfVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJy8nKSB7IHJldHVybiAwOyB9XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUubm9faHR0cClbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuICAnbWFpbHRvOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5tYWlsdG8pIHtcbiAgICAgICAgc2VsZi5yZS5tYWlsdG8gPSAgbmV3IFJlZ0V4cChcbiAgICAgICAgICAnXicgKyBzZWxmLnJlLnNyY19lbWFpbF9uYW1lICsgJ0AnICsgc2VsZi5yZS5zcmNfaG9zdF9zdHJpY3QsICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUubWFpbHRvLnRlc3QodGFpbCkpIHtcbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5tYWlsdG8pWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxufTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cblxuLy8gUkUgcGF0dGVybiBmb3IgMi1jaGFyYWN0ZXIgdGxkcyAoYXV0b2dlbmVyYXRlZCBieSAuL3N1cHBvcnQvdGxkc18yY2hhcl9nZW4uanMpXG52YXIgdGxkc18yY2hfc3JjX3JlID0gJ2FbY2RlZmdpbG1ub3Fyc3R1d3h6XXxiW2FiZGVmZ2hpam1ub3JzdHZ3eXpdfGNbYWNkZmdoaWtsbW5vcnV2d3h5el18ZFtlamttb3pdfGVbY2VncnN0dV18Zltpamttb3JdfGdbYWJkZWZnaGlsbW5wcXJzdHV3eV18aFtrbW5ydHVdfGlbZGVsbW5vcXJzdF18altlbW9wXXxrW2VnaGltbnByd3l6XXxsW2FiY2lrcnN0dXZ5XXxtW2FjZGVnaGtsbW5vcHFyc3R1dnd4eXpdfG5bYWNlZmdpbG9wcnV6XXxvbXxwW2FlZmdoa2xtbnJzdHd5XXxxYXxyW2Vvc3V3XXxzW2FiY2RlZ2hpamtsbW5vcnR1dnh5el18dFtjZGZnaGprbG1ub3J0dnd6XXx1W2Fna3N5el18dlthY2VnaW51XXx3W2ZzXXx5W2V0XXx6W2Ftd10nO1xuXG4vLyBET04nVCB0cnkgdG8gbWFrZSBQUnMgd2l0aCBjaGFuZ2VzLiBFeHRlbmQgVExEcyB3aXRoIExpbmtpZnlJdC50bGRzKCkgaW5zdGVhZFxudmFyIHRsZHNfZGVmYXVsdCA9ICdiaXp8Y29tfGVkdXxnb3Z8bmV0fG9yZ3xwcm98d2VifHh4eHxhZXJvfGFzaWF8Y29vcHxpbmZvfG11c2V1bXxuYW1lfHNob3B80YDRhCcuc3BsaXQoJ3wnKTtcblxuLyplc2xpbnQtZW5hYmxlIG1heC1sZW4qL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiByZXNldFNjYW5DYWNoZShzZWxmKSB7XG4gIHNlbGYuX19pbmRleF9fID0gLTE7XG4gIHNlbGYuX190ZXh0X2NhY2hlX18gICA9ICcnO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0b3IocmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0ZXh0LCBwb3MpIHtcbiAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgIGlmIChyZS50ZXN0KHRhaWwpKSB7XG4gICAgICByZXR1cm4gdGFpbC5tYXRjaChyZSlbMF0ubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9ybWFsaXplcigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwgc2VsZikge1xuICAgIHNlbGYubm9ybWFsaXplKG1hdGNoKTtcbiAgfTtcbn1cblxuLy8gU2NoZW1hcyBjb21waWxlci4gQnVpbGQgcmVnZXhwcy5cbi8vXG5mdW5jdGlvbiBjb21waWxlKHNlbGYpIHtcblxuICAvLyBMb2FkICYgY2xvbmUgUkUgcGF0dGVybnMuXG4gIHZhciByZSA9IHNlbGYucmUgPSByZXF1aXJlKCcuL2xpYi9yZScpKHNlbGYuX19vcHRzX18pO1xuXG4gIC8vIERlZmluZSBkeW5hbWljIHBhdHRlcm5zXG4gIHZhciB0bGRzID0gc2VsZi5fX3RsZHNfXy5zbGljZSgpO1xuXG4gIHNlbGYub25Db21waWxlKCk7XG5cbiAgaWYgKCFzZWxmLl9fdGxkc19yZXBsYWNlZF9fKSB7XG4gICAgdGxkcy5wdXNoKHRsZHNfMmNoX3NyY19yZSk7XG4gIH1cbiAgdGxkcy5wdXNoKHJlLnNyY194bik7XG5cbiAgcmUuc3JjX3RsZHMgPSB0bGRzLmpvaW4oJ3wnKTtcblxuICBmdW5jdGlvbiB1bnRwbCh0cGwpIHsgcmV0dXJuIHRwbC5yZXBsYWNlKCclVExEUyUnLCByZS5zcmNfdGxkcyk7IH1cblxuICByZS5lbWFpbF9mdXp6eSAgICAgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9lbWFpbF9mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfZnV6enkgICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfZnV6enkpLCAnaScpO1xuICByZS5saW5rX25vX2lwX2Z1enp5ID0gUmVnRXhwKHVudHBsKHJlLnRwbF9saW5rX25vX2lwX2Z1enp5KSwgJ2knKTtcbiAgcmUuaG9zdF9mdXp6eV90ZXN0ICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfaG9zdF9mdXp6eV90ZXN0KSwgJ2knKTtcblxuICAvL1xuICAvLyBDb21waWxlIGVhY2ggc2NoZW1hXG4gIC8vXG5cbiAgdmFyIGFsaWFzZXMgPSBbXTtcblxuICBzZWxmLl9fY29tcGlsZWRfXyA9IHt9OyAvLyBSZXNldCBjb21waWxlZCBkYXRhXG5cbiAgZnVuY3Rpb24gc2NoZW1hRXJyb3IobmFtZSwgdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcoTGlua2lmeUl0KSBJbnZhbGlkIHNjaGVtYSBcIicgKyBuYW1lICsgJ1wiOiAnICsgdmFsKTtcbiAgfVxuXG4gIE9iamVjdC5rZXlzKHNlbGYuX19zY2hlbWFzX18pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsID0gc2VsZi5fX3NjaGVtYXNfX1tuYW1lXTtcblxuICAgIC8vIHNraXAgZGlzYWJsZWQgbWV0aG9kc1xuICAgIGlmICh2YWwgPT09IG51bGwpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgY29tcGlsZWQgPSB7IHZhbGlkYXRlOiBudWxsLCBsaW5rOiBudWxsIH07XG5cbiAgICBzZWxmLl9fY29tcGlsZWRfX1tuYW1lXSA9IGNvbXBpbGVkO1xuXG4gICAgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gY3JlYXRlVmFsaWRhdG9yKHZhbC52YWxpZGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsLnZhbGlkYXRlKSkge1xuICAgICAgICBjb21waWxlZC52YWxpZGF0ZSA9IHZhbC52YWxpZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbC5ub3JtYWxpemUpKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IHZhbC5ub3JtYWxpemU7XG4gICAgICB9IGVsc2UgaWYgKCF2YWwubm9ybWFsaXplKSB7XG4gICAgICAgIGNvbXBpbGVkLm5vcm1hbGl6ZSA9IGNyZWF0ZU5vcm1hbGl6ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcodmFsKSkge1xuICAgICAgYWxpYXNlcy5wdXNoKG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNjaGVtYUVycm9yKG5hbWUsIHZhbCk7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIENvbXBpbGUgcG9zdHBvbmVkIGFsaWFzZXNcbiAgLy9cblxuICBhbGlhc2VzLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgaWYgKCFzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0pIHtcbiAgICAgIC8vIFNpbGVudGx5IGZhaWwgb24gbWlzc2VkIHNjaGVtYXMgdG8gYXZvaWQgZXJyb25zIG9uIGRpc2FibGUuXG4gICAgICAvLyBzY2hlbWFFcnJvcihhbGlhcywgc2VsZi5fX3NjaGVtYXNfX1thbGlhc10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuX19jb21waWxlZF9fW2FsaWFzXS52YWxpZGF0ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0udmFsaWRhdGU7XG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLm5vcm1hbGl6ZSA9XG4gICAgICBzZWxmLl9fY29tcGlsZWRfX1tzZWxmLl9fc2NoZW1hc19fW2FsaWFzXV0ubm9ybWFsaXplO1xuICB9KTtcblxuICAvL1xuICAvLyBGYWtlIHJlY29yZCBmb3IgZ3Vlc3NlZCBsaW5rc1xuICAvL1xuICBzZWxmLl9fY29tcGlsZWRfX1snJ10gPSB7IHZhbGlkYXRlOiBudWxsLCBub3JtYWxpemU6IGNyZWF0ZU5vcm1hbGl6ZXIoKSB9O1xuXG4gIC8vXG4gIC8vIEJ1aWxkIHNjaGVtYSBjb25kaXRpb25cbiAgLy9cbiAgdmFyIHNsaXN0ID0gT2JqZWN0LmtleXMoc2VsZi5fX2NvbXBpbGVkX18pXG4gICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIGRpc2FibGVkICYgZmFrZSBzY2hlbWFzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZS5sZW5ndGggPiAwICYmIHNlbGYuX19jb21waWxlZF9fW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgLm1hcChlc2NhcGVSRSlcbiAgICAgICAgICAgICAgICAgICAgICAuam9pbignfCcpO1xuICAvLyAoPyFfKSBjYXVzZSAxLjV4IHNsb3dkb3duXG4gIHNlbGYucmUuc2NoZW1hX3Rlc3QgICA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaScpO1xuICBzZWxmLnJlLnNjaGVtYV9zZWFyY2ggPSBSZWdFeHAoJyhefCg/IV8pKD86Wz48XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpKCcgKyBzbGlzdCArICcpJywgJ2lnJyk7XG5cbiAgc2VsZi5yZS5wcmV0ZXN0ID0gUmVnRXhwKFxuICAgICcoJyArIHNlbGYucmUuc2NoZW1hX3Rlc3Quc291cmNlICsgJyl8KCcgKyBzZWxmLnJlLmhvc3RfZnV6enlfdGVzdC5zb3VyY2UgKyAnKXxAJyxcbiAgICAnaSdcbiAgKTtcblxuICAvL1xuICAvLyBDbGVhbnVwXG4gIC8vXG5cbiAgcmVzZXRTY2FuQ2FjaGUoc2VsZik7XG59XG5cbi8qKlxuICogY2xhc3MgTWF0Y2hcbiAqXG4gKiBNYXRjaCByZXN1bHQuIFNpbmdsZSBlbGVtZW50IG9mIGFycmF5LCByZXR1cm5lZCBieSBbW0xpbmtpZnlJdCNtYXRjaF1dXG4gKiovXG5mdW5jdGlvbiBNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgc3RhcnQgPSBzZWxmLl9faW5kZXhfXyxcbiAgICAgIGVuZCAgID0gc2VsZi5fX2xhc3RfaW5kZXhfXyxcbiAgICAgIHRleHQgID0gc2VsZi5fX3RleHRfY2FjaGVfXy5zbGljZShzdGFydCwgZW5kKTtcblxuICAvKipcbiAgICogTWF0Y2gjc2NoZW1hIC0+IFN0cmluZ1xuICAgKlxuICAgKiBQcmVmaXggKHByb3RvY29sKSBmb3IgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5zY2hlbWEgICAgPSBzZWxmLl9fc2NoZW1hX18udG9Mb3dlckNhc2UoKTtcbiAgLyoqXG4gICAqIE1hdGNoI2luZGV4IC0+IE51bWJlclxuICAgKlxuICAgKiBGaXJzdCBwb3NpdGlvbiBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmluZGV4ICAgICA9IHN0YXJ0ICsgc2hpZnQ7XG4gIC8qKlxuICAgKiBNYXRjaCNsYXN0SW5kZXggLT4gTnVtYmVyXG4gICAqXG4gICAqIE5leHQgcG9zaXRpb24gYWZ0ZXIgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5sYXN0SW5kZXggPSBlbmQgKyBzaGlmdDtcbiAgLyoqXG4gICAqIE1hdGNoI3JhdyAtPiBTdHJpbmdcbiAgICpcbiAgICogTWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy5yYXcgICAgICAgPSB0ZXh0O1xuICAvKipcbiAgICogTWF0Y2gjdGV4dCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm90bWFsaXplZCB0ZXh0IG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMudGV4dCAgICAgID0gdGV4dDtcbiAgLyoqXG4gICAqIE1hdGNoI3VybCAtPiBTdHJpbmdcbiAgICpcbiAgICogTm9ybWFsaXplZCB1cmwgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy51cmwgICAgICAgPSB0ZXh0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNYXRjaChzZWxmLCBzaGlmdCkge1xuICB2YXIgbWF0Y2ggPSBuZXcgTWF0Y2goc2VsZiwgc2hpZnQpO1xuXG4gIHNlbGYuX19jb21waWxlZF9fW21hdGNoLnNjaGVtYV0ubm9ybWFsaXplKG1hdGNoLCBzZWxmKTtcblxuICByZXR1cm4gbWF0Y2g7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBMaW5raWZ5SXRcbiAqKi9cblxuLyoqXG4gKiBuZXcgTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpXG4gKiAtIHNjaGVtYXMgKE9iamVjdCk6IE9wdGlvbmFsLiBBZGRpdGlvbmFsIHNjaGVtYXMgdG8gdmFsaWRhdGUgKHByZWZpeC92YWxpZGF0b3IpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogQ3JlYXRlcyBuZXcgbGlua2lmaWVyIGluc3RhbmNlIHdpdGggb3B0aW9uYWwgYWRkaXRpb25hbCBzY2hlbWFzLlxuICogQ2FuIGJlIGNhbGxlZCB3aXRob3V0IGBuZXdgIGtleXdvcmQgZm9yIGNvbnZlbmllbmNlLlxuICpcbiAqIEJ5IGRlZmF1bHQgdW5kZXJzdGFuZHM6XG4gKlxuICogLSBgaHR0cChzKTovLy4uLmAgLCBgZnRwOi8vLi4uYCwgYG1haWx0bzouLi5gICYgYC8vLi4uYCBsaW5rc1xuICogLSBcImZ1enp5XCIgbGlua3MgYW5kIGVtYWlscyAoZXhhbXBsZS5jb20sIGZvb0BiYXIuY29tKS5cbiAqXG4gKiBgc2NoZW1hc2AgaXMgYW4gb2JqZWN0LCB3aGVyZSBlYWNoIGtleS92YWx1ZSBkZXNjcmliZXMgcHJvdG9jb2wvcnVsZTpcbiAqXG4gKiAtIF9fa2V5X18gLSBsaW5rIHByZWZpeCAodXN1YWxseSwgcHJvdG9jb2wgbmFtZSB3aXRoIGA6YCBhdCB0aGUgZW5kLCBgc2t5cGU6YFxuICogICBmb3IgZXhhbXBsZSkuIGBsaW5raWZ5LWl0YCBtYWtlcyBzaHVyZSB0aGF0IHByZWZpeCBpcyBub3QgcHJlY2VlZGVkIHdpdGhcbiAqICAgYWxwaGFudW1lcmljIGNoYXIgYW5kIHN5bWJvbHMuIE9ubHkgd2hpdGVzcGFjZXMgYW5kIHB1bmN0dWF0aW9uIGFsbG93ZWQuXG4gKiAtIF9fdmFsdWVfXyAtIHJ1bGUgdG8gY2hlY2sgdGFpbCBhZnRlciBsaW5rIHByZWZpeFxuICogICAtIF9TdHJpbmdfIC0ganVzdCBhbGlhcyB0byBleGlzdGluZyBydWxlXG4gKiAgIC0gX09iamVjdF9cbiAqICAgICAtIF92YWxpZGF0ZV8gLSB2YWxpZGF0b3IgZnVuY3Rpb24gKHNob3VsZCByZXR1cm4gbWF0Y2hlZCBsZW5ndGggb24gc3VjY2VzcyksXG4gKiAgICAgICBvciBgUmVnRXhwYC5cbiAqICAgICAtIF9ub3JtYWxpemVfIC0gb3B0aW9uYWwgZnVuY3Rpb24gdG8gbm9ybWFsaXplIHRleHQgJiB1cmwgb2YgbWF0Y2hlZCByZXN1bHRcbiAqICAgICAgIChmb3IgZXhhbXBsZSwgZm9yIEB0d2l0dGVyIG1lbnRpb25zKS5cbiAqXG4gKiBgb3B0aW9uc2A6XG4gKlxuICogLSBfX2Z1enp5TGlua19fIC0gcmVjb2duaWdlIFVSTC1zIHdpdGhvdXQgYGh0dHAocyk6YCBwcmVmaXguIERlZmF1bHQgYHRydWVgLlxuICogLSBfX2Z1enp5SVBfXyAtIGFsbG93IElQcyBpbiBmdXp6eSBsaW5rcyBhYm92ZS4gQ2FuIGNvbmZsaWN0IHdpdGggc29tZSB0ZXh0c1xuICogICBsaWtlIHZlcnNpb24gbnVtYmVycy4gRGVmYXVsdCBgZmFsc2VgLlxuICogLSBfX2Z1enp5RW1haWxfXyAtIHJlY29nbml6ZSBlbWFpbHMgd2l0aG91dCBgbWFpbHRvOmAgcHJlZml4LlxuICpcbiAqKi9cbmZ1bmN0aW9uIExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaW5raWZ5SXQpKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoaXNPcHRpb25zT2JqKHNjaGVtYXMpKSB7XG4gICAgICBvcHRpb25zID0gc2NoZW1hcztcbiAgICAgIHNjaGVtYXMgPSB7fTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9fb3B0c19fICAgICAgICAgICA9IGFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8vIENhY2hlIGxhc3QgdGVzdGVkIHJlc3VsdC4gVXNlZCB0byBza2lwIHJlcGVhdGluZyBzdGVwcyBvbiBuZXh0IGBtYXRjaGAgY2FsbC5cbiAgdGhpcy5fX2luZGV4X18gICAgICAgICAgPSAtMTtcbiAgdGhpcy5fX2xhc3RfaW5kZXhfXyAgICAgPSAtMTsgLy8gTmV4dCBzY2FuIHBvc2l0aW9uXG4gIHRoaXMuX19zY2hlbWFfXyAgICAgICAgID0gJyc7XG4gIHRoaXMuX190ZXh0X2NhY2hlX18gICAgID0gJyc7XG5cbiAgdGhpcy5fX3NjaGVtYXNfXyAgICAgICAgPSBhc3NpZ24oe30sIGRlZmF1bHRTY2hlbWFzLCBzY2hlbWFzKTtcbiAgdGhpcy5fX2NvbXBpbGVkX18gICAgICAgPSB7fTtcblxuICB0aGlzLl9fdGxkc19fICAgICAgICAgICA9IHRsZHNfZGVmYXVsdDtcbiAgdGhpcy5fX3RsZHNfcmVwbGFjZWRfXyAgPSBmYWxzZTtcblxuICB0aGlzLnJlID0ge307XG5cbiAgY29tcGlsZSh0aGlzKTtcbn1cblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjYWRkKHNjaGVtYSwgZGVmaW5pdGlvbilcbiAqIC0gc2NoZW1hIChTdHJpbmcpOiBydWxlIG5hbWUgKGZpeGVkIHBhdHRlcm4gcHJlZml4KVxuICogLSBkZWZpbml0aW9uIChTdHJpbmd8UmVnRXhwfE9iamVjdCk6IHNjaGVtYSBkZWZpbml0aW9uXG4gKlxuICogQWRkIG5ldyBydWxlIGRlZmluaXRpb24uIFNlZSBjb25zdHJ1Y3RvciBkZXNjcmlwdGlvbiBmb3IgZGV0YWlscy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHNjaGVtYSwgZGVmaW5pdGlvbikge1xuICB0aGlzLl9fc2NoZW1hc19fW3NjaGVtYV0gPSBkZWZpbml0aW9uO1xuICBjb21waWxlKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3NldChvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB7IGZ1enp5TGlua3xmdXp6eUVtYWlsfGZ1enp5SVA6IHRydWV8ZmFsc2UgfVxuICpcbiAqIFNldCByZWNvZ25pdGlvbiBvcHRpb25zIGZvciBsaW5rcyB3aXRob3V0IHNjaGVtYS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgdGhpcy5fX29wdHNfXyA9IGFzc2lnbih0aGlzLl9fb3B0c19fLCBvcHRpb25zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFNlYXJjaGVzIGxpbmtpZmlhYmxlIHBhdHRlcm4gYW5kIHJldHVybnMgYHRydWVgIG9uIHN1Y2Nlc3Mgb3IgYGZhbHNlYCBvbiBmYWlsLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gdGVzdCh0ZXh0KSB7XG4gIC8vIFJlc2V0IHNjYW4gY2FjaGVcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyA9IHRleHQ7XG4gIHRoaXMuX19pbmRleF9fICAgICAgPSAtMTtcblxuICBpZiAoIXRleHQubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHZhciBtLCBtbCwgbWUsIGxlbiwgc2hpZnQsIG5leHQsIHJlLCB0bGRfcG9zLCBhdF9wb3M7XG5cbiAgLy8gdHJ5IHRvIHNjYW4gZm9yIGxpbmsgd2l0aCBzY2hlbWEgLSB0aGF0J3MgdGhlIG1vc3Qgc2ltcGxlIHJ1bGVcbiAgaWYgKHRoaXMucmUuc2NoZW1hX3Rlc3QudGVzdCh0ZXh0KSkge1xuICAgIHJlID0gdGhpcy5yZS5zY2hlbWFfc2VhcmNoO1xuICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKChtID0gcmUuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgIGxlbiA9IHRoaXMudGVzdFNjaGVtYUF0KHRleHQsIG1bMl0sIHJlLmxhc3RJbmRleCk7XG4gICAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSBtWzJdO1xuICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gbS5pbmRleCArIG1bMV0ubGVuZ3RoO1xuICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbS5pbmRleCArIG1bMF0ubGVuZ3RoICsgbGVuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5fX29wdHNfXy5mdXp6eUxpbmsgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ2h0dHA6J10pIHtcbiAgICAvLyBndWVzcyBzY2hlbWFsZXNzIGxpbmtzXG4gICAgdGxkX3BvcyA9IHRleHQuc2VhcmNoKHRoaXMucmUuaG9zdF9mdXp6eV90ZXN0KTtcbiAgICBpZiAodGxkX3BvcyA+PSAwKSB7XG4gICAgICAvLyBpZiB0bGQgaXMgbG9jYXRlZCBhZnRlciBmb3VuZCBsaW5rIC0gbm8gbmVlZCB0byBjaGVjayBmdXp6eSBwYXR0ZXJuXG4gICAgICBpZiAodGhpcy5fX2luZGV4X18gPCAwIHx8IHRsZF9wb3MgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICBpZiAoKG1sID0gdGV4dC5tYXRjaCh0aGlzLl9fb3B0c19fLmZ1enp5SVAgPyB0aGlzLnJlLmxpbmtfZnV6enkgOiB0aGlzLnJlLmxpbmtfbm9faXBfZnV6enkpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgICAgc2hpZnQgPSBtbC5pbmRleCArIG1sWzFdLmxlbmd0aDtcblxuICAgICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXykge1xuICAgICAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9ICcnO1xuICAgICAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IHNoaWZ0O1xuICAgICAgICAgICAgdGhpcy5fX2xhc3RfaW5kZXhfXyA9IG1sLmluZGV4ICsgbWxbMF0ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5RW1haWwgJiYgdGhpcy5fX2NvbXBpbGVkX19bJ21haWx0bzonXSkge1xuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgZW1haWxzXG4gICAgYXRfcG9zID0gdGV4dC5pbmRleE9mKCdAJyk7XG4gICAgaWYgKGF0X3BvcyA+PSAwKSB7XG4gICAgICAvLyBXZSBjYW4ndCBza2lwIHRoaXMgY2hlY2ssIGJlY2F1c2UgdGhpcyBjYXNlcyBhcmUgcG9zc2libGU6XG4gICAgICAvLyAxOTIuMTY4LjEuMUBnbWFpbC5jb20sIG15LmluQGV4YW1wbGUuY29tXG4gICAgICBpZiAoKG1lID0gdGV4dC5tYXRjaCh0aGlzLnJlLmVtYWlsX2Z1enp5KSkgIT09IG51bGwpIHtcblxuICAgICAgICBzaGlmdCA9IG1lLmluZGV4ICsgbWVbMV0ubGVuZ3RoO1xuICAgICAgICBuZXh0ICA9IG1lLmluZGV4ICsgbWVbMF0ubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgc2hpZnQgPCB0aGlzLl9faW5kZXhfXyB8fFxuICAgICAgICAgICAgKHNoaWZ0ID09PSB0aGlzLl9faW5kZXhfXyAmJiBuZXh0ID4gdGhpcy5fX2xhc3RfaW5kZXhfXykpIHtcbiAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJ21haWx0bzonO1xuICAgICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBzaGlmdDtcbiAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLl9faW5kZXhfXyA+PSAwO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNwcmV0ZXN0KHRleHQpIC0+IEJvb2xlYW5cbiAqXG4gKiBWZXJ5IHF1aWNrIGNoZWNrLCB0aGF0IGNhbiBnaXZlIGZhbHNlIHBvc2l0aXZlcy4gUmV0dXJucyB0cnVlIGlmIGxpbmsgTUFZIEJFXG4gKiBjYW4gZXhpc3RzLiBDYW4gYmUgdXNlZCBmb3Igc3BlZWQgb3B0aW1pemF0aW9uLCB3aGVuIHlvdSBuZWVkIHRvIGNoZWNrIHRoYXRcbiAqIGxpbmsgTk9UIGV4aXN0cy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUucHJldGVzdCA9IGZ1bmN0aW9uIHByZXRlc3QodGV4dCkge1xuICByZXR1cm4gdGhpcy5yZS5wcmV0ZXN0LnRlc3QodGV4dCk7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3Rlc3RTY2hlbWFBdCh0ZXh0LCBuYW1lLCBwb3NpdGlvbikgLT4gTnVtYmVyXG4gKiAtIHRleHQgKFN0cmluZyk6IHRleHQgdG8gc2NhblxuICogLSBuYW1lIChTdHJpbmcpOiBydWxlIChzY2hlbWEpIG5hbWVcbiAqIC0gcG9zaXRpb24gKE51bWJlcik6IHRleHQgb2Zmc2V0IHRvIGNoZWNrIGZyb21cbiAqXG4gKiBTaW1pbGFyIHRvIFtbTGlua2lmeUl0I3Rlc3RdXSBidXQgY2hlY2tzIG9ubHkgc3BlY2lmaWMgcHJvdG9jb2wgdGFpbCBleGFjdGx5XG4gKiBhdCBnaXZlbiBwb3NpdGlvbi4gUmV0dXJucyBsZW5ndGggb2YgZm91bmQgcGF0dGVybiAoMCBvbiBmYWlsKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGVzdFNjaGVtYUF0ID0gZnVuY3Rpb24gdGVzdFNjaGVtYUF0KHRleHQsIHNjaGVtYSwgcG9zKSB7XG4gIC8vIElmIG5vdCBzdXBwb3J0ZWQgc2NoZW1hIGNoZWNrIHJlcXVlc3RlZCAtIHRlcm1pbmF0ZVxuICBpZiAoIXRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiB0aGlzLl9fY29tcGlsZWRfX1tzY2hlbWEudG9Mb3dlckNhc2UoKV0udmFsaWRhdGUodGV4dCwgcG9zLCB0aGlzKTtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjbWF0Y2godGV4dCkgLT4gQXJyYXl8bnVsbFxuICpcbiAqIFJldHVybnMgYXJyYXkgb2YgZm91bmQgbGluayBkZXNjcmlwdGlvbnMgb3IgYG51bGxgIG9uIGZhaWwuIFdlIHN0cm9uZ2x5XG4gKiByZWNvbW1lbmQgdG8gdXNlIFtbTGlua2lmeUl0I3Rlc3RdXSBmaXJzdCwgZm9yIGJlc3Qgc3BlZWQuXG4gKlxuICogIyMjIyMgUmVzdWx0IG1hdGNoIGRlc2NyaXB0aW9uXG4gKlxuICogLSBfX3NjaGVtYV9fIC0gbGluayBzY2hlbWEsIGNhbiBiZSBlbXB0eSBmb3IgZnV6enkgbGlua3MsIG9yIGAvL2AgZm9yXG4gKiAgIHByb3RvY29sLW5ldXRyYWwgIGxpbmtzLlxuICogLSBfX2luZGV4X18gLSBvZmZzZXQgb2YgbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fbGFzdEluZGV4X18gLSBpbmRleCBvZiBuZXh0IGNoYXIgYWZ0ZXIgbWF0aGNoIGVuZFxuICogLSBfX3Jhd19fIC0gbWF0Y2hlZCB0ZXh0XG4gKiAtIF9fdGV4dF9fIC0gbm9ybWFsaXplZCB0ZXh0XG4gKiAtIF9fdXJsX18gLSBsaW5rLCBnZW5lcmF0ZWQgZnJvbSBtYXRjaGVkIHRleHRcbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCh0ZXh0KSB7XG4gIHZhciBzaGlmdCA9IDAsIHJlc3VsdCA9IFtdO1xuXG4gIC8vIFRyeSB0byB0YWtlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSBjYWNoZSwgaWYgLnRlc3QoKSBjYWxsZWQgYmVmb3JlXG4gIGlmICh0aGlzLl9faW5kZXhfXyA+PSAwICYmIHRoaXMuX190ZXh0X2NhY2hlX18gPT09IHRleHQpIHtcbiAgICByZXN1bHQucHVzaChjcmVhdGVNYXRjaCh0aGlzLCBzaGlmdCkpO1xuICAgIHNoaWZ0ID0gdGhpcy5fX2xhc3RfaW5kZXhfXztcbiAgfVxuXG4gIC8vIEN1dCBoZWFkIGlmIGNhY2hlIHdhcyB1c2VkXG4gIHZhciB0YWlsID0gc2hpZnQgPyB0ZXh0LnNsaWNlKHNoaWZ0KSA6IHRleHQ7XG5cbiAgLy8gU2NhbiBzdHJpbmcgdW50aWwgZW5kIHJlYWNoZWRcbiAgd2hpbGUgKHRoaXMudGVzdCh0YWlsKSkge1xuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG5cbiAgICB0YWlsID0gdGFpbC5zbGljZSh0aGlzLl9fbGFzdF9pbmRleF9fKTtcbiAgICBzaGlmdCArPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICB9XG5cbiAgaWYgKHJlc3VsdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCN0bGRzKGxpc3QgWywga2VlcE9sZF0pIC0+IHRoaXNcbiAqIC0gbGlzdCAoQXJyYXkpOiBsaXN0IG9mIHRsZHNcbiAqIC0ga2VlcE9sZCAoQm9vbGVhbik6IG1lcmdlIHdpdGggY3VycmVudCBsaXN0IGlmIGB0cnVlYCAoYGZhbHNlYCBieSBkZWZhdWx0KVxuICpcbiAqIExvYWQgKG9yIG1lcmdlKSBuZXcgdGxkcyBsaXN0LiBUaG9zZSBhcmUgdXNlciBmb3IgZnV6enkgbGlua3MgKHdpdGhvdXQgcHJlZml4KVxuICogdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzLiBCeSBkZWZhdWx0IHRoaXMgYWxnb3J5dGhtIHVzZWQ6XG4gKlxuICogLSBob3N0bmFtZSB3aXRoIGFueSAyLWxldHRlciByb290IHpvbmVzIGFyZSBvay5cbiAqIC0gYml6fGNvbXxlZHV8Z292fG5ldHxvcmd8cHJvfHdlYnx4eHh8YWVyb3xhc2lhfGNvb3B8aW5mb3xtdXNldW18bmFtZXxzaG9wfNGA0YRcbiAqICAgYXJlIG9rLlxuICogLSBlbmNvZGVkIChgeG4tLS4uLmApIHJvb3Qgem9uZXMgYXJlIG9rLlxuICpcbiAqIElmIGxpc3QgaXMgcmVwbGFjZWQsIHRoZW4gZXhhY3QgbWF0Y2ggZm9yIDItY2hhcnMgcm9vdCB6b25lcyB3aWxsIGJlIGNoZWNrZWQuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRsZHMgPSBmdW5jdGlvbiB0bGRzKGxpc3QsIGtlZXBPbGQpIHtcbiAgbGlzdCA9IEFycmF5LmlzQXJyYXkobGlzdCkgPyBsaXN0IDogWyBsaXN0IF07XG5cbiAgaWYgKCFrZWVwT2xkKSB7XG4gICAgdGhpcy5fX3RsZHNfXyA9IGxpc3Quc2xpY2UoKTtcbiAgICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fID0gdHJ1ZTtcbiAgICBjb21waWxlKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdGhpcy5fX3RsZHNfXyA9IHRoaXMuX190bGRzX18uY29uY2F0KGxpc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsLCBpZHgsIGFycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsICE9PSBhcnJbaWR4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmV2ZXJzZSgpO1xuXG4gIGNvbXBpbGUodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBMaW5raWZ5SXQjbm9ybWFsaXplKG1hdGNoKVxuICpcbiAqIERlZmF1bHQgbm9ybWFsaXplciAoaWYgc2NoZW1hIGRvZXMgbm90IGRlZmluZSBpdCdzIG93bikuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShtYXRjaCkge1xuXG4gIC8vIERvIG1pbmltYWwgcG9zc2libGUgY2hhbmdlcyBieSBkZWZhdWx0LiBOZWVkIHRvIGNvbGxlY3QgZmVlZGJhY2sgcHJpb3JcbiAgLy8gdG8gbW92ZSBmb3J3YXJkIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9saW5raWZ5LWl0L2lzc3Vlcy8xXG5cbiAgaWYgKCFtYXRjaC5zY2hlbWEpIHsgbWF0Y2gudXJsID0gJ2h0dHA6Ly8nICsgbWF0Y2gudXJsOyB9XG5cbiAgaWYgKG1hdGNoLnNjaGVtYSA9PT0gJ21haWx0bzonICYmICEvXm1haWx0bzovaS50ZXN0KG1hdGNoLnVybCkpIHtcbiAgICBtYXRjaC51cmwgPSAnbWFpbHRvOicgKyBtYXRjaC51cmw7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjb25Db21waWxlKClcbiAqXG4gKiBPdmVycmlkZSB0byBtb2RpZnkgYmFzaWMgUmVnRXhwLXMuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLm9uQ29tcGlsZSA9IGZ1bmN0aW9uIG9uQ29tcGlsZSgpIHtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBMaW5raWZ5SXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgcmUgPSB7fTtcblxuICAvLyBVc2UgZGlyZWN0IGV4dHJhY3QgaW5zdGVhZCBvZiBgcmVnZW5lcmF0ZWAgdG8gcmVkdXNlIGJyb3dzZXJpZmllZCBzaXplXG4gIHJlLnNyY19BbnkgPSByZXF1aXJlKCd1Yy5taWNyby9wcm9wZXJ0aWVzL0FueS9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX0NjICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvQ2MvcmVnZXgnKS5zb3VyY2U7XG4gIHJlLnNyY19aICAgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL1ovcmVnZXgnKS5zb3VyY2U7XG4gIHJlLnNyY19QICAgPSByZXF1aXJlKCd1Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXgnKS5zb3VyY2U7XG5cbiAgLy8gXFxwe1xcWlxcUFxcQ2NcXENGfSAod2hpdGUgc3BhY2VzICsgY29udHJvbCArIGZvcm1hdCArIHB1bmN0dWF0aW9uKVxuICByZS5zcmNfWlBDYyA9IFsgcmUuc3JjX1osIHJlLnNyY19QLCByZS5zcmNfQ2MgXS5qb2luKCd8Jyk7XG5cbiAgLy8gXFxwe1xcWlxcQ2N9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sKVxuICByZS5zcmNfWkNjID0gWyByZS5zcmNfWiwgcmUuc3JjX0NjIF0uam9pbignfCcpO1xuXG4gIC8vIEV4cGVyaW1lbnRhbC4gTGlzdCBvZiBjaGFycywgY29tcGxldGVseSBwcm9oaWJpdGVkIGluIGxpbmtzXG4gIC8vIGJlY2F1c2UgY2FuIHNlcGFyYXRlIGl0IGZyb20gb3RoZXIgcGFydCBvZiB0ZXh0XG4gIHZhciB0ZXh0X3NlcGFyYXRvcnMgPSAnWz48XFx1ZmY1Y10nO1xuXG4gIC8vIEFsbCBwb3NzaWJsZSB3b3JkIGNoYXJhY3RlcnMgKGV2ZXJ5dGhpbmcgd2l0aG91dCBwdW5jdHVhdGlvbiwgc3BhY2VzICYgY29udHJvbHMpXG4gIC8vIERlZmluZWQgdmlhIHB1bmN0dWF0aW9uICYgc3BhY2VzIHRvIHNhdmUgc3BhY2VcbiAgLy8gU2hvdWxkIGJlIHNvbWV0aGluZyBsaWtlIFxccHtcXExcXE5cXFNcXE19IChcXHcgYnV0IHdpdGhvdXQgYF9gKVxuICByZS5zcmNfcHNldWRvX2xldHRlciAgICAgICA9ICcoPzooPyEnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKScgKyByZS5zcmNfQW55ICsgJyknO1xuICAvLyBUaGUgc2FtZSBhcyBhYm90aGUgYnV0IHdpdGhvdXQgWzAtOV1cbiAgLy8gdmFyIHNyY19wc2V1ZG9fbGV0dGVyX25vbl9kID0gJyg/Oig/IVswLTldfCcgKyBzcmNfWlBDYyArICcpJyArIHNyY19BbnkgKyAnKSc7XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICByZS5zcmNfaXA0ID1cblxuICAgICcoPzooMjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcXFwuKXszfSgyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pJztcblxuICAvLyBQcm9oaWJpdCBhbnkgb2YgXCJAL1tdKClcIiBpbiB1c2VyL3Bhc3MgdG8gYXZvaWQgd3JvbmcgZG9tYWluIGZldGNoLlxuICByZS5zcmNfYXV0aCAgICA9ICcoPzooPzooPyEnICsgcmUuc3JjX1pDYyArICd8W0AvXFxcXFtcXFxcXSgpXSkuKStAKT8nO1xuXG4gIHJlLnNyY19wb3J0ID1cblxuICAgICcoPzo6KD86Nig/OlswLTRdXFxcXGR7M318NSg/OlswLTRdXFxcXGR7Mn18NSg/OlswLTJdXFxcXGR8M1swLTVdKSkpfFsxLTVdP1xcXFxkezEsNH0pKT8nO1xuXG4gIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3IgPVxuXG4gICAgJyg/PSR8JyArIHRleHRfc2VwYXJhdG9ycyArICd8JyArIHJlLnNyY19aUENjICsgJykoPyEtfF98OlxcXFxkfFxcXFwuLXxcXFxcLig/ISR8JyArIHJlLnNyY19aUENjICsgJykpJztcblxuICByZS5zcmNfcGF0aCA9XG5cbiAgICAnKD86JyArXG4gICAgICAnWy8/I10nICtcbiAgICAgICAgJyg/OicgK1xuICAgICAgICAgICcoPyEnICsgcmUuc3JjX1pDYyArICd8JyArIHRleHRfc2VwYXJhdG9ycyArICd8WygpW1xcXFxde30uLFwiXFwnPyFcXFxcLTtdKS58JyArXG4gICAgICAgICAgJ1xcXFxbKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFxcXFxdKS4pKlxcXFxdfCcgK1xuICAgICAgICAgICdcXFxcKCg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbKV0pLikqXFxcXCl8JyArXG4gICAgICAgICAgJ1xcXFx7KD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFt9XSkuKSpcXFxcfXwnICtcbiAgICAgICAgICAnXFxcXFwiKD86KD8hJyArIHJlLnNyY19aQ2MgKyAnfFtcIl0pLikrXFxcXFwifCcgK1xuICAgICAgICAgIFwiXFxcXCcoPzooPyFcIiArIHJlLnNyY19aQ2MgKyBcInxbJ10pLikrXFxcXCd8XCIgK1xuICAgICAgICAgIFwiXFxcXCcoPz1cIiArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJ3xbLV0pLnwnICsgIC8vIGFsbG93IGBJJ21fa2luZ2AgaWYgbm8gcGFpciBmb3VuZFxuICAgICAgICAgICdcXFxcLnsyLH1bYS16QS1aMC05JS8mXXwnICsgLy8gZ29vZ2xlIGhhcyBtYW55IGRvdHMgaW4gXCJnb29nbGUgc2VhcmNoXCIgbGlua3MgKCM2NiwgIzgxKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnaXRodWIgaGFzIC4uLiBpbiBjb21taXQgcmFuZ2UgbGlua3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdHJpY3QgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIGVuZ2xpc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHBlcmNlbnQtZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gcGFydHMgb2YgZmlsZSBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBwYXJhbXMgc2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW50aWwgbW9yZSBleGFtcGxlcyBmb3VuZC5cbiAgICAgICAgICAnXFxcXC4oPyEnICsgcmUuc3JjX1pDYyArICd8Wy5dKS58JyArXG4gICAgICAgICAgKG9wdHMgJiYgb3B0c1snLS0tJ10gP1xuICAgICAgICAgICAgJ1xcXFwtKD8hLS0oPzpbXi1dfCQpKSg/Oi0qKXwnIC8vIGAtLS1gID0+IGxvbmcgZGFzaCwgdGVybWluYXRlXG4gICAgICAgICAgICA6XG4gICAgICAgICAgICAnXFxcXC0rfCdcbiAgICAgICAgICApICtcbiAgICAgICAgICAnLCg/IScgKyByZS5zcmNfWkNjICsgJykufCcgKyAgICAgICAvLyBhbGxvdyBgLCwsYCBpbiBwYXRoc1xuICAgICAgICAgICc7KD8hJyArIHJlLnNyY19aQ2MgKyAnKS58JyArICAgICAgIC8vIGFsbG93IGA7YCBpZiBub3QgZm9sbG93ZWQgYnkgc3BhY2UtbGlrZSBjaGFyXG4gICAgICAgICAgJ1xcXFwhKyg/IScgKyByZS5zcmNfWkNjICsgJ3xbIV0pLnwnICsgIC8vIGFsbG93IGAhISFgIGluIHBhdGhzLCBidXQgbm90IGF0IHRoZSBlbmRcbiAgICAgICAgICAnXFxcXD8oPyEnICsgcmUuc3JjX1pDYyArICd8Wz9dKS4nICtcbiAgICAgICAgJykrJyArXG4gICAgICAnfFxcXFwvJyArXG4gICAgJyk/JztcblxuICAvLyBBbGxvdyBhbnl0aGluZyBpbiBtYXJrZG93biBzcGVjLCBmb3JiaWQgcXVvdGUgKFwiKSBhdCB0aGUgZmlyc3QgcG9zaXRpb25cbiAgLy8gYmVjYXVzZSBlbWFpbHMgZW5jbG9zZWQgaW4gcXVvdGVzIGFyZSBmYXIgbW9yZSBjb21tb25cbiAgcmUuc3JjX2VtYWlsX25hbWUgPVxuXG4gICAgJ1tcXFxcLTs6Jj1cXFxcK1xcXFwkLFxcXFwuYS16QS1aMC05X11bXFxcXC07OiY9XFxcXCtcXFxcJCxcXFxcXCJcXFxcLmEtekEtWjAtOV9dKic7XG5cbiAgcmUuc3JjX3huID1cblxuICAgICd4bi0tW2EtejAtOVxcXFwtXXsxLDU5fSc7XG5cbiAgLy8gTW9yZSB0byByZWFkIGFib3V0IGRvbWFpbiBuYW1lc1xuICAvLyBodHRwOi8vc2VydmVyZmF1bHQuY29tL3F1ZXN0aW9ucy82MzgyNjAvXG5cbiAgcmUuc3JjX2RvbWFpbl9yb290ID1cblxuICAgIC8vIEFsbG93IGxldHRlcnMgJiBkaWdpdHMgKGh0dHA6Ly90ZXN0MSlcbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfeG4gK1xuICAgICAgJ3wnICtcbiAgICAgIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJ3sxLDYzfScgK1xuICAgICcpJztcblxuICByZS5zcmNfZG9tYWluID1cblxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY194biArXG4gICAgICAnfCcgK1xuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpJyArXG4gICAgICAnfCcgK1xuICAgICAgJyg/OicgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcoPzotfCcgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpezAsNjF9JyArIHJlLnNyY19wc2V1ZG9fbGV0dGVyICsgJyknICtcbiAgICAnKSc7XG5cbiAgcmUuc3JjX2hvc3QgPVxuXG4gICAgJyg/OicgK1xuICAgIC8vIERvbid0IG5lZWQgSVAgY2hlY2ssIGJlY2F1c2UgZGlnaXRzIGFyZSBhbHJlYWR5IGFsbG93ZWQgaW4gbm9ybWFsIGRvbWFpbiBuYW1lc1xuICAgIC8vICAgc3JjX2lwNCArXG4gICAgLy8gJ3wnICtcbiAgICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKicgKyByZS5zcmNfZG9tYWluLypfcm9vdCovICsgJyknICtcbiAgICAnKSc7XG5cbiAgcmUudHBsX2hvc3RfZnV6enkgPVxuXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX2lwNCArXG4gICAgJ3wnICtcbiAgICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKyg/OiVUTERTJSkpJyArXG4gICAgJyknO1xuXG4gIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ID1cblxuICAgICcoPzooPzooPzonICsgcmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKyg/OiVUTERTJSkpJztcblxuICByZS5zcmNfaG9zdF9zdHJpY3QgPVxuXG4gICAgcmUuc3JjX2hvc3QgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X2Z1enp5X3N0cmljdCA9XG5cbiAgICByZS50cGxfaG9zdF9mdXp6eSArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUuc3JjX2hvc3RfcG9ydF9zdHJpY3QgPVxuXG4gICAgcmUuc3JjX2hvc3QgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfcG9ydF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3RfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cbiAgcmUudHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3Rfbm9faXBfZnV6enkgKyByZS5zcmNfcG9ydCArIHJlLnNyY19ob3N0X3Rlcm1pbmF0b3I7XG5cblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLyBNYWluIHJ1bGVzXG5cbiAgLy8gUnVkZSB0ZXN0IGZ1enp5IGxpbmtzIGJ5IGhvc3QsIGZvciBxdWljayBkZW55XG4gIHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QgPVxuXG4gICAgJ2xvY2FsaG9zdHx3d3dcXFxcLnxcXFxcLlxcXFxkezEsM31cXFxcLnwoPzpcXFxcLig/OiVUTERTJSkoPzonICsgcmUuc3JjX1pQQ2MgKyAnfD58JCkpJztcblxuICByZS50cGxfZW1haWxfZnV6enkgPVxuXG4gICAgICAnKF58JyArIHRleHRfc2VwYXJhdG9ycyArICd8XCJ8XFxcXCh8JyArIHJlLnNyY19aQ2MgKyAnKScgK1xuICAgICAgJygnICsgcmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgKyAnKSc7XG5cbiAgcmUudHBsX2xpbmtfZnV6enkgPVxuICAgICAgLy8gRnV6enkgbGluayBjYW4ndCBiZSBwcmVwZW5kZWQgd2l0aCAuOi9cXC0gYW5kIG5vbiBwdW5jdHVhdGlvbi5cbiAgICAgIC8vIGJ1dCBjYW4gc3RhcnQgd2l0aCA+IChtYXJrZG93biBibG9ja3F1b3RlKVxuICAgICAgJyhefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSknICtcbiAgICAgICcoKD8hWyQrPD0+XmB8XFx1ZmY1Y10pJyArIHJlLnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ICsgcmUuc3JjX3BhdGggKyAnKSc7XG5cbiAgcmUudHBsX2xpbmtfbm9faXBfZnV6enkgPVxuICAgICAgLy8gRnV6enkgbGluayBjYW4ndCBiZSBwcmVwZW5kZWQgd2l0aCAuOi9cXC0gYW5kIG5vbiBwdW5jdHVhdGlvbi5cbiAgICAgIC8vIGJ1dCBjYW4gc3RhcnQgd2l0aCA+IChtYXJrZG93biBibG9ja3F1b3RlKVxuICAgICAgJyhefCg/IVsuOi9cXFxcLV9AXSkoPzpbJCs8PT5eYHxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSknICtcbiAgICAgICcoKD8hWyQrPD0+XmB8XFx1ZmY1Y10pJyArIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ICsgcmUuc3JjX3BhdGggKyAnKSc7XG5cbiAgcmV0dXJuIHJlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliLycpO1xuIiwiLy8gSFRNTDUgZW50aXRpZXMgbWFwOiB7IG5hbWUgLT4gdXRmMTZzdHJpbmcgfVxuLy9cbid1c2Ugc3RyaWN0JztcblxuLyplc2xpbnQgcXVvdGVzOjAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdlbnRpdGllcy9saWIvbWFwcy9lbnRpdGllcy5qc29uJyk7XG4iLCIvLyBMaXN0IG9mIHZhbGlkIGh0bWwgYmxvY2tzIG5hbWVzLCBhY2NvcnRpbmcgdG8gY29tbW9ubWFyayBzcGVjXG4vLyBodHRwOi8vamdtLmdpdGh1Yi5pby9Db21tb25NYXJrL3NwZWMuaHRtbCNodG1sLWJsb2Nrc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdhZGRyZXNzJyxcbiAgJ2FydGljbGUnLFxuICAnYXNpZGUnLFxuICAnYmFzZScsXG4gICdiYXNlZm9udCcsXG4gICdibG9ja3F1b3RlJyxcbiAgJ2JvZHknLFxuICAnY2FwdGlvbicsXG4gICdjZW50ZXInLFxuICAnY29sJyxcbiAgJ2NvbGdyb3VwJyxcbiAgJ2RkJyxcbiAgJ2RldGFpbHMnLFxuICAnZGlhbG9nJyxcbiAgJ2RpcicsXG4gICdkaXYnLFxuICAnZGwnLFxuICAnZHQnLFxuICAnZmllbGRzZXQnLFxuICAnZmlnY2FwdGlvbicsXG4gICdmaWd1cmUnLFxuICAnZm9vdGVyJyxcbiAgJ2Zvcm0nLFxuICAnZnJhbWUnLFxuICAnZnJhbWVzZXQnLFxuICAnaDEnLFxuICAnaDInLFxuICAnaDMnLFxuICAnaDQnLFxuICAnaDUnLFxuICAnaDYnLFxuICAnaGVhZCcsXG4gICdoZWFkZXInLFxuICAnaHInLFxuICAnaHRtbCcsXG4gICdpZnJhbWUnLFxuICAnbGVnZW5kJyxcbiAgJ2xpJyxcbiAgJ2xpbmsnLFxuICAnbWFpbicsXG4gICdtZW51JyxcbiAgJ21lbnVpdGVtJyxcbiAgJ25hdicsXG4gICdub2ZyYW1lcycsXG4gICdvbCcsXG4gICdvcHRncm91cCcsXG4gICdvcHRpb24nLFxuICAncCcsXG4gICdwYXJhbScsXG4gICdzZWN0aW9uJyxcbiAgJ3NvdXJjZScsXG4gICdzdW1tYXJ5JyxcbiAgJ3RhYmxlJyxcbiAgJ3Rib2R5JyxcbiAgJ3RkJyxcbiAgJ3Rmb290JyxcbiAgJ3RoJyxcbiAgJ3RoZWFkJyxcbiAgJ3RpdGxlJyxcbiAgJ3RyJyxcbiAgJ3RyYWNrJyxcbiAgJ3VsJ1xuXTtcbiIsIi8vIFJlZ2V4cHMgdG8gbWF0Y2ggaHRtbCBlbGVtZW50c1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhdHRyX25hbWUgICAgID0gJ1thLXpBLVpfOl1bYS16QS1aMC05Oi5fLV0qJztcblxudmFyIHVucXVvdGVkICAgICAgPSAnW15cIlxcJz08PmBcXFxceDAwLVxcXFx4MjBdKyc7XG52YXIgc2luZ2xlX3F1b3RlZCA9IFwiJ1teJ10qJ1wiO1xudmFyIGRvdWJsZV9xdW90ZWQgPSAnXCJbXlwiXSpcIic7XG5cbnZhciBhdHRyX3ZhbHVlICA9ICcoPzonICsgdW5xdW90ZWQgKyAnfCcgKyBzaW5nbGVfcXVvdGVkICsgJ3wnICsgZG91YmxlX3F1b3RlZCArICcpJztcblxudmFyIGF0dHJpYnV0ZSAgID0gJyg/OlxcXFxzKycgKyBhdHRyX25hbWUgKyAnKD86XFxcXHMqPVxcXFxzKicgKyBhdHRyX3ZhbHVlICsgJyk/KSc7XG5cbnZhciBvcGVuX3RhZyAgICA9ICc8W0EtWmEtel1bQS1aYS16MC05XFxcXC1dKicgKyBhdHRyaWJ1dGUgKyAnKlxcXFxzKlxcXFwvPz4nO1xuXG52YXIgY2xvc2VfdGFnICAgPSAnPFxcXFwvW0EtWmEtel1bQS1aYS16MC05XFxcXC1dKlxcXFxzKj4nO1xudmFyIGNvbW1lbnQgICAgID0gJzwhLS0tLT58PCEtLSg/Oi0/W14+LV0pKD86LT9bXi1dKSotLT4nO1xudmFyIHByb2Nlc3NpbmcgID0gJzxbP11bXFxcXHNcXFxcU10qP1s/XT4nO1xudmFyIGRlY2xhcmF0aW9uID0gJzwhW0EtWl0rXFxcXHMrW14+XSo+JztcbnZhciBjZGF0YSAgICAgICA9ICc8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nO1xuXG52YXIgSFRNTF9UQUdfUkUgPSBuZXcgUmVnRXhwKCdeKD86JyArIG9wZW5fdGFnICsgJ3wnICsgY2xvc2VfdGFnICsgJ3wnICsgY29tbWVudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBwcm9jZXNzaW5nICsgJ3wnICsgZGVjbGFyYXRpb24gKyAnfCcgKyBjZGF0YSArICcpJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnKScpO1xuXG5tb2R1bGUuZXhwb3J0cy5IVE1MX1RBR19SRSA9IEhUTUxfVEFHX1JFO1xubW9kdWxlLmV4cG9ydHMuSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IEhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG4iLCIvLyBVdGlsaXRpZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cblxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG4vLyBNZXJnZSBvYmplY3RzXG4vL1xuZnVuY3Rpb24gYXNzaWduKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG9iamVjdCcpO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vLyBSZW1vdmUgZWxlbWVudCBmcm9tIGFycmF5IGFuZCBwdXQgYW5vdGhlciBhcnJheSBhdCB0aG9zZSBwb3NpdGlvbi5cbi8vIFVzZWZ1bCBmb3Igc29tZSBvcGVyYXRpb25zIHdpdGggdG9rZW5zXG5mdW5jdGlvbiBhcnJheVJlcGxhY2VBdChzcmMsIHBvcywgbmV3RWxlbWVudHMpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChzcmMuc2xpY2UoMCwgcG9zKSwgbmV3RWxlbWVudHMsIHNyYy5zbGljZShwb3MgKyAxKSk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbnRpdHlDb2RlKGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgLy8gYnJva2VuIHNlcXVlbmNlXG4gIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gbmV2ZXIgdXNlZFxuICBpZiAoYyA+PSAweEZERDAgJiYgYyA8PSAweEZERUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmICgoYyAmIDB4RkZGRikgPT09IDB4RkZGRiB8fCAoYyAmIDB4RkZGRikgPT09IDB4RkZGRSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gY29udHJvbCBjb2Rlc1xuICBpZiAoYyA+PSAweDAwICYmIGMgPD0gMHgwOCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPT09IDB4MEIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4MEUgJiYgYyA8PSAweDFGKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA+PSAweDdGICYmIGMgPD0gMHg5RikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gb3V0IG9mIHJhbmdlXG4gIGlmIChjID4gMHgxMEZGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgaWYgKGMgPiAweGZmZmYpIHtcbiAgICBjIC09IDB4MTAwMDA7XG4gICAgdmFyIHN1cnJvZ2F0ZTEgPSAweGQ4MDAgKyAoYyA+PiAxMCksXG4gICAgICAgIHN1cnJvZ2F0ZTIgPSAweGRjMDAgKyAoYyAmIDB4M2ZmKTtcblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHN1cnJvZ2F0ZTEsIHN1cnJvZ2F0ZTIpO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xufVxuXG5cbnZhciBVTkVTQ0FQRV9NRF9SRSAgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS5cXC86Ozw9Pj9AW1xcXFxcXF1eX2B7fH1+XSkvZztcbnZhciBFTlRJVFlfUkUgICAgICAgPSAvJihbYS16I11bYS16MC05XXsxLDMxfSk7L2dpO1xudmFyIFVORVNDQVBFX0FMTF9SRSA9IG5ldyBSZWdFeHAoVU5FU0NBUEVfTURfUkUuc291cmNlICsgJ3wnICsgRU5USVRZX1JFLnNvdXJjZSwgJ2dpJyk7XG5cbnZhciBESUdJVEFMX0VOVElUWV9URVNUX1JFID0gL14jKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKS9pO1xuXG52YXIgZW50aXRpZXMgPSByZXF1aXJlKCcuL2VudGl0aWVzJyk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBuYW1lKSB7XG4gIHZhciBjb2RlID0gMDtcblxuICBpZiAoaGFzKGVudGl0aWVzLCBuYW1lKSkge1xuICAgIHJldHVybiBlbnRpdGllc1tuYW1lXTtcbiAgfVxuXG4gIGlmIChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDB4MjMvKiAjICovICYmIERJR0lUQUxfRU5USVRZX1RFU1RfUkUudGVzdChuYW1lKSkge1xuICAgIGNvZGUgPSBuYW1lWzFdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDIpLCAxNikgOiBwYXJzZUludChuYW1lLnNsaWNlKDEpLCAxMCk7XG5cbiAgICBpZiAoaXNWYWxpZEVudGl0eUNvZGUoY29kZSkpIHtcbiAgICAgIHJldHVybiBmcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuLypmdW5jdGlvbiByZXBsYWNlRW50aXRpZXMoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignJicpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKEVOVElUWV9SRSwgcmVwbGFjZUVudGl0eVBhdHRlcm4pO1xufSovXG5cbmZ1bmN0aW9uIHVuZXNjYXBlTWQoc3RyKSB7XG4gIGlmIChzdHIuaW5kZXhPZignXFxcXCcpIDwgMCkgeyByZXR1cm4gc3RyOyB9XG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9NRF9SRSwgJyQxJyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlQWxsKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDAgJiYgc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShVTkVTQ0FQRV9BTExfUkUsIGZ1bmN0aW9uIChtYXRjaCwgZXNjYXBlZCwgZW50aXR5KSB7XG4gICAgaWYgKGVzY2FwZWQpIHsgcmV0dXJuIGVzY2FwZWQ7IH1cbiAgICByZXR1cm4gcmVwbGFjZUVudGl0eVBhdHRlcm4obWF0Y2gsIGVudGl0eSk7XG4gIH0pO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgSFRNTF9FU0NBUEVfVEVTVF9SRSA9IC9bJjw+XCJdLztcbnZhciBIVE1MX0VTQ0FQRV9SRVBMQUNFX1JFID0gL1smPD5cIl0vZztcbnZhciBIVE1MX1JFUExBQ0VNRU5UUyA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnXG59O1xuXG5mdW5jdGlvbiByZXBsYWNlVW5zYWZlQ2hhcihjaCkge1xuICByZXR1cm4gSFRNTF9SRVBMQUNFTUVOVFNbY2hdO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cikge1xuICBpZiAoSFRNTF9FU0NBUEVfVEVTVF9SRS50ZXN0KHN0cikpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSwgcmVwbGFjZVVuc2FmZUNoYXIpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBSRUdFWFBfRVNDQVBFX1JFID0gL1suPyorXiRbXFxdXFxcXCgpe318LV0vZztcblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShSRUdFWFBfRVNDQVBFX1JFLCAnXFxcXCQmJyk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzU3BhY2UoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6XG4gICAgY2FzZSAweDIwOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBacyAodW5pY29kZSBjbGFzcykgfHwgW1xcdFxcZlxcdlxcclxcbl1cbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjb2RlKSB7XG4gIGlmIChjb2RlID49IDB4MjAwMCAmJiBjb2RlIDw9IDB4MjAwQSkgeyByZXR1cm4gdHJ1ZTsgfVxuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDk6IC8vIFxcdFxuICAgIGNhc2UgMHgwQTogLy8gXFxuXG4gICAgY2FzZSAweDBCOiAvLyBcXHZcbiAgICBjYXNlIDB4MEM6IC8vIFxcZlxuICAgIGNhc2UgMHgwRDogLy8gXFxyXG4gICAgY2FzZSAweDIwOlxuICAgIGNhc2UgMHhBMDpcbiAgICBjYXNlIDB4MTY4MDpcbiAgICBjYXNlIDB4MjAyRjpcbiAgICBjYXNlIDB4MjA1RjpcbiAgICBjYXNlIDB4MzAwMDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtbGVuKi9cbnZhciBVTklDT0RFX1BVTkNUX1JFID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9QL3JlZ2V4Jyk7XG5cbi8vIEN1cnJlbnRseSB3aXRob3V0IGFzdHJhbCBjaGFyYWN0ZXJzIHN1cHBvcnQuXG5mdW5jdGlvbiBpc1B1bmN0Q2hhcihjaCkge1xuICByZXR1cm4gVU5JQ09ERV9QVU5DVF9SRS50ZXN0KGNoKTtcbn1cblxuXG4vLyBNYXJrZG93biBBU0NJSSBwdW5jdHVhdGlvbiBjaGFyYWN0ZXJzLlxuLy9cbi8vICEsIFwiLCAjLCAkLCAlLCAmLCAnLCAoLCApLCAqLCArLCAsLCAtLCAuLCAvLCA6LCA7LCA8LCA9LCA+LCA/LCBALCBbLCBcXCwgXSwgXiwgXywgYCwgeywgfCwgfSwgb3IgflxuLy8gaHR0cDovL3NwZWMuY29tbW9ubWFyay5vcmcvMC4xNS8jYXNjaWktcHVuY3R1YXRpb24tY2hhcmFjdGVyXG4vL1xuLy8gRG9uJ3QgY29uZnVzZSB3aXRoIHVuaWNvZGUgcHVuY3R1YXRpb24gISEhIEl0IGxhY2tzIHNvbWUgY2hhcnMgaW4gYXNjaWkgcmFuZ2UuXG4vL1xuZnVuY3Rpb24gaXNNZEFzY2lpUHVuY3QoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgyMS8qICEgKi86XG4gICAgY2FzZSAweDIyLyogXCIgKi86XG4gICAgY2FzZSAweDIzLyogIyAqLzpcbiAgICBjYXNlIDB4MjQvKiAkICovOlxuICAgIGNhc2UgMHgyNS8qICUgKi86XG4gICAgY2FzZSAweDI2LyogJiAqLzpcbiAgICBjYXNlIDB4MjcvKiAnICovOlxuICAgIGNhc2UgMHgyOC8qICggKi86XG4gICAgY2FzZSAweDI5LyogKSAqLzpcbiAgICBjYXNlIDB4MkEvKiAqICovOlxuICAgIGNhc2UgMHgyQi8qICsgKi86XG4gICAgY2FzZSAweDJDLyogLCAqLzpcbiAgICBjYXNlIDB4MkQvKiAtICovOlxuICAgIGNhc2UgMHgyRS8qIC4gKi86XG4gICAgY2FzZSAweDJGLyogLyAqLzpcbiAgICBjYXNlIDB4M0EvKiA6ICovOlxuICAgIGNhc2UgMHgzQi8qIDsgKi86XG4gICAgY2FzZSAweDNDLyogPCAqLzpcbiAgICBjYXNlIDB4M0QvKiA9ICovOlxuICAgIGNhc2UgMHgzRS8qID4gKi86XG4gICAgY2FzZSAweDNGLyogPyAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3Qy8qIHwgKi86XG4gICAgY2FzZSAweDdELyogfSAqLzpcbiAgICBjYXNlIDB4N0UvKiB+ICovOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBIZXBsZXIgdG8gdW5pZnkgW3JlZmVyZW5jZSBsYWJlbHNdLlxuLy9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIpIHtcbiAgLy8gVHJpbSBhbmQgY29sbGFwc2Ugd2hpdGVzcGFjZVxuICAvL1xuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcblxuICAvLyBJbiBub2RlIHYxMCAn4bqeJy50b0xvd2VyQ2FzZSgpID09PSAn4bm+Jywgd2hpY2ggaXMgcHJlc3VtZWQgdG8gYmUgYSBidWdcbiAgLy8gZml4ZWQgaW4gdjEyIChjb3VsZG4ndCBmaW5kIGFueSBkZXRhaWxzKS5cbiAgLy9cbiAgLy8gU28gdHJlYXQgdGhpcyBvbmUgYXMgYSBzcGVjaWFsIGNhc2VcbiAgLy8gKHJlbW92ZSB0aGlzIHdoZW4gbm9kZSB2MTAgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCkuXG4gIC8vXG4gIGlmICgn4bqeJy50b0xvd2VyQ2FzZSgpID09PSAn4bm+Jykge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC/hup4vZywgJ8OfJyk7XG4gIH1cblxuICAvLyAudG9Mb3dlckNhc2UoKS50b1VwcGVyQ2FzZSgpIHNob3VsZCBnZXQgcmlkIG9mIGFsbCBkaWZmZXJlbmNlc1xuICAvLyBiZXR3ZWVuIGxldHRlciB2YXJpYW50cy5cbiAgLy9cbiAgLy8gU2ltcGxlIC50b0xvd2VyQ2FzZSgpIGRvZXNuJ3Qgbm9ybWFsaXplIDEyNSBjb2RlIHBvaW50cyBjb3JyZWN0bHksXG4gIC8vIGFuZCAudG9VcHBlckNhc2UgZG9lc24ndCBub3JtYWxpemUgNiBvZiB0aGVtIChsaXN0IG9mIGV4Y2VwdGlvbnM6XG4gIC8vIMSwLCDPtCwg4bqeLCDihKYsIOKEqiwg4oSrIC0gdGhvc2UgYXJlIGFscmVhZHkgdXBwZXJjYXNlZCwgYnV0IGhhdmUgZGlmZmVyZW50bHlcbiAgLy8gdXBwZXJjYXNlZCB2ZXJzaW9ucykuXG4gIC8vXG4gIC8vIEhlcmUncyBhbiBleGFtcGxlIHNob3dpbmcgaG93IGl0IGhhcHBlbnMuIExldHMgdGFrZSBncmVlayBsZXR0ZXIgb21lZ2E6XG4gIC8vIHVwcGVyY2FzZSBVKzAzOTggKM6YKSwgVSswM2Y0ICjPtCkgYW5kIGxvd2VyY2FzZSBVKzAzYjggKM64KSwgVSswM2QxICjPkSlcbiAgLy9cbiAgLy8gVW5pY29kZSBlbnRyaWVzOlxuICAvLyAwMzk4O0dSRUVLIENBUElUQUwgTEVUVEVSIFRIRVRBO0x1OzA7TDs7Ozs7Tjs7OzswM0I4O1xuICAvLyAwM0I4O0dSRUVLIFNNQUxMIExFVFRFUiBUSEVUQTtMbDswO0w7Ozs7O047OzswMzk4OzswMzk4XG4gIC8vIDAzRDE7R1JFRUsgVEhFVEEgU1lNQk9MO0xsOzA7TDs8Y29tcGF0PiAwM0I4Ozs7O047R1JFRUsgU01BTEwgTEVUVEVSIFNDUklQVCBUSEVUQTs7MDM5ODs7MDM5OFxuICAvLyAwM0Y0O0dSRUVLIENBUElUQUwgVEhFVEEgU1lNQk9MO0x1OzA7TDs8Y29tcGF0PiAwMzk4Ozs7O047Ozs7MDNCODtcbiAgLy9cbiAgLy8gQ2FzZS1pbnNlbnNpdGl2ZSBjb21wYXJpc29uIHNob3VsZCB0cmVhdCBhbGwgb2YgdGhlbSBhcyBlcXVpdmFsZW50LlxuICAvL1xuICAvLyBCdXQgLnRvTG93ZXJDYXNlKCkgZG9lc24ndCBjaGFuZ2Ugz5EgKGl0J3MgYWxyZWFkeSBsb3dlcmNhc2UpLFxuICAvLyBhbmQgLnRvVXBwZXJDYXNlKCkgZG9lc24ndCBjaGFuZ2Ugz7QgKGFscmVhZHkgdXBwZXJjYXNlKS5cbiAgLy9cbiAgLy8gQXBwbHlpbmcgZmlyc3QgbG93ZXIgdGhlbiB1cHBlciBjYXNlIG5vcm1hbGl6ZXMgYW55IGNoYXJhY3RlcjpcbiAgLy8gJ1xcdTAzOThcXHUwM2Y0XFx1MDNiOFxcdTAzZDEnLnRvTG93ZXJDYXNlKCkudG9VcHBlckNhc2UoKSA9PT0gJ1xcdTAzOThcXHUwMzk4XFx1MDM5OFxcdTAzOTgnXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgaXMgZXF1aXZhbGVudCB0byB1bmljb2RlIGNhc2UgZm9sZGluZzsgdW5pY29kZSBub3JtYWxpemF0aW9uXG4gIC8vIGlzIGEgZGlmZmVyZW50IHN0ZXAgdGhhdCBpcyBub3QgcmVxdWlyZWQgaGVyZS5cbiAgLy9cbiAgLy8gRmluYWwgcmVzdWx0IHNob3VsZCBiZSB1cHBlcmNhc2VkLCBiZWNhdXNlIGl0J3MgbGF0ZXIgc3RvcmVkIGluIGFuIG9iamVjdFxuICAvLyAodGhpcyBhdm9pZCBhIGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBtZW1iZXJzLFxuICAvLyBtb3N0IG5vdGFibHksIGBfX3Byb3RvX19gKVxuICAvL1xuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkudG9VcHBlckNhc2UoKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUmUtZXhwb3J0IGxpYnJhcmllcyBjb21tb25seSB1c2VkIGluIGJvdGggbWFya2Rvd24taXQgYW5kIGl0cyBwbHVnaW5zLFxuLy8gc28gcGx1Z2lucyB3b24ndCBoYXZlIHRvIGRlcGVuZCBvbiB0aGVtIGV4cGxpY2l0bHksIHdoaWNoIHJlZHVjZXMgdGhlaXJcbi8vIGJ1bmRsZWQgc2l6ZSAoZS5nLiBhIGJyb3dzZXIgYnVpbGQpLlxuLy9cbmV4cG9ydHMubGliICAgICAgICAgICAgICAgICA9IHt9O1xuZXhwb3J0cy5saWIubWR1cmwgICAgICAgICAgID0gcmVxdWlyZSgnbWR1cmwnKTtcbmV4cG9ydHMubGliLnVjbWljcm8gICAgICAgICA9IHJlcXVpcmUoJ3VjLm1pY3JvJyk7XG5cbmV4cG9ydHMuYXNzaWduICAgICAgICAgICAgICA9IGFzc2lnbjtcbmV4cG9ydHMuaXNTdHJpbmcgICAgICAgICAgICA9IGlzU3RyaW5nO1xuZXhwb3J0cy5oYXMgICAgICAgICAgICAgICAgID0gaGFzO1xuZXhwb3J0cy51bmVzY2FwZU1kICAgICAgICAgID0gdW5lc2NhcGVNZDtcbmV4cG9ydHMudW5lc2NhcGVBbGwgICAgICAgICA9IHVuZXNjYXBlQWxsO1xuZXhwb3J0cy5pc1ZhbGlkRW50aXR5Q29kZSAgID0gaXNWYWxpZEVudGl0eUNvZGU7XG5leHBvcnRzLmZyb21Db2RlUG9pbnQgICAgICAgPSBmcm9tQ29kZVBvaW50O1xuLy8gZXhwb3J0cy5yZXBsYWNlRW50aXRpZXMgICAgID0gcmVwbGFjZUVudGl0aWVzO1xuZXhwb3J0cy5lc2NhcGVIdG1sICAgICAgICAgID0gZXNjYXBlSHRtbDtcbmV4cG9ydHMuYXJyYXlSZXBsYWNlQXQgICAgICA9IGFycmF5UmVwbGFjZUF0O1xuZXhwb3J0cy5pc1NwYWNlICAgICAgICAgICAgID0gaXNTcGFjZTtcbmV4cG9ydHMuaXNXaGl0ZVNwYWNlICAgICAgICA9IGlzV2hpdGVTcGFjZTtcbmV4cG9ydHMuaXNNZEFzY2lpUHVuY3QgICAgICA9IGlzTWRBc2NpaVB1bmN0O1xuZXhwb3J0cy5pc1B1bmN0Q2hhciAgICAgICAgID0gaXNQdW5jdENoYXI7XG5leHBvcnRzLmVzY2FwZVJFICAgICAgICAgICAgPSBlc2NhcGVSRTtcbmV4cG9ydHMubm9ybWFsaXplUmVmZXJlbmNlICA9IG5vcm1hbGl6ZVJlZmVyZW5jZTtcbiIsIi8vIEp1c3QgYSBzaG9ydGN1dCBmb3IgYnVsayBleHBvcnRcbid1c2Ugc3RyaWN0JztcblxuXG5leHBvcnRzLnBhcnNlTGlua0xhYmVsICAgICAgID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX2xhYmVsJyk7XG5leHBvcnRzLnBhcnNlTGlua0Rlc3RpbmF0aW9uID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX2Rlc3RpbmF0aW9uJyk7XG5leHBvcnRzLnBhcnNlTGlua1RpdGxlICAgICAgID0gcmVxdWlyZSgnLi9wYXJzZV9saW5rX3RpdGxlJyk7XG4iLCIvLyBQYXJzZSBsaW5rIGRlc3RpbmF0aW9uXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1bmVzY2FwZUFsbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rRGVzdGluYXRpb24oc3RyLCBwb3MsIG1heCkge1xuICB2YXIgY29kZSwgbGV2ZWwsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBzdGFydCA9IHBvcyxcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBwb3M6IDAsXG4gICAgICAgIGxpbmVzOiAwLFxuICAgICAgICBzdHI6ICcnXG4gICAgICB9O1xuXG4gIGlmIChzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDNDIC8qIDwgKi8pIHtcbiAgICBwb3MrKztcbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmIChjb2RlID09PSAweDBBIC8qIFxcbiAqLykgeyByZXR1cm4gcmVzdWx0OyB9XG4gICAgICBpZiAoY29kZSA9PT0gMHgzQyAvKiA8ICovKSB7IHJldHVybiByZXN1bHQ7IH1cbiAgICAgIGlmIChjb2RlID09PSAweDNFIC8qID4gKi8pIHtcbiAgICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XG4gICAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcbiAgICAgICAgcmVzdWx0Lm9rID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgICAgcG9zICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICAvLyBubyBjbG9zaW5nICc+J1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyB0aGlzIHNob3VsZCBiZSAuLi4gfSBlbHNlIHsgLi4uIGJyYW5jaFxuXG4gIGxldmVsID0gMDtcbiAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNvZGUgPT09IDB4MjApIHsgYnJlYWs7IH1cblxuICAgIC8vIGFzY2lpIGNvbnRyb2wgY2hhcmFjdGVyc1xuICAgIGlmIChjb2RlIDwgMHgyMCB8fCBjb2RlID09PSAweDdGKSB7IGJyZWFrOyB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHg1QyAvKiBcXCAqLyAmJiBwb3MgKyAxIDwgbWF4KSB7XG4gICAgICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDB4MjApIHsgYnJlYWs7IH1cbiAgICAgIHBvcyArPSAyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MjggLyogKCAqLykge1xuICAgICAgbGV2ZWwrKztcbiAgICAgIGlmIChsZXZlbCA+IDMyKSB7IHJldHVybiByZXN1bHQ7IH1cbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOSAvKiApICovKSB7XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHsgYnJlYWs7IH1cbiAgICAgIGxldmVsLS07XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHBvcykgeyByZXR1cm4gcmVzdWx0OyB9XG4gIGlmIChsZXZlbCAhPT0gMCkgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCwgcG9zKSk7XG4gIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICByZXN1bHQucG9zID0gcG9zO1xuICByZXN1bHQub2sgPSB0cnVlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIFBhcnNlIGxpbmsgbGFiZWxcbi8vXG4vLyB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBmaXJzdCBjaGFyYWN0ZXIgKFwiW1wiKSBhbHJlYWR5IG1hdGNoZXM7XG4vLyByZXR1cm5zIHRoZSBlbmQgb2YgdGhlIGxhYmVsXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGFydCwgZGlzYWJsZU5lc3RlZCkge1xuICB2YXIgbGV2ZWwsIGZvdW5kLCBtYXJrZXIsIHByZXZQb3MsXG4gICAgICBsYWJlbEVuZCA9IC0xLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zO1xuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMTtcbiAgbGV2ZWwgPSAxO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBtYXgpIHtcbiAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpO1xuICAgIGlmIChtYXJrZXIgPT09IDB4NUQgLyogXSAqLykge1xuICAgICAgbGV2ZWwtLTtcbiAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZQb3MgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubWQuaW5saW5lLnNraXBUb2tlbihzdGF0ZSk7XG4gICAgaWYgKG1hcmtlciA9PT0gMHg1QiAvKiBbICovKSB7XG4gICAgICBpZiAocHJldlBvcyA9PT0gc3RhdGUucG9zIC0gMSkge1xuICAgICAgICAvLyBpbmNyZWFzZSBsZXZlbCBpZiB3ZSBmaW5kIHRleHQgYFtgLCB3aGljaCBpcyBub3QgYSBwYXJ0IG9mIGFueSB0b2tlblxuICAgICAgICBsZXZlbCsrO1xuICAgICAgfSBlbHNlIGlmIChkaXNhYmxlTmVzdGVkKSB7XG4gICAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmb3VuZCkge1xuICAgIGxhYmVsRW5kID0gc3RhdGUucG9zO1xuICB9XG5cbiAgLy8gcmVzdG9yZSBvbGQgc3RhdGVcbiAgc3RhdGUucG9zID0gb2xkUG9zO1xuXG4gIHJldHVybiBsYWJlbEVuZDtcbn07XG4iLCIvLyBQYXJzZSBsaW5rIHRpdGxlXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1bmVzY2FwZUFsbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rVGl0bGUoc3RyLCBwb3MsIG1heCkge1xuICB2YXIgY29kZSxcbiAgICAgIG1hcmtlcixcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHN0YXJ0ID0gcG9zLFxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgbGluZXM6IDAsXG4gICAgICAgIHN0cjogJydcbiAgICAgIH07XG5cbiAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gIG1hcmtlciA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHgyMiAvKiBcIiAqLyAmJiBtYXJrZXIgIT09IDB4MjcgLyogJyAqLyAmJiBtYXJrZXIgIT09IDB4MjggLyogKCAqLykgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcG9zKys7XG5cbiAgLy8gaWYgb3BlbmluZyBtYXJrZXIgaXMgXCIoXCIsIHN3aXRjaCBpdCB0byBjbG9zaW5nIG1hcmtlciBcIilcIlxuICBpZiAobWFya2VyID09PSAweDI4KSB7IG1hcmtlciA9IDB4Mjk7IH1cblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XG4gICAgICByZXN1bHQubGluZXMgPSBsaW5lcztcbiAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcbiAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyOCAvKiAoICovICYmIG1hcmtlciA9PT0gMHgyOSAvKiApICovKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgcG9zKys7XG4gICAgICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xuICAgICAgICBsaW5lcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBNYWluIHBhcnNlciBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJyk7XG52YXIgaGVscGVycyAgICAgID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG52YXIgUmVuZGVyZXIgICAgID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xudmFyIFBhcnNlckNvcmUgICA9IHJlcXVpcmUoJy4vcGFyc2VyX2NvcmUnKTtcbnZhciBQYXJzZXJCbG9jayAgPSByZXF1aXJlKCcuL3BhcnNlcl9ibG9jaycpO1xudmFyIFBhcnNlcklubGluZSA9IHJlcXVpcmUoJy4vcGFyc2VyX2lubGluZScpO1xudmFyIExpbmtpZnlJdCAgICA9IHJlcXVpcmUoJ2xpbmtpZnktaXQnKTtcbnZhciBtZHVybCAgICAgICAgPSByZXF1aXJlKCdtZHVybCcpO1xudmFyIHB1bnljb2RlICAgICA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cblxudmFyIGNvbmZpZyA9IHtcbiAgZGVmYXVsdDogcmVxdWlyZSgnLi9wcmVzZXRzL2RlZmF1bHQnKSxcbiAgemVybzogcmVxdWlyZSgnLi9wcmVzZXRzL3plcm8nKSxcbiAgY29tbW9ubWFyazogcmVxdWlyZSgnLi9wcmVzZXRzL2NvbW1vbm1hcmsnKVxufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vXG4vLyBUaGlzIHZhbGlkYXRvciBjYW4gcHJvaGliaXQgbW9yZSB0aGFuIHJlYWxseSBuZWVkZWQgdG8gcHJldmVudCBYU1MuIEl0J3MgYVxuLy8gdHJhZGVvZmYgdG8ga2VlcCBjb2RlIHNpbXBsZSBhbmQgdG8gYmUgc2VjdXJlIGJ5IGRlZmF1bHQuXG4vL1xuLy8gSWYgeW91IG5lZWQgZGlmZmVyZW50IHNldHVwIC0gb3ZlcnJpZGUgdmFsaWRhdG9yIG1ldGhvZCBhcyB5b3Ugd2lzaC4gT3Jcbi8vIHJlcGxhY2UgaXQgd2l0aCBkdW1teSBmdW5jdGlvbiBhbmQgdXNlIGV4dGVybmFsIHNhbml0aXplci5cbi8vXG5cbnZhciBCQURfUFJPVE9fUkUgPSAvXih2YnNjcmlwdHxqYXZhc2NyaXB0fGZpbGV8ZGF0YSk6LztcbnZhciBHT09EX0RBVEFfUkUgPSAvXmRhdGE6aW1hZ2VcXC8oZ2lmfHBuZ3xqcGVnfHdlYnApOy87XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGluayh1cmwpIHtcbiAgLy8gdXJsIHNob3VsZCBiZSBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnQsIGFuZCBleGlzdGluZyBlbnRpdGllcyBhcmUgZGVjb2RlZFxuICB2YXIgc3RyID0gdXJsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBCQURfUFJPVE9fUkUudGVzdChzdHIpID8gKEdPT0RfREFUQV9SRS50ZXN0KHN0cikgPyB0cnVlIDogZmFsc2UpIDogdHJ1ZTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG52YXIgUkVDT0RFX0hPU1ROQU1FX0ZPUiA9IFsgJ2h0dHA6JywgJ2h0dHBzOicsICdtYWlsdG86JyBdO1xuXG5mdW5jdGlvbiBub3JtYWxpemVMaW5rKHVybCkge1xuICB2YXIgcGFyc2VkID0gbWR1cmwucGFyc2UodXJsLCB0cnVlKTtcblxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgLy8gRW5jb2RlIGhvc3RuYW1lcyBpbiB1cmxzIGxpa2U6XG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IGVuY29kZSB1bmtub3duIHNjaGVtYXMsIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSBlbmNvZGVcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcbiAgICAvL1xuICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkocGFyc2VkLmhvc3RuYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7IC8qKi8gfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZHVybC5lbmNvZGUobWR1cmwuZm9ybWF0KHBhcnNlZCkpO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVMaW5rVGV4dCh1cmwpIHtcbiAgdmFyIHBhcnNlZCA9IG1kdXJsLnBhcnNlKHVybCwgdHJ1ZSk7XG5cbiAgaWYgKHBhcnNlZC5ob3N0bmFtZSkge1xuICAgIC8vIEVuY29kZSBob3N0bmFtZXMgaW4gdXJscyBsaWtlOlxuICAgIC8vIGBodHRwOi8vaG9zdC9gLCBgaHR0cHM6Ly9ob3N0L2AsIGBtYWlsdG86dXNlckBob3N0YCwgYC8vaG9zdC9gXG4gICAgLy9cbiAgICAvLyBXZSBkb24ndCBlbmNvZGUgdW5rbm93biBzY2hlbWFzLCBiZWNhdXNlIGl0J3MgbGlrZWx5IHRoYXQgd2UgZW5jb2RlXG4gICAgLy8gc29tZXRoaW5nIHdlIHNob3VsZG4ndCAoZS5nLiBgc2t5cGU6bmFtZWAgdHJlYXRlZCBhcyBgc2t5cGU6aG9zdGApXG4gICAgLy9cbiAgICBpZiAoIXBhcnNlZC5wcm90b2NvbCB8fCBSRUNPREVfSE9TVE5BTUVfRk9SLmluZGV4T2YocGFyc2VkLnByb3RvY29sKSA+PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZWQuaG9zdG5hbWUgPSBwdW55Y29kZS50b1VuaWNvZGUocGFyc2VkLmhvc3RuYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7IC8qKi8gfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCAnJScgdG8gZXhjbHVkZSBsaXN0IGJlY2F1c2Ugb2YgaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2lzc3Vlcy83MjBcbiAgcmV0dXJuIG1kdXJsLmRlY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSwgbWR1cmwuZGVjb2RlLmRlZmF1bHRDaGFycyArICclJyk7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBNYXJrZG93bkl0XG4gKlxuICogTWFpbiBwYXJzZXIvcmVuZGVyZXIgY2xhc3MuXG4gKlxuICogIyMjIyMgVXNhZ2VcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBub2RlLmpzLCBcImNsYXNzaWNcIiB3YXk6XG4gKiB2YXIgTWFya2Rvd25JdCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JyksXG4gKiAgICAgbWQgPSBuZXcgTWFya2Rvd25JdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gbm9kZS5qcywgdGhlIHNhbWUsIGJ1dCB3aXRoIHN1Z2FyOlxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gYnJvd3NlciB3aXRob3V0IEFNRCwgYWRkZWQgdG8gXCJ3aW5kb3dcIiBvbiBzY3JpcHQgbG9hZFxuICogLy8gTm90ZSwgdGhlcmUgYXJlIG5vIGRhc2guXG4gKiB2YXIgbWQgPSB3aW5kb3cubWFya2Rvd25pdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKiBgYGBcbiAqXG4gKiBTaW5nbGUgbGluZSByZW5kZXJpbmcsIHdpdGhvdXQgcGFyYWdyYXBoIHdyYXA6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcklubGluZSgnX19tYXJrZG93bi1pdF9fIHJ1bGV6eiEnKTtcbiAqIGBgYFxuICoqL1xuXG4vKipcbiAqIG5ldyBNYXJrZG93bkl0KFtwcmVzZXROYW1lLCBvcHRpb25zXSlcbiAqIC0gcHJlc2V0TmFtZSAoU3RyaW5nKTogb3B0aW9uYWwsIGBjb21tb25tYXJrYCAvIGB6ZXJvYFxuICogLSBvcHRpb25zIChPYmplY3QpXG4gKlxuICogQ3JlYXRlcyBwYXJzZXIgaW5zdGFuc2Ugd2l0aCBnaXZlbiBjb25maWcuIENhbiBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YC5cbiAqXG4gKiAjIyMjIyBwcmVzZXROYW1lXG4gKlxuICogTWFya2Rvd25JdCBwcm92aWRlcyBuYW1lZCBwcmVzZXRzIGFzIGEgY29udmVuaWVuY2UgdG8gcXVpY2tseVxuICogZW5hYmxlL2Rpc2FibGUgYWN0aXZlIHN5bnRheCBydWxlcyBhbmQgb3B0aW9ucyBmb3IgY29tbW9uIHVzZSBjYXNlcy5cbiAqXG4gKiAtIFtcImNvbW1vbm1hcmtcIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMpIC1cbiAqICAgY29uZmlndXJlcyBwYXJzZXIgdG8gc3RyaWN0IFtDb21tb25NYXJrXShodHRwOi8vY29tbW9ubWFyay5vcmcvKSBtb2RlLlxuICogLSBbZGVmYXVsdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2RlZmF1bHQuanMpIC1cbiAqICAgc2ltaWxhciB0byBHRk0sIHVzZWQgd2hlbiBubyBwcmVzZXQgbmFtZSBnaXZlbi4gRW5hYmxlcyBhbGwgYXZhaWxhYmxlIHJ1bGVzLFxuICogICBidXQgc3RpbGwgd2l0aG91dCBodG1sLCB0eXBvZ3JhcGhlciAmIGF1dG9saW5rZXIuXG4gKiAtIFtcInplcm9cIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL3plcm8uanMpIC1cbiAqICAgYWxsIHJ1bGVzIGRpc2FibGVkLiBVc2VmdWwgdG8gcXVpY2tseSBzZXR1cCB5b3VyIGNvbmZpZyB2aWEgYC5lbmFibGUoKWAuXG4gKiAgIEZvciBleGFtcGxlLCB3aGVuIHlvdSBuZWVkIG9ubHkgYGJvbGRgIGFuZCBgaXRhbGljYCBtYXJrdXAgYW5kIG5vdGhpbmcgZWxzZS5cbiAqXG4gKiAjIyMjIyBvcHRpb25zOlxuICpcbiAqIC0gX19odG1sX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlLiBCZSBjYXJlZnVsIVxuICogICBUaGF0J3Mgbm90IHNhZmUhIFlvdSBtYXkgbmVlZCBleHRlcm5hbCBzYW5pdGl6ZXIgdG8gcHJvdGVjdCBvdXRwdXQgZnJvbSBYU1MuXG4gKiAgIEl0J3MgYmV0dGVyIHRvIGV4dGVuZCBmZWF0dXJlcyB2aWEgcGx1Z2lucywgaW5zdGVhZCBvZiBlbmFibGluZyBIVE1MLlxuICogLSBfX3hodG1sT3V0X18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGFkZCAnLycgd2hlbiBjbG9zaW5nIHNpbmdsZSB0YWdzXG4gKiAgIChgPGJyIC8+YCkuIFRoaXMgaXMgbmVlZGVkIG9ubHkgZm9yIGZ1bGwgQ29tbW9uTWFyayBjb21wYXRpYmlsaXR5LiBJbiByZWFsXG4gKiAgIHdvcmxkIHlvdSB3aWxsIG5lZWQgSFRNTCBvdXRwdXQuXG4gKiAtIF9fYnJlYWtzX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGNvbnZlcnQgYFxcbmAgaW4gcGFyYWdyYXBocyBpbnRvIGA8YnI+YC5cbiAqIC0gX19sYW5nUHJlZml4X18gLSBgbGFuZ3VhZ2UtYC4gQ1NTIGxhbmd1YWdlIGNsYXNzIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrcy5cbiAqICAgQ2FuIGJlIHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaGlnaGxpZ2h0ZXJzLlxuICogLSBfX2xpbmtpZnlfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dCB0byBsaW5rcy5cbiAqIC0gX190eXBvZ3JhcGhlcl9fICAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIFtzb21lIGxhbmd1YWdlLW5ldXRyYWxcbiAqICAgcmVwbGFjZW1lbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMpICtcbiAqICAgcXVvdGVzIGJlYXV0aWZpY2F0aW9uIChzbWFydHF1b3RlcykuXG4gKiAtIF9fcXVvdGVzX18gLSBg4oCc4oCd4oCY4oCZYCwgU3RyaW5nIG9yIEFycmF5LiBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50XG4gKiAgIHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQgYW5kIHNtYXJ0cXVvdGVzIG9uLiBGb3IgZXhhbXBsZSwgeW91IGNhblxuICogICB1c2UgYCfCq8K74oCe4oCcJ2AgZm9yIFJ1c3NpYW4sIGAn4oCe4oCc4oCa4oCYJ2AgZm9yIEdlcm1hbiwgYW5kXG4gKiAgIGBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddYCBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gKiAtIF9faGlnaGxpZ2h0X18gLSBgbnVsbGAuIEhpZ2hsaWdodGVyIGZ1bmN0aW9uIGZvciBmZW5jZWQgY29kZSBibG9ja3MuXG4gKiAgIEhpZ2hsaWdodGVyIGBmdW5jdGlvbiAoc3RyLCBsYW5nKWAgc2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwuIEl0IGNhbiBhbHNvXG4gKiAgIHJldHVybiBlbXB0eSBzdHJpbmcgaWYgdGhlIHNvdXJjZSB3YXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkXG4gKiAgIGV4dGVybmFseS4gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBjb21tb25tYXJrIG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoJ2NvbW1vbm1hcmsnKTtcbiAqXG4gKiAvLyBkZWZhdWx0IG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGh0bWw6IHRydWUsXG4gKiAgIGxpbmtpZnk6IHRydWUsXG4gKiAgIHR5cG9ncmFwaGVyOiB0cnVlXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyMjIFN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBgYGBqc1xuICogdmFyIGhsanMgPSByZXF1aXJlKCdoaWdobGlnaHQuanMnKSAvLyBodHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiAqXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuIGhsanMuaGlnaGxpZ2h0KHN0ciwgeyBsYW5ndWFnZTogbGFuZywgaWdub3JlSWxsZWdhbHM6IHRydWUgfSkudmFsdWU7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnJzsgLy8gdXNlIGV4dGVybmFsIGRlZmF1bHQgZXNjYXBpbmdcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBPciB3aXRoIGZ1bGwgd3JhcHBlciBvdmVycmlkZSAoaWYgeW91IG5lZWQgYXNzaWduIGNsYXNzIHRvIGA8cHJlPmApOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJykgLy8gaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4gKlxuICogLy8gQWN0dWFsIGRlZmF1bHQgdmFsdWVzXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuICc8cHJlIGNsYXNzPVwiaGxqc1wiPjxjb2RlPicgK1xuICogICAgICAgICAgICAgICAgaGxqcy5oaWdobGlnaHQoc3RyLCB7IGxhbmd1YWdlOiBsYW5nLCBpZ25vcmVJbGxlZ2FsczogdHJ1ZSB9KS52YWx1ZSArXG4gKiAgICAgICAgICAgICAgICAnPC9jb2RlPjwvcHJlPic7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnPHByZSBjbGFzcz1cImhsanNcIj48Y29kZT4nICsgbWQudXRpbHMuZXNjYXBlSHRtbChzdHIpICsgJzwvY29kZT48L3ByZT4nO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqKi9cbmZ1bmN0aW9uIE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFya2Rvd25JdCkpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHByZXNldE5hbWUpKSB7XG4gICAgICBvcHRpb25zID0gcHJlc2V0TmFtZSB8fCB7fTtcbiAgICAgIHByZXNldE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaW5saW5lIC0+IFBhcnNlcklubGluZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1BhcnNlcklubGluZV1dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5pbmxpbmUgPSBuZXcgUGFyc2VySW5saW5lKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjYmxvY2sgLT4gUGFyc2VyQmxvY2tcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJCbG9ja11dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5ibG9jayA9IG5ldyBQYXJzZXJCbG9jaygpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2NvcmUgLT4gQ29yZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW0NvcmVdXSBjaGFpbiBleGVjdXRvci4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuY29yZSA9IG5ldyBQYXJzZXJDb3JlKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjcmVuZGVyZXIgLT4gUmVuZGVyZXJcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tSZW5kZXJlcl1dLiBVc2UgaXQgdG8gbW9kaWZ5IG91dHB1dCBsb29rLiBPciB0byBhZGQgcmVuZGVyaW5nXG4gICAqIHJ1bGVzIGZvciBuZXcgdG9rZW4gdHlwZXMsIGdlbmVyYXRlZCBieSBwbHVnaW5zLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBmdW5jdGlvbiBteVRva2VuKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNlbGYpIHtcbiAgICogICAvLy4uLlxuICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAqIH07XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzWydteV90b2tlbiddID0gbXlUb2tlblxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtbUmVuZGVyZXJdXSBkb2NzIGFuZCBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpLlxuICAgKiovXG4gIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNsaW5raWZ5IC0+IExpbmtpZnlJdFxuICAgKlxuICAgKiBbbGlua2lmeS1pdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQpIGluc3RhbmNlLlxuICAgKiBVc2VkIGJ5IFtsaW5raWZ5XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcylcbiAgICogcnVsZS5cbiAgICoqL1xuICB0aGlzLmxpbmtpZnkgPSBuZXcgTGlua2lmeUl0KCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjdmFsaWRhdGVMaW5rKHVybCkgLT4gQm9vbGVhblxuICAgKlxuICAgKiBMaW5rIHZhbGlkYXRpb24gZnVuY3Rpb24uIENvbW1vbk1hcmsgYWxsb3dzIHRvbyBtdWNoIGluIGxpbmtzLiBCeSBkZWZhdWx0XG4gICAqIHdlIGRpc2FibGUgYGphdmFzY3JpcHQ6YCwgYHZic2NyaXB0OmAsIGBmaWxlOmAgc2NoZW1hcywgYW5kIGFsbW9zdCBhbGwgYGRhdGE6Li4uYCBzY2hlbWFzXG4gICAqIGV4Y2VwdCBzb21lIGVtYmVkZGVkIGltYWdlIHR5cGVzLlxuICAgKlxuICAgKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJlaGF2aW91cjpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqIC8vIGVuYWJsZSBldmVyeXRoaW5nXG4gICAqIG1kLnZhbGlkYXRlTGluayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICogYGBgXG4gICAqKi9cbiAgdGhpcy52YWxpZGF0ZUxpbmsgPSB2YWxpZGF0ZUxpbms7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbm9ybWFsaXplTGluayh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGVuY29kZSBsaW5rIHVybCB0byBhIG1hY2hpbmUtcmVhZGFibGUgZm9ybWF0LFxuICAgKiB3aGljaCBpbmNsdWRlcyB1cmwtZW5jb2RpbmcsIHB1bnljb2RlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5ub3JtYWxpemVMaW5rID0gbm9ybWFsaXplTGluaztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rVGV4dCh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRlY29kZSBsaW5rIHVybCB0byBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdGBcbiAgICoqL1xuICB0aGlzLm5vcm1hbGl6ZUxpbmtUZXh0ID0gbm9ybWFsaXplTGlua1RleHQ7XG5cblxuICAvLyBFeHBvc2UgdXRpbHMgJiBoZWxwZXJzIGZvciBlYXN5IGFjY2VzIGZyb20gcGx1Z2luc1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3V0aWxzIC0+IHV0aWxzXG4gICAqXG4gICAqIEFzc29ydGVkIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvY29tbW9uL3V0aWxzLmpzKS5cbiAgICoqL1xuICB0aGlzLnV0aWxzID0gdXRpbHM7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaGVscGVycyAtPiBoZWxwZXJzXG4gICAqXG4gICAqIExpbmsgY29tcG9uZW50cyBwYXJzZXIgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvaGVscGVycykuXG4gICAqKi9cbiAgdGhpcy5oZWxwZXJzID0gdXRpbHMuYXNzaWduKHt9LCBoZWxwZXJzKTtcblxuXG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLmNvbmZpZ3VyZShwcmVzZXROYW1lKTtcblxuICBpZiAob3B0aW9ucykgeyB0aGlzLnNldChvcHRpb25zKTsgfVxufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuc2V0KG9wdGlvbnMpXG4gKlxuICogU2V0IHBhcnNlciBvcHRpb25zIChpbiB0aGUgc2FtZSBmb3JtYXQgYXMgaW4gY29uc3RydWN0b3IpLiBQcm9iYWJseSwgeW91XG4gKiB3aWxsIG5ldmVyIG5lZWQgaXQsIGJ1dCB5b3UgY2FuIGNoYW5nZSBvcHRpb25zIGFmdGVyIGNvbnN0cnVjdG9yIGNhbGwuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnNldCh7IGh0bWw6IHRydWUsIGJyZWFrczogdHJ1ZSB9KVxuICogICAgICAgICAgICAgLnNldCh7IHR5cG9ncmFwaGVyLCB0cnVlIH0pO1xuICogYGBgXG4gKlxuICogX19Ob3RlOl9fIFRvIGFjaGlldmUgdGhlIGJlc3QgcG9zc2libGUgcGVyZm9ybWFuY2UsIGRvbid0IG1vZGlmeSBhXG4gKiBgbWFya2Rvd24taXRgIGluc3RhbmNlIG9wdGlvbnMgb24gdGhlIGZseS4gSWYgeW91IG5lZWQgbXVsdGlwbGUgY29uZmlndXJhdGlvbnNcbiAqIGl0J3MgYmVzdCB0byBjcmVhdGUgbXVsdGlwbGUgaW5zdGFuY2VzIGFuZCBpbml0aWFsaXplIGVhY2ggd2l0aCBzZXBhcmF0ZVxuICogY29uZmlnLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdXRpbHMuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlLCBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5jb25maWd1cmUocHJlc2V0cylcbiAqXG4gKiBCYXRjaCBsb2FkIG9mIGFsbCBvcHRpb25zIGFuZCBjb21wZW5lbnQgc2V0dGluZ3MuIFRoaXMgaXMgaW50ZXJuYWwgbWV0aG9kLFxuICogYW5kIHlvdSBwcm9iYWJseSB3aWxsIG5vdCBuZWVkIGl0LiBCdXQgaWYgeW91IHdpbGwgLSBzZWUgYXZhaWxhYmxlIHByZXNldHNcbiAqIGFuZCBkYXRhIHN0cnVjdHVyZSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L3RyZWUvbWFzdGVyL2xpYi9wcmVzZXRzKVxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgcHJlc2V0cyBpbnN0ZWFkIG9mIGRpcmVjdCBjb25maWcgbG9hZHMuIFRoYXRcbiAqIHdpbGwgZ2l2ZSBiZXR0ZXIgY29tcGF0aWJpbGl0eSB3aXRoIG5leHQgdmVyc2lvbnMuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAocHJlc2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXMsIHByZXNldE5hbWU7XG5cbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHByZXNldHMpKSB7XG4gICAgcHJlc2V0TmFtZSA9IHByZXNldHM7XG4gICAgcHJlc2V0cyA9IGNvbmZpZ1twcmVzZXROYW1lXTtcbiAgICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCBcIicgKyBwcmVzZXROYW1lICsgJ1wiLCBjaGVjayBuYW1lJyk7IH1cbiAgfVxuXG4gIGlmICghcHJlc2V0cykgeyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGBtYXJrZG93bi1pdGAgcHJlc2V0LCBjYW5cXCd0IGJlIGVtcHR5Jyk7IH1cblxuICBpZiAocHJlc2V0cy5vcHRpb25zKSB7IHNlbGYuc2V0KHByZXNldHMub3B0aW9ucyk7IH1cblxuICBpZiAocHJlc2V0cy5jb21wb25lbnRzKSB7XG4gICAgT2JqZWN0LmtleXMocHJlc2V0cy5jb21wb25lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlczIpIHtcbiAgICAgICAgc2VsZltuYW1lXS5ydWxlcjIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5lbmFibGUobGlzdCwgaWdub3JlSW52YWxpZClcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogcnVsZSBuYW1lIG9yIGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGVcbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBsaXN0IG9yIHJ1bGVzLiBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZmluZCBhcHByb3ByaWF0ZSBjb21wb25lbnRzLFxuICogY29udGFpbmluZyBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBydWxlIG5vdCBmb3VuZCwgYW5kIGBpZ25vcmVJbnZhbGlkYFxuICogbm90IHNldCAtIHRocm93cyBleGNlcHRpb24uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLmVuYWJsZShbJ3N1YicsICdzdXAnXSlcbiAqICAgICAgICAgICAgIC5kaXNhYmxlKCdzbWFydHF1b3RlcycpO1xuICogYGBgXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIFsgJ2NvcmUnLCAnYmxvY2snLCAnaW5saW5lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuICB9LCB0aGlzKTtcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGVuYWJsZSB1bmtub3duIHJ1bGUocyk6ICcgKyBtaXNzZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuZGlzYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQuZW5hYmxlXV0sIGJ1dCB0dXJuIHNwZWNpZmllZCBydWxlcyBvZmYuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICBbICdjb3JlJywgJ2Jsb2NrJywgJ2lubGluZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZGlzYWJsZShsaXN0LCB0cnVlKSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmRpc2FibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGRpc2FibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC51c2UocGx1Z2luLCBwYXJhbXMpXG4gKlxuICogTG9hZCBzcGVjaWZpZWQgcGx1Z2luIHdpdGggZ2l2ZW4gcGFyYW1zIGludG8gY3VycmVudCBwYXJzZXIgaW5zdGFuY2UuXG4gKiBJdCdzIGp1c3QgYSBzdWdhciB0byBjYWxsIGBwbHVnaW4obWQsIHBhcmFtcylgIHdpdGggY3VycmluZy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGl0ZXJhdG9yID0gcmVxdWlyZSgnbWFya2Rvd24taXQtZm9yLWlubGluZScpO1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAudXNlKGl0ZXJhdG9yLCAnZm9vX3JlcGxhY2UnLCAndGV4dCcsIGZ1bmN0aW9uICh0b2tlbnMsIGlkeCkge1xuICogICAgICAgICAgICAgICB0b2tlbnNbaWR4XS5jb250ZW50ID0gdG9rZW5zW2lkeF0uY29udGVudC5yZXBsYWNlKC9mb28vZywgJ2JhcicpO1xuICogICAgICAgICAgICAgfSk7XG4gKiBgYGBcbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4gLyosIHBhcmFtcywgLi4uICovKSB7XG4gIHZhciBhcmdzID0gWyB0aGlzIF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICBwbHVnaW4uYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5wYXJzZShzcmMsIGVudikgLT4gQXJyYXlcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFBhcnNlIGlucHV0IHN0cmluZyBhbmQgcmV0dXJuIGxpc3Qgb2YgYmxvY2sgdG9rZW5zIChzcGVjaWFsIHRva2VuIHR5cGVcbiAqIFwiaW5saW5lXCIgd2lsbCBjb250YWluIGxpc3Qgb2YgaW5saW5lIHRva2VucykuIFlvdSBzaG91bGQgbm90IGNhbGwgdGhpc1xuICogbWV0aG9kIGRpcmVjdGx5LCB1bnRpbCB5b3Ugd3JpdGUgY3VzdG9tIHJlbmRlcmVyIChmb3IgZXhhbXBsZSwgdG8gcHJvZHVjZVxuICogQVNUKS5cbiAqXG4gKiBgZW52YCBpcyB1c2VkIHRvIHBhc3MgZGF0YSBiZXR3ZWVuIFwiZGlzdHJpYnV0ZWRcIiBydWxlcyBhbmQgcmV0dXJuIGFkZGl0aW9uYWxcbiAqIG1ldGFkYXRhIGxpa2UgcmVmZXJlbmNlIGluZm8sIG5lZWRlZCBmb3IgdGhlIHJlbmRlcmVyLiBJdCBhbHNvIGNhbiBiZSB1c2VkIHRvXG4gKiBpbmplY3QgZGF0YSBpbiBzcGVjaWZpYyBjYXNlcy4gVXN1YWxseSwgeW91IHdpbGwgYmUgb2sgdG8gcGFzcyBge31gLFxuICogYW5kIHRoZW4gcGFzcyB1cGRhdGVkIG9iamVjdCB0byByZW5kZXJlci5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGlmICh0eXBlb2Ygc3JjICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZGF0YSBzaG91bGQgYmUgYSBTdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLmNvcmUuU3RhdGUoc3JjLCB0aGlzLCBlbnYpO1xuXG4gIHRoaXMuY29yZS5wcm9jZXNzKHN0YXRlKTtcblxuICByZXR1cm4gc3RhdGUudG9rZW5zO1xufTtcblxuXG4vKipcbiAqIE1hcmtkb3duSXQucmVuZGVyKHNyYyBbLCBlbnZdKSAtPiBTdHJpbmdcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFJlbmRlciBtYXJrZG93biBzdHJpbmcgaW50byBodG1sLiBJdCBkb2VzIGFsbCBtYWdpYyBmb3IgeW91IDopLlxuICpcbiAqIGBlbnZgIGNhbiBiZSB1c2VkIHRvIGluamVjdCBhZGRpdGlvbmFsIG1ldGFkYXRhIChge31gIGJ5IGRlZmF1bHQpLlxuICogQnV0IHlvdSB3aWxsIG5vdCBuZWVkIGl0IHdpdGggaGlnaCBwcm9iYWJpbGl0eS4gU2VlIGFsc28gY29tbWVudFxuICogaW4gW1tNYXJrZG93bkl0LnBhcnNlXV0uXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9O1xuXG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlKHNyYywgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xufTtcblxuXG4vKiogaW50ZXJuYWxcbiAqIE1hcmtkb3duSXQucGFyc2VJbmxpbmUoc3JjLCBlbnYpIC0+IEFycmF5XG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQucGFyc2VdXSBidXQgc2tpcCBhbGwgYmxvY2sgcnVsZXMuIEl0IHJldHVybnMgdGhlXG4gKiBibG9jayB0b2tlbnMgbGlzdCB3aXRoIHRoZSBzaW5nbGUgYGlubGluZWAgZWxlbWVudCwgY29udGFpbmluZyBwYXJzZWQgaW5saW5lXG4gKiB0b2tlbnMgaW4gYGNoaWxkcmVuYCBwcm9wZXJ0eS4gQWxzbyB1cGRhdGVzIGBlbnZgIG9iamVjdC5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnBhcnNlSW5saW5lID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLmNvcmUuU3RhdGUoc3JjLCB0aGlzLCBlbnYpO1xuXG4gIHN0YXRlLmlubGluZU1vZGUgPSB0cnVlO1xuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLnRva2Vucztcbn07XG5cblxuLyoqXG4gKiBNYXJrZG93bkl0LnJlbmRlcklubGluZShzcmMgWywgZW52XSkgLT4gU3RyaW5nXG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBTaW1pbGFyIHRvIFtbTWFya2Rvd25JdC5yZW5kZXJdXSBidXQgZm9yIHNpbmdsZSBwYXJhZ3JhcGggY29udGVudC4gUmVzdWx0XG4gKiB3aWxsIE5PVCBiZSB3cmFwcGVkIGludG8gYDxwPmAgdGFncy5cbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBlbnYgPSBlbnYgfHwge307XG5cbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMucGFyc2VJbmxpbmUoc3JjLCBlbnYpLCB0aGlzLm9wdGlvbnMsIGVudik7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTWFya2Rvd25JdDtcbiIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgUGFyc2VyQmxvY2tcbiAqXG4gKiBCbG9jay1sZXZlbCB0b2tlbml6ZXIuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG52YXIgX3J1bGVzID0gW1xuICAvLyBGaXJzdCAyIHBhcmFtcyAtIHJ1bGUgbmFtZSAmIHNvdXJjZS4gU2Vjb25kYXJ5IGFycmF5IC0gbGlzdCBvZiBydWxlcyxcbiAgLy8gd2hpY2ggY2FuIGJlIHRlcm1pbmF0ZWQgYnkgdGhpcyBvbmUuXG4gIFsgJ3RhYmxlJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3RhYmxlJyksICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScgXSBdLFxuICBbICdjb2RlJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9jb2RlJykgXSxcbiAgWyAnZmVuY2UnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svZmVuY2UnKSwgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdibG9ja3F1b3RlJywgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ibG9ja3F1b3RlJyksIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2hyJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2hyJyksICAgICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnbGlzdCcsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGlzdCcpLCAgICAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAncmVmZXJlbmNlJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svcmVmZXJlbmNlJykgXSxcbiAgWyAnaHRtbF9ibG9jaycsIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaHRtbF9ibG9jaycpLCBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAnaGVhZGluZycsICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaGVhZGluZycpLCAgICBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAnbGhlYWRpbmcnLCAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svbGhlYWRpbmcnKSBdLFxuICBbICdwYXJhZ3JhcGgnLCAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9wYXJhZ3JhcGgnKSBdXG5dO1xuXG5cbi8qKlxuICogbmV3IFBhcnNlckJsb2NrKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlckJsb2NrKCkge1xuICAvKipcbiAgICogUGFyc2VyQmxvY2sjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgYmxvY2sgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdLCB7IGFsdDogKF9ydWxlc1tpXVsyXSB8fCBbXSkuc2xpY2UoKSB9KTtcbiAgfVxufVxuXG5cbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2Vcbi8vXG5QYXJzZXJCbG9jay5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSkge1xuICB2YXIgb2ssIGksXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXIuZ2V0UnVsZXMoJycpLFxuICAgICAgbGVuID0gcnVsZXMubGVuZ3RoLFxuICAgICAgbGluZSA9IHN0YXJ0TGluZSxcbiAgICAgIGhhc0VtcHR5TGluZXMgPSBmYWxzZSxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7XG5cbiAgd2hpbGUgKGxpbmUgPCBlbmRMaW5lKSB7XG4gICAgc3RhdGUubGluZSA9IGxpbmUgPSBzdGF0ZS5za2lwRW1wdHlMaW5lcyhsaW5lKTtcbiAgICBpZiAobGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBUZXJtaW5hdGlvbiBjb25kaXRpb24gZm9yIG5lc3RlZCBjYWxscy5cbiAgICAvLyBOZXN0ZWQgY2FsbHMgY3VycmVudGx5IHVzZWQgZm9yIGJsb2NrcXVvdGVzICYgbGlzdHNcbiAgICBpZiAoc3RhdGUuc0NvdW50W2xpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBJZiBuZXN0aW5nIGxldmVsIGV4Y2VlZGVkIC0gc2tpcCB0YWlsIHRvIHRoZSBlbmQuIFRoYXQncyBub3Qgb3JkaW5hcnlcbiAgICAvLyBzaXR1YXRpb24gYW5kIHdlIHNob3VsZCBub3QgY2FyZSBhYm91dCBjb250ZW50LlxuICAgIGlmIChzdGF0ZS5sZXZlbCA+PSBtYXhOZXN0aW5nKSB7XG4gICAgICBzdGF0ZS5saW5lID0gZW5kTGluZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUubGluZWBcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb2sgPSBydWxlc1tpXShzdGF0ZSwgbGluZSwgZW5kTGluZSwgZmFsc2UpO1xuICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gc2V0IHN0YXRlLnRpZ2h0IGlmIHdlIGhhZCBhbiBlbXB0eSBsaW5lIGJlZm9yZSBjdXJyZW50IHRhZ1xuICAgIC8vIGkuZS4gbGF0ZXN0IGVtcHR5IGxpbmUgc2hvdWxkIG5vdCBjb3VudFxuICAgIHN0YXRlLnRpZ2h0ID0gIWhhc0VtcHR5TGluZXM7XG5cbiAgICAvLyBwYXJhZ3JhcGggbWlnaHQgXCJlYXRcIiBvbmUgbmV3bGluZSBhZnRlciBpdCBpbiBuZXN0ZWQgbGlzdHNcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGxpbmUgPSBzdGF0ZS5saW5lO1xuXG4gICAgaWYgKGxpbmUgPCBlbmRMaW5lICYmIHN0YXRlLmlzRW1wdHkobGluZSkpIHtcbiAgICAgIGhhc0VtcHR5TGluZXMgPSB0cnVlO1xuICAgICAgbGluZSsrO1xuICAgICAgc3RhdGUubGluZSA9IGxpbmU7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2VyQmxvY2sucGFyc2Uoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpXG4gKlxuICogUHJvY2VzcyBpbnB1dCBzdHJpbmcgYW5kIHB1c2ggYmxvY2sgdG9rZW5zIGludG8gYG91dFRva2Vuc2BcbiAqKi9cblBhcnNlckJsb2NrLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzcmMpIHsgcmV0dXJuOyB9XG5cbiAgc3RhdGUgPSBuZXcgdGhpcy5TdGF0ZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucyk7XG5cbiAgdGhpcy50b2tlbml6ZShzdGF0ZSwgc3RhdGUubGluZSwgc3RhdGUubGluZU1heCk7XG59O1xuXG5cblBhcnNlckJsb2NrLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svc3RhdGVfYmxvY2snKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlckJsb2NrO1xuIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBDb3JlXG4gKlxuICogVG9wLWxldmVsIHJ1bGVzIGV4ZWN1dG9yLiBHbHVlcyBibG9jay9pbmxpbmUgcGFyc2VycyBhbmQgZG9lcyBpbnRlcm1lZGlhdGVcbiAqIHRyYW5zZm9ybWF0aW9ucy5cbiAqKi9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgUnVsZXIgID0gcmVxdWlyZSgnLi9ydWxlcicpO1xuXG5cbnZhciBfcnVsZXMgPSBbXG4gIFsgJ25vcm1hbGl6ZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL25vcm1hbGl6ZScpICAgICAgXSxcbiAgWyAnYmxvY2snLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvYmxvY2snKSAgICAgICAgICBdLFxuICBbICdpbmxpbmUnLCAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9pbmxpbmUnKSAgICAgICAgIF0sXG4gIFsgJ2xpbmtpZnknLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2xpbmtpZnknKSAgICAgICAgXSxcbiAgWyAncmVwbGFjZW1lbnRzJywgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvcmVwbGFjZW1lbnRzJykgICBdLFxuICBbICdzbWFydHF1b3RlcycsICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9zbWFydHF1b3RlcycpICAgIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgQ29yZSgpXG4gKiovXG5mdW5jdGlvbiBDb3JlKCkge1xuICAvKipcbiAgICogQ29yZSNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBjb3JlIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIENvcmUucHJvY2VzcyhzdGF0ZSlcbiAqXG4gKiBFeGVjdXRlcyBjb3JlIGNoYWluIHJ1bGVzLlxuICoqL1xuQ29yZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgaSwgbCwgcnVsZXM7XG5cbiAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKTtcblxuICBmb3IgKGkgPSAwLCBsID0gcnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcnVsZXNbaV0oc3RhdGUpO1xuICB9XG59O1xuXG5Db3JlLnByb3RvdHlwZS5TdGF0ZSA9IHJlcXVpcmUoJy4vcnVsZXNfY29yZS9zdGF0ZV9jb3JlJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb3JlO1xuIiwiLyoqIGludGVybmFsXG4gKiBjbGFzcyBQYXJzZXJJbmxpbmVcbiAqXG4gKiBUb2tlbml6ZXMgcGFyYWdyYXBoIGNvbnRlbnQuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICAgICAgICAgICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUGFyc2VyIHJ1bGVzXG5cbnZhciBfcnVsZXMgPSBbXG4gIFsgJ3RleHQnLCAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3RleHQnKSBdLFxuICBbICduZXdsaW5lJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9uZXdsaW5lJykgXSxcbiAgWyAnZXNjYXBlJywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvZXNjYXBlJykgXSxcbiAgWyAnYmFja3RpY2tzJywgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYmFja3RpY2tzJykgXSxcbiAgWyAnc3RyaWtldGhyb3VnaCcsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaCcpLnRva2VuaXplIF0sXG4gIFsgJ2VtcGhhc2lzJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VtcGhhc2lzJykudG9rZW5pemUgXSxcbiAgWyAnbGluaycsICAgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvbGluaycpIF0sXG4gIFsgJ2ltYWdlJywgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2ltYWdlJykgXSxcbiAgWyAnYXV0b2xpbmsnLCAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYXV0b2xpbmsnKSBdLFxuICBbICdodG1sX2lubGluZScsICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9odG1sX2lubGluZScpIF0sXG4gIFsgJ2VudGl0eScsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VudGl0eScpIF1cbl07XG5cbnZhciBfcnVsZXMyID0gW1xuICBbICdiYWxhbmNlX3BhaXJzJywgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzJykgXSxcbiAgWyAnc3RyaWtldGhyb3VnaCcsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RyaWtldGhyb3VnaCcpLnBvc3RQcm9jZXNzIF0sXG4gIFsgJ2VtcGhhc2lzJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VtcGhhc2lzJykucG9zdFByb2Nlc3MgXSxcbiAgWyAndGV4dF9jb2xsYXBzZScsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZScpIF1cbl07XG5cblxuLyoqXG4gKiBuZXcgUGFyc2VySW5saW5lKClcbiAqKi9cbmZ1bmN0aW9uIFBhcnNlcklubGluZSgpIHtcbiAgdmFyIGk7XG5cbiAgLyoqXG4gICAqIFBhcnNlcklubGluZSNydWxlciAtPiBSdWxlclxuICAgKlxuICAgKiBbW1J1bGVyXV0gaW5zdGFuY2UuIEtlZXAgY29uZmlndXJhdGlvbiBvZiBpbmxpbmUgcnVsZXMuXG4gICAqKi9cbiAgdGhpcy5ydWxlciA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcklubGluZSNydWxlcjIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBTZWNvbmQgcnVsZXIgdXNlZCBmb3IgcG9zdC1wcm9jZXNzaW5nXG4gICAqIChlLmcuIGluIGVtcGhhc2lzLWxpa2UgcnVsZXMpLlxuICAgKiovXG4gIHRoaXMucnVsZXIyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IF9ydWxlczIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyMi5wdXNoKF9ydWxlczJbaV1bMF0sIF9ydWxlczJbaV1bMV0pO1xuICB9XG59XG5cblxuLy8gU2tpcCBzaW5nbGUgdG9rZW4gYnkgcnVubmluZyBhbGwgcnVsZXMgaW4gdmFsaWRhdGlvbiBtb2RlO1xuLy8gcmV0dXJucyBgdHJ1ZWAgaWYgYW55IHJ1bGUgcmVwb3J0ZWQgc3VjY2Vzc1xuLy9cblBhcnNlcklubGluZS5wcm90b3R5cGUuc2tpcFRva2VuID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBvaywgaSwgcG9zID0gc3RhdGUucG9zLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3RpbmcsXG4gICAgICBjYWNoZSA9IHN0YXRlLmNhY2hlO1xuXG5cbiAgaWYgKHR5cGVvZiBjYWNoZVtwb3NdICE9PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLnBvcyA9IGNhY2hlW3Bvc107XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgLy8gSW5jcmVtZW50IHN0YXRlLmxldmVsIGFuZCBkZWNyZW1lbnQgaXQgbGF0ZXIgdG8gbGltaXQgcmVjdXJzaW9uLlxuICAgICAgLy8gSXQncyBoYXJtbGVzcyB0byBkbyBoZXJlLCBiZWNhdXNlIG5vIHRva2VucyBhcmUgY3JlYXRlZC4gQnV0IGlkZWFsbHksXG4gICAgICAvLyB3ZSdkIG5lZWQgYSBzZXBhcmF0ZSBwcml2YXRlIHN0YXRlIHZhcmlhYmxlIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAvL1xuICAgICAgc3RhdGUubGV2ZWwrKztcbiAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIHRydWUpO1xuICAgICAgc3RhdGUubGV2ZWwtLTtcblxuICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRvbyBtdWNoIG5lc3RpbmcsIGp1c3Qgc2tpcCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJhZ3JhcGguXG4gICAgLy9cbiAgICAvLyBOT1RFOiB0aGlzIHdpbGwgY2F1c2UgbGlua3MgdG8gYmVoYXZlIGluY29ycmVjdGx5IGluIHRoZSBmb2xsb3dpbmcgY2FzZSxcbiAgICAvLyAgICAgICB3aGVuIGFuIGFtb3VudCBvZiBgW2AgaXMgZXhhY3RseSBlcXVhbCB0byBgbWF4TmVzdGluZyArIDFgOlxuICAgIC8vXG4gICAgLy8gICAgICAgW1tbW1tbW1tbW1tbW1tbW1tbW1tbZm9vXSgpXG4gICAgLy9cbiAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyB3b3JrYXJvdW5kIHdoZW4gQ00gc3RhbmRhcmQgd2lsbCBhbGxvdyBuZXN0ZWQgbGlua3NcbiAgICAvLyAgICAgICAod2UgY2FuIHJlcGxhY2UgaXQgYnkgcHJldmVudGluZyBsaW5rcyBmcm9tIGJlaW5nIHBhcnNlZCBpblxuICAgIC8vICAgICAgIHZhbGlkYXRpb24gbW9kZSlcbiAgICAvL1xuICAgIHN0YXRlLnBvcyA9IHN0YXRlLnBvc01heDtcbiAgfVxuXG4gIGlmICghb2spIHsgc3RhdGUucG9zKys7IH1cbiAgY2FjaGVbcG9zXSA9IHN0YXRlLnBvcztcbn07XG5cblxuLy8gR2VuZXJhdGUgdG9rZW5zIGZvciBpbnB1dCByYW5nZVxuLy9cblBhcnNlcklubGluZS5wcm90b3R5cGUudG9rZW5pemUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIG9rLCBpLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIGVuZCA9IHN0YXRlLnBvc01heCxcbiAgICAgIG1heE5lc3RpbmcgPSBzdGF0ZS5tZC5vcHRpb25zLm1heE5lc3Rpbmc7XG5cbiAgd2hpbGUgKHN0YXRlLnBvcyA8IGVuZCkge1xuICAgIC8vIFRyeSBhbGwgcG9zc2libGUgcnVsZXMuXG4gICAgLy8gT24gc3VjY2VzcywgcnVsZSBzaG91bGQ6XG4gICAgLy9cbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUucG9zYFxuICAgIC8vIC0gdXBkYXRlIGBzdGF0ZS50b2tlbnNgXG4gICAgLy8gLSByZXR1cm4gdHJ1ZVxuXG4gICAgaWYgKHN0YXRlLmxldmVsIDwgbWF4TmVzdGluZykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKG9rKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9rKSB7XG4gICAgICBpZiAoc3RhdGUucG9zID49IGVuZCkgeyBicmVhazsgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbc3RhdGUucG9zKytdO1xuICB9XG5cbiAgaWYgKHN0YXRlLnBlbmRpbmcpIHtcbiAgICBzdGF0ZS5wdXNoUGVuZGluZygpO1xuICB9XG59O1xuXG5cbi8qKlxuICogUGFyc2VySW5saW5lLnBhcnNlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKVxuICpcbiAqIFByb2Nlc3MgaW5wdXQgc3RyaW5nIGFuZCBwdXNoIGlubGluZSB0b2tlbnMgaW50byBgb3V0VG9rZW5zYFxuICoqL1xuUGFyc2VySW5saW5lLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzdHIsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB2YXIgaSwgcnVsZXMsIGxlbjtcbiAgdmFyIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuXG4gIHRoaXMudG9rZW5pemUoc3RhdGUpO1xuXG4gIHJ1bGVzID0gdGhpcy5ydWxlcjIuZ2V0UnVsZXMoJycpO1xuICBsZW4gPSBydWxlcy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcnVsZXNbaV0oc3RhdGUpO1xuICB9XG59O1xuXG5cblBhcnNlcklubGluZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9zdGF0ZV9pbmxpbmUnKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcklubGluZTtcbiIsIi8vIENvbW1vbm1hcmsgZGVmYXVsdCBvcHRpb25zXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgdHJ1ZSwgICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgdHJ1ZSwgICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gQ291bGQgYmUgZWl0aGVyIGEgU3RyaW5nIG9yIGFuIEFycmF5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlICfCq8K74oCe4oCcJyBmb3IgUnVzc2lhbiwgJ+KAnuKAnOKAmuKAmCcgZm9yIEdlcm1hbixcbiAgICAvLyBhbmQgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXSBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScsIC8qIOKAnOKAneKAmOKAmSAqL1xuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGlzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZCBleHRlcm5hbHkuXG4gICAgLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDIwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ25vcm1hbGl6ZScsXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdpbmxpbmUnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGJsb2NrOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAnYmxvY2txdW90ZScsXG4gICAgICAgICdjb2RlJyxcbiAgICAgICAgJ2ZlbmNlJyxcbiAgICAgICAgJ2hlYWRpbmcnLFxuICAgICAgICAnaHInLFxuICAgICAgICAnaHRtbF9ibG9jaycsXG4gICAgICAgICdsaGVhZGluZycsXG4gICAgICAgICdsaXN0JyxcbiAgICAgICAgJ3JlZmVyZW5jZScsXG4gICAgICAgICdwYXJhZ3JhcGgnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGlubGluZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2F1dG9saW5rJyxcbiAgICAgICAgJ2JhY2t0aWNrcycsXG4gICAgICAgICdlbXBoYXNpcycsXG4gICAgICAgICdlbnRpdHknLFxuICAgICAgICAnZXNjYXBlJyxcbiAgICAgICAgJ2h0bWxfaW5saW5lJyxcbiAgICAgICAgJ2ltYWdlJyxcbiAgICAgICAgJ2xpbmsnLFxuICAgICAgICAnbmV3bGluZScsXG4gICAgICAgICd0ZXh0J1xuICAgICAgXSxcbiAgICAgIHJ1bGVzMjogW1xuICAgICAgICAnYmFsYW5jZV9wYWlycycsXG4gICAgICAgICdlbXBoYXNpcycsXG4gICAgICAgICd0ZXh0X2NvbGxhcHNlJ1xuICAgICAgXVxuICAgIH1cbiAgfVxufTtcbiIsIi8vIG1hcmtkb3duLWl0IGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIGZhbHNlLCAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIGZhbHNlLCAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAxMDAgICAgICAgICAgICAvLyBJbnRlcm5hbCBwcm90ZWN0aW9uLCByZWN1cnNpb24gbGltaXRcbiAgfSxcblxuICBjb21wb25lbnRzOiB7XG5cbiAgICBjb3JlOiB7fSxcbiAgICBibG9jazoge30sXG4gICAgaW5saW5lOiB7fVxuICB9XG59O1xuIiwiLy8gXCJaZXJvXCIgcHJlc2V0LCB3aXRoIG5vdGhpbmcgZW5hYmxlZC4gVXNlZnVsIGZvciBtYW51YWwgY29uZmlndXJpbmcgb2Ygc2ltcGxlXG4vLyBtb2Rlcy4gRm9yIGV4YW1wbGUsIHRvIHBhcnNlIGJvbGQvaXRhbGljIG9ubHkuXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb3B0aW9uczoge1xuICAgIGh0bWw6ICAgICAgICAgZmFsc2UsICAgICAgICAvLyBFbmFibGUgSFRNTCB0YWdzIGluIHNvdXJjZVxuICAgIHhodG1sT3V0OiAgICAgZmFsc2UsICAgICAgICAvLyBVc2UgJy8nIHRvIGNsb3NlIHNpbmdsZSB0YWdzICg8YnIgLz4pXG4gICAgYnJlYWtzOiAgICAgICBmYWxzZSwgICAgICAgIC8vIENvbnZlcnQgJ1xcbicgaW4gcGFyYWdyYXBocyBpbnRvIDxicj5cbiAgICBsYW5nUHJlZml4OiAgICdsYW5ndWFnZS0nLCAgLy8gQ1NTIGxhbmd1YWdlIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrc1xuICAgIGxpbmtpZnk6ICAgICAgZmFsc2UsICAgICAgICAvLyBhdXRvY29udmVydCBVUkwtbGlrZSB0ZXh0cyB0byBsaW5rc1xuXG4gICAgLy8gRW5hYmxlIHNvbWUgbGFuZ3VhZ2UtbmV1dHJhbCByZXBsYWNlbWVudHMgKyBxdW90ZXMgYmVhdXRpZmljYXRpb25cbiAgICB0eXBvZ3JhcGhlcjogIGZhbHNlLFxuXG4gICAgLy8gRG91YmxlICsgc2luZ2xlIHF1b3RlcyByZXBsYWNlbWVudCBwYWlycywgd2hlbiB0eXBvZ3JhcGhlciBlbmFibGVkLFxuICAgIC8vIGFuZCBzbWFydHF1b3RlcyBvbi4gQ291bGQgYmUgZWl0aGVyIGEgU3RyaW5nIG9yIGFuIEFycmF5LlxuICAgIC8vXG4gICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlICfCq8K74oCe4oCcJyBmb3IgUnVzc2lhbiwgJ+KAnuKAnOKAmuKAmCcgZm9yIEdlcm1hbixcbiAgICAvLyBhbmQgWyfCq1xceEEwJywgJ1xceEEwwrsnLCAn4oC5XFx4QTAnLCAnXFx4QTDigLonXSBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gICAgcXVvdGVzOiAnXFx1MjAxY1xcdTIwMWRcXHUyMDE4XFx1MjAxOScsIC8qIOKAnOKAneKAmOKAmSAqL1xuXG4gICAgLy8gSGlnaGxpZ2h0ZXIgZnVuY3Rpb24uIFNob3VsZCByZXR1cm4gZXNjYXBlZCBIVE1MLFxuICAgIC8vIG9yICcnIGlmIHRoZSBzb3VyY2Ugc3RyaW5nIGlzIG5vdCBjaGFuZ2VkIGFuZCBzaG91bGQgYmUgZXNjYXBlZCBleHRlcm5hbHkuXG4gICAgLy8gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gKC8qc3RyLCBsYW5nKi8pIHsgcmV0dXJuICcnOyB9XG4gICAgLy9cbiAgICBoaWdobGlnaHQ6IG51bGwsXG5cbiAgICBtYXhOZXN0aW5nOiAgIDIwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ25vcm1hbGl6ZScsXG4gICAgICAgICdibG9jaycsXG4gICAgICAgICdpbmxpbmUnXG4gICAgICBdXG4gICAgfSxcblxuICAgIGJsb2NrOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAncGFyYWdyYXBoJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICd0ZXh0J1xuICAgICAgXSxcbiAgICAgIHJ1bGVzMjogW1xuICAgICAgICAnYmFsYW5jZV9wYWlycycsXG4gICAgICAgICd0ZXh0X2NvbGxhcHNlJ1xuICAgICAgXVxuICAgIH1cbiAgfVxufTtcbiIsIi8qKlxuICogY2xhc3MgUmVuZGVyZXJcbiAqXG4gKiBHZW5lcmF0ZXMgSFRNTCBmcm9tIHBhcnNlZCB0b2tlbiBzdHJlYW0uIEVhY2ggaW5zdGFuY2UgaGFzIGluZGVwZW5kZW50XG4gKiBjb3B5IG9mIHJ1bGVzLiBUaG9zZSBjYW4gYmUgcmV3cml0dGVuIHdpdGggZWFzZS4gQWxzbywgeW91IGNhbiBhZGQgbmV3XG4gKiBydWxlcyBpZiB5b3UgY3JlYXRlIHBsdWdpbiBhbmQgYWRkcyBuZXcgdG9rZW4gdHlwZXMuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGFzc2lnbiAgICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykuYXNzaWduO1xudmFyIHVuZXNjYXBlQWxsICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG52YXIgZXNjYXBlSHRtbCAgICAgID0gcmVxdWlyZSgnLi9jb21tb24vdXRpbHMnKS5lc2NhcGVIdG1sO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbnZhciBkZWZhdWx0X3J1bGVzID0ge307XG5cblxuZGVmYXVsdF9ydWxlcy5jb2RlX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgcmV0dXJuICAnPGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+JyArXG4gICAgICAgICAgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KSArXG4gICAgICAgICAgJzwvY29kZT4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmNvZGVfYmxvY2sgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIHJldHVybiAgJzxwcmUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+PGNvZGU+JyArXG4gICAgICAgICAgZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KSArXG4gICAgICAgICAgJzwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmZlbmNlID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XSxcbiAgICAgIGluZm8gPSB0b2tlbi5pbmZvID8gdW5lc2NhcGVBbGwodG9rZW4uaW5mbykudHJpbSgpIDogJycsXG4gICAgICBsYW5nTmFtZSA9ICcnLFxuICAgICAgbGFuZ0F0dHJzID0gJycsXG4gICAgICBoaWdobGlnaHRlZCwgaSwgYXJyLCB0bXBBdHRycywgdG1wVG9rZW47XG5cbiAgaWYgKGluZm8pIHtcbiAgICBhcnIgPSBpbmZvLnNwbGl0KC8oXFxzKykvZyk7XG4gICAgbGFuZ05hbWUgPSBhcnJbMF07XG4gICAgbGFuZ0F0dHJzID0gYXJyLnNsaWNlKDIpLmpvaW4oJycpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgaGlnaGxpZ2h0ZWQgPSBvcHRpb25zLmhpZ2hsaWdodCh0b2tlbi5jb250ZW50LCBsYW5nTmFtZSwgbGFuZ0F0dHJzKSB8fCBlc2NhcGVIdG1sKHRva2VuLmNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGhpZ2hsaWdodGVkID0gZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KTtcbiAgfVxuXG4gIGlmIChoaWdobGlnaHRlZC5pbmRleE9mKCc8cHJlJykgPT09IDApIHtcbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWQgKyAnXFxuJztcbiAgfVxuXG4gIC8vIElmIGxhbmd1YWdlIGV4aXN0cywgaW5qZWN0IGNsYXNzIGdlbnRseSwgd2l0aG91dCBtb2RpZnlpbmcgb3JpZ2luYWwgdG9rZW4uXG4gIC8vIE1heSBiZSwgb25lIGRheSB3ZSB3aWxsIGFkZCAuZGVlcENsb25lKCkgZm9yIHRva2VuIGFuZCBzaW1wbGlmeSB0aGlzIHBhcnQsIGJ1dFxuICAvLyBub3cgd2UgcHJlZmVyIHRvIGtlZXAgdGhpbmdzIGxvY2FsLlxuICBpZiAoaW5mbykge1xuICAgIGkgICAgICAgID0gdG9rZW4uYXR0ckluZGV4KCdjbGFzcycpO1xuICAgIHRtcEF0dHJzID0gdG9rZW4uYXR0cnMgPyB0b2tlbi5hdHRycy5zbGljZSgpIDogW107XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRtcEF0dHJzLnB1c2goWyAnY2xhc3MnLCBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZSBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wQXR0cnNbaV0gPSB0bXBBdHRyc1tpXS5zbGljZSgpO1xuICAgICAgdG1wQXR0cnNbaV1bMV0gKz0gJyAnICsgb3B0aW9ucy5sYW5nUHJlZml4ICsgbGFuZ05hbWU7XG4gICAgfVxuXG4gICAgLy8gRmFrZSB0b2tlbiBqdXN0IHRvIHJlbmRlciBhdHRyaWJ1dGVzXG4gICAgdG1wVG9rZW4gPSB7XG4gICAgICBhdHRyczogdG1wQXR0cnNcbiAgICB9O1xuXG4gICAgcmV0dXJuICAnPHByZT48Y29kZScgKyBzbGYucmVuZGVyQXR0cnModG1wVG9rZW4pICsgJz4nXG4gICAgICAgICAgKyBoaWdobGlnaHRlZFxuICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICB9XG5cblxuICByZXR1cm4gICc8cHJlPjxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPidcbiAgICAgICAgKyBoaWdobGlnaHRlZFxuICAgICAgICArICc8L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5pbWFnZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF07XG5cbiAgLy8gXCJhbHRcIiBhdHRyIE1VU1QgYmUgc2V0LCBldmVuIGlmIGVtcHR5LiBCZWNhdXNlIGl0J3MgbWFuZGF0b3J5IGFuZFxuICAvLyBzaG91bGQgYmUgcGxhY2VkIG9uIHByb3BlciBwb3NpdGlvbiBmb3IgdGVzdHMuXG4gIC8vXG4gIC8vIFJlcGxhY2UgY29udGVudCB3aXRoIGFjdHVhbCB2YWx1ZVxuXG4gIHRva2VuLmF0dHJzW3Rva2VuLmF0dHJJbmRleCgnYWx0JyldWzFdID1cbiAgICBzbGYucmVuZGVySW5saW5lQXNUZXh0KHRva2VuLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuXG4gIHJldHVybiBzbGYucmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmhhcmRicmVhayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbic7XG59O1xuZGVmYXVsdF9ydWxlcy5zb2Z0YnJlYWsgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMgLyosIGVudiAqLykge1xuICByZXR1cm4gb3B0aW9ucy5icmVha3MgPyAob3B0aW9ucy54aHRtbE91dCA/ICc8YnIgLz5cXG4nIDogJzxicj5cXG4nKSA6ICdcXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLnRleHQgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gZXNjYXBlSHRtbCh0b2tlbnNbaWR4XS5jb250ZW50KTtcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5odG1sX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xuZGVmYXVsdF9ydWxlcy5odG1sX2lubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiB0b2tlbnNbaWR4XS5jb250ZW50O1xufTtcblxuXG4vKipcbiAqIG5ldyBSZW5kZXJlcigpXG4gKlxuICogQ3JlYXRlcyBuZXcgW1tSZW5kZXJlcl1dIGluc3RhbmNlIGFuZCBmaWxsIFtbUmVuZGVyZXIjcnVsZXNdXSB3aXRoIGRlZmF1bHRzLlxuICoqL1xuZnVuY3Rpb24gUmVuZGVyZXIoKSB7XG5cbiAgLyoqXG4gICAqIFJlbmRlcmVyI3J1bGVzIC0+IE9iamVjdFxuICAgKlxuICAgKiBDb250YWlucyByZW5kZXIgcnVsZXMgZm9yIHRva2Vucy4gQ2FuIGJlIHVwZGF0ZWQgYW5kIGV4dGVuZGVkLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBtZC5yZW5kZXJlci5ydWxlcy5zdHJvbmdfb3BlbiAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPGI+JzsgfTtcbiAgICogbWQucmVuZGVyZXIucnVsZXMuc3Ryb25nX2Nsb3NlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzwvYj4nOyB9O1xuICAgKlxuICAgKiB2YXIgcmVzdWx0ID0gbWQucmVuZGVySW5saW5lKC4uLik7XG4gICAqIGBgYFxuICAgKlxuICAgKiBFYWNoIHJ1bGUgaXMgY2FsbGVkIGFzIGluZGVwZW5kZW50IHN0YXRpYyBmdW5jdGlvbiB3aXRoIGZpeGVkIHNpZ25hdHVyZTpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiBmdW5jdGlvbiBteV90b2tlbl9yZW5kZXIodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgcmVuZGVyZXIpIHtcbiAgICogICAvLyAuLi5cbiAgICogICByZXR1cm4gcmVuZGVyZWRIVE1MO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKlxuICAgKiBTZWUgW3NvdXJjZSBjb2RlXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3JlbmRlcmVyLmpzKVxuICAgKiBmb3IgbW9yZSBkZXRhaWxzIGFuZCBleGFtcGxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVzID0gYXNzaWduKHt9LCBkZWZhdWx0X3J1bGVzKTtcbn1cblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlckF0dHJzKHRva2VuKSAtPiBTdHJpbmdcbiAqXG4gKiBSZW5kZXIgdG9rZW4gYXR0cmlidXRlcyB0byBzdHJpbmcuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVyQXR0cnMgPSBmdW5jdGlvbiByZW5kZXJBdHRycyh0b2tlbikge1xuICB2YXIgaSwgbCwgcmVzdWx0O1xuXG4gIGlmICghdG9rZW4uYXR0cnMpIHsgcmV0dXJuICcnOyB9XG5cbiAgcmVzdWx0ID0gJyc7XG5cbiAgZm9yIChpID0gMCwgbCA9IHRva2VuLmF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJlc3VsdCArPSAnICcgKyBlc2NhcGVIdG1sKHRva2VuLmF0dHJzW2ldWzBdKSArICc9XCInICsgZXNjYXBlSHRtbCh0b2tlbi5hdHRyc1tpXVsxXSkgKyAnXCInO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucykgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9mIHRva2Vuc1xuICogLSBpZHggKE51bWJlZCk6IHRva2VuIGluZGV4IHRvIHJlbmRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKlxuICogRGVmYXVsdCB0b2tlbiByZW5kZXJlci4gQ2FuIGJlIG92ZXJyaWRlbiBieSBjdXN0b20gZnVuY3Rpb25cbiAqIGluIFtbUmVuZGVyZXIjcnVsZXNdXS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUb2tlbiA9IGZ1bmN0aW9uIHJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKSB7XG4gIHZhciBuZXh0VG9rZW4sXG4gICAgICByZXN1bHQgPSAnJyxcbiAgICAgIG5lZWRMZiA9IGZhbHNlLFxuICAgICAgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICAvLyBUaWdodCBsaXN0IHBhcmFncmFwaHNcbiAgaWYgKHRva2VuLmhpZGRlbikge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIEluc2VydCBhIG5ld2xpbmUgYmV0d2VlbiBoaWRkZW4gcGFyYWdyYXBoIGFuZCBzdWJzZXF1ZW50IG9wZW5pbmdcbiAgLy8gYmxvY2stbGV2ZWwgdGFnLlxuICAvL1xuICAvLyBGb3IgZXhhbXBsZSwgaGVyZSB3ZSBzaG91bGQgaW5zZXJ0IGEgbmV3bGluZSBiZWZvcmUgYmxvY2txdW90ZTpcbiAgLy8gIC0gYVxuICAvLyAgICA+XG4gIC8vXG4gIGlmICh0b2tlbi5ibG9jayAmJiB0b2tlbi5uZXN0aW5nICE9PSAtMSAmJiBpZHggJiYgdG9rZW5zW2lkeCAtIDFdLmhpZGRlbikge1xuICAgIHJlc3VsdCArPSAnXFxuJztcbiAgfVxuXG4gIC8vIEFkZCB0b2tlbiBuYW1lLCBlLmcuIGA8aW1nYFxuICByZXN1bHQgKz0gKHRva2VuLm5lc3RpbmcgPT09IC0xID8gJzwvJyA6ICc8JykgKyB0b2tlbi50YWc7XG5cbiAgLy8gRW5jb2RlIGF0dHJpYnV0ZXMsIGUuZy4gYDxpbWcgc3JjPVwiZm9vXCJgXG4gIHJlc3VsdCArPSB0aGlzLnJlbmRlckF0dHJzKHRva2VuKTtcblxuICAvLyBBZGQgYSBzbGFzaCBmb3Igc2VsZi1jbG9zaW5nIHRhZ3MsIGUuZy4gYDxpbWcgc3JjPVwiZm9vXCIgL2BcbiAgaWYgKHRva2VuLm5lc3RpbmcgPT09IDAgJiYgb3B0aW9ucy54aHRtbE91dCkge1xuICAgIHJlc3VsdCArPSAnIC8nO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgYSBuZXdsaW5lIGFmdGVyIHRoaXMgdGFnXG4gIGlmICh0b2tlbi5ibG9jaykge1xuICAgIG5lZWRMZiA9IHRydWU7XG5cbiAgICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMSkge1xuICAgICAgaWYgKGlkeCArIDEgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIG5leHRUb2tlbiA9IHRva2Vuc1tpZHggKyAxXTtcblxuICAgICAgICBpZiAobmV4dFRva2VuLnR5cGUgPT09ICdpbmxpbmUnIHx8IG5leHRUb2tlbi5oaWRkZW4pIHtcbiAgICAgICAgICAvLyBCbG9jay1sZXZlbCB0YWcgY29udGFpbmluZyBhbiBpbmxpbmUgdGFnLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgbmVlZExmID0gZmFsc2U7XG5cbiAgICAgICAgfSBlbHNlIGlmIChuZXh0VG9rZW4ubmVzdGluZyA9PT0gLTEgJiYgbmV4dFRva2VuLnRhZyA9PT0gdG9rZW4udGFnKSB7XG4gICAgICAgICAgLy8gT3BlbmluZyB0YWcgKyBjbG9zaW5nIHRhZyBvZiB0aGUgc2FtZSB0eXBlLiBFLmcuIGA8bGk+PC9saT5gLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgbmVlZExmID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXN1bHQgKz0gbmVlZExmID8gJz5cXG4nIDogJz4nO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVySW5saW5lKHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbmRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBUaGUgc2FtZSBhcyBbW1JlbmRlcmVyLnJlbmRlcl1dLCBidXQgZm9yIHNpbmdsZSB0b2tlbiBvZiBgaW5saW5lYCB0eXBlLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZSA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgdHlwZSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0eXBlID0gdG9rZW5zW2ldLnR5cGU7XG5cbiAgICBpZiAodHlwZW9mIHJ1bGVzW3R5cGVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmVzdWx0ICs9IHJ1bGVzW3R5cGVdKHRva2VucywgaSwgb3B0aW9ucywgZW52LCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVyVG9rZW4odG9rZW5zLCBpLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKiogaW50ZXJuYWxcbiAqIFJlbmRlcmVyLnJlbmRlcklubGluZUFzVGV4dCh0b2tlbnMsIG9wdGlvbnMsIGVudikgLT4gU3RyaW5nXG4gKiAtIHRva2VucyAoQXJyYXkpOiBsaXN0IG9uIGJsb2NrIHRva2VucyB0byByZW5kZXJcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcGFyYW1zIG9mIHBhcnNlciBpbnN0YW5jZVxuICogLSBlbnYgKE9iamVjdCk6IGFkZGl0aW9uYWwgZGF0YSBmcm9tIHBhcnNlZCBpbnB1dCAocmVmZXJlbmNlcywgZm9yIGV4YW1wbGUpXG4gKlxuICogU3BlY2lhbCBrbHVkZ2UgZm9yIGltYWdlIGBhbHRgIGF0dHJpYnV0ZXMgdG8gY29uZm9ybSBDb21tb25NYXJrIHNwZWMuXG4gKiBEb24ndCB0cnkgdG8gdXNlIGl0ISBTcGVjIHJlcXVpcmVzIHRvIHNob3cgYGFsdGAgY29udGVudCB3aXRoIHN0cmlwcGVkIG1hcmt1cCxcbiAqIGluc3RlYWQgb2Ygc2ltcGxlIGVzY2FwaW5nLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlcklubGluZUFzVGV4dCA9IGZ1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMsIGVudikge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICByZXN1bHQgKz0gdG9rZW5zW2ldLmNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0b2tlbnNbaV0udHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lQXNUZXh0KHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICB9IGVsc2UgaWYgKHRva2Vuc1tpXS50eXBlID09PSAnc29mdGJyZWFrJykge1xuICAgICAgcmVzdWx0ICs9ICdcXG4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyKHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbmRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBUYWtlcyB0b2tlbiBzdHJlYW0gYW5kIGdlbmVyYXRlcyBIVE1MLiBQcm9iYWJseSwgeW91IHdpbGwgbmV2ZXIgbmVlZCB0byBjYWxsXG4gKiB0aGlzIG1ldGhvZCBkaXJlY3RseS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIGksIGxlbiwgdHlwZSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHR5cGUgPSB0b2tlbnNbaV0udHlwZTtcblxuICAgIGlmICh0eXBlID09PSAnaW5saW5lJykge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lKHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBydWxlc1t0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0b2tlbnNbaV0udHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMsIGVudik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XG4iLCIvKipcbiAqIGNsYXNzIFJ1bGVyXG4gKlxuICogSGVscGVyIGNsYXNzLCB1c2VkIGJ5IFtbTWFya2Rvd25JdCNjb3JlXV0sIFtbTWFya2Rvd25JdCNibG9ja11dIGFuZFxuICogW1tNYXJrZG93bkl0I2lubGluZV1dIHRvIG1hbmFnZSBzZXF1ZW5jZXMgb2YgZnVuY3Rpb25zIChydWxlcyk6XG4gKlxuICogLSBrZWVwIHJ1bGVzIGluIGRlZmluZWQgb3JkZXJcbiAqIC0gYXNzaWduIHRoZSBuYW1lIHRvIGVhY2ggcnVsZVxuICogLSBlbmFibGUvZGlzYWJsZSBydWxlc1xuICogLSBhZGQvcmVwbGFjZSBydWxlc1xuICogLSBhbGxvdyBhc3NpZ24gcnVsZXMgdG8gYWRkaXRpb25hbCBuYW1lZCBjaGFpbnMgKGluIHRoZSBzYW1lKVxuICogLSBjYWNoZWluZyBsaXN0cyBvZiBhY3RpdmUgcnVsZXNcbiAqXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSB1bnRpbCB3cml0ZSBwbHVnaW5zLiBGb3Igc2ltcGxlXG4gKiBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dLCBbW01hcmtkb3duSXQuZW5hYmxlXV0gYW5kXG4gKiBbW01hcmtkb3duSXQudXNlXV0uXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBuZXcgUnVsZXIoKVxuICoqL1xuZnVuY3Rpb24gUnVsZXIoKSB7XG4gIC8vIExpc3Qgb2YgYWRkZWQgcnVsZXMuIEVhY2ggZWxlbWVudCBpczpcbiAgLy9cbiAgLy8ge1xuICAvLyAgIG5hbWU6IFhYWCxcbiAgLy8gICBlbmFibGVkOiBCb29sZWFuLFxuICAvLyAgIGZuOiBGdW5jdGlvbigpLFxuICAvLyAgIGFsdDogWyBuYW1lMiwgbmFtZTMgXVxuICAvLyB9XG4gIC8vXG4gIHRoaXMuX19ydWxlc19fID0gW107XG5cbiAgLy8gQ2FjaGVkIHJ1bGUgY2hhaW5zLlxuICAvL1xuICAvLyBGaXJzdCBsZXZlbCAtIGNoYWluIG5hbWUsICcnIGZvciBkZWZhdWx0LlxuICAvLyBTZWNvbmQgbGV2ZWwgLSBkaWdpbmFsIGFuY2hvciBmb3IgZmFzdCBmaWx0ZXJpbmcgYnkgY2hhcmNvZGVzLlxuICAvL1xuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXIgbWV0aG9kcywgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5XG5cblxuLy8gRmluZCBydWxlIGluZGV4IGJ5IG5hbWVcbi8vXG5SdWxlci5wcm90b3R5cGUuX19maW5kX18gPSBmdW5jdGlvbiAobmFtZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX19ydWxlc19fLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuX19ydWxlc19fW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8vIEJ1aWxkIHJ1bGVzIGxvb2t1cCBjYWNoZVxuLy9cblJ1bGVyLnByb3RvdHlwZS5fX2NvbXBpbGVfXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2hhaW5zID0gWyAnJyBdO1xuXG4gIC8vIGNvbGxlY3QgdW5pcXVlIG5hbWVzXG4gIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAoIXJ1bGUuZW5hYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHJ1bGUuYWx0LmZvckVhY2goZnVuY3Rpb24gKGFsdE5hbWUpIHtcbiAgICAgIGlmIChjaGFpbnMuaW5kZXhPZihhbHROYW1lKSA8IDApIHtcbiAgICAgICAgY2hhaW5zLnB1c2goYWx0TmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHNlbGYuX19jYWNoZV9fID0ge307XG5cbiAgY2hhaW5zLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dID0gW107XG4gICAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmIChjaGFpbiAmJiBydWxlLmFsdC5pbmRleE9mKGNoYWluKSA8IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXS5wdXNoKHJ1bGUuZm4pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5hdChuYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gbmFtZSAoU3RyaW5nKTogcnVsZSBuYW1lIHRvIHJlcGxhY2UuXG4gKiAtIGZuIChGdW5jdGlvbik6IG5ldyBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBuZXcgcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBSZXBsYWNlIHJ1bGUgYnkgbmFtZSB3aXRoIG5ldyBmdW5jdGlvbiAmIG9wdGlvbnMuIFRocm93cyBlcnJvciBpZiBuYW1lIG5vdFxuICogZm91bmQuXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBSZXBsYWNlIGV4aXN0aW5nIHR5cG9ncmFwaGVyIHJlcGxhY2VtZW50IHJ1bGUgd2l0aCBuZXcgb25lOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5jb3JlLnJ1bGVyLmF0KCdyZXBsYWNlbWVudHMnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBuYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fW2luZGV4XS5mbiA9IGZuO1xuICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uYWx0ID0gb3B0LmFsdCB8fCBbXTtcbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmJlZm9yZShiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIGJlZm9yZU5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoaXMgb25lLlxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIEFkZCBuZXcgcnVsZSB0byBjaGFpbiBiZWZvcmUgb25lIHdpdGggZ2l2ZW4gbmFtZS4gU2VlIGFsc29cbiAqIFtbUnVsZXIuYWZ0ZXJdXSwgW1tSdWxlci5wdXNoXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuYmxvY2sucnVsZXIuYmVmb3JlKCdwYXJhZ3JhcGgnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24gKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKGJlZm9yZU5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYmVmb3JlTmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXgsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmFmdGVyKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBhZnRlck5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgdGhpcyBvbmUuXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogQWRkIG5ldyBydWxlIHRvIGNoYWluIGFmdGVyIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLnB1c2hdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5pbmxpbmUucnVsZXIuYWZ0ZXIoJ3RleHQnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhhZnRlck5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYWZ0ZXJOYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCArIDEsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSdWxlci5wdXNoKHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBQdXNoIG5ldyBydWxlIHRvIHRoZSBlbmQgb2YgY2hhaW4uIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLmFmdGVyXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5wdXNoKCdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLl9fcnVsZXNfXy5wdXNoKHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmVuYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIGFueSBydWxlIG5hbWUgbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuXG4gKiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgcnVsZSBuYW1lcyAoaWYgbm8gZXhjZXB0aW9uIGhhcHBlbmVkKS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmRpc2FibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICAvLyBTZWFyY2ggYnkgbmFtZSBhbmQgZW5hYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IHRydWU7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5lbmFibGVPbmx5KGxpc3QgWywgaWdub3JlSW52YWxpZF0pXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGUgKHdoaXRlbGlzdCkuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcywgYW5kIGRpc2FibGUgZXZlcnl0aGluZyBlbHNlLiBJZiBhbnkgcnVsZSBuYW1lXG4gKiBub3QgZm91bmQgLSB0aHJvdyBFcnJvci4gRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlXV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlT25seSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB0aGlzLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7IHJ1bGUuZW5hYmxlZCA9IGZhbHNlOyB9KTtcblxuICB0aGlzLmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5kaXNhYmxlKGxpc3QgWywgaWdub3JlSW52YWxpZF0pIC0+IEFycmF5XG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRGlzYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5lbmFibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGRpc2FibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgaWYgKGlnbm9yZUludmFsaWQpIHsgcmV0dXJuOyB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fX3J1bGVzX19baWR4XS5lbmFibGVkID0gZmFsc2U7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5nZXRSdWxlcyhjaGFpbk5hbWUpIC0+IEFycmF5XG4gKlxuICogUmV0dXJuIGFycmF5IG9mIGFjdGl2ZSBmdW5jdGlvbnMgKHJ1bGVzKSBmb3IgZ2l2ZW4gY2hhaW4gbmFtZS4gSXQgYW5hbHl6ZXNcbiAqIHJ1bGVzIGNvbmZpZ3VyYXRpb24sIGNvbXBpbGVzIGNhY2hlcyBpZiBub3QgZXhpc3RzIGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBEZWZhdWx0IGNoYWluIG5hbWUgaXMgYCcnYCAoZW1wdHkgc3RyaW5nKS4gSXQgY2FuJ3QgYmUgc2tpcHBlZC4gVGhhdCdzXG4gKiBkb25lIGludGVudGlvbmFsbHksIHRvIGtlZXAgc2lnbmF0dXJlIG1vbm9tb3JwaGljIGZvciBoaWdoIHNwZWVkLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmdldFJ1bGVzID0gZnVuY3Rpb24gKGNoYWluTmFtZSkge1xuICBpZiAodGhpcy5fX2NhY2hlX18gPT09IG51bGwpIHtcbiAgICB0aGlzLl9fY29tcGlsZV9fKCk7XG4gIH1cblxuICAvLyBDaGFpbiBjYW4gYmUgZW1wdHksIGlmIHJ1bGVzIGRpc2FibGVkLiBCdXQgd2Ugc3RpbGwgaGF2ZSB0byByZXR1cm4gQXJyYXkuXG4gIHJldHVybiB0aGlzLl9fY2FjaGVfX1tjaGFpbk5hbWVdIHx8IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSdWxlcjtcbiIsIi8vIEJsb2NrIHF1b3Rlc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBhZGp1c3RUYWIsXG4gICAgICBjaCxcbiAgICAgIGksXG4gICAgICBpbml0aWFsLFxuICAgICAgbCxcbiAgICAgIGxhc3RMaW5lRW1wdHksXG4gICAgICBsaW5lcyxcbiAgICAgIG5leHRMaW5lLFxuICAgICAgb2Zmc2V0LFxuICAgICAgb2xkQk1hcmtzLFxuICAgICAgb2xkQlNDb3VudCxcbiAgICAgIG9sZEluZGVudCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICBvbGRTQ291bnQsXG4gICAgICBvbGRUU2hpZnQsXG4gICAgICBzcGFjZUFmdGVyTWFya2VyLFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdG9rZW4sXG4gICAgICBpc091dGRlbnRlZCxcbiAgICAgIG9sZExpbmVNYXggPSBzdGF0ZS5saW5lTWF4LFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGNoZWNrIHRoZSBibG9jayBxdW90ZSBtYXJrZXJcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSAhPT0gMHgzRS8qID4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gd2Uga25vdyB0aGF0IGl0J3MgZ29pbmcgdG8gYmUgYSB2YWxpZCBibG9ja3F1b3RlLFxuICAvLyBzbyBubyBwb2ludCB0cnlpbmcgdG8gZmluZCB0aGUgZW5kIG9mIGl0IGluIHNpbGVudCBtb2RlXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBzZXQgb2Zmc2V0IHBhc3Qgc3BhY2VzIGFuZCBcIj5cIlxuICBpbml0aWFsID0gb2Zmc2V0ID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyAxO1xuXG4gIC8vIHNraXAgb25lIG9wdGlvbmFsIHNwYWNlIGFmdGVyICc+J1xuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCAvKiBzcGFjZSAqLykge1xuICAgIC8vICcgPiAgIHRlc3QgJ1xuICAgIC8vICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZTpcbiAgICBwb3MrKztcbiAgICBpbml0aWFsKys7XG4gICAgb2Zmc2V0Kys7XG4gICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwOSAvKiB0YWIgKi8pIHtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcblxuICAgIGlmICgoc3RhdGUuYnNDb3VudFtzdGFydExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgIC8vICcgID5cXHQgIHRlc3QgJ1xuICAgICAgLy8gICAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKHRhYiBoYXMgd2lkdGg9PT0xKVxuICAgICAgcG9zKys7XG4gICAgICBpbml0aWFsKys7XG4gICAgICBvZmZzZXQrKztcbiAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAnID5cXHQgIHRlc3QgJ1xuICAgICAgLy8gICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKyBzaGlmdCBic0NvdW50IHNsaWdodGx5XG4gICAgICAvLyAgICAgICAgIHRvIG1ha2UgZXh0cmEgc3BhY2UgYXBwZWFyXG4gICAgICBhZGp1c3RUYWIgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gZmFsc2U7XG4gIH1cblxuICBvbGRCTWFya3MgPSBbIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdIF07XG4gIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdID0gcG9zO1xuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gKyAoYWRqdXN0VGFiID8gMSA6IDApKSAlIDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBvbGRCU0NvdW50ID0gWyBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMCk7XG5cbiAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XG5cbiAgb2xkU0NvdW50ID0gWyBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldCAtIGluaXRpYWw7XG5cbiAgb2xkVFNoaWZ0ID0gWyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xuXG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdibG9ja3F1b3RlJyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAnYmxvY2txdW90ZSc7XG5cbiAgLy8gU2VhcmNoIHRoZSBlbmQgb2YgdGhlIGJsb2NrXG4gIC8vXG4gIC8vIEJsb2NrIGVuZHMgd2l0aCBlaXRoZXI6XG4gIC8vICAxLiBhbiBlbXB0eSBsaW5lIG91dHNpZGU6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvL1xuICAvLyAgICAgYGBgXG4gIC8vICAyLiBhbiBlbXB0eSBsaW5lIGluc2lkZTpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPlxuICAvLyAgICAgdGVzdFxuICAvLyAgICAgYGBgXG4gIC8vICAzLiBhbm90aGVyIHRhZzpcbiAgLy8gICAgIGBgYFxuICAvLyAgICAgPiB0ZXN0XG4gIC8vICAgICAgLSAtIC1cbiAgLy8gICAgIGBgYFxuICBmb3IgKG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gY2hlY2sgaWYgaXQncyBvdXRkZW50ZWQsIGkuZS4gaXQncyBpbnNpZGUgbGlzdCBpdGVtIGFuZCBpbmRlbnRlZFxuICAgIC8vIGxlc3MgdGhhbiBzYWlkIGxpc3QgaXRlbTpcbiAgICAvL1xuICAgIC8vIGBgYFxuICAgIC8vIDEuIGFueXRoaW5nXG4gICAgLy8gICAgPiBjdXJyZW50IGJsb2NrcXVvdGVcbiAgICAvLyAyLiBjaGVja2luZyB0aGlzIGxpbmVcbiAgICAvLyBgYGBcbiAgICBpc091dGRlbnRlZCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQ7XG5cbiAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaWYgKHBvcyA+PSBtYXgpIHtcbiAgICAgIC8vIENhc2UgMTogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhpcyBsaW5lIGlzIGVtcHR5LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSA9PT0gMHgzRS8qID4gKi8gJiYgIWlzT3V0ZGVudGVkKSB7XG4gICAgICAvLyBUaGlzIGxpbmUgaXMgaW5zaWRlIHRoZSBibG9ja3F1b3RlLlxuXG4gICAgICAvLyBzZXQgb2Zmc2V0IHBhc3Qgc3BhY2VzIGFuZCBcIj5cIlxuICAgICAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyAxO1xuXG4gICAgICAvLyBza2lwIG9uZSBvcHRpb25hbCBzcGFjZSBhZnRlciAnPidcbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDIwIC8qIHNwYWNlICovKSB7XG4gICAgICAgIC8vICcgPiAgIHRlc3QgJ1xuICAgICAgICAvLyAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmU6XG4gICAgICAgIHBvcysrO1xuICAgICAgICBpbml0aWFsKys7XG4gICAgICAgIG9mZnNldCsrO1xuICAgICAgICBhZGp1c3RUYWIgPSBmYWxzZTtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MDkgLyogdGFiICovKSB7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuXG4gICAgICAgIGlmICgoc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyBvZmZzZXQpICUgNCA9PT0gMykge1xuICAgICAgICAgIC8vICcgID5cXHQgIHRlc3QgJ1xuICAgICAgICAgIC8vICAgICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlICh0YWIgaGFzIHdpZHRoPT09MSlcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgICBpbml0aWFsKys7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gJyA+XFx0ICB0ZXN0ICdcbiAgICAgICAgICAvLyAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSArIHNoaWZ0IGJzQ291bnQgc2xpZ2h0bHlcbiAgICAgICAgICAvLyAgICAgICAgIHRvIG1ha2UgZXh0cmEgc3BhY2UgYXBwZWFyXG4gICAgICAgICAgYWRqdXN0VGFiID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BhY2VBZnRlck1hcmtlciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gPSBwb3M7XG5cbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQgLSAob2Zmc2V0ICsgc3RhdGUuYnNDb3VudFtuZXh0TGluZV0gKyAoYWRqdXN0VGFiID8gMSA6IDApKSAlIDQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuXG4gICAgICBsYXN0TGluZUVtcHR5ID0gcG9zID49IG1heDtcblxuICAgICAgb2xkQlNDb3VudC5wdXNoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdKTtcbiAgICAgIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdID0gc3RhdGUuc0NvdW50W25leHRMaW5lXSArIDEgKyAoc3BhY2VBZnRlck1hcmtlciA/IDEgOiAwKTtcblxuICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdID0gb2Zmc2V0IC0gaW5pdGlhbDtcblxuICAgICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS50U2hpZnRbbmV4dExpbmVdID0gcG9zIC0gc3RhdGUuYk1hcmtzW25leHRMaW5lXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIENhc2UgMjogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhlIGxhc3QgbGluZSB3YXMgZW1wdHkuXG4gICAgaWYgKGxhc3RMaW5lRW1wdHkpIHsgYnJlYWs7IH1cblxuICAgIC8vIENhc2UgMzogYW5vdGhlciB0YWcgZm91bmQuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGVybWluYXRlKSB7XG4gICAgICAvLyBRdWlyayB0byBlbmZvcmNlIFwiaGFyZCB0ZXJtaW5hdGlvbiBtb2RlXCIgZm9yIHBhcmFncmFwaHM7XG4gICAgICAvLyBub3JtYWxseSBpZiB5b3UgY2FsbCBgdG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgbmV4dExpbmUpYCxcbiAgICAgIC8vIHBhcmFncmFwaHMgd2lsbCBsb29rIGJlbG93IG5leHRMaW5lIGZvciBwYXJhZ3JhcGggY29udGludWF0aW9uLFxuICAgICAgLy8gYnV0IGlmIGJsb2NrcXVvdGUgaXMgdGVybWluYXRlZCBieSBhbm90aGVyIHRhZywgdGhleSBzaG91bGRuJ3RcbiAgICAgIHN0YXRlLmxpbmVNYXggPSBuZXh0TGluZTtcblxuICAgICAgaWYgKHN0YXRlLmJsa0luZGVudCAhPT0gMCkge1xuICAgICAgICAvLyBzdGF0ZS5ibGtJbmRlbnQgd2FzIG5vbi16ZXJvLCB3ZSBub3cgc2V0IGl0IHRvIHplcm8sXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlIGFsbCBvZmZzZXRzIHRvIGFwcGVhciBhc1xuICAgICAgICAvLyBpZiBpbmRlbnQgd2Fzbid0IGNoYW5nZWRcbiAgICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgICBvbGRTQ291bnQucHVzaChzdGF0ZS5zQ291bnRbbmV4dExpbmVdKTtcbiAgICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSAtPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgb2xkVFNoaWZ0LnB1c2goc3RhdGUudFNoaWZ0W25leHRMaW5lXSk7XG4gICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG5cbiAgICAvLyBBIG5lZ2F0aXZlIGluZGVudGF0aW9uIG1lYW5zIHRoYXQgdGhpcyBpcyBhIHBhcmFncmFwaCBjb250aW51YXRpb25cbiAgICAvL1xuICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPSAtMTtcbiAgfVxuXG4gIG9sZEluZGVudCA9IHN0YXRlLmJsa0luZGVudDtcbiAgc3RhdGUuYmxrSW5kZW50ID0gMDtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdibG9ja3F1b3RlX29wZW4nLCAnYmxvY2txdW90ZScsIDEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG4gIHRva2VuLm1hcCAgICA9IGxpbmVzID0gWyBzdGFydExpbmUsIDAgXTtcblxuICBzdGF0ZS5tZC5ibG9jay50b2tlbml6ZShzdGF0ZSwgc3RhcnRMaW5lLCBuZXh0TGluZSk7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnYmxvY2txdW90ZV9jbG9zZScsICdibG9ja3F1b3RlJywgLTEpO1xuICB0b2tlbi5tYXJrdXAgPSAnPic7XG5cbiAgc3RhdGUubGluZU1heCA9IG9sZExpbmVNYXg7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuICBsaW5lc1sxXSA9IHN0YXRlLmxpbmU7XG5cbiAgLy8gUmVzdG9yZSBvcmlnaW5hbCB0U2hpZnQ7IHRoaXMgbWlnaHQgbm90IGJlIG5lY2Vzc2FyeSBzaW5jZSB0aGUgcGFyc2VyXG4gIC8vIGhhcyBhbHJlYWR5IGJlZW4gaGVyZSwgYnV0IGp1c3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBkbyB0aGF0LlxuICBmb3IgKGkgPSAwOyBpIDwgb2xkVFNoaWZ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3RhdGUuYk1hcmtzW2kgKyBzdGFydExpbmVdID0gb2xkQk1hcmtzW2ldO1xuICAgIHN0YXRlLnRTaGlmdFtpICsgc3RhcnRMaW5lXSA9IG9sZFRTaGlmdFtpXTtcbiAgICBzdGF0ZS5zQ291bnRbaSArIHN0YXJ0TGluZV0gPSBvbGRTQ291bnRbaV07XG4gICAgc3RhdGUuYnNDb3VudFtpICsgc3RhcnRMaW5lXSA9IG9sZEJTQ291bnRbaV07XG4gIH1cbiAgc3RhdGUuYmxrSW5kZW50ID0gb2xkSW5kZW50O1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIENvZGUgYmxvY2sgKDQgc3BhY2VzIHBhZGRlZClcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29kZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBuZXh0TGluZSwgbGFzdCwgdG9rZW47XG5cbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50IDwgNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYXN0ID0gbmV4dExpbmUgPSBzdGFydExpbmUgKyAxO1xuXG4gIHdoaWxlIChuZXh0TGluZSA8IGVuZExpbmUpIHtcbiAgICBpZiAoc3RhdGUuaXNFbXB0eShuZXh0TGluZSkpIHtcbiAgICAgIG5leHRMaW5lKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICBuZXh0TGluZSsrO1xuICAgICAgbGFzdCA9IG5leHRMaW5lO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUubGluZSA9IGxhc3Q7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2NvZGVfYmxvY2snLCAnY29kZScsIDApO1xuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBsYXN0LCA0ICsgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkgKyAnXFxuJztcbiAgdG9rZW4ubWFwICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gZmVuY2VzIChgYGAgbGFuZywgfn5+IGxhbmcpXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZlbmNlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgbWFya2VyLCBsZW4sIHBhcmFtcywgbmV4dExpbmUsIG1lbSwgdG9rZW4sIG1hcmt1cCxcbiAgICAgIGhhdmVFbmRNYXJrZXIgPSBmYWxzZSxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAocG9zICsgMyA+IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChtYXJrZXIgIT09IDB4N0UvKiB+ICovICYmIG1hcmtlciAhPT0gMHg2MCAvKiBgICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gc2NhbiBtYXJrZXIgbGVuZ3RoXG4gIG1lbSA9IHBvcztcbiAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcblxuICBsZW4gPSBwb3MgLSBtZW07XG5cbiAgaWYgKGxlbiA8IDMpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya3VwID0gc3RhdGUuc3JjLnNsaWNlKG1lbSwgcG9zKTtcbiAgcGFyYW1zID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICBpZiAobWFya2VyID09PSAweDYwIC8qIGAgKi8pIHtcbiAgICBpZiAocGFyYW1zLmluZGV4T2YoU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpKSA+PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gU2luY2Ugc3RhcnQgaXMgZm91bmQsIHdlIGNhbiByZXBvcnQgc3VjY2VzcyBoZXJlIGluIHZhbGlkYXRpb24gbW9kZVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gc2VhcmNoIGVuZCBvZiBibG9ja1xuICBuZXh0TGluZSA9IHN0YXJ0TGluZTtcblxuICBmb3IgKDs7KSB7XG4gICAgbmV4dExpbmUrKztcbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkge1xuICAgICAgLy8gdW5jbG9zZWQgYmxvY2sgc2hvdWxkIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIGRvY3VtZW50LlxuICAgICAgLy8gYWxzbyBibG9jayBzZWVtcyB0byBiZSBhdXRvY2xvc2VkIGJ5IGVuZCBvZiBwYXJlbnRcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHBvcyA9IG1lbSA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHtcbiAgICAgIC8vIG5vbi1lbXB0eSBsaW5lIHdpdGggbmVnYXRpdmUgaW5kZW50IHNob3VsZCBzdG9wIHRoZSBsaXN0OlxuICAgICAgLy8gLSBgYGBcbiAgICAgIC8vICB0ZXN0XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gbWFya2VyKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7XG4gICAgICAvLyBjbG9zaW5nIGZlbmNlIHNob3VsZCBiZSBpbmRlbnRlZCBsZXNzIHRoYW4gNCBzcGFjZXNcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG5cbiAgICAvLyBjbG9zaW5nIGNvZGUgZmVuY2UgbXVzdCBiZSBhdCBsZWFzdCBhcyBsb25nIGFzIHRoZSBvcGVuaW5nIG9uZVxuICAgIGlmIChwb3MgLSBtZW0gPCBsZW4pIHsgY29udGludWU7IH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0YWlsIGhhcyBzcGFjZXMgb25seVxuICAgIHBvcyA9IHN0YXRlLnNraXBTcGFjZXMocG9zKTtcblxuICAgIGlmIChwb3MgPCBtYXgpIHsgY29udGludWU7IH1cblxuICAgIGhhdmVFbmRNYXJrZXIgPSB0cnVlO1xuICAgIC8vIGZvdW5kIVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gSWYgYSBmZW5jZSBoYXMgaGVhZGluZyBzcGFjZXMsIHRoZXkgc2hvdWxkIGJlIHJlbW92ZWQgZnJvbSBpdHMgaW5uZXIgYmxvY2tcbiAgbGVuID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV07XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lICsgKGhhdmVFbmRNYXJrZXIgPyAxIDogMCk7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2ZlbmNlJywgJ2NvZGUnLCAwKTtcbiAgdG9rZW4uaW5mbyAgICA9IHBhcmFtcztcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSArIDEsIG5leHRMaW5lLCBsZW4sIHRydWUpO1xuICB0b2tlbi5tYXJrdXAgID0gbWFya3VwO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBoZWFkaW5nICgjLCAjIywgLi4uKVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbGV2ZWwsIHRtcCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgY2ggID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4MjMvKiAjICovIHx8IHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gY291bnQgaGVhZGluZyBsZXZlbFxuICBsZXZlbCA9IDE7XG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpO1xuICB3aGlsZSAoY2ggPT09IDB4MjMvKiAjICovICYmIHBvcyA8IG1heCAmJiBsZXZlbCA8PSA2KSB7XG4gICAgbGV2ZWwrKztcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KCsrcG9zKTtcbiAgfVxuXG4gIGlmIChsZXZlbCA+IDYgfHwgKHBvcyA8IG1heCAmJiAhaXNTcGFjZShjaCkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBMZXQncyBjdXQgdGFpbHMgbGlrZSAnICAgICMjIyAgJyBmcm9tIHRoZSBlbmQgb2Ygc3RyaW5nXG5cbiAgbWF4ID0gc3RhdGUuc2tpcFNwYWNlc0JhY2sobWF4LCBwb3MpO1xuICB0bXAgPSBzdGF0ZS5za2lwQ2hhcnNCYWNrKG1heCwgMHgyMywgcG9zKTsgLy8gI1xuICBpZiAodG1wID4gcG9zICYmIGlzU3BhY2Uoc3RhdGUuc3JjLmNoYXJDb2RlQXQodG1wIC0gMSkpKSB7XG4gICAgbWF4ID0gdG1wO1xuICB9XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19vcGVuJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gIHRva2VuLm1hcmt1cCA9ICcjIyMjIyMjIycuc2xpY2UoMCwgbGV2ZWwpO1xuICB0b2tlbi5tYXAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ICA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCkudHJpbSgpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19jbG9zZScsICdoJyArIFN0cmluZyhsZXZlbCksIC0xKTtcbiAgdG9rZW4ubWFya3VwID0gJyMjIyMjIyMjJy5zbGljZSgwLCBsZXZlbCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gSG9yaXpvbnRhbCBydWxlXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHIoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBtYXJrZXIsIGNudCwgY2gsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tzdGFydExpbmVdO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAvLyBDaGVjayBociBtYXJrZXJcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHg1Ri8qIF8gKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBtYXJrZXJzIGNhbiBiZSBtaXhlZCB3aXRoIHNwYWNlcywgYnV0IHRoZXJlIHNob3VsZCBiZSBhdCBsZWFzdCAzIG9mIHRoZW1cblxuICBjbnQgPSAxO1xuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgaWYgKGNoICE9PSBtYXJrZXIgJiYgIWlzU3BhY2UoY2gpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmIChjaCA9PT0gbWFya2VyKSB7IGNudCsrOyB9XG4gIH1cblxuICBpZiAoY250IDwgMykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgc3RhdGUubGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnaHInLCAnaHInLCAwKTtcbiAgdG9rZW4ubWFwICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4ubWFya3VwID0gQXJyYXkoY250ICsgMSkuam9pbihTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcikpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIEhUTUwgYmxvY2tcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBibG9ja19uYW1lcyA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX2Jsb2NrcycpO1xudmFyIEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9yZScpLkhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG5cbi8vIEFuIGFycmF5IG9mIG9wZW5pbmcgYW5kIGNvcnJlc3BvbmRpbmcgY2xvc2luZyBzZXF1ZW5jZXMgZm9yIGh0bWwgdGFncyxcbi8vIGxhc3QgYXJndW1lbnQgZGVmaW5lcyB3aGV0aGVyIGl0IGNhbiB0ZXJtaW5hdGUgYSBwYXJhZ3JhcGggb3Igbm90XG4vL1xudmFyIEhUTUxfU0VRVUVOQ0VTID0gW1xuICBbIC9ePChzY3JpcHR8cHJlfHN0eWxlfHRleHRhcmVhKSg/PShcXHN8PnwkKSkvaSwgLzxcXC8oc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSk+L2ksIHRydWUgXSxcbiAgWyAvXjwhLS0vLCAgICAgICAgLy0tPi8sICAgdHJ1ZSBdLFxuICBbIC9ePFxcPy8sICAgICAgICAgL1xcPz4vLCAgIHRydWUgXSxcbiAgWyAvXjwhW0EtWl0vLCAgICAgLz4vLCAgICAgdHJ1ZSBdLFxuICBbIC9ePCFcXFtDREFUQVxcWy8sIC9cXF1cXF0+LywgdHJ1ZSBdLFxuICBbIG5ldyBSZWdFeHAoJ148Lz8oJyArIGJsb2NrX25hbWVzLmpvaW4oJ3wnKSArICcpKD89KFxcXFxzfC8/PnwkKSknLCAnaScpLCAvXiQvLCB0cnVlIF0sXG4gIFsgbmV3IFJlZ0V4cChIVE1MX09QRU5fQ0xPU0VfVEFHX1JFLnNvdXJjZSArICdcXFxccyokJyksICAvXiQvLCBmYWxzZSBdXG5dO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHRtbF9ibG9jayhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGksIG5leHRMaW5lLCB0b2tlbiwgbGluZVRleHQsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmh0bWwpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICBmb3IgKGkgPSAwOyBpIDwgSFRNTF9TRVFVRU5DRVMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoSFRNTF9TRVFVRU5DRVNbaV1bMF0udGVzdChsaW5lVGV4dCkpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGlmIChpID09PSBIVE1MX1NFUVVFTkNFUy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkge1xuICAgIC8vIHRydWUgaWYgdGhpcyBzZXF1ZW5jZSBjYW4gYmUgYSB0ZXJtaW5hdG9yLCBmYWxzZSBvdGhlcndpc2VcbiAgICByZXR1cm4gSFRNTF9TRVFVRU5DRVNbaV1bMl07XG4gIH1cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgLy8gSWYgd2UgYXJlIGhlcmUgLSB3ZSBkZXRlY3RlZCBIVE1MIGJsb2NrLlxuICAvLyBMZXQncyByb2xsIGRvd24gdGlsbCBibG9jayBlbmQuXG4gIGlmICghSFRNTF9TRVFVRU5DRVNbaV1bMV0udGVzdChsaW5lVGV4dCkpIHtcbiAgICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lOyBuZXh0TGluZSsrKSB7XG4gICAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG4gICAgICBsaW5lVGV4dCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCk7XG5cbiAgICAgIGlmIChIVE1MX1NFUVVFTkNFU1tpXVsxXS50ZXN0KGxpbmVUZXh0KSkge1xuICAgICAgICBpZiAobGluZVRleHQubGVuZ3RoICE9PSAwKSB7IG5leHRMaW5lKys7IH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdodG1sX2Jsb2NrJywgJycsIDApO1xuICB0b2tlbi5tYXAgICAgID0gWyBzdGFydExpbmUsIG5leHRMaW5lIF07XG4gIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIHRydWUpO1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIGxoZWFkaW5nICgtLS0sID09PSlcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGhlYWRpbmcoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZS8qLCBzaWxlbnQqLykge1xuICB2YXIgY29udGVudCwgdGVybWluYXRlLCBpLCBsLCB0b2tlbiwgcG9zLCBtYXgsIGxldmVsLCBtYXJrZXIsXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDEsIG9sZFBhcmVudFR5cGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygncGFyYWdyYXBoJyk7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncGFyYWdyYXBoJzsgLy8gdXNlIHBhcmFncmFwaCB0byBtYXRjaCB0ZXJtaW5hdG9yUnVsZXNcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy9cbiAgICAvLyBDaGVjayBmb3IgdW5kZXJsaW5lIGluIHNldGV4dCBoZWFkZXJcbiAgICAvL1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgICBpZiAocG9zIDwgbWF4KSB7XG4gICAgICAgIG1hcmtlciA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gMHgyRC8qIC0gKi8gfHwgbWFya2VyID09PSAweDNELyogPSAqLykge1xuICAgICAgICAgIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG4gICAgICAgICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuXG4gICAgICAgICAgaWYgKHBvcyA+PSBtYXgpIHtcbiAgICAgICAgICAgIGxldmVsID0gKG1hcmtlciA9PT0gMHgzRC8qID0gKi8gPyAxIDogMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBpZiAoIWxldmVsKSB7XG4gICAgLy8gRGlkbid0IGZpbmQgdmFsaWQgdW5kZXJsaW5lXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAxO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19vcGVuJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgMSk7XG4gIHRva2VuLm1hcmt1cCAgID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSAtIDEgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2hlYWRpbmdfY2xvc2UnLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAtMSk7XG4gIHRva2VuLm1hcmt1cCAgID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIExpc3RzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbi8vIFNlYXJjaCBgWy0rKl1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFmdGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkge1xuICB2YXIgbWFya2VyLCBwb3MsIG1heCwgY2g7XG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuICAvLyBDaGVjayBidWxsZXRcbiAgaWYgKG1hcmtlciAhPT0gMHgyQS8qICogKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyRC8qIC0gKi8gJiZcbiAgICAgIG1hcmtlciAhPT0gMHgyQi8qICsgKi8pIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgLy8gXCIgLXRlc3QgXCIgLSBpcyBub3QgYSBsaXN0IGl0ZW1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcG9zO1xufVxuXG4vLyBTZWFyY2ggYFxcZCtbLildW1xcbiBdYCwgcmV0dXJucyBuZXh0IHBvcyBhZnRlciBtYXJrZXIgb24gc3VjY2Vzc1xuLy8gb3IgLTEgb24gZmFpbC5cbmZ1bmN0aW9uIHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIHZhciBjaCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSxcbiAgICAgIHBvcyA9IHN0YXJ0LFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gTGlzdCBtYXJrZXIgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMiBjaGFycyAoZGlnaXQgKyBkb3QpXG4gIGlmIChwb3MgKyAxID49IG1heCkgeyByZXR1cm4gLTE7IH1cblxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICBpZiAoY2ggPCAweDMwLyogMCAqLyB8fCBjaCA+IDB4MzkvKiA5ICovKSB7IHJldHVybiAtMTsgfVxuXG4gIGZvciAoOzspIHtcbiAgICAvLyBFT0wgLT4gZmFpbFxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG5cbiAgICBpZiAoY2ggPj0gMHgzMC8qIDAgKi8gJiYgY2ggPD0gMHgzOS8qIDkgKi8pIHtcblxuICAgICAgLy8gTGlzdCBtYXJrZXIgc2hvdWxkIGhhdmUgbm8gbW9yZSB0aGFuIDkgZGlnaXRzXG4gICAgICAvLyAocHJldmVudHMgaW50ZWdlciBvdmVyZmxvdyBpbiBicm93c2VycylcbiAgICAgIGlmIChwb3MgLSBzdGFydCA+PSAxMCkgeyByZXR1cm4gLTE7IH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZm91bmQgdmFsaWQgbWFya2VyXG4gICAgaWYgKGNoID09PSAweDI5LyogKSAqLyB8fCBjaCA9PT0gMHgyZS8qIC4gKi8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmICghaXNTcGFjZShjaCkpIHtcbiAgICAgIC8vIFwiIDEudGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcG9zO1xufVxuXG5mdW5jdGlvbiBtYXJrVGlnaHRQYXJhZ3JhcGhzKHN0YXRlLCBpZHgpIHtcbiAgdmFyIGksIGwsXG4gICAgICBsZXZlbCA9IHN0YXRlLmxldmVsICsgMjtcblxuICBmb3IgKGkgPSBpZHggKyAyLCBsID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDI7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoc3RhdGUudG9rZW5zW2ldLmxldmVsID09PSBsZXZlbCAmJiBzdGF0ZS50b2tlbnNbaV0udHlwZSA9PT0gJ3BhcmFncmFwaF9vcGVuJykge1xuICAgICAgc3RhdGUudG9rZW5zW2kgKyAyXS5oaWRkZW4gPSB0cnVlO1xuICAgICAgc3RhdGUudG9rZW5zW2ldLmhpZGRlbiA9IHRydWU7XG4gICAgICBpICs9IDI7XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0KHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsXG4gICAgICBjb250ZW50U3RhcnQsXG4gICAgICBpLFxuICAgICAgaW5kZW50LFxuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIsXG4gICAgICBpbml0aWFsLFxuICAgICAgaXNPcmRlcmVkLFxuICAgICAgaXRlbUxpbmVzLFxuICAgICAgbCxcbiAgICAgIGxpc3RMaW5lcyxcbiAgICAgIGxpc3RUb2tJZHgsXG4gICAgICBtYXJrZXJDaGFyQ29kZSxcbiAgICAgIG1hcmtlclZhbHVlLFxuICAgICAgbWF4LFxuICAgICAgbmV4dExpbmUsXG4gICAgICBvZmZzZXQsXG4gICAgICBvbGRMaXN0SW5kZW50LFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIG9sZFNDb3VudCxcbiAgICAgIG9sZFRTaGlmdCxcbiAgICAgIG9sZFRpZ2h0LFxuICAgICAgcG9zLFxuICAgICAgcG9zQWZ0ZXJNYXJrZXIsXG4gICAgICBwcmV2RW1wdHlFbmQsXG4gICAgICBzdGFydCxcbiAgICAgIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyxcbiAgICAgIHRva2VuLFxuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IGZhbHNlLFxuICAgICAgdGlnaHQgPSB0cnVlO1xuXG4gIC8vIGlmIGl0J3MgaW5kZW50ZWQgbW9yZSB0aGFuIDMgc3BhY2VzLCBpdCBzaG91bGQgYmUgYSBjb2RlIGJsb2NrXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFNwZWNpYWwgY2FzZTpcbiAgLy8gIC0gaXRlbSAxXG4gIC8vICAgLSBpdGVtIDJcbiAgLy8gICAgLSBpdGVtIDNcbiAgLy8gICAgIC0gaXRlbSA0XG4gIC8vICAgICAgLSB0aGlzIG9uZSBpcyBhIHBhcmFncmFwaCBjb250aW51YXRpb25cbiAgaWYgKHN0YXRlLmxpc3RJbmRlbnQgPj0gMCAmJlxuICAgICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5saXN0SW5kZW50ID49IDQgJiZcbiAgICAgIHN0YXRlLnNDb3VudFtzdGFydExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gbGltaXQgY29uZGl0aW9ucyB3aGVuIGxpc3QgY2FuIGludGVycnVwdFxuICAvLyBhIHBhcmFncmFwaCAodmFsaWRhdGlvbiBtb2RlIG9ubHkpXG4gIGlmIChzaWxlbnQgJiYgc3RhdGUucGFyZW50VHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAvLyBOZXh0IGxpc3QgaXRlbSBzaG91bGQgc3RpbGwgdGVybWluYXRlIHByZXZpb3VzIGxpc3QgaXRlbTtcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBjYW4gZmFpbCBpZiBwbHVnaW5zIHVzZSBibGtJbmRlbnQgYXMgd2VsbCBhcyBsaXN0cyxcbiAgICAvLyBidXQgSSBob3BlIHRoZSBzcGVjIGdldHMgZml4ZWQgbG9uZyBiZWZvcmUgdGhhdCBoYXBwZW5zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZWN0IGxpc3QgdHlwZSBhbmQgcG9zaXRpb24gYWZ0ZXIgbWFya2VyXG4gIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSB0cnVlO1xuICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICBtYXJrZXJWYWx1ZSA9IE51bWJlcihzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvc0FmdGVyTWFya2VyIC0gMSkpO1xuXG4gICAgLy8gSWYgd2UncmUgc3RhcnRpbmcgYSBuZXcgb3JkZXJlZCBsaXN0IHJpZ2h0IGFmdGVyXG4gICAgLy8gYSBwYXJhZ3JhcGgsIGl0IHNob3VsZCBzdGFydCB3aXRoIDEuXG4gICAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGggJiYgbWFya2VyVmFsdWUgIT09IDEpIHJldHVybiBmYWxzZTtcblxuICB9IGVsc2UgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gZmFsc2U7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyB1bm9yZGVyZWQgbGlzdCByaWdodCBhZnRlclxuICAvLyBhIHBhcmFncmFwaCwgZmlyc3QgbGluZSBzaG91bGQgbm90IGJlIGVtcHR5LlxuICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCkge1xuICAgIGlmIChzdGF0ZS5za2lwU3BhY2VzKHBvc0FmdGVyTWFya2VyKSA+PSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2Ugc2hvdWxkIHRlcm1pbmF0ZSBsaXN0IG9uIHN0eWxlIGNoYW5nZS4gUmVtZW1iZXIgZmlyc3Qgb25lIHRvIGNvbXBhcmUuXG4gIG1hcmtlckNoYXJDb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKTtcblxuICAvLyBGb3IgdmFsaWRhdGlvbiBtb2RlIHdlIGNhbiB0ZXJtaW5hdGUgaW1tZWRpYXRlbHlcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIFN0YXJ0IGxpc3RcbiAgbGlzdFRva0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X29wZW4nLCAnb2wnLCAxKTtcbiAgICBpZiAobWFya2VyVmFsdWUgIT09IDEpIHtcbiAgICAgIHRva2VuLmF0dHJzID0gWyBbICdzdGFydCcsIG1hcmtlclZhbHVlIF0gXTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X29wZW4nLCAndWwnLCAxKTtcbiAgfVxuXG4gIHRva2VuLm1hcCAgICA9IGxpc3RMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIC8vXG4gIC8vIEl0ZXJhdGUgbGlzdCBpdGVtc1xuICAvL1xuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuICBwcmV2RW1wdHlFbmQgPSBmYWxzZTtcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2xpc3QnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdsaXN0JztcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgcG9zID0gcG9zQWZ0ZXJNYXJrZXI7XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zQWZ0ZXJNYXJrZXIgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSkgJSA0O1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICBjb250ZW50U3RhcnQgPSBwb3M7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCkge1xuICAgICAgLy8gdHJpbW1pbmcgc3BhY2UgaW4gXCItICAgIFxcbiAgM1wiIGNhc2UsIGluZGVudCBpcyAxIGhlcmVcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSBvZmZzZXQgLSBpbml0aWFsO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIDQgc3BhY2VzLCB0aGUgaW5kZW50IGlzIDFcbiAgICAvLyAodGhlIHJlc3QgaXMganVzdCBpbmRlbnRlZCBjb2RlIGJsb2NrKVxuICAgIGlmIChpbmRlbnRBZnRlck1hcmtlciA+IDQpIHsgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxOyB9XG5cbiAgICAvLyBcIiAgLSAgdGVzdFwiXG4gICAgLy8gIF5eXl5eIC0gY2FsY3VsYXRpbmcgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdGhpbmdcbiAgICBpbmRlbnQgPSBpbml0aWFsICsgaW5kZW50QWZ0ZXJNYXJrZXI7XG5cbiAgICAvLyBSdW4gc3VicGFyc2VyICYgd3JpdGUgdG9rZW5zXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlzdF9pdGVtX29wZW4nLCAnbGknLCAxKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcbiAgICB0b2tlbi5tYXAgICAgPSBpdGVtTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuICAgIGlmIChpc09yZGVyZWQpIHtcbiAgICAgIHRva2VuLmluZm8gPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvc0FmdGVyTWFya2VyIC0gMSk7XG4gICAgfVxuXG4gICAgLy8gY2hhbmdlIGN1cnJlbnQgc3RhdGUsIHRoZW4gcmVzdG9yZSBpdCBhZnRlciBwYXJzZXIgc3ViY2FsbFxuICAgIG9sZFRpZ2h0ID0gc3RhdGUudGlnaHQ7XG4gICAgb2xkVFNoaWZ0ID0gc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgb2xkU0NvdW50ID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV07XG5cbiAgICAvLyAgLSBleGFtcGxlIGxpc3RcbiAgICAvLyBeIGxpc3RJbmRlbnQgcG9zaXRpb24gd2lsbCBiZSBoZXJlXG4gICAgLy8gICBeIGJsa0luZGVudCBwb3NpdGlvbiB3aWxsIGJlIGhlcmVcbiAgICAvL1xuICAgIG9sZExpc3RJbmRlbnQgPSBzdGF0ZS5saXN0SW5kZW50O1xuICAgIHN0YXRlLmxpc3RJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gICAgc3RhdGUuYmxrSW5kZW50ID0gaW5kZW50O1xuXG4gICAgc3RhdGUudGlnaHQgPSB0cnVlO1xuICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gY29udGVudFN0YXJ0IC0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG4gICAgc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gPSBvZmZzZXQ7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCAmJiBzdGF0ZS5pc0VtcHR5KHN0YXJ0TGluZSArIDEpKSB7XG4gICAgICAvLyB3b3JrYXJvdW5kIGZvciB0aGlzIGNhc2VcbiAgICAgIC8vIChsaXN0IGl0ZW0gaXMgZW1wdHksIGxpc3QgdGVybWluYXRlcyBiZWZvcmUgXCJmb29cIik6XG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgLy8gICAtXG4gICAgICAvL1xuICAgICAgLy8gICAgIGZvb1xuICAgICAgLy8gfn5+fn5+fn5cbiAgICAgIHN0YXRlLmxpbmUgPSBNYXRoLm1pbihzdGF0ZS5saW5lICsgMiwgZW5kTGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLm1kLmJsb2NrLnRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIElmIGFueSBvZiBsaXN0IGl0ZW0gaXMgdGlnaHQsIG1hcmsgbGlzdCBhcyB0aWdodFxuICAgIGlmICghc3RhdGUudGlnaHQgfHwgcHJldkVtcHR5RW5kKSB7XG4gICAgICB0aWdodCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBJdGVtIGJlY29tZSBsb29zZSBpZiBmaW5pc2ggd2l0aCBlbXB0eSBsaW5lLFxuICAgIC8vIGJ1dCB3ZSBzaG91bGQgZmlsdGVyIGxhc3QgZWxlbWVudCwgYmVjYXVzZSBpdCBtZWFucyBsaXN0IGZpbmlzaFxuICAgIHByZXZFbXB0eUVuZCA9IChzdGF0ZS5saW5lIC0gc3RhcnRMaW5lKSA+IDEgJiYgc3RhdGUuaXNFbXB0eShzdGF0ZS5saW5lIC0gMSk7XG5cbiAgICBzdGF0ZS5ibGtJbmRlbnQgPSBzdGF0ZS5saXN0SW5kZW50O1xuICAgIHN0YXRlLmxpc3RJbmRlbnQgPSBvbGRMaXN0SW5kZW50O1xuICAgIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID0gb2xkVFNoaWZ0O1xuICAgIHN0YXRlLnNDb3VudFtzdGFydExpbmVdID0gb2xkU0NvdW50O1xuICAgIHN0YXRlLnRpZ2h0ID0gb2xkVGlnaHQ7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaXN0X2l0ZW1fY2xvc2UnLCAnbGknLCAtMSk7XG4gICAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSA9IHN0YXRlLmxpbmU7XG4gICAgaXRlbUxpbmVzWzFdID0gbmV4dExpbmU7XG4gICAgY29udGVudFN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV07XG5cbiAgICBpZiAobmV4dExpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuXG4gICAgLy9cbiAgICAvLyBUcnkgdG8gY2hlY2sgaWYgbGlzdCBpcyB0ZXJtaW5hdGVkIG9yIGNvbnRpbnVlZC5cbiAgICAvL1xuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICAgIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIHRlcm1pbmF0aW5nIGJsb2NrIGZvdW5kXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuXG4gICAgLy8gZmFpbCBpZiBsaXN0IGhhcyBhbm90aGVyIHR5cGVcbiAgICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgICBwb3NBZnRlck1hcmtlciA9IHNraXBPcmRlcmVkTGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxuICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zQWZ0ZXJNYXJrZXIgPSBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgbmV4dExpbmUpO1xuICAgICAgaWYgKHBvc0FmdGVyTWFya2VyIDwgMCkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIGlmIChtYXJrZXJDaGFyQ29kZSAhPT0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKSkgeyBicmVhazsgfVxuICB9XG5cbiAgLy8gRmluYWxpemUgbGlzdFxuICBpZiAoaXNPcmRlcmVkKSB7XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCdvcmRlcmVkX2xpc3RfY2xvc2UnLCAnb2wnLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCdidWxsZXRfbGlzdF9jbG9zZScsICd1bCcsIC0xKTtcbiAgfVxuICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcblxuICBsaXN0TGluZXNbMV0gPSBuZXh0TGluZTtcbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIC8vIG1hcmsgcGFyYWdyYXBocyB0aWdodCBpZiBuZWVkZWRcbiAgaWYgKHRpZ2h0KSB7XG4gICAgbWFya1RpZ2h0UGFyYWdyYXBocyhzdGF0ZSwgbGlzdFRva0lkeCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQYXJhZ3JhcGhcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyYWdyYXBoKHN0YXRlLCBzdGFydExpbmUvKiwgZW5kTGluZSovKSB7XG4gIHZhciBjb250ZW50LCB0ZXJtaW5hdGUsIGksIGwsIHRva2VuLCBvbGRQYXJlbnRUeXBlLFxuICAgICAgbmV4dExpbmUgPSBzdGFydExpbmUgKyAxLFxuICAgICAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3BhcmFncmFwaCcpLFxuICAgICAgZW5kTGluZSA9IHN0YXRlLmxpbmVNYXg7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAncGFyYWdyYXBoJztcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgZmFsc2UpLnRyaW0oKTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdwYXJhZ3JhcGhfb3BlbicsICdwJywgMSk7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG4gIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdwYXJhZ3JhcGhfY2xvc2UnLCAncCcsIC0xKTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlZmVyZW5jZShzdGF0ZSwgc3RhcnRMaW5lLCBfZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGRlc3RFbmRQb3MsXG4gICAgICBkZXN0RW5kTGluZU5vLFxuICAgICAgZW5kTGluZSxcbiAgICAgIGhyZWYsXG4gICAgICBpLFxuICAgICAgbCxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgcmVzLFxuICAgICAgc3RhcnQsXG4gICAgICBzdHIsXG4gICAgICB0ZXJtaW5hdGUsXG4gICAgICB0ZXJtaW5hdG9yUnVsZXMsXG4gICAgICB0aXRsZSxcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSxcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gU2ltcGxlIGNoZWNrIHRvIHF1aWNrbHkgaW50ZXJydXB0IHNjYW4gb24gW2xpbmtdKHVybCkgYXQgdGhlIHN0YXJ0IG9mIGxpbmUuXG4gIC8vIENhbiBiZSB1c2VmdWwgb24gcHJhY3RpY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9pc3N1ZXMvNTRcbiAgd2hpbGUgKCsrcG9zIDwgbWF4KSB7XG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUQgLyogXSAqLyAmJlxuICAgICAgICBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgLSAxKSAhPT0gMHg1Qy8qIFxcICovKSB7XG4gICAgICBpZiAocG9zICsgMSA9PT0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGVuZExpbmUgPSBzdGF0ZS5saW5lTWF4O1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ3JlZmVyZW5jZScpO1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3JlZmVyZW5jZSc7XG5cbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBxdWlyayBmb3IgYmxvY2txdW90ZXMsIHRoaXMgbGluZSBzaG91bGQgYWxyZWFkeSBiZSBjaGVja2VkIGJ5IHRoYXQgcnVsZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgMCkgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gU29tZSB0YWdzIGNhbiB0ZXJtaW5hdGUgcGFyYWdyYXBoIHdpdGhvdXQgZW1wdHkgbGluZS5cbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gIH1cblxuICBzdHIgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG4gIG1heCA9IHN0ci5sZW5ndGg7XG5cbiAgZm9yIChwb3MgPSAxOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHg1QiAvKiBbICovKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMHg1RCAvKiBdICovKSB7XG4gICAgICBsYWJlbEVuZCA9IHBvcztcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4MEEgLyogXFxuICovKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUMgLyogXFwgKi8pIHtcbiAgICAgIHBvcysrO1xuICAgICAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpID09PSAweDBBKSB7XG4gICAgICAgIGxpbmVzKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhYmVsRW5kIDwgMCB8fCBzdHIuY2hhckNvZGVBdChsYWJlbEVuZCArIDEpICE9PSAweDNBLyogOiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgIF5eXiBza2lwIG9wdGlvbmFsIHdoaXRlc3BhY2UgaGVyZVxuICBmb3IgKHBvcyA9IGxhYmVsRW5kICsgMjsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGxpbmVzKys7XG4gICAgfSBlbHNlIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgLyplc2xpbnQgbm8tZW1wdHk6MCovXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFtsYWJlbF06ICAgZGVzdGluYXRpb24gICAndGl0bGUnXG4gIC8vICAgICAgICAgICAgXl5eXl5eXl5eXl4gcGFyc2UgdGhpc1xuICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0ciwgcG9zLCBtYXgpO1xuICBpZiAoIXJlcy5vaykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgaWYgKCFzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gcmVzLnBvcztcbiAgbGluZXMgKz0gcmVzLmxpbmVzO1xuXG4gIC8vIHNhdmUgY3Vyc29yIHN0YXRlLCB3ZSBjb3VsZCByZXF1aXJlIHRvIHJvbGxiYWNrIGxhdGVyXG4gIGRlc3RFbmRQb3MgPSBwb3M7XG4gIGRlc3RFbmRMaW5lTm8gPSBsaW5lcztcblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgXl5eIHNraXBwaW5nIHRob3NlIHNwYWNlc1xuICBzdGFydCA9IHBvcztcbiAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIC8qZXNsaW50IG5vLWVtcHR5OjAqL1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzZSB0aGlzXG4gIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RyLCBwb3MsIG1heCk7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICB0aXRsZSA9IHJlcy5zdHI7XG4gICAgcG9zID0gcmVzLnBvcztcbiAgICBsaW5lcyArPSByZXMubGluZXM7XG4gIH0gZWxzZSB7XG4gICAgdGl0bGUgPSAnJztcbiAgICBwb3MgPSBkZXN0RW5kUG9zO1xuICAgIGxpbmVzID0gZGVzdEVuZExpbmVObztcbiAgfVxuXG4gIC8vIHNraXAgdHJhaWxpbmcgc3BhY2VzIHVudGlsIHRoZSByZXN0IG9mIHRoZSBsaW5lXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBvcyA8IG1heCAmJiBzdHIuY2hhckNvZGVBdChwb3MpICE9PSAweDBBKSB7XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUgYWZ0ZXIgdGl0bGUsXG4gICAgICAvLyBidXQgaXQgY291bGQgc3RpbGwgYmUgYSB2YWxpZCByZWZlcmVuY2UgaWYgd2Ugcm9sbCBiYWNrXG4gICAgICB0aXRsZSA9ICcnO1xuICAgICAgcG9zID0gZGVzdEVuZFBvcztcbiAgICAgIGxpbmVzID0gZGVzdEVuZExpbmVObztcbiAgICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gICAgICAgIHBvcysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQSkge1xuICAgIC8vIGdhcmJhZ2UgYXQgdGhlIGVuZCBvZiB0aGUgbGluZVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGxhYmVsID0gbm9ybWFsaXplUmVmZXJlbmNlKHN0ci5zbGljZSgxLCBsYWJlbEVuZCkpO1xuICBpZiAoIWxhYmVsKSB7XG4gICAgLy8gQ29tbW9uTWFyayAwLjIwIGRpc2FsbG93cyBlbXB0eSBsYWJlbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBSZWZlcmVuY2UgY2FuIG5vdCB0ZXJtaW5hdGUgYW55dGhpbmcuIFRoaXMgY2hlY2sgaXMgZm9yIHNhZmV0eSBvbmx5LlxuICAvKmlzdGFuYnVsIGlnbm9yZSBpZiovXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzID0ge307XG4gIH1cbiAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlc1tsYWJlbF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID0geyB0aXRsZTogdGl0bGUsIGhyZWY6IGhyZWYgfTtcbiAgfVxuXG4gIHN0YXRlLnBhcmVudFR5cGUgPSBvbGRQYXJlbnRUeXBlO1xuXG4gIHN0YXRlLmxpbmUgPSBzdGFydExpbmUgKyBsaW5lcyArIDE7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFBhcnNlciBzdGF0ZSBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUb2tlbiA9IHJlcXVpcmUoJy4uL3Rva2VuJyk7XG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuZnVuY3Rpb24gU3RhdGVCbG9jayhzcmMsIG1kLCBlbnYsIHRva2Vucykge1xuICB2YXIgY2gsIHMsIHN0YXJ0LCBwb3MsIGxlbiwgaW5kZW50LCBvZmZzZXQsIGluZGVudF9mb3VuZDtcblxuICB0aGlzLnNyYyA9IHNyYztcblxuICAvLyBsaW5rIHRvIHBhcnNlciBpbnN0YW5jZVxuICB0aGlzLm1kICAgICA9IG1kO1xuXG4gIHRoaXMuZW52ID0gZW52O1xuXG4gIC8vXG4gIC8vIEludGVybmFsIHN0YXRlIHZhcnRpYWJsZXNcbiAgLy9cblxuICB0aGlzLnRva2VucyA9IHRva2VucztcblxuICB0aGlzLmJNYXJrcyA9IFtdOyAgLy8gbGluZSBiZWdpbiBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMuZU1hcmtzID0gW107ICAvLyBsaW5lIGVuZCBvZmZzZXRzIGZvciBmYXN0IGp1bXBzXG4gIHRoaXMudFNoaWZ0ID0gW107ICAvLyBvZmZzZXRzIG9mIHRoZSBmaXJzdCBub24tc3BhY2UgY2hhcmFjdGVycyAodGFicyBub3QgZXhwYW5kZWQpXG4gIHRoaXMuc0NvdW50ID0gW107ICAvLyBpbmRlbnRzIGZvciBlYWNoIGxpbmUgKHRhYnMgZXhwYW5kZWQpXG5cbiAgLy8gQW4gYW1vdW50IG9mIHZpcnR1YWwgc3BhY2VzICh0YWJzIGV4cGFuZGVkKSBiZXR3ZWVuIGJlZ2lubmluZ1xuICAvLyBvZiBlYWNoIGxpbmUgKGJNYXJrcykgYW5kIHJlYWwgYmVnaW5uaW5nIG9mIHRoYXQgbGluZS5cbiAgLy9cbiAgLy8gSXQgZXhpc3RzIG9ubHkgYXMgYSBoYWNrIGJlY2F1c2UgYmxvY2txdW90ZXMgb3ZlcnJpZGUgYk1hcmtzXG4gIC8vIGxvc2luZyBpbmZvcm1hdGlvbiBpbiB0aGUgcHJvY2Vzcy5cbiAgLy9cbiAgLy8gSXQncyB1c2VkIG9ubHkgd2hlbiBleHBhbmRpbmcgdGFicywgeW91IGNhbiB0aGluayBhYm91dCBpdCBhc1xuICAvLyBhbiBpbml0aWFsIHRhYiBsZW5ndGgsIGUuZy4gYnNDb3VudD0yMSBhcHBsaWVkIHRvIHN0cmluZyBgXFx0MTIzYFxuICAvLyBtZWFucyBmaXJzdCB0YWIgc2hvdWxkIGJlIGV4cGFuZGVkIHRvIDQtMjElNCA9PT0gMyBzcGFjZXMuXG4gIC8vXG4gIHRoaXMuYnNDb3VudCA9IFtdO1xuXG4gIC8vIGJsb2NrIHBhcnNlciB2YXJpYWJsZXNcbiAgdGhpcy5ibGtJbmRlbnQgID0gMDsgLy8gcmVxdWlyZWQgYmxvY2sgY29udGVudCBpbmRlbnQgKGZvciBleGFtcGxlLCBpZiB3ZSBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zaWRlIGEgbGlzdCwgaXQgd291bGQgYmUgcG9zaXRpb25lZCBhZnRlciBsaXN0IG1hcmtlcilcbiAgdGhpcy5saW5lICAgICAgID0gMDsgLy8gbGluZSBpbmRleCBpbiBzcmNcbiAgdGhpcy5saW5lTWF4ICAgID0gMDsgLy8gbGluZXMgY291bnRcbiAgdGhpcy50aWdodCAgICAgID0gZmFsc2U7ICAvLyBsb29zZS90aWdodCBtb2RlIGZvciBsaXN0c1xuICB0aGlzLmRkSW5kZW50ICAgPSAtMTsgLy8gaW5kZW50IG9mIHRoZSBjdXJyZW50IGRkIGJsb2NrICgtMSBpZiB0aGVyZSBpc24ndCBhbnkpXG4gIHRoaXMubGlzdEluZGVudCA9IC0xOyAvLyBpbmRlbnQgb2YgdGhlIGN1cnJlbnQgbGlzdCBibG9jayAoLTEgaWYgdGhlcmUgaXNuJ3QgYW55KVxuXG4gIC8vIGNhbiBiZSAnYmxvY2txdW90ZScsICdsaXN0JywgJ3Jvb3QnLCAncGFyYWdyYXBoJyBvciAncmVmZXJlbmNlJ1xuICAvLyB1c2VkIGluIGxpc3RzIHRvIGRldGVybWluZSBpZiB0aGV5IGludGVycnVwdCBhIHBhcmFncmFwaFxuICB0aGlzLnBhcmVudFR5cGUgPSAncm9vdCc7XG5cbiAgdGhpcy5sZXZlbCA9IDA7XG5cbiAgLy8gcmVuZGVyZXJcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICAvLyBDcmVhdGUgY2FjaGVzXG4gIC8vIEdlbmVyYXRlIG1hcmtlcnMuXG4gIHMgPSB0aGlzLnNyYztcbiAgaW5kZW50X2ZvdW5kID0gZmFsc2U7XG5cbiAgZm9yIChzdGFydCA9IHBvcyA9IGluZGVudCA9IG9mZnNldCA9IDAsIGxlbiA9IHMubGVuZ3RoOyBwb3MgPCBsZW47IHBvcysrKSB7XG4gICAgY2ggPSBzLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmICghaW5kZW50X2ZvdW5kKSB7XG4gICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgaW5kZW50Kys7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IDQgLSBvZmZzZXQgJSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZW50X2ZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4MEEgfHwgcG9zID09PSBsZW4gLSAxKSB7XG4gICAgICBpZiAoY2ggIT09IDB4MEEpIHsgcG9zKys7IH1cbiAgICAgIHRoaXMuYk1hcmtzLnB1c2goc3RhcnQpO1xuICAgICAgdGhpcy5lTWFya3MucHVzaChwb3MpO1xuICAgICAgdGhpcy50U2hpZnQucHVzaChpbmRlbnQpO1xuICAgICAgdGhpcy5zQ291bnQucHVzaChvZmZzZXQpO1xuICAgICAgdGhpcy5ic0NvdW50LnB1c2goMCk7XG5cbiAgICAgIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuICAgICAgaW5kZW50ID0gMDtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBmYWtlIGVudHJ5IHRvIHNpbXBsaWZ5IGNhY2hlIGJvdW5kcyBjaGVja3NcbiAgdGhpcy5iTWFya3MucHVzaChzLmxlbmd0aCk7XG4gIHRoaXMuZU1hcmtzLnB1c2gocy5sZW5ndGgpO1xuICB0aGlzLnRTaGlmdC5wdXNoKDApO1xuICB0aGlzLnNDb3VudC5wdXNoKDApO1xuICB0aGlzLmJzQ291bnQucHVzaCgwKTtcblxuICB0aGlzLmxpbmVNYXggPSB0aGlzLmJNYXJrcy5sZW5ndGggLSAxOyAvLyBkb24ndCBjb3VudCBsYXN0IGZha2UgbGluZVxufVxuXG4vLyBQdXNoIG5ldyB0b2tlbiB0byBcInN0cmVhbVwiLlxuLy9cblN0YXRlQmxvY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpO1xuICB0b2tlbi5ibG9jayA9IHRydWU7XG5cbiAgaWYgKG5lc3RpbmcgPCAwKSB0aGlzLmxldmVsLS07IC8vIGNsb3NpbmcgdGFnXG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcbiAgaWYgKG5lc3RpbmcgPiAwKSB0aGlzLmxldmVsKys7IC8vIG9wZW5pbmcgdGFnXG5cbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblN0YXRlQmxvY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5KGxpbmUpIHtcbiAgcmV0dXJuIHRoaXMuYk1hcmtzW2xpbmVdICsgdGhpcy50U2hpZnRbbGluZV0gPj0gdGhpcy5lTWFya3NbbGluZV07XG59O1xuXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwRW1wdHlMaW5lcyA9IGZ1bmN0aW9uIHNraXBFbXB0eUxpbmVzKGZyb20pIHtcbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5saW5lTWF4OyBmcm9tIDwgbWF4OyBmcm9tKyspIHtcbiAgICBpZiAodGhpcy5iTWFya3NbZnJvbV0gKyB0aGlzLnRTaGlmdFtmcm9tXSA8IHRoaXMuZU1hcmtzW2Zyb21dKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZyb207XG59O1xuXG4vLyBTa2lwIHNwYWNlcyBmcm9tIGdpdmVuIHBvc2l0aW9uLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcFNwYWNlcyA9IGZ1bmN0aW9uIHNraXBTcGFjZXMocG9zKSB7XG4gIHZhciBjaDtcblxuICBmb3IgKHZhciBtYXggPSB0aGlzLnNyYy5sZW5ndGg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgc3BhY2VzIGZyb20gZ2l2ZW4gcG9zaXRpb24gaW4gcmV2ZXJzZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBTcGFjZXNCYWNrID0gZnVuY3Rpb24gc2tpcFNwYWNlc0JhY2socG9zLCBtaW4pIHtcbiAgaWYgKHBvcyA8PSBtaW4pIHsgcmV0dXJuIHBvczsgfVxuXG4gIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICBpZiAoIWlzU3BhY2UodGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIFNraXAgY2hhciBjb2RlcyBmcm9tIGdpdmVuIHBvc2l0aW9uXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwQ2hhcnMgPSBmdW5jdGlvbiBza2lwQ2hhcnMocG9zLCBjb2RlKSB7XG4gIGZvciAodmFyIG1heCA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGlmICh0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IGNvZGUpIHsgYnJlYWs7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBjaGFyIGNvZGVzIHJldmVyc2UgZnJvbSBnaXZlbiBwb3NpdGlvbiAtIDFcblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBDaGFyc0JhY2sgPSBmdW5jdGlvbiBza2lwQ2hhcnNCYWNrKHBvcywgY29kZSwgbWluKSB7XG4gIGlmIChwb3MgPD0gbWluKSB7IHJldHVybiBwb3M7IH1cblxuICB3aGlsZSAocG9zID4gbWluKSB7XG4gICAgaWYgKGNvZGUgIT09IHRoaXMuc3JjLmNoYXJDb2RlQXQoLS1wb3MpKSB7IHJldHVybiBwb3MgKyAxOyB9XG4gIH1cbiAgcmV0dXJuIHBvcztcbn07XG5cbi8vIGN1dCBsaW5lcyByYW5nZSBmcm9tIHNvdXJjZS5cblN0YXRlQmxvY2sucHJvdG90eXBlLmdldExpbmVzID0gZnVuY3Rpb24gZ2V0TGluZXMoYmVnaW4sIGVuZCwgaW5kZW50LCBrZWVwTGFzdExGKSB7XG4gIHZhciBpLCBsaW5lSW5kZW50LCBjaCwgZmlyc3QsIGxhc3QsIHF1ZXVlLCBsaW5lU3RhcnQsXG4gICAgICBsaW5lID0gYmVnaW47XG5cbiAgaWYgKGJlZ2luID49IGVuZCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHF1ZXVlID0gbmV3IEFycmF5KGVuZCAtIGJlZ2luKTtcblxuICBmb3IgKGkgPSAwOyBsaW5lIDwgZW5kOyBsaW5lKyssIGkrKykge1xuICAgIGxpbmVJbmRlbnQgPSAwO1xuICAgIGxpbmVTdGFydCA9IGZpcnN0ID0gdGhpcy5iTWFya3NbbGluZV07XG5cbiAgICBpZiAobGluZSArIDEgPCBlbmQgfHwga2VlcExhc3RMRikge1xuICAgICAgLy8gTm8gbmVlZCBmb3IgYm91bmRzIGNoZWNrIGJlY2F1c2Ugd2UgaGF2ZSBmYWtlIGVudHJ5IG9uIHRhaWwuXG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV0gKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gdGhpcy5lTWFya3NbbGluZV07XG4gICAgfVxuXG4gICAgd2hpbGUgKGZpcnN0IDwgbGFzdCAmJiBsaW5lSW5kZW50IDwgaW5kZW50KSB7XG4gICAgICBjaCA9IHRoaXMuc3JjLmNoYXJDb2RlQXQoZmlyc3QpO1xuXG4gICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgbGluZUluZGVudCArPSA0IC0gKGxpbmVJbmRlbnQgKyB0aGlzLmJzQ291bnRbbGluZV0pICUgNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZmlyc3QgLSBsaW5lU3RhcnQgPCB0aGlzLnRTaGlmdFtsaW5lXSkge1xuICAgICAgICAvLyBwYXRjaGVkIHRTaGlmdCBtYXNrZWQgY2hhcmFjdGVycyB0byBsb29rIGxpa2Ugc3BhY2VzIChibG9ja3F1b3RlcywgbGlzdCBtYXJrZXJzKVxuICAgICAgICBsaW5lSW5kZW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZmlyc3QrKztcbiAgICB9XG5cbiAgICBpZiAobGluZUluZGVudCA+IGluZGVudCkge1xuICAgICAgLy8gcGFydGlhbGx5IGV4cGFuZGluZyB0YWJzIGluIGNvZGUgYmxvY2tzLCBlLmcgJ1xcdFxcdGZvb2JhcidcbiAgICAgIC8vIHdpdGggaW5kZW50PTIgYmVjb21lcyAnICBcXHRmb29iYXInXG4gICAgICBxdWV1ZVtpXSA9IG5ldyBBcnJheShsaW5lSW5kZW50IC0gaW5kZW50ICsgMSkuam9pbignICcpICsgdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZVtpXSA9IHRoaXMuc3JjLnNsaWNlKGZpcnN0LCBsYXN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcXVldWUuam9pbignJyk7XG59O1xuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGJsb2NrIHJ1bGVzXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVCbG9jaztcbiIsIi8vIEdGTSB0YWJsZSwgaHR0cHM6Ly9naXRodWIuZ2l0aHViLmNvbS9nZm0vI3RhYmxlcy1leHRlbnNpb24tXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbmZ1bmN0aW9uIGdldExpbmUoc3RhdGUsIGxpbmUpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLmJNYXJrc1tsaW5lXSArIHN0YXRlLnRTaGlmdFtsaW5lXSxcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tsaW5lXTtcblxuICByZXR1cm4gc3RhdGUuc3JjLnN1YnN0cihwb3MsIG1heCAtIHBvcyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZWRTcGxpdChzdHIpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgcG9zID0gMCxcbiAgICAgIG1heCA9IHN0ci5sZW5ndGgsXG4gICAgICBjaCxcbiAgICAgIGlzRXNjYXBlZCA9IGZhbHNlLFxuICAgICAgbGFzdFBvcyA9IDAsXG4gICAgICBjdXJyZW50ID0gJyc7XG5cbiAgY2ggID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgaWYgKGNoID09PSAweDdjLyogfCAqLykge1xuICAgICAgaWYgKCFpc0VzY2FwZWQpIHtcbiAgICAgICAgLy8gcGlwZSBzZXBhcmF0aW5nIGNlbGxzLCAnfCdcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCArIHN0ci5zdWJzdHJpbmcobGFzdFBvcywgcG9zKSk7XG4gICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgbGFzdFBvcyA9IHBvcyArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlc2NhcGVkIHBpcGUsICdcXHwnXG4gICAgICAgIGN1cnJlbnQgKz0gc3RyLnN1YnN0cmluZyhsYXN0UG9zLCBwb3MgLSAxKTtcbiAgICAgICAgbGFzdFBvcyA9IHBvcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0VzY2FwZWQgPSAoY2ggPT09IDB4NWMvKiBcXCAqLyk7XG4gICAgcG9zKys7XG5cbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gIH1cblxuICByZXN1bHQucHVzaChjdXJyZW50ICsgc3RyLnN1YnN0cmluZyhsYXN0UG9zKSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRhYmxlKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsIGxpbmVUZXh0LCBwb3MsIGksIGwsIG5leHRMaW5lLCBjb2x1bW5zLCBjb2x1bW5Db3VudCwgdG9rZW4sXG4gICAgICBhbGlnbnMsIHQsIHRhYmxlTGluZXMsIHRib2R5TGluZXMsIG9sZFBhcmVudFR5cGUsIHRlcm1pbmF0ZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcywgZmlyc3RDaCwgc2Vjb25kQ2g7XG5cbiAgLy8gc2hvdWxkIGhhdmUgYXQgbGVhc3QgdHdvIGxpbmVzXG4gIGlmIChzdGFydExpbmUgKyAyID4gZW5kTGluZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIHNlY29uZCBsaW5lIHNob3VsZCBiZSAnfCcsICctJywgJzonLFxuICAvLyBhbmQgbm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgYWxsb3dlZCBidXQgc3BhY2VzO1xuICAvLyBiYXNpY2FsbHksIHRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgL15bLTp8XVstOnxcXHNdKiQvIHJlZ2V4cFxuXG4gIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICBpZiAocG9zID49IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgZmlyc3RDaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgaWYgKGZpcnN0Q2ggIT09IDB4N0MvKiB8ICovICYmIGZpcnN0Q2ggIT09IDB4MkQvKiAtICovICYmIGZpcnN0Q2ggIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChwb3MgPj0gc3RhdGUuZU1hcmtzW25leHRMaW5lXSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBzZWNvbmRDaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgaWYgKHNlY29uZENoICE9PSAweDdDLyogfCAqLyAmJiBzZWNvbmRDaCAhPT0gMHgyRC8qIC0gKi8gJiYgc2Vjb25kQ2ggIT09IDB4M0EvKiA6ICovICYmICFpc1NwYWNlKHNlY29uZENoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGlmIGZpcnN0IGNoYXJhY3RlciBpcyAnLScsIHRoZW4gc2Vjb25kIGNoYXJhY3RlciBtdXN0IG5vdCBiZSBhIHNwYWNlXG4gIC8vIChkdWUgdG8gcGFyc2luZyBhbWJpZ3VpdHkgd2l0aCBsaXN0KVxuICBpZiAoZmlyc3RDaCA9PT0gMHgyRC8qIC0gKi8gJiYgaXNTcGFjZShzZWNvbmRDaCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgd2hpbGUgKHBvcyA8IHN0YXRlLmVNYXJrc1tuZXh0TGluZV0pIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY2ggIT09IDB4N0MvKiB8ICovICYmIGNoICE9PSAweDJELyogLSAqLyAmJiBjaCAhPT0gMHgzQS8qIDogKi8gJiYgIWlzU3BhY2UoY2gpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSArIDEpO1xuXG4gIGNvbHVtbnMgPSBsaW5lVGV4dC5zcGxpdCgnfCcpO1xuICBhbGlnbnMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0ID0gY29sdW1uc1tpXS50cmltKCk7XG4gICAgaWYgKCF0KSB7XG4gICAgICAvLyBhbGxvdyBlbXB0eSBjb2x1bW5zIGJlZm9yZSBhbmQgYWZ0ZXIgdGFibGUsIGJ1dCBub3QgaW4gYmV0d2VlbiBjb2x1bW5zO1xuICAgICAgLy8gZS5nLiBhbGxvdyBgIHwtLS18IGAsIGRpc2FsbG93IGAgLS0tfHwtLS0gYFxuICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gY29sdW1ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL146Py0rOj8kLy50ZXN0KHQpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmICh0LmNoYXJDb2RlQXQodC5sZW5ndGggLSAxKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8gPyAnY2VudGVyJyA6ICdyaWdodCcpO1xuICAgIH0gZWxzZSBpZiAodC5jaGFyQ29kZUF0KDApID09PSAweDNBLyogOiAqLykge1xuICAgICAgYWxpZ25zLnB1c2goJ2xlZnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ25zLnB1c2goJycpO1xuICAgIH1cbiAgfVxuXG4gIGxpbmVUZXh0ID0gZ2V0TGluZShzdGF0ZSwgc3RhcnRMaW5lKS50cmltKCk7XG4gIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dCk7XG4gIGlmIChjb2x1bW5zLmxlbmd0aCAmJiBjb2x1bW5zWzBdID09PSAnJykgY29sdW1ucy5zaGlmdCgpO1xuICBpZiAoY29sdW1ucy5sZW5ndGggJiYgY29sdW1uc1tjb2x1bW5zLmxlbmd0aCAtIDFdID09PSAnJykgY29sdW1ucy5wb3AoKTtcblxuICAvLyBoZWFkZXIgcm93IHdpbGwgZGVmaW5lIGFuIGFtb3VudCBvZiBjb2x1bW5zIGluIHRoZSBlbnRpcmUgdGFibGUsXG4gIC8vIGFuZCBhbGlnbiByb3cgc2hvdWxkIGJlIGV4YWN0bHkgdGhlIHNhbWUgKHRoZSByZXN0IG9mIHRoZSByb3dzIGNhbiBkaWZmZXIpXG4gIGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGg7XG4gIGlmIChjb2x1bW5Db3VudCA9PT0gMCB8fCBjb2x1bW5Db3VudCAhPT0gYWxpZ25zLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAndGFibGUnO1xuXG4gIC8vIHVzZSAnYmxvY2txdW90ZScgbGlzdHMgZm9yIHRlcm1pbmF0aW9uIGJlY2F1c2UgaXQnc1xuICAvLyB0aGUgbW9zdCBzaW1pbGFyIHRvIHRhYmxlc1xuICB0ZXJtaW5hdG9yUnVsZXMgPSBzdGF0ZS5tZC5ibG9jay5ydWxlci5nZXRSdWxlcygnYmxvY2txdW90ZScpO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RhYmxlX29wZW4nLCAndGFibGUnLCAxKTtcbiAgdG9rZW4ubWFwID0gdGFibGVMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndGhlYWRfb3BlbicsICd0aGVhZCcsIDEpO1xuICB0b2tlbi5tYXAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RyX29wZW4nLCAndHInLCAxKTtcbiAgdG9rZW4ubWFwID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgY29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgndGhfb3BlbicsICd0aCcsIDEpO1xuICAgIGlmIChhbGlnbnNbaV0pIHtcbiAgICAgIHRva2VuLmF0dHJzICA9IFsgWyAnc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldIF0gXTtcbiAgICB9XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ICA9IGNvbHVtbnNbaV0udHJpbSgpO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RoX2Nsb3NlJywgJ3RoJywgLTEpO1xuICB9XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndHJfY2xvc2UnLCAndHInLCAtMSk7XG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RoZWFkX2Nsb3NlJywgJ3RoZWFkJywgLTEpO1xuXG4gIGZvciAobmV4dExpbmUgPSBzdGFydExpbmUgKyAyOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG4gICAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBuZXh0TGluZSkudHJpbSgpO1xuICAgIGlmICghbGluZVRleHQpIHsgYnJlYWs7IH1cbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IGJyZWFrOyB9XG4gICAgY29sdW1ucyA9IGVzY2FwZWRTcGxpdChsaW5lVGV4dCk7XG4gICAgaWYgKGNvbHVtbnMubGVuZ3RoICYmIGNvbHVtbnNbMF0gPT09ICcnKSBjb2x1bW5zLnNoaWZ0KCk7XG4gICAgaWYgKGNvbHVtbnMubGVuZ3RoICYmIGNvbHVtbnNbY29sdW1ucy5sZW5ndGggLSAxXSA9PT0gJycpIGNvbHVtbnMucG9wKCk7XG5cbiAgICBpZiAobmV4dExpbmUgPT09IHN0YXJ0TGluZSArIDIpIHtcbiAgICAgIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3Rib2R5X29wZW4nLCAndGJvZHknLCAxKTtcbiAgICAgIHRva2VuLm1hcCA9IHRib2R5TGluZXMgPSBbIHN0YXJ0TGluZSArIDIsIDAgXTtcbiAgICB9XG5cbiAgICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0cl9vcGVuJywgJ3RyJywgMSk7XG4gICAgdG9rZW4ubWFwID0gWyBuZXh0TGluZSwgbmV4dExpbmUgKyAxIF07XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9vcGVuJywgJ3RkJywgMSk7XG4gICAgICBpZiAoYWxpZ25zW2ldKSB7XG4gICAgICAgIHRva2VuLmF0dHJzICA9IFsgWyAnc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldIF0gXTtcbiAgICAgIH1cblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ICA9IGNvbHVtbnNbaV0gPyBjb2x1bW5zW2ldLnRyaW0oKSA6ICcnO1xuICAgICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9jbG9zZScsICd0ZCcsIC0xKTtcbiAgICB9XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKTtcbiAgfVxuXG4gIGlmICh0Ym9keUxpbmVzKSB7XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0Ym9keV9jbG9zZScsICd0Ym9keScsIC0xKTtcbiAgICB0Ym9keUxpbmVzWzFdID0gbmV4dExpbmU7XG4gIH1cblxuICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RhYmxlX2Nsb3NlJywgJ3RhYmxlJywgLTEpO1xuICB0YWJsZUxpbmVzWzFdID0gbmV4dExpbmU7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2soc3RhdGUpIHtcbiAgdmFyIHRva2VuO1xuXG4gIGlmIChzdGF0ZS5pbmxpbmVNb2RlKSB7XG4gICAgdG9rZW4gICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ICA9IHN0YXRlLnNyYztcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgMCwgMSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG4gICAgc3RhdGUudG9rZW5zLnB1c2godG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLm1kLmJsb2NrLnBhcnNlKHN0YXRlLnNyYywgc3RhdGUubWQsIHN0YXRlLmVudiwgc3RhdGUudG9rZW5zKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmUoc3RhdGUpIHtcbiAgdmFyIHRva2VucyA9IHN0YXRlLnRva2VucywgdG9rLCBpLCBsO1xuXG4gIC8vIFBhcnNlIGlubGluZXNcbiAgZm9yIChpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0b2sgPSB0b2tlbnNbaV07XG4gICAgaWYgKHRvay50eXBlID09PSAnaW5saW5lJykge1xuICAgICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKHRvay5jb250ZW50LCBzdGF0ZS5tZCwgc3RhdGUuZW52LCB0b2suY2hpbGRyZW4pO1xuICAgIH1cbiAgfVxufTtcbiIsIi8vIFJlcGxhY2UgbGluay1saWtlIHRleHRzIHdpdGggbGluayBub2Rlcy5cbi8vXG4vLyBDdXJyZW50bHkgcmVzdHJpY3RlZCBieSBgbWQudmFsaWRhdGVMaW5rKClgIHRvIGh0dHAvaHR0cHMvZnRwXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhcnJheVJlcGxhY2VBdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmFycmF5UmVwbGFjZUF0O1xuXG5cbmZ1bmN0aW9uIGlzTGlua09wZW4oc3RyKSB7XG4gIHJldHVybiAvXjxhWz5cXHNdL2kudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNMaW5rQ2xvc2Uoc3RyKSB7XG4gIHJldHVybiAvXjxcXC9hXFxzKj4vaS50ZXN0KHN0cik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5raWZ5KHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsLCB0b2tlbnMsIHRva2VuLCBjdXJyZW50VG9rZW4sIG5vZGVzLCBsbiwgdGV4dCwgcG9zLCBsYXN0UG9zLFxuICAgICAgbGV2ZWwsIGh0bWxMaW5rTGV2ZWwsIHVybCwgZnVsbFVybCwgdXJsVGV4dCxcbiAgICAgIGJsb2NrVG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbGlua3M7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmxpbmtpZnkpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChqID0gMCwgbCA9IGJsb2NrVG9rZW5zLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGlmIChibG9ja1Rva2Vuc1tqXS50eXBlICE9PSAnaW5saW5lJyB8fFxuICAgICAgICAhc3RhdGUubWQubGlua2lmeS5wcmV0ZXN0KGJsb2NrVG9rZW5zW2pdLmNvbnRlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0b2tlbnMgPSBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbjtcblxuICAgIGh0bWxMaW5rTGV2ZWwgPSAwO1xuXG4gICAgLy8gV2Ugc2NhbiBmcm9tIHRoZSBlbmQsIHRvIGtlZXAgcG9zaXRpb24gd2hlbiBuZXcgdGFncyBhZGRlZC5cbiAgICAvLyBVc2UgcmV2ZXJzZWQgbG9naWMgaW4gbGlua3Mgc3RhcnQvZW5kIG1hdGNoXG4gICAgZm9yIChpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjdXJyZW50VG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBtYXJrZG93biBsaW5rc1xuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAnbGlua19jbG9zZScpIHtcbiAgICAgICAgaS0tO1xuICAgICAgICB3aGlsZSAodG9rZW5zW2ldLmxldmVsICE9PSBjdXJyZW50VG9rZW4ubGV2ZWwgJiYgdG9rZW5zW2ldLnR5cGUgIT09ICdsaW5rX29wZW4nKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgaHRtbCB0YWcgbGlua3NcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2h0bWxfaW5saW5lJykge1xuICAgICAgICBpZiAoaXNMaW5rT3BlbihjdXJyZW50VG9rZW4uY29udGVudCkgJiYgaHRtbExpbmtMZXZlbCA+IDApIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGlua0Nsb3NlKGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xuICAgICAgICAgIGh0bWxMaW5rTGV2ZWwrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGh0bWxMaW5rTGV2ZWwgPiAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIHN0YXRlLm1kLmxpbmtpZnkudGVzdChjdXJyZW50VG9rZW4uY29udGVudCkpIHtcblxuICAgICAgICB0ZXh0ID0gY3VycmVudFRva2VuLmNvbnRlbnQ7XG4gICAgICAgIGxpbmtzID0gc3RhdGUubWQubGlua2lmeS5tYXRjaCh0ZXh0KTtcblxuICAgICAgICAvLyBOb3cgc3BsaXQgc3RyaW5nIHRvIG5vZGVzXG4gICAgICAgIG5vZGVzID0gW107XG4gICAgICAgIGxldmVsID0gY3VycmVudFRva2VuLmxldmVsO1xuICAgICAgICBsYXN0UG9zID0gMDtcblxuICAgICAgICBmb3IgKGxuID0gMDsgbG4gPCBsaW5rcy5sZW5ndGg7IGxuKyspIHtcblxuICAgICAgICAgIHVybCA9IGxpbmtzW2xuXS51cmw7XG4gICAgICAgICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdXJsVGV4dCA9IGxpbmtzW2xuXS50ZXh0O1xuXG4gICAgICAgICAgLy8gTGlua2lmaWVyIG1pZ2h0IHNlbmQgcmF3IGhvc3RuYW1lcyBsaWtlIFwiZXhhbXBsZS5jb21cIiwgd2hlcmUgdXJsXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggZG9tYWluIG5hbWUuIFNvIHdlIHByZXBlbmQgaHR0cDovLyBpbiB0aG9zZSBjYXNlcyxcbiAgICAgICAgICAvLyBhbmQgcmVtb3ZlIGl0IGFmdGVyd2FyZHMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoIWxpbmtzW2xuXS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnaHR0cDovLycgKyB1cmxUZXh0KS5yZXBsYWNlKC9eaHR0cDpcXC9cXC8vLCAnJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5rc1tsbl0uc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QodXJsVGV4dCkpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnbWFpbHRvOicgKyB1cmxUZXh0KS5yZXBsYWNlKC9ebWFpbHRvOi8sICcnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybFRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvcyA9IGxpbmtzW2xuXS5pbmRleDtcblxuICAgICAgICAgIGlmIChwb3MgPiBsYXN0UG9zKSB7XG4gICAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQuc2xpY2UobGFzdFBvcywgcG9zKTtcbiAgICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICAgICAgdG9rZW4uYXR0cnMgICA9IFsgWyAnaHJlZicsIGZ1bGxVcmwgXSBdO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbCsrO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHVybFRleHQ7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignbGlua19jbG9zZScsICdhJywgLTEpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSAtLWxldmVsO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIGxhc3RQb3MgPSBsaW5rc1tsbl0ubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UG9zIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0LnNsaWNlKGxhc3RQb3MpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2UgY3VycmVudCBub2RlXG4gICAgICAgIGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuID0gdG9rZW5zID0gYXJyYXlSZXBsYWNlQXQodG9rZW5zLCBpLCBub2Rlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIiwiLy8gTm9ybWFsaXplIGlucHV0IHN0cmluZ1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gaHR0cHM6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMjkvI2xpbmUtZW5kaW5nXG52YXIgTkVXTElORVNfUkUgID0gL1xcclxcbj98XFxuL2c7XG52YXIgTlVMTF9SRSAgICAgID0gL1xcMC9nO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplKHN0YXRlKSB7XG4gIHZhciBzdHI7XG5cbiAgLy8gTm9ybWFsaXplIG5ld2xpbmVzXG4gIHN0ciA9IHN0YXRlLnNyYy5yZXBsYWNlKE5FV0xJTkVTX1JFLCAnXFxuJyk7XG5cbiAgLy8gUmVwbGFjZSBOVUxMIGNoYXJhY3RlcnNcbiAgc3RyID0gc3RyLnJlcGxhY2UoTlVMTF9SRSwgJ1xcdUZGRkQnKTtcblxuICBzdGF0ZS5zcmMgPSBzdHI7XG59O1xuIiwiLy8gU2ltcGxlIHR5cG9ncmFwaGljIHJlcGxhY2VtZW50c1xuLy9cbi8vIChjKSAoQykg4oaSIMKpXG4vLyAodG0pIChUTSkg4oaSIOKEolxuLy8gKHIpIChSKSDihpIgwq5cbi8vICstIOKGkiDCsVxuLy8gKHApIChQKSAtPiDCp1xuLy8gLi4uIOKGkiDigKYgKGFsc28gPy4uLi4g4oaSID8uLiwgIS4uLi4g4oaSICEuLilcbi8vID8/Pz8/Pz8/IOKGkiA/Pz8sICEhISEhIOKGkiAhISEsIGAsLGAg4oaSIGAsYFxuLy8gLS0g4oaSICZuZGFzaDssIC0tLSDihpIgJm1kYXNoO1xuLy9cbid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzpcbi8vIC0gZnJhY3Rpb25hbHMgMS8yLCAxLzQsIDMvNCAtPiDCvSwgwrwsIMK+XG4vLyAtIG1pbHRpcGxpY2F0aW9uIDIgeCA0IC0+IDIgw5cgNFxuXG52YXIgUkFSRV9SRSA9IC9cXCstfFxcLlxcLnxcXD9cXD9cXD9cXD98ISEhIXwsLHwtLS87XG5cbi8vIFdvcmthcm91bmQgZm9yIHBoYW50b21qcyAtIG5lZWQgcmVnZXggd2l0aG91dCAvZyBmbGFnLFxuLy8gb3Igcm9vdCBjaGVjayB3aWxsIGZhaWwgZXZlcnkgc2Vjb25kIHRpbWVcbnZhciBTQ09QRURfQUJCUl9URVNUX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaTtcblxudmFyIFNDT1BFRF9BQkJSX1JFID0gL1xcKChjfHRtfHJ8cClcXCkvaWc7XG52YXIgU0NPUEVEX0FCQlIgPSB7XG4gIGM6ICfCqScsXG4gIHI6ICfCricsXG4gIHA6ICfCpycsXG4gIHRtOiAn4oSiJ1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZUZuKG1hdGNoLCBuYW1lKSB7XG4gIHJldHVybiBTQ09QRURfQUJCUltuYW1lLnRvTG93ZXJDYXNlKCldO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlX3Njb3BlZChpbmxpbmVUb2tlbnMpIHtcbiAgdmFyIGksIHRva2VuLCBpbnNpZGVfYXV0b2xpbmsgPSAwO1xuXG4gIGZvciAoaSA9IGlubGluZVRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHRva2VuID0gaW5saW5lVG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiAhaW5zaWRlX2F1dG9saW5rKSB7XG4gICAgICB0b2tlbi5jb250ZW50ID0gdG9rZW4uY29udGVudC5yZXBsYWNlKFNDT1BFRF9BQkJSX1JFLCByZXBsYWNlRm4pO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19vcGVuJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluay0tO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlID09PSAnbGlua19jbG9zZScgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmsrKztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZV9yYXJlKGlubGluZVRva2Vucykge1xuICB2YXIgaSwgdG9rZW4sIGluc2lkZV9hdXRvbGluayA9IDA7XG5cbiAgZm9yIChpID0gaW5saW5lVG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdG9rZW4gPSBpbmxpbmVUb2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RleHQnICYmICFpbnNpZGVfYXV0b2xpbmspIHtcbiAgICAgIGlmIChSQVJFX1JFLnRlc3QodG9rZW4uY29udGVudCkpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnRcbiAgICAgICAgICAucmVwbGFjZSgvXFwrLS9nLCAnwrEnKVxuICAgICAgICAgIC8vIC4uLCAuLi4sIC4uLi4uLi4gLT4g4oCmXG4gICAgICAgICAgLy8gYnV0ID8uLi4uLiAmICEuLi4uLiAtPiA/Li4gJiAhLi5cbiAgICAgICAgICAucmVwbGFjZSgvXFwuezIsfS9nLCAn4oCmJykucmVwbGFjZSgvKFs/IV0p4oCmL2csICckMS4uJylcbiAgICAgICAgICAucmVwbGFjZSgvKFs/IV0pezQsfS9nLCAnJDEkMSQxJykucmVwbGFjZSgvLHsyLH0vZywgJywnKVxuICAgICAgICAgIC8vIGVtLWRhc2hcbiAgICAgICAgICAucmVwbGFjZSgvKF58W14tXSktLS0oPz1bXi1dfCQpL21nLCAnJDFcXHUyMDE0JylcbiAgICAgICAgICAvLyBlbi1kYXNoXG4gICAgICAgICAgLnJlcGxhY2UoLyhefFxccyktLSg/PVxcc3wkKS9tZywgJyQxXFx1MjAxMycpXG4gICAgICAgICAgLnJlcGxhY2UoLyhefFteLVxcc10pLS0oPz1bXi1cXHNdfCQpL21nLCAnJDFcXHUyMDEzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX29wZW4nICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rLS07XG4gICAgfVxuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICdsaW5rX2Nsb3NlJyAmJiB0b2tlbi5pbmZvID09PSAnYXV0bycpIHtcbiAgICAgIGluc2lkZV9hdXRvbGluaysrO1xuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICB2YXIgYmxrSWR4O1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy50eXBvZ3JhcGhlcikgeyByZXR1cm47IH1cblxuICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJykgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKFNDT1BFRF9BQkJSX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgcmVwbGFjZV9zY29wZWQoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGlmIChSQVJFX1JFLnRlc3Qoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY29udGVudCkpIHtcbiAgICAgIHJlcGxhY2VfcmFyZShzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbik7XG4gICAgfVxuXG4gIH1cbn07XG4iLCIvLyBDb252ZXJ0IHN0cmFpZ2h0IHF1b3RhdGlvbiBtYXJrcyB0byB0eXBvZ3JhcGhpYyBvbmVzXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBpc1doaXRlU3BhY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzV2hpdGVTcGFjZTtcbnZhciBpc1B1bmN0Q2hhciAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzUHVuY3RDaGFyO1xudmFyIGlzTWRBc2NpaVB1bmN0ID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNNZEFzY2lpUHVuY3Q7XG5cbnZhciBRVU9URV9URVNUX1JFID0gL1snXCJdLztcbnZhciBRVU9URV9SRSA9IC9bJ1wiXS9nO1xudmFyIEFQT1NUUk9QSEUgPSAnXFx1MjAxOSc7IC8qIOKAmSAqL1xuXG5cbmZ1bmN0aW9uIHJlcGxhY2VBdChzdHIsIGluZGV4LCBjaCkge1xuICByZXR1cm4gc3RyLnN1YnN0cigwLCBpbmRleCkgKyBjaCArIHN0ci5zdWJzdHIoaW5kZXggKyAxKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc19pbmxpbmVzKHRva2Vucywgc3RhdGUpIHtcbiAgdmFyIGksIHRva2VuLCB0ZXh0LCB0LCBwb3MsIG1heCwgdGhpc0xldmVsLCBpdGVtLCBsYXN0Q2hhciwgbmV4dENoYXIsXG4gICAgICBpc0xhc3RQdW5jdENoYXIsIGlzTmV4dFB1bmN0Q2hhciwgaXNMYXN0V2hpdGVTcGFjZSwgaXNOZXh0V2hpdGVTcGFjZSxcbiAgICAgIGNhbk9wZW4sIGNhbkNsb3NlLCBqLCBpc1NpbmdsZSwgc3RhY2ssIG9wZW5RdW90ZSwgY2xvc2VRdW90ZTtcblxuICBzdGFjayA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIHRoaXNMZXZlbCA9IHRva2Vuc1tpXS5sZXZlbDtcblxuICAgIGZvciAoaiA9IHN0YWNrLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICBpZiAoc3RhY2tbal0ubGV2ZWwgPD0gdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIHN0YWNrLmxlbmd0aCA9IGogKyAxO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICd0ZXh0JykgeyBjb250aW51ZTsgfVxuXG4gICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgcG9zID0gMDtcbiAgICBtYXggPSB0ZXh0Lmxlbmd0aDtcblxuICAgIC8qZXNsaW50IG5vLWxhYmVsczowLGJsb2NrLXNjb3BlZC12YXI6MCovXG4gICAgT1VURVI6XG4gICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgUVVPVEVfUkUubGFzdEluZGV4ID0gcG9zO1xuICAgICAgdCA9IFFVT1RFX1JFLmV4ZWModGV4dCk7XG4gICAgICBpZiAoIXQpIHsgYnJlYWs7IH1cblxuICAgICAgY2FuT3BlbiA9IGNhbkNsb3NlID0gdHJ1ZTtcbiAgICAgIHBvcyA9IHQuaW5kZXggKyAxO1xuICAgICAgaXNTaW5nbGUgPSAodFswXSA9PT0gXCInXCIpO1xuXG4gICAgICAvLyBGaW5kIHByZXZpb3VzIGNoYXJhY3RlcixcbiAgICAgIC8vIGRlZmF1bHQgdG8gc3BhY2UgaWYgaXQncyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaW5lXG4gICAgICAvL1xuICAgICAgbGFzdENoYXIgPSAweDIwO1xuXG4gICAgICBpZiAodC5pbmRleCAtIDEgPj0gMCkge1xuICAgICAgICBsYXN0Q2hhciA9IHRleHQuY2hhckNvZGVBdCh0LmluZGV4IC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBpZiAodG9rZW5zW2pdLnR5cGUgPT09ICdzb2Z0YnJlYWsnIHx8IHRva2Vuc1tqXS50eXBlID09PSAnaGFyZGJyZWFrJykgYnJlYWs7IC8vIGxhc3RDaGFyIGRlZmF1bHRzIHRvIDB4MjBcbiAgICAgICAgICBpZiAoIXRva2Vuc1tqXS5jb250ZW50KSBjb250aW51ZTsgLy8gc2hvdWxkIHNraXAgYWxsIHRva2VucyBleGNlcHQgJ3RleHQnLCAnaHRtbF9pbmxpbmUnIG9yICdjb2RlX2lubGluZSdcblxuICAgICAgICAgIGxhc3RDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCh0b2tlbnNbal0uY29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIG5leHQgY2hhcmFjdGVyLFxuICAgICAgLy8gZGVmYXVsdCB0byBzcGFjZSBpZiBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgIC8vXG4gICAgICBuZXh0Q2hhciA9IDB4MjA7XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbmV4dENoYXIgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlID09PSAnc29mdGJyZWFrJyB8fCB0b2tlbnNbal0udHlwZSA9PT0gJ2hhcmRicmVhaycpIGJyZWFrOyAvLyBuZXh0Q2hhciBkZWZhdWx0cyB0byAweDIwXG4gICAgICAgICAgaWYgKCF0b2tlbnNbal0uY29udGVudCkgY29udGludWU7IC8vIHNob3VsZCBza2lwIGFsbCB0b2tlbnMgZXhjZXB0ICd0ZXh0JywgJ2h0bWxfaW5saW5lJyBvciAnY29kZV9pbmxpbmUnXG5cbiAgICAgICAgICBuZXh0Q2hhciA9IHRva2Vuc1tqXS5jb250ZW50LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcbiAgICAgIGlzTmV4dFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KG5leHRDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHRDaGFyKSk7XG5cbiAgICAgIGlzTGFzdFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobGFzdENoYXIpO1xuICAgICAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cbiAgICAgIGlmIChpc05leHRXaGl0ZVNwYWNlKSB7XG4gICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgICAgIGlmICghKGlzTGFzdFdoaXRlU3BhY2UgfHwgaXNMYXN0UHVuY3RDaGFyKSkge1xuICAgICAgICAgIGNhbk9wZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNMYXN0V2hpdGVTcGFjZSkge1xuICAgICAgICBjYW5DbG9zZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChpc0xhc3RQdW5jdENoYXIpIHtcbiAgICAgICAgaWYgKCEoaXNOZXh0V2hpdGVTcGFjZSB8fCBpc05leHRQdW5jdENoYXIpKSB7XG4gICAgICAgICAgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV4dENoYXIgPT09IDB4MjIgLyogXCIgKi8gJiYgdFswXSA9PT0gJ1wiJykge1xuICAgICAgICBpZiAobGFzdENoYXIgPj0gMHgzMCAvKiAwICovICYmIGxhc3RDaGFyIDw9IDB4MzkgLyogOSAqLykge1xuICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZTogMVwiXCIgLSBjb3VudCBmaXJzdCBxdW90ZSBhcyBhbiBpbmNoXG4gICAgICAgICAgY2FuQ2xvc2UgPSBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4gJiYgY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBxdW90ZXMgaW4gdGhlIG1pZGRsZSBvZiBwdW5jdHVhdGlvbiBzZXF1ZW5jZSwgYnV0IG5vdFxuICAgICAgICAvLyBpbiB0aGUgbWlkZGxlIG9mIHRoZSB3b3JkcywgaS5lLjpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gMS4gZm9vIFwiIGJhciBcIiBiYXogLSBub3QgcmVwbGFjZWRcbiAgICAgICAgLy8gMi4gZm9vLVwiLWJhci1cIi1iYXogLSByZXBsYWNlZFxuICAgICAgICAvLyAzLiBmb29cImJhclwiYmF6ICAgICAtIG5vdCByZXBsYWNlZFxuICAgICAgICAvL1xuICAgICAgICBjYW5PcGVuID0gaXNMYXN0UHVuY3RDaGFyO1xuICAgICAgICBjYW5DbG9zZSA9IGlzTmV4dFB1bmN0Q2hhcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjYW5PcGVuICYmICFjYW5DbG9zZSkge1xuICAgICAgICAvLyBtaWRkbGUgb2Ygd29yZFxuICAgICAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FuQ2xvc2UpIHtcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBiZSBhIGNsb3NpbmcgcXVvdGUsIHJld2luZCB0aGUgc3RhY2sgdG8gZ2V0IGEgbWF0Y2hcbiAgICAgICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG4gICAgICAgICAgaWYgKHN0YWNrW2pdLmxldmVsIDwgdGhpc0xldmVsKSB7IGJyZWFrOyB9XG4gICAgICAgICAgaWYgKGl0ZW0uc2luZ2xlID09PSBpc1NpbmdsZSAmJiBzdGFja1tqXS5sZXZlbCA9PT0gdGhpc0xldmVsKSB7XG4gICAgICAgICAgICBpdGVtID0gc3RhY2tbal07XG5cbiAgICAgICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgICAgICBvcGVuUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1syXTtcbiAgICAgICAgICAgICAgY2xvc2VRdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzNdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3BlblF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbMF07XG4gICAgICAgICAgICAgIGNsb3NlUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1sxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVwbGFjZSB0b2tlbi5jb250ZW50ICpiZWZvcmUqIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50LFxuICAgICAgICAgICAgLy8gYmVjYXVzZSwgaWYgdGhleSBhcmUgcG9pbnRpbmcgYXQgdGhlIHNhbWUgdG9rZW4sIHJlcGxhY2VBdFxuICAgICAgICAgICAgLy8gY291bGQgbWVzcyB1cCBpbmRpY2VzIHdoZW4gcXVvdGUgbGVuZ3RoICE9IDFcbiAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgY2xvc2VRdW90ZSk7XG4gICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCA9IHJlcGxhY2VBdChcbiAgICAgICAgICAgICAgdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsIGl0ZW0ucG9zLCBvcGVuUXVvdGUpO1xuXG4gICAgICAgICAgICBwb3MgKz0gY2xvc2VRdW90ZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKGl0ZW0udG9rZW4gPT09IGkpIHsgcG9zICs9IG9wZW5RdW90ZS5sZW5ndGggLSAxOyB9XG5cbiAgICAgICAgICAgIHRleHQgPSB0b2tlbi5jb250ZW50O1xuICAgICAgICAgICAgbWF4ID0gdGV4dC5sZW5ndGg7XG5cbiAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IGo7XG4gICAgICAgICAgICBjb250aW51ZSBPVVRFUjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNhbk9wZW4pIHtcbiAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgdG9rZW46IGksXG4gICAgICAgICAgcG9zOiB0LmluZGV4LFxuICAgICAgICAgIHNpbmdsZTogaXNTaW5nbGUsXG4gICAgICAgICAgbGV2ZWw6IHRoaXNMZXZlbFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuQ2xvc2UgJiYgaXNTaW5nbGUpIHtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBBUE9TVFJPUEhFKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNtYXJ0cXVvdGVzKHN0YXRlKSB7XG4gIC8qZXNsaW50IG1heC1kZXB0aDowKi9cbiAgdmFyIGJsa0lkeDtcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMudHlwb2dyYXBoZXIpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChibGtJZHggPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMTsgYmxrSWR4ID49IDA7IGJsa0lkeC0tKSB7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2Jsa0lkeF0udHlwZSAhPT0gJ2lubGluZScgfHxcbiAgICAgICAgIVFVT1RFX1RFU1RfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcHJvY2Vzc19pbmxpbmVzKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuLCBzdGF0ZSk7XG4gIH1cbn07XG4iLCIvLyBDb3JlIHN0YXRlIG9iamVjdFxuLy9cbid1c2Ugc3RyaWN0JztcblxudmFyIFRva2VuID0gcmVxdWlyZSgnLi4vdG9rZW4nKTtcblxuXG5mdW5jdGlvbiBTdGF0ZUNvcmUoc3JjLCBtZCwgZW52KSB7XG4gIHRoaXMuc3JjID0gc3JjO1xuICB0aGlzLmVudiA9IGVudjtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy5pbmxpbmVNb2RlID0gZmFsc2U7XG4gIHRoaXMubWQgPSBtZDsgLy8gbGluayB0byBwYXJzZXIgaW5zdGFuY2Vcbn1cblxuLy8gcmUtZXhwb3J0IFRva2VuIGNsYXNzIHRvIHVzZSBpbiBjb3JlIHJ1bGVzXG5TdGF0ZUNvcmUucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUNvcmU7XG4iLCIvLyBQcm9jZXNzIGF1dG9saW5rcyAnPHByb3RvY29sOi4uLj4nXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vKmVzbGludCBtYXgtbGVuOjAqL1xudmFyIEVNQUlMX1JFICAgID0gL14oW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKikkLztcbnZhciBBVVRPTElOS19SRSA9IC9eKFthLXpBLVpdW2EtekEtWjAtOSsuXFwtXXsxLDMxfSk6KFtePD5cXHgwMC1cXHgyMF0qKSQvO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYXV0b2xpbmsoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgdXJsLCBmdWxsVXJsLCB0b2tlbiwgY2gsIHN0YXJ0LCBtYXgsXG4gICAgICBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXJ0ID0gc3RhdGUucG9zO1xuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgZm9yICg7Oykge1xuICAgIGlmICgrK3BvcyA+PSBtYXgpIHJldHVybiBmYWxzZTtcblxuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjaCA9PT0gMHgzQyAvKiA8ICovKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGNoID09PSAweDNFIC8qID4gKi8pIGJyZWFrO1xuICB9XG5cbiAgdXJsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0ICsgMSwgcG9zKTtcblxuICBpZiAoQVVUT0xJTktfUkUudGVzdCh1cmwpKSB7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gdXJsLmxlbmd0aCArIDI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoRU1BSUxfUkUudGVzdCh1cmwpKSB7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsoJ21haWx0bzonICsgdXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gdXJsLmxlbmd0aCArIDI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiLy8gUGFyc2UgYmFja3RpY2tzXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJhY2t0aWNrKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHN0YXJ0LCBtYXgsIG1hcmtlciwgdG9rZW4sIG1hdGNoU3RhcnQsIG1hdGNoRW5kLCBvcGVuZXJMZW5ndGgsIGNsb3Nlckxlbmd0aCxcbiAgICAgIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4NjAvKiBgICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXJ0ID0gcG9zO1xuICBwb3MrKztcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIC8vIHNjYW4gbWFya2VyIGxlbmd0aFxuICB3aGlsZSAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NjAvKiBgICovKSB7IHBvcysrOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MpO1xuICBvcGVuZXJMZW5ndGggPSBtYXJrZXIubGVuZ3RoO1xuXG4gIGlmIChzdGF0ZS5iYWNrdGlja3NTY2FubmVkICYmIChzdGF0ZS5iYWNrdGlja3Nbb3BlbmVyTGVuZ3RoXSB8fCAwKSA8PSBzdGFydCkge1xuICAgIGlmICghc2lsZW50KSBzdGF0ZS5wZW5kaW5nICs9IG1hcmtlcjtcbiAgICBzdGF0ZS5wb3MgKz0gb3BlbmVyTGVuZ3RoO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgbWF0Y2hTdGFydCA9IG1hdGNoRW5kID0gcG9zO1xuXG4gIC8vIE5vdGhpbmcgZm91bmQgaW4gdGhlIGNhY2hlLCBzY2FuIHVudGlsIHRoZSBlbmQgb2YgdGhlIGxpbmUgKG9yIHVudGlsIG1hcmtlciBpcyBmb3VuZClcbiAgd2hpbGUgKChtYXRjaFN0YXJ0ID0gc3RhdGUuc3JjLmluZGV4T2YoJ2AnLCBtYXRjaEVuZCkpICE9PSAtMSkge1xuICAgIG1hdGNoRW5kID0gbWF0Y2hTdGFydCArIDE7XG5cbiAgICAvLyBzY2FuIG1hcmtlciBsZW5ndGhcbiAgICB3aGlsZSAobWF0Y2hFbmQgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQobWF0Y2hFbmQpID09PSAweDYwLyogYCAqLykgeyBtYXRjaEVuZCsrOyB9XG5cbiAgICBjbG9zZXJMZW5ndGggPSBtYXRjaEVuZCAtIG1hdGNoU3RhcnQ7XG5cbiAgICBpZiAoY2xvc2VyTGVuZ3RoID09PSBvcGVuZXJMZW5ndGgpIHtcbiAgICAgIC8vIEZvdW5kIG1hdGNoaW5nIGNsb3NlciBsZW5ndGguXG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCdjb2RlX2lubGluZScsICdjb2RlJywgMCk7XG4gICAgICAgIHRva2VuLm1hcmt1cCAgPSBtYXJrZXI7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXRjaFN0YXJ0KVxuICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJyAnKVxuICAgICAgICAgIC5yZXBsYWNlKC9eICguKykgJC8sICckMScpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gbWF0Y2hFbmQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBTb21lIGRpZmZlcmVudCBsZW5ndGggZm91bmQsIHB1dCBpdCBpbiBjYWNoZSBhcyB1cHBlciBsaW1pdCBvZiB3aGVyZSBjbG9zZXIgY2FuIGJlIGZvdW5kXG4gICAgc3RhdGUuYmFja3RpY2tzW2Nsb3Nlckxlbmd0aF0gPSBtYXRjaFN0YXJ0O1xuICB9XG5cbiAgLy8gU2Nhbm5lZCB0aHJvdWdoIHRoZSBlbmQsIGRpZG4ndCBmaW5kIGFueXRoaW5nXG4gIHN0YXRlLmJhY2t0aWNrc1NjYW5uZWQgPSB0cnVlO1xuXG4gIGlmICghc2lsZW50KSBzdGF0ZS5wZW5kaW5nICs9IG1hcmtlcjtcbiAgc3RhdGUucG9zICs9IG9wZW5lckxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gRm9yIGVhY2ggb3BlbmluZyBlbXBoYXNpcy1saWtlIG1hcmtlciBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyBvbmVcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gcHJvY2Vzc0RlbGltaXRlcnMoc3RhdGUsIGRlbGltaXRlcnMpIHtcbiAgdmFyIGNsb3NlcklkeCwgb3BlbmVySWR4LCBjbG9zZXIsIG9wZW5lciwgbWluT3BlbmVySWR4LCBuZXdNaW5PcGVuZXJJZHgsXG4gICAgICBpc09kZE1hdGNoLCBsYXN0SnVtcCxcbiAgICAgIG9wZW5lcnNCb3R0b20gPSB7fSxcbiAgICAgIG1heCA9IGRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGlmICghbWF4KSByZXR1cm47XG5cbiAgLy8gaGVhZGVySWR4IGlzIHRoZSBmaXJzdCBkZWxpbWl0ZXIgb2YgdGhlIGN1cnJlbnQgKHdoZXJlIGNsb3NlciBpcykgZGVsaW1pdGVyIHJ1blxuICB2YXIgaGVhZGVySWR4ID0gMDtcbiAgdmFyIGxhc3RUb2tlbklkeCA9IC0yOyAvLyBuZWVkcyBhbnkgdmFsdWUgbG93ZXIgdGhhbiAtMVxuICB2YXIganVtcHMgPSBbXTtcblxuICBmb3IgKGNsb3NlcklkeCA9IDA7IGNsb3NlcklkeCA8IG1heDsgY2xvc2VySWR4KyspIHtcbiAgICBjbG9zZXIgPSBkZWxpbWl0ZXJzW2Nsb3NlcklkeF07XG5cbiAgICBqdW1wcy5wdXNoKDApO1xuXG4gICAgLy8gbWFya2VycyBiZWxvbmcgdG8gc2FtZSBkZWxpbWl0ZXIgcnVuIGlmOlxuICAgIC8vICAtIHRoZXkgaGF2ZSBhZGphY2VudCB0b2tlbnNcbiAgICAvLyAgLSBBTkQgbWFya2VycyBhcmUgdGhlIHNhbWVcbiAgICAvL1xuICAgIGlmIChkZWxpbWl0ZXJzW2hlYWRlcklkeF0ubWFya2VyICE9PSBjbG9zZXIubWFya2VyIHx8IGxhc3RUb2tlbklkeCAhPT0gY2xvc2VyLnRva2VuIC0gMSkge1xuICAgICAgaGVhZGVySWR4ID0gY2xvc2VySWR4O1xuICAgIH1cblxuICAgIGxhc3RUb2tlbklkeCA9IGNsb3Nlci50b2tlbjtcblxuICAgIC8vIExlbmd0aCBpcyBvbmx5IHVzZWQgZm9yIGVtcGhhc2lzLXNwZWNpZmljIFwicnVsZSBvZiAzXCIsXG4gICAgLy8gaWYgaXQncyBub3QgZGVmaW5lZCAoaW4gc3RyaWtldGhyb3VnaCBvciAzcmQgcGFydHkgcGx1Z2lucyksXG4gICAgLy8gd2UgY2FuIGRlZmF1bHQgaXQgdG8gMCB0byBkaXNhYmxlIHRob3NlIGNoZWNrcy5cbiAgICAvL1xuICAgIGNsb3Nlci5sZW5ndGggPSBjbG9zZXIubGVuZ3RoIHx8IDA7XG5cbiAgICBpZiAoIWNsb3Nlci5jbG9zZSkgY29udGludWU7XG5cbiAgICAvLyBQcmV2aW91c2x5IGNhbGN1bGF0ZWQgbG93ZXIgYm91bmRzIChwcmV2aW91cyBmYWlscylcbiAgICAvLyBmb3IgZWFjaCBtYXJrZXIsIGVhY2ggZGVsaW1pdGVyIGxlbmd0aCBtb2R1bG8gMyxcbiAgICAvLyBhbmQgZm9yIHdoZXRoZXIgdGhpcyBjbG9zZXIgY2FuIGJlIGFuIG9wZW5lcjtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY29tbW9ubWFyay9jbWFyay9jb21taXQvMzQyNTBlMTJjY2ViZGM2MzcyYjhiNDljNDRmYWI1N2M3MjQ0MzQ2MFxuICAgIGlmICghb3BlbmVyc0JvdHRvbS5oYXNPd25Qcm9wZXJ0eShjbG9zZXIubWFya2VyKSkge1xuICAgICAgb3BlbmVyc0JvdHRvbVtjbG9zZXIubWFya2VyXSA9IFsgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSBdO1xuICAgIH1cblxuICAgIG1pbk9wZW5lcklkeCA9IG9wZW5lcnNCb3R0b21bY2xvc2VyLm1hcmtlcl1bKGNsb3Nlci5vcGVuID8gMyA6IDApICsgKGNsb3Nlci5sZW5ndGggJSAzKV07XG5cbiAgICBvcGVuZXJJZHggPSBoZWFkZXJJZHggLSBqdW1wc1toZWFkZXJJZHhdIC0gMTtcblxuICAgIG5ld01pbk9wZW5lcklkeCA9IG9wZW5lcklkeDtcblxuICAgIGZvciAoOyBvcGVuZXJJZHggPiBtaW5PcGVuZXJJZHg7IG9wZW5lcklkeCAtPSBqdW1wc1tvcGVuZXJJZHhdICsgMSkge1xuICAgICAgb3BlbmVyID0gZGVsaW1pdGVyc1tvcGVuZXJJZHhdO1xuXG4gICAgICBpZiAob3BlbmVyLm1hcmtlciAhPT0gY2xvc2VyLm1hcmtlcikgY29udGludWU7XG5cbiAgICAgIGlmIChvcGVuZXIub3BlbiAmJiBvcGVuZXIuZW5kIDwgMCkge1xuXG4gICAgICAgIGlzT2RkTWF0Y2ggPSBmYWxzZTtcblxuICAgICAgICAvLyBmcm9tIHNwZWM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIG9uZSBvZiB0aGUgZGVsaW1pdGVycyBjYW4gYm90aCBvcGVuIGFuZCBjbG9zZSBlbXBoYXNpcywgdGhlbiB0aGVcbiAgICAgICAgLy8gc3VtIG9mIHRoZSBsZW5ndGhzIG9mIHRoZSBkZWxpbWl0ZXIgcnVucyBjb250YWluaW5nIHRoZSBvcGVuaW5nIGFuZFxuICAgICAgICAvLyBjbG9zaW5nIGRlbGltaXRlcnMgbXVzdCBub3QgYmUgYSBtdWx0aXBsZSBvZiAzIHVubGVzcyBib3RoIGxlbmd0aHNcbiAgICAgICAgLy8gYXJlIG11bHRpcGxlcyBvZiAzLlxuICAgICAgICAvL1xuICAgICAgICBpZiAob3BlbmVyLmNsb3NlIHx8IGNsb3Nlci5vcGVuKSB7XG4gICAgICAgICAgaWYgKChvcGVuZXIubGVuZ3RoICsgY2xvc2VyLmxlbmd0aCkgJSAzID09PSAwKSB7XG4gICAgICAgICAgICBpZiAob3BlbmVyLmxlbmd0aCAlIDMgIT09IDAgfHwgY2xvc2VyLmxlbmd0aCAlIDMgIT09IDApIHtcbiAgICAgICAgICAgICAgaXNPZGRNYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc09kZE1hdGNoKSB7XG4gICAgICAgICAgLy8gSWYgcHJldmlvdXMgZGVsaW1pdGVyIGNhbm5vdCBiZSBhbiBvcGVuZXIsIHdlIGNhbiBzYWZlbHkgc2tpcFxuICAgICAgICAgIC8vIHRoZSBlbnRpcmUgc2VxdWVuY2UgaW4gZnV0dXJlIGNoZWNrcy4gVGhpcyBpcyByZXF1aXJlZCB0byBtYWtlXG4gICAgICAgICAgLy8gc3VyZSBhbGdvcml0aG0gaGFzIGxpbmVhciBjb21wbGV4aXR5IChzZWUgKl8qXypfKl8qXy4uLiBjYXNlKS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIGxhc3RKdW1wID0gb3BlbmVySWR4ID4gMCAmJiAhZGVsaW1pdGVyc1tvcGVuZXJJZHggLSAxXS5vcGVuID9cbiAgICAgICAgICAgIGp1bXBzW29wZW5lcklkeCAtIDFdICsgMSA6XG4gICAgICAgICAgICAwO1xuXG4gICAgICAgICAganVtcHNbY2xvc2VySWR4XSA9IGNsb3NlcklkeCAtIG9wZW5lcklkeCArIGxhc3RKdW1wO1xuICAgICAgICAgIGp1bXBzW29wZW5lcklkeF0gPSBsYXN0SnVtcDtcblxuICAgICAgICAgIGNsb3Nlci5vcGVuICA9IGZhbHNlO1xuICAgICAgICAgIG9wZW5lci5lbmQgICA9IGNsb3NlcklkeDtcbiAgICAgICAgICBvcGVuZXIuY2xvc2UgPSBmYWxzZTtcbiAgICAgICAgICBuZXdNaW5PcGVuZXJJZHggPSAtMTtcbiAgICAgICAgICAvLyB0cmVhdCBuZXh0IHRva2VuIGFzIHN0YXJ0IG9mIHJ1bixcbiAgICAgICAgICAvLyBpdCBvcHRpbWl6ZXMgc2tpcHMgaW4gKio8Li4uPioqYSoqPC4uLj4qKiBwYXRob2xvZ2ljYWwgY2FzZVxuICAgICAgICAgIGxhc3RUb2tlbklkeCA9IC0yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5ld01pbk9wZW5lcklkeCAhPT0gLTEpIHtcbiAgICAgIC8vIElmIG1hdGNoIGZvciB0aGlzIGRlbGltaXRlciBydW4gZmFpbGVkLCB3ZSB3YW50IHRvIHNldCBsb3dlciBib3VuZCBmb3JcbiAgICAgIC8vIGZ1dHVyZSBsb29rdXBzLiBUaGlzIGlzIHJlcXVpcmVkIHRvIG1ha2Ugc3VyZSBhbGdvcml0aG0gaGFzIGxpbmVhclxuICAgICAgLy8gY29tcGxleGl0eS5cbiAgICAgIC8vXG4gICAgICAvLyBTZWUgZGV0YWlscyBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvbW1vbm1hcmsvY21hcmsvaXNzdWVzLzE3OCNpc3N1ZWNvbW1lbnQtMjcwNDE3NDQyXG4gICAgICAvL1xuICAgICAgb3BlbmVyc0JvdHRvbVtjbG9zZXIubWFya2VyXVsoY2xvc2VyLm9wZW4gPyAzIDogMCkgKyAoKGNsb3Nlci5sZW5ndGggfHwgMCkgJSAzKV0gPSBuZXdNaW5PcGVuZXJJZHg7XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5rX3BhaXJzKHN0YXRlKSB7XG4gIHZhciBjdXJyLFxuICAgICAgdG9rZW5zX21ldGEgPSBzdGF0ZS50b2tlbnNfbWV0YSxcbiAgICAgIG1heCA9IHN0YXRlLnRva2Vuc19tZXRhLmxlbmd0aDtcblxuICBwcm9jZXNzRGVsaW1pdGVycyhzdGF0ZSwgc3RhdGUuZGVsaW1pdGVycyk7XG5cbiAgZm9yIChjdXJyID0gMDsgY3VyciA8IG1heDsgY3VycisrKSB7XG4gICAgaWYgKHRva2Vuc19tZXRhW2N1cnJdICYmIHRva2Vuc19tZXRhW2N1cnJdLmRlbGltaXRlcnMpIHtcbiAgICAgIHByb2Nlc3NEZWxpbWl0ZXJzKHN0YXRlLCB0b2tlbnNfbWV0YVtjdXJyXS5kZWxpbWl0ZXJzKTtcbiAgICB9XG4gIH1cbn07XG4iLCIvLyBQcm9jZXNzICp0aGlzKiBhbmQgX3RoYXRfXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbi8vIEluc2VydCBlYWNoIG1hcmtlciBhcyBhIHNlcGFyYXRlIHRleHQgdG9rZW4sIGFuZCBhZGQgaXQgdG8gZGVsaW1pdGVyIGxpc3Rcbi8vXG5tb2R1bGUuZXhwb3J0cy50b2tlbml6ZSA9IGZ1bmN0aW9uIGVtcGhhc2lzKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGksIHNjYW5uZWQsIHRva2VuLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAobWFya2VyICE9PSAweDVGIC8qIF8gKi8gJiYgbWFya2VyICE9PSAweDJBIC8qICogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCBtYXJrZXIgPT09IDB4MkEpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzY2FubmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKTtcblxuICAgIHN0YXRlLmRlbGltaXRlcnMucHVzaCh7XG4gICAgICAvLyBDaGFyIGNvZGUgb2YgdGhlIHN0YXJ0aW5nIG1hcmtlciAobnVtYmVyKS5cbiAgICAgIC8vXG4gICAgICBtYXJrZXI6IG1hcmtlcixcblxuICAgICAgLy8gVG90YWwgbGVuZ3RoIG9mIHRoZXNlIHNlcmllcyBvZiBkZWxpbWl0ZXJzLlxuICAgICAgLy9cbiAgICAgIGxlbmd0aDogc2Nhbm5lZC5sZW5ndGgsXG5cbiAgICAgIC8vIEEgcG9zaXRpb24gb2YgdGhlIHRva2VuIHRoaXMgZGVsaW1pdGVyIGNvcnJlc3BvbmRzIHRvLlxuICAgICAgLy9cbiAgICAgIHRva2VuOiAgc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG5cbiAgICAgIC8vIElmIHRoaXMgZGVsaW1pdGVyIGlzIG1hdGNoZWQgYXMgYSB2YWxpZCBvcGVuZXIsIGBlbmRgIHdpbGwgYmVcbiAgICAgIC8vIGVxdWFsIHRvIGl0cyBwb3NpdGlvbiwgb3RoZXJ3aXNlIGl0J3MgYC0xYC5cbiAgICAgIC8vXG4gICAgICBlbmQ6ICAgIC0xLFxuXG4gICAgICAvLyBCb29sZWFuIGZsYWdzIHRoYXQgZGV0ZXJtaW5lIGlmIHRoaXMgZGVsaW1pdGVyIGNvdWxkIG9wZW4gb3IgY2xvc2VcbiAgICAgIC8vIGFuIGVtcGhhc2lzLlxuICAgICAgLy9cbiAgICAgIG9wZW46ICAgc2Nhbm5lZC5jYW5fb3BlbixcbiAgICAgIGNsb3NlOiAgc2Nhbm5lZC5jYW5fY2xvc2VcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuZnVuY3Rpb24gcG9zdFByb2Nlc3Moc3RhdGUsIGRlbGltaXRlcnMpIHtcbiAgdmFyIGksXG4gICAgICBzdGFydERlbGltLFxuICAgICAgZW5kRGVsaW0sXG4gICAgICB0b2tlbixcbiAgICAgIGNoLFxuICAgICAgaXNTdHJvbmcsXG4gICAgICBtYXggPSBkZWxpbWl0ZXJzLmxlbmd0aDtcblxuICBmb3IgKGkgPSBtYXggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDVGLyogXyAqLyAmJiBzdGFydERlbGltLm1hcmtlciAhPT0gMHgyQS8qICogKi8pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3Mgb25seSBvcGVuaW5nIG1hcmtlcnNcbiAgICBpZiAoc3RhcnREZWxpbS5lbmQgPT09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBlbmREZWxpbSA9IGRlbGltaXRlcnNbc3RhcnREZWxpbS5lbmRdO1xuXG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIGRlbGltaXRlciBoYXMgdGhlIHNhbWUgbWFya2VyIGFuZCBpcyBhZGphY2VudCB0byB0aGlzIG9uZSxcbiAgICAvLyBtZXJnZSB0aG9zZSBpbnRvIG9uZSBzdHJvbmcgZGVsaW1pdGVyLlxuICAgIC8vXG4gICAgLy8gYDxlbT48ZW0+d2hhdGV2ZXI8L2VtPjwvZW0+YCAtPiBgPHN0cm9uZz53aGF0ZXZlcjwvc3Ryb25nPmBcbiAgICAvL1xuICAgIGlzU3Ryb25nID0gaSA+IDAgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbaSAtIDFdLmVuZCA9PT0gc3RhcnREZWxpbS5lbmQgKyAxICYmXG4gICAgICAgICAgICAgICAvLyBjaGVjayB0aGF0IGZpcnN0IHR3byBtYXJrZXJzIG1hdGNoIGFuZCBhZGphY2VudFxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpIC0gMV0ubWFya2VyID09PSBzdGFydERlbGltLm1hcmtlciAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpIC0gMV0udG9rZW4gPT09IHN0YXJ0RGVsaW0udG9rZW4gLSAxICYmXG4gICAgICAgICAgICAgICAvLyBjaGVjayB0aGF0IGxhc3QgdHdvIG1hcmtlcnMgYXJlIGFkamFjZW50ICh3ZSBjYW4gc2FmZWx5IGFzc3VtZSB0aGV5IG1hdGNoKVxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZCArIDFdLnRva2VuID09PSBlbmREZWxpbS50b2tlbiArIDE7XG5cbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnREZWxpbS5tYXJrZXIpO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tzdGFydERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nX29wZW4nIDogJ2VtX29wZW4nO1xuICAgIHRva2VuLnRhZyAgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmcnIDogJ2VtJztcbiAgICB0b2tlbi5uZXN0aW5nID0gMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gaXNTdHJvbmcgPyBjaCArIGNoIDogY2g7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZ19jbG9zZScgOiAnZW1fY2xvc2UnO1xuICAgIHRva2VuLnRhZyAgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmcnIDogJ2VtJztcbiAgICB0b2tlbi5uZXN0aW5nID0gLTE7XG4gICAgdG9rZW4ubWFya3VwICA9IGlzU3Ryb25nID8gY2ggKyBjaCA6IGNoO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIGlmIChpc1N0cm9uZykge1xuICAgICAgc3RhdGUudG9rZW5zW2RlbGltaXRlcnNbaSAtIDFdLnRva2VuXS5jb250ZW50ID0gJyc7XG4gICAgICBzdGF0ZS50b2tlbnNbZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZCArIDFdLnRva2VuXS5jb250ZW50ID0gJyc7XG4gICAgICBpLS07XG4gICAgfVxuICB9XG59XG5cblxuLy8gV2FsayB0aHJvdWdoIGRlbGltaXRlciBsaXN0IGFuZCByZXBsYWNlIHRleHQgdG9rZW5zIHdpdGggdGFnc1xuLy9cbm1vZHVsZS5leHBvcnRzLnBvc3RQcm9jZXNzID0gZnVuY3Rpb24gZW1waGFzaXMoc3RhdGUpIHtcbiAgdmFyIGN1cnIsXG4gICAgICB0b2tlbnNfbWV0YSA9IHN0YXRlLnRva2Vuc19tZXRhLFxuICAgICAgbWF4ID0gc3RhdGUudG9rZW5zX21ldGEubGVuZ3RoO1xuXG4gIHBvc3RQcm9jZXNzKHN0YXRlLCBzdGF0ZS5kZWxpbWl0ZXJzKTtcblxuICBmb3IgKGN1cnIgPSAwOyBjdXJyIDwgbWF4OyBjdXJyKyspIHtcbiAgICBpZiAodG9rZW5zX21ldGFbY3Vycl0gJiYgdG9rZW5zX21ldGFbY3Vycl0uZGVsaW1pdGVycykge1xuICAgICAgcG9zdFByb2Nlc3Moc3RhdGUsIHRva2Vuc19tZXRhW2N1cnJdLmRlbGltaXRlcnMpO1xuICAgIH1cbiAgfVxufTtcbiIsIi8vIFByb2Nlc3MgaHRtbCBlbnRpdHkgLSAmIzEyMzssICYjeEFGOywgJnF1b3Q7LCAuLi5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW50aXRpZXMgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vZW50aXRpZXMnKTtcbnZhciBoYXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmhhcztcbnZhciBpc1ZhbGlkRW50aXR5Q29kZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzVmFsaWRFbnRpdHlDb2RlO1xudmFyIGZyb21Db2RlUG9pbnQgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuZnJvbUNvZGVQb2ludDtcblxuXG52YXIgRElHSVRBTF9SRSA9IC9eJiMoKD86eFthLWYwLTldezEsNn18WzAtOV17MSw3fSkpOy9pO1xudmFyIE5BTUVEX1JFICAgPSAvXiYoW2Etel1bYS16MC05XXsxLDMxfSk7L2k7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbnRpdHkoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIGNvZGUsIG1hdGNoLCBwb3MgPSBzdGF0ZS5wb3MsIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyNi8qICYgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHBvcyArIDEgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuXG4gICAgaWYgKGNoID09PSAweDIzIC8qICMgKi8pIHtcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goRElHSVRBTF9SRSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICBjb2RlID0gbWF0Y2hbMV1bMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3gnID8gcGFyc2VJbnQobWF0Y2hbMV0uc2xpY2UoMSksIDE2KSA6IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgICAgc3RhdGUucGVuZGluZyArPSBpc1ZhbGlkRW50aXR5Q29kZShjb2RlKSA/IGZyb21Db2RlUG9pbnQoY29kZSkgOiBmcm9tQ29kZVBvaW50KDB4RkZGRCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gc3RhdGUuc3JjLnNsaWNlKHBvcykubWF0Y2goTkFNRURfUkUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGlmIChoYXMoZW50aXRpZXMsIG1hdGNoWzFdKSkge1xuICAgICAgICAgIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gZW50aXRpZXNbbWF0Y2hbMV1dOyB9XG4gICAgICAgICAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gJyYnOyB9XG4gIHN0YXRlLnBvcysrO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQcm9jZXNzIGVzY2FwZWQgY2hhcnMgYW5kIGhhcmRicmVha3NcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cbnZhciBFU0NBUEVEID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHsgRVNDQVBFRC5wdXNoKDApOyB9XG5cbidcXFxcIVwiIyQlJlxcJygpKissLi86Ozw9Pj9AW11eX2B7fH1+LSdcbiAgLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaCkgeyBFU0NBUEVEW2NoLmNoYXJDb2RlQXQoMCldID0gMTsgfSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDVDLyogXFwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zKys7XG5cbiAgaWYgKHBvcyA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmIChjaCA8IDI1NiAmJiBFU0NBUEVEW2NoXSAhPT0gMCkge1xuICAgICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmNbcG9zXTsgfVxuICAgICAgc3RhdGUucG9zICs9IDI7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4MEEpIHtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICAgIC8vIHNraXAgbGVhZGluZyB3aGl0ZXNwYWNlcyBmcm9tIG5leHQgbGluZVxuICAgICAgd2hpbGUgKHBvcyA8IG1heCkge1xuICAgICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICAgICAgcG9zKys7XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLnBvcyA9IHBvcztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gJ1xcXFwnOyB9XG4gIHN0YXRlLnBvcysrO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQcm9jZXNzIGh0bWwgdGFnc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIEhUTUxfVEFHX1JFID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfcmUnKS5IVE1MX1RBR19SRTtcblxuXG5mdW5jdGlvbiBpc0xldHRlcihjaCkge1xuICAvKmVzbGludCBuby1iaXR3aXNlOjAqL1xuICB2YXIgbGMgPSBjaCB8IDB4MjA7IC8vIHRvIGxvd2VyIGNhc2VcbiAgcmV0dXJuIChsYyA+PSAweDYxLyogYSAqLykgJiYgKGxjIDw9IDB4N2EvKiB6ICovKTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGh0bWxfaW5saW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBtYXRjaCwgbWF4LCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBDaGVjayBzdGFydFxuICBtYXggPSBzdGF0ZS5wb3NNYXg7XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDNDLyogPCAqLyB8fFxuICAgICAgcG9zICsgMiA+PSBtYXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBRdWljayBmYWlsIG9uIHNlY29uZCBjaGFyXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gIGlmIChjaCAhPT0gMHgyMS8qICEgKi8gJiZcbiAgICAgIGNoICE9PSAweDNGLyogPyAqLyAmJlxuICAgICAgY2ggIT09IDB4MkYvKiAvICovICYmXG4gICAgICAhaXNMZXR0ZXIoY2gpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChIVE1MX1RBR19SRSk7XG4gIGlmICghbWF0Y2gpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnaHRtbF9pbmxpbmUnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIHBvcyArIG1hdGNoWzBdLmxlbmd0aCk7XG4gIH1cbiAgc3RhdGUucG9zICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2VzcyAhW2ltYWdlXSg8c3JjPiBcInRpdGxlXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGltYWdlKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIGF0dHJzLFxuICAgICAgY29kZSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgbGFiZWxTdGFydCxcbiAgICAgIHBvcyxcbiAgICAgIHJlZixcbiAgICAgIHJlcyxcbiAgICAgIHRpdGxlLFxuICAgICAgdG9rZW4sXG4gICAgICB0b2tlbnMsXG4gICAgICBzdGFydCxcbiAgICAgIGhyZWYgPSAnJyxcbiAgICAgIG9sZFBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIG1heCA9IHN0YXRlLnBvc01heDtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHgyMS8qICEgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MgKyAxKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDI7XG4gIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zICsgMSwgZmFsc2UpO1xuXG4gIC8vIHBhcnNlciBmYWlsZWQgdG8gZmluZCAnXScsIHNvIGl0J3Mgbm90IGEgdmFsaWQgbGlua1xuICBpZiAobGFiZWxFbmQgPCAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDI4LyogKCAqLykge1xuICAgIC8vXG4gICAgLy8gSW5saW5lIGxpbmtcbiAgICAvL1xuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgcG9zKys7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgIF5eXl5eXiBwYXJzaW5nIGxpbmsgZGVzdGluYXRpb25cbiAgICBzdGFydCA9IHBvcztcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0Rlc3RpbmF0aW9uKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChyZXMub2spIHtcbiAgICAgIGhyZWYgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rKHJlcy5zdHIpO1xuICAgICAgaWYgKHN0YXRlLm1kLnZhbGlkYXRlTGluayhocmVmKSkge1xuICAgICAgICBwb3MgPSByZXMucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHJlZiA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzaW5nIGxpbmsgdGl0bGVcbiAgICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0YXRlLnNyYywgcG9zLCBzdGF0ZS5wb3NNYXgpO1xuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhcnQgIT09IHBvcyAmJiByZXMub2spIHtcbiAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgIHBvcyA9IHJlcy5wb3M7XG5cbiAgICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gbWF4IHx8IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MjkvKiApICovKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHBvcysrO1xuICB9IGVsc2Uge1xuICAgIC8vXG4gICAgLy8gTGluayByZWZlcmVuY2VcbiAgICAvL1xuICAgIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXMgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVCLyogWyAqLykge1xuICAgICAgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgcG9zID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgcG9zKTtcbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShzdGFydCwgcG9zKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgfVxuXG4gICAgLy8gY292ZXJzIGxhYmVsID09PSAnJyBhbmQgbGFiZWwgPT09IHVuZGVmaW5lZFxuICAgIC8vIChjb2xsYXBzZWQgcmVmZXJlbmNlIGxpbmsgYW5kIHNob3J0Y3V0IHJlZmVyZW5jZSBsaW5rIHJlc3BlY3RpdmVseSlcbiAgICBpZiAoIWxhYmVsKSB7IGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKGxhYmVsU3RhcnQsIGxhYmVsRW5kKTsgfVxuXG4gICAgcmVmID0gc3RhdGUuZW52LnJlZmVyZW5jZXNbbm9ybWFsaXplUmVmZXJlbmNlKGxhYmVsKV07XG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaHJlZiA9IHJlZi5ocmVmO1xuICAgIHRpdGxlID0gcmVmLnRpdGxlO1xuICB9XG5cbiAgLy9cbiAgLy8gV2UgZm91bmQgdGhlIGVuZCBvZiB0aGUgbGluaywgYW5kIGtub3cgZm9yIGEgZmFjdCBpdCdzIGEgdmFsaWQgbGluaztcbiAgLy8gc28gYWxsIHRoYXQncyBsZWZ0IHRvIGRvIGlzIHRvIGNhbGwgdG9rZW5pemVyLlxuICAvL1xuICBpZiAoIXNpbGVudCkge1xuICAgIGNvbnRlbnQgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpO1xuXG4gICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKFxuICAgICAgY29udGVudCxcbiAgICAgIHN0YXRlLm1kLFxuICAgICAgc3RhdGUuZW52LFxuICAgICAgdG9rZW5zID0gW11cbiAgICApO1xuXG4gICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbWFnZScsICdpbWcnLCAwKTtcbiAgICB0b2tlbi5hdHRycyAgICA9IGF0dHJzID0gWyBbICdzcmMnLCBocmVmIF0sIFsgJ2FsdCcsICcnIF0gXTtcbiAgICB0b2tlbi5jaGlsZHJlbiA9IHRva2VucztcbiAgICB0b2tlbi5jb250ZW50ICA9IGNvbnRlbnQ7XG5cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2VzcyBbbGlua10oPHRvPiBcInN0dWZmXCIpXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5vcm1hbGl6ZVJlZmVyZW5jZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykubm9ybWFsaXplUmVmZXJlbmNlO1xudmFyIGlzU3BhY2UgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmsoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgYXR0cnMsXG4gICAgICBjb2RlLFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbEVuZCxcbiAgICAgIGxhYmVsU3RhcnQsXG4gICAgICBwb3MsXG4gICAgICByZXMsXG4gICAgICByZWYsXG4gICAgICB0b2tlbixcbiAgICAgIGhyZWYgPSAnJyxcbiAgICAgIHRpdGxlID0gJycsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIHBhcnNlUmVmZXJlbmNlID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDE7XG4gIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zLCB0cnVlKTtcblxuICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgJ10nLCBzbyBpdCdzIG5vdCBhIHZhbGlkIGxpbmtcbiAgaWYgKGxhYmVsRW5kIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyOC8qICggKi8pIHtcbiAgICAvL1xuICAgIC8vIElubGluZSBsaW5rXG4gICAgLy9cblxuICAgIC8vIG1pZ2h0IGhhdmUgZm91bmQgYSB2YWxpZCBzaG9ydGN1dCBsaW5rLCBkaXNhYmxlIHJlZmVyZW5jZSBwYXJzaW5nXG4gICAgcGFyc2VSZWZlcmVuY2UgPSBmYWxzZTtcblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHBvcysrO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICBeXl5eXl4gcGFyc2luZyBsaW5rIGRlc3RpbmF0aW9uXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocmVzLm9rKSB7XG4gICAgICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgICAgIGlmIChzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHtcbiAgICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhyZWYgPSAnJztcbiAgICAgIH1cblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICAgIH1cblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgXl5eXl5eXiBwYXJzaW5nIGxpbmsgdGl0bGVcbiAgICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgICAgIHRpdGxlID0gcmVzLnN0cjtcbiAgICAgICAgcG9zID0gcmVzLnBvcztcblxuICAgICAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIC8vIHBhcnNpbmcgYSB2YWxpZCBzaG9ydGN1dCBsaW5rIGZhaWxlZCwgZmFsbGJhY2sgdG8gcmVmZXJlbmNlXG4gICAgICBwYXJzZVJlZmVyZW5jZSA9IHRydWU7XG4gICAgfVxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKHBhcnNlUmVmZXJlbmNlKSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICBpZiAoIXJlZikge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWY7XG4gICAgdGl0bGUgPSByZWYudGl0bGU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgc3RhdGUucG9zID0gbGFiZWxTdGFydDtcbiAgICBzdGF0ZS5wb3NNYXggPSBsYWJlbEVuZDtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgdG9rZW4uYXR0cnMgID0gYXR0cnMgPSBbIFsgJ2hyZWYnLCBocmVmIF0gXTtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGF0dHJzLnB1c2goWyAndGl0bGUnLCB0aXRsZSBdKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5tZC5pbmxpbmUudG9rZW5pemUoc3RhdGUpO1xuXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlua19jbG9zZScsICdhJywgLTEpO1xuICB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICBzdGF0ZS5wb3NNYXggPSBtYXg7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFByb2NlZXNzICdcXG4nXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbmV3bGluZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBwbWF4LCBtYXgsIHdzLCBwb3MgPSBzdGF0ZS5wb3M7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEvKiBcXG4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG1heCA9IHN0YXRlLnBlbmRpbmcubGVuZ3RoIC0gMTtcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIC8vICcgIFxcbicgLT4gaGFyZGJyZWFrXG4gIC8vIExvb2t1cCBpbiBwZW5kaW5nIGNoYXJzIGlzIGJhZCBwcmFjdGljZSEgRG9uJ3QgY29weSB0byBvdGhlciBydWxlcyFcbiAgLy8gUGVuZGluZyBzdHJpbmcgaXMgc3RvcmVkIGluIGNvbmNhdCBtb2RlLCBpbmRleGVkIGxvb2t1cHMgd2lsbCBjYXVzZVxuICAvLyBjb252ZXJ0aW9uIHRvIGZsYXQgbW9kZS5cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBpZiAocG1heCA+PSAwICYmIHN0YXRlLnBlbmRpbmcuY2hhckNvZGVBdChwbWF4KSA9PT0gMHgyMCkge1xuICAgICAgaWYgKHBtYXggPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCAtIDEpID09PSAweDIwKSB7XG4gICAgICAgIC8vIEZpbmQgd2hpdGVzcGFjZXMgdGFpbCBvZiBwZW5kaW5nIGNoYXJzLlxuICAgICAgICB3cyA9IHBtYXggLSAxO1xuICAgICAgICB3aGlsZSAod3MgPj0gMSAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQod3MgLSAxKSA9PT0gMHgyMCkgd3MtLTtcblxuICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5zbGljZSgwLCB3cyk7XG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcuc2xpY2UoMCwgLTEpO1xuICAgICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICB9XG4gIH1cblxuICBwb3MrKztcblxuICAvLyBza2lwIGhlYWRpbmcgc3BhY2VzIGZvciBuZXh0IGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBpc1NwYWNlKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7IHBvcysrOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBJbmxpbmUgcGFyc2VyIHN0YXRlXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgVG9rZW4gICAgICAgICAgPSByZXF1aXJlKCcuLi90b2tlbicpO1xudmFyIGlzV2hpdGVTcGFjZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNXaGl0ZVNwYWNlO1xudmFyIGlzUHVuY3RDaGFyICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNQdW5jdENoYXI7XG52YXIgaXNNZEFzY2lpUHVuY3QgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc01kQXNjaWlQdW5jdDtcblxuXG5mdW5jdGlvbiBTdGF0ZUlubGluZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB0aGlzLnNyYyA9IHNyYztcbiAgdGhpcy5lbnYgPSBlbnY7XG4gIHRoaXMubWQgPSBtZDtcbiAgdGhpcy50b2tlbnMgPSBvdXRUb2tlbnM7XG4gIHRoaXMudG9rZW5zX21ldGEgPSBBcnJheShvdXRUb2tlbnMubGVuZ3RoKTtcblxuICB0aGlzLnBvcyA9IDA7XG4gIHRoaXMucG9zTWF4ID0gdGhpcy5zcmMubGVuZ3RoO1xuICB0aGlzLmxldmVsID0gMDtcbiAgdGhpcy5wZW5kaW5nID0gJyc7XG4gIHRoaXMucGVuZGluZ0xldmVsID0gMDtcblxuICAvLyBTdG9yZXMgeyBzdGFydDogZW5kIH0gcGFpcnMuIFVzZWZ1bCBmb3IgYmFja3RyYWNrXG4gIC8vIG9wdGltaXphdGlvbiBvZiBwYWlycyBwYXJzZSAoZW1waGFzaXMsIHN0cmlrZXMpLlxuICB0aGlzLmNhY2hlID0ge307XG5cbiAgLy8gTGlzdCBvZiBlbXBoYXNpcy1saWtlIGRlbGltaXRlcnMgZm9yIGN1cnJlbnQgdGFnXG4gIHRoaXMuZGVsaW1pdGVycyA9IFtdO1xuXG4gIC8vIFN0YWNrIG9mIGRlbGltaXRlciBsaXN0cyBmb3IgdXBwZXIgbGV2ZWwgdGFnc1xuICB0aGlzLl9wcmV2X2RlbGltaXRlcnMgPSBbXTtcblxuICAvLyBiYWNrdGljayBsZW5ndGggPT4gbGFzdCBzZWVuIHBvc2l0aW9uXG4gIHRoaXMuYmFja3RpY2tzID0ge307XG4gIHRoaXMuYmFja3RpY2tzU2Nhbm5lZCA9IGZhbHNlO1xufVxuXG5cbi8vIEZsdXNoIHBlbmRpbmcgdGV4dFxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKCd0ZXh0JywgJycsIDApO1xuICB0b2tlbi5jb250ZW50ID0gdGhpcy5wZW5kaW5nO1xuICB0b2tlbi5sZXZlbCA9IHRoaXMucGVuZGluZ0xldmVsO1xuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgdGhpcy5wZW5kaW5nID0gJyc7XG4gIHJldHVybiB0b2tlbjtcbn07XG5cblxuLy8gUHVzaCBuZXcgdG9rZW4gdG8gXCJzdHJlYW1cIi5cbi8vIElmIHBlbmRpbmcgdGV4dCBleGlzdHMgLSBmbHVzaCBpdCBhcyB0ZXh0IHRva2VuXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gIGlmICh0aGlzLnBlbmRpbmcpIHtcbiAgICB0aGlzLnB1c2hQZW5kaW5nKCk7XG4gIH1cblxuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4odHlwZSwgdGFnLCBuZXN0aW5nKTtcbiAgdmFyIHRva2VuX21ldGEgPSBudWxsO1xuXG4gIGlmIChuZXN0aW5nIDwgMCkge1xuICAgIC8vIGNsb3NpbmcgdGFnXG4gICAgdGhpcy5sZXZlbC0tO1xuICAgIHRoaXMuZGVsaW1pdGVycyA9IHRoaXMuX3ByZXZfZGVsaW1pdGVycy5wb3AoKTtcbiAgfVxuXG4gIHRva2VuLmxldmVsID0gdGhpcy5sZXZlbDtcblxuICBpZiAobmVzdGluZyA+IDApIHtcbiAgICAvLyBvcGVuaW5nIHRhZ1xuICAgIHRoaXMubGV2ZWwrKztcbiAgICB0aGlzLl9wcmV2X2RlbGltaXRlcnMucHVzaCh0aGlzLmRlbGltaXRlcnMpO1xuICAgIHRoaXMuZGVsaW1pdGVycyA9IFtdO1xuICAgIHRva2VuX21ldGEgPSB7IGRlbGltaXRlcnM6IHRoaXMuZGVsaW1pdGVycyB9O1xuICB9XG5cbiAgdGhpcy5wZW5kaW5nTGV2ZWwgPSB0aGlzLmxldmVsO1xuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgdGhpcy50b2tlbnNfbWV0YS5wdXNoKHRva2VuX21ldGEpO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5cbi8vIFNjYW4gYSBzZXF1ZW5jZSBvZiBlbXBoYXNpcy1saWtlIG1hcmtlcnMsIGFuZCBkZXRlcm1pbmUgd2hldGhlclxuLy8gaXQgY2FuIHN0YXJ0IGFuIGVtcGhhc2lzIHNlcXVlbmNlIG9yIGVuZCBhbiBlbXBoYXNpcyBzZXF1ZW5jZS5cbi8vXG4vLyAgLSBzdGFydCAtIHBvc2l0aW9uIHRvIHNjYW4gZnJvbSAoaXQgc2hvdWxkIHBvaW50IGF0IGEgdmFsaWQgbWFya2VyKTtcbi8vICAtIGNhblNwbGl0V29yZCAtIGRldGVybWluZSBpZiB0aGVzZSBtYXJrZXJzIGNhbiBiZSBmb3VuZCBpbnNpZGUgYSB3b3JkXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnNjYW5EZWxpbXMgPSBmdW5jdGlvbiAoc3RhcnQsIGNhblNwbGl0V29yZCkge1xuICB2YXIgcG9zID0gc3RhcnQsIGxhc3RDaGFyLCBuZXh0Q2hhciwgY291bnQsIGNhbl9vcGVuLCBjYW5fY2xvc2UsXG4gICAgICBpc0xhc3RXaGl0ZVNwYWNlLCBpc0xhc3RQdW5jdENoYXIsXG4gICAgICBpc05leHRXaGl0ZVNwYWNlLCBpc05leHRQdW5jdENoYXIsXG4gICAgICBsZWZ0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIHJpZ2h0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIG1heCA9IHRoaXMucG9zTWF4LFxuICAgICAgbWFya2VyID0gdGhpcy5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgLy8gdHJlYXQgYmVnaW5uaW5nIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBsYXN0Q2hhciA9IHN0YXJ0ID4gMCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQgLSAxKSA6IDB4MjA7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCAmJiB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IG1hcmtlcikgeyBwb3MrKzsgfVxuXG4gIGNvdW50ID0gcG9zIC0gc3RhcnQ7XG5cbiAgLy8gdHJlYXQgZW5kIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBuZXh0Q2hhciA9IHBvcyA8IG1heCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSA6IDB4MjA7XG5cbiAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcbiAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcblxuICBpc0xhc3RXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKGxhc3RDaGFyKTtcbiAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cbiAgaWYgKGlzTmV4dFdoaXRlU3BhY2UpIHtcbiAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgaWYgKCEoaXNMYXN0V2hpdGVTcGFjZSB8fCBpc0xhc3RQdW5jdENoYXIpKSB7XG4gICAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTGFzdFdoaXRlU3BhY2UpIHtcbiAgICByaWdodF9mbGFua2luZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xuICAgICAgcmlnaHRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNhblNwbGl0V29yZCkge1xuICAgIGNhbl9vcGVuICA9IGxlZnRfZmxhbmtpbmcgICYmICghcmlnaHRfZmxhbmtpbmcgfHwgaXNMYXN0UHVuY3RDaGFyKTtcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZyAmJiAoIWxlZnRfZmxhbmtpbmcgIHx8IGlzTmV4dFB1bmN0Q2hhcik7XG4gIH0gZWxzZSB7XG4gICAgY2FuX29wZW4gID0gbGVmdF9mbGFua2luZztcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2FuX29wZW46ICBjYW5fb3BlbixcbiAgICBjYW5fY2xvc2U6IGNhbl9jbG9zZSxcbiAgICBsZW5ndGg6ICAgIGNvdW50XG4gIH07XG59O1xuXG5cbi8vIHJlLWV4cG9ydCBUb2tlbiBjbGFzcyB0byB1c2UgaW4gYmxvY2sgcnVsZXNcblN0YXRlSW5saW5lLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVJbmxpbmU7XG4iLCIvLyB+fnN0cmlrZSB0aHJvdWdofn5cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gSW5zZXJ0IGVhY2ggbWFya2VyIGFzIGEgc2VwYXJhdGUgdGV4dCB0b2tlbiwgYW5kIGFkZCBpdCB0byBkZWxpbWl0ZXIgbGlzdFxuLy9cbm1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBpLCBzY2FubmVkLCB0b2tlbiwgbGVuLCBjaCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCB0cnVlKTtcbiAgbGVuID0gc2Nhbm5lZC5sZW5ndGg7XG4gIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gIGlmIChsZW4gPCAyKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChsZW4gJSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoO1xuICAgIGxlbi0tO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoICsgY2g7XG5cbiAgICBzdGF0ZS5kZWxpbWl0ZXJzLnB1c2goe1xuICAgICAgbWFya2VyOiBtYXJrZXIsXG4gICAgICBsZW5ndGg6IDAsICAgICAvLyBkaXNhYmxlIFwicnVsZSBvZiAzXCIgbGVuZ3RoIGNoZWNrcyBtZWFudCBmb3IgZW1waGFzaXNcbiAgICAgIHRva2VuOiAgc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG4gICAgICBlbmQ6ICAgIC0xLFxuICAgICAgb3BlbjogICBzY2FubmVkLmNhbl9vcGVuLFxuICAgICAgY2xvc2U6ICBzY2FubmVkLmNhbl9jbG9zZVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGUucG9zICs9IHNjYW5uZWQubGVuZ3RoO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5mdW5jdGlvbiBwb3N0UHJvY2VzcyhzdGF0ZSwgZGVsaW1pdGVycykge1xuICB2YXIgaSwgaixcbiAgICAgIHN0YXJ0RGVsaW0sXG4gICAgICBlbmREZWxpbSxcbiAgICAgIHRva2VuLFxuICAgICAgbG9uZU1hcmtlcnMgPSBbXSxcbiAgICAgIG1heCA9IGRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDdFLyogfiAqLykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZW5kRGVsaW0gPSBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kXTtcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbc3RhcnREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX29wZW4nO1xuICAgIHRva2VuLnRhZyAgICAgPSAncyc7XG4gICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgdG9rZW4ubWFya3VwICA9ICd+fic7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX2Nsb3NlJztcbiAgICB0b2tlbi50YWcgICAgID0gJ3MnO1xuICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gJ35+JztcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuIC0gMV0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgIHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLmNvbnRlbnQgPT09ICd+Jykge1xuXG4gICAgICBsb25lTWFya2Vycy5wdXNoKGVuZERlbGltLnRva2VuIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgYSBtYXJrZXIgc2VxdWVuY2UgaGFzIGFuIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgaXQncyBzcGxpdHRlZFxuICAvLyBsaWtlIHRoaXM6IGB+fn5+fmAgLT4gYH5gICsgYH5+YCArIGB+fmAsIGxlYXZpbmcgb25lIG1hcmtlciBhdCB0aGVcbiAgLy8gc3RhcnQgb2YgdGhlIHNlcXVlbmNlLlxuICAvL1xuICAvLyBTbywgd2UgaGF2ZSB0byBtb3ZlIGFsbCB0aG9zZSBtYXJrZXJzIGFmdGVyIHN1YnNlcXVlbnQgc19jbG9zZSB0YWdzLlxuICAvL1xuICB3aGlsZSAobG9uZU1hcmtlcnMubGVuZ3RoKSB7XG4gICAgaSA9IGxvbmVNYXJrZXJzLnBvcCgpO1xuICAgIGogPSBpICsgMTtcblxuICAgIHdoaWxlIChqIDwgc3RhdGUudG9rZW5zLmxlbmd0aCAmJiBzdGF0ZS50b2tlbnNbal0udHlwZSA9PT0gJ3NfY2xvc2UnKSB7XG4gICAgICBqKys7XG4gICAgfVxuXG4gICAgai0tO1xuXG4gICAgaWYgKGkgIT09IGopIHtcbiAgICAgIHRva2VuID0gc3RhdGUudG9rZW5zW2pdO1xuICAgICAgc3RhdGUudG9rZW5zW2pdID0gc3RhdGUudG9rZW5zW2ldO1xuICAgICAgc3RhdGUudG9rZW5zW2ldID0gdG9rZW47XG4gICAgfVxuICB9XG59XG5cblxuLy8gV2FsayB0aHJvdWdoIGRlbGltaXRlciBsaXN0IGFuZCByZXBsYWNlIHRleHQgdG9rZW5zIHdpdGggdGFnc1xuLy9cbm1vZHVsZS5leHBvcnRzLnBvc3RQcm9jZXNzID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSkge1xuICB2YXIgY3VycixcbiAgICAgIHRva2Vuc19tZXRhID0gc3RhdGUudG9rZW5zX21ldGEsXG4gICAgICBtYXggPSBzdGF0ZS50b2tlbnNfbWV0YS5sZW5ndGg7XG5cbiAgcG9zdFByb2Nlc3Moc3RhdGUsIHN0YXRlLmRlbGltaXRlcnMpO1xuXG4gIGZvciAoY3VyciA9IDA7IGN1cnIgPCBtYXg7IGN1cnIrKykge1xuICAgIGlmICh0b2tlbnNfbWV0YVtjdXJyXSAmJiB0b2tlbnNfbWV0YVtjdXJyXS5kZWxpbWl0ZXJzKSB7XG4gICAgICBwb3N0UHJvY2VzcyhzdGF0ZSwgdG9rZW5zX21ldGFbY3Vycl0uZGVsaW1pdGVycyk7XG4gICAgfVxuICB9XG59O1xuIiwiLy8gU2tpcCB0ZXh0IGNoYXJhY3RlcnMgZm9yIHRleHQgdG9rZW4sIHBsYWNlIHRob3NlIHRvIHBlbmRpbmcgYnVmZmVyXG4vLyBhbmQgaW5jcmVtZW50IGN1cnJlbnQgcG9zXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBSdWxlIHRvIHNraXAgcHVyZSB0ZXh0XG4vLyAne30kJUB+Kz06JyByZXNlcnZlZCBmb3IgZXh0ZW50aW9uc1xuXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cblxuLy8gISEhISBEb24ndCBjb25mdXNlIHdpdGggXCJNYXJrZG93biBBU0NJSSBQdW5jdHVhdGlvblwiIGNoYXJzXG4vLyBodHRwOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjE1LyNhc2NpaS1wdW5jdHVhdGlvbi1jaGFyYWN0ZXJcbmZ1bmN0aW9uIGlzVGVybWluYXRvckNoYXIoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgwQS8qIFxcbiAqLzpcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyRC8qIC0gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0MvKiA8ICovOlxuICAgIGNhc2UgMHgzRC8qID0gKi86XG4gICAgY2FzZSAweDNFLyogPiAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcztcblxuICB3aGlsZSAocG9zIDwgc3RhdGUucG9zTWF4ICYmICFpc1Rlcm1pbmF0b3JDaGFyKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zID09PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhdGUucG9zLCBwb3MpOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gQWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb24sIGZvciBtZW1vcnkuXG4vL1xuLy8gSXQgY29zdHMgMTAlIG9mIHBlcmZvcm1hbmNlLCBidXQgYWxsb3dzIGV4dGVuZCB0ZXJtaW5hdG9ycyBsaXN0LCBpZiBwbGFjZSBpdFxuLy8gdG8gYFBhcmNlcklubGluZWAgcHJvcGVydHkuIFByb2JhYmx5LCB3aWxsIHN3aXRjaCB0byBpdCBzb21ldGltZSwgc3VjaFxuLy8gZmxleGliaWxpdHkgcmVxdWlyZWQuXG5cbi8qXG52YXIgVEVSTUlOQVRPUl9SRSA9IC9bXFxuISMkJSYqK1xcLTo8PT5AW1xcXFxcXF1eX2B7fX5dLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGlkeCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLnNlYXJjaChURVJNSU5BVE9SX1JFKTtcblxuICAvLyBmaXJzdCBjaGFyIGlzIHRlcm1pbmF0b3IgLT4gZW1wdHkgdGV4dFxuICBpZiAoaWR4ID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIG5vIHRlcm1pbmF0b3IgLT4gdGV4dCB0aWxsIGVuZCBvZiBzdHJpbmdcbiAgaWYgKGlkeCA8IDApIHtcbiAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShwb3MpOyB9XG4gICAgc3RhdGUucG9zID0gc3RhdGUuc3JjLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgaWR4KTsgfVxuXG4gIHN0YXRlLnBvcyArPSBpZHg7XG5cbiAgcmV0dXJuIHRydWU7XG59OyovXG4iLCIvLyBDbGVhbiB1cCB0b2tlbnMgYWZ0ZXIgZW1waGFzaXMgYW5kIHN0cmlrZXRocm91Z2ggcG9zdHByb2Nlc3Npbmc6XG4vLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIGludG8gb25lIGFuZCByZS1jYWxjdWxhdGUgYWxsIHRva2VuIGxldmVsc1xuLy9cbi8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgaW5pdGlhbGx5IGVtcGhhc2lzIGRlbGltaXRlciBtYXJrZXJzICgqLCBfLCB+KVxuLy8gYXJlIHRyZWF0ZWQgYXMgdGhlaXIgb3duIHNlcGFyYXRlIHRleHQgdG9rZW5zLiBUaGVuIGVtcGhhc2lzIHJ1bGUgZWl0aGVyXG4vLyBsZWF2ZXMgdGhlbSBhcyB0ZXh0IChuZWVkZWQgdG8gbWVyZ2Ugd2l0aCBhZGphY2VudCB0ZXh0KSBvciB0dXJucyB0aGVtXG4vLyBpbnRvIG9wZW5pbmcvY2xvc2luZyB0YWdzICh3aGljaCBtZXNzZXMgdXAgbGV2ZWxzIGluc2lkZSkuXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGV4dF9jb2xsYXBzZShzdGF0ZSkge1xuICB2YXIgY3VyciwgbGFzdCxcbiAgICAgIGxldmVsID0gMCxcbiAgICAgIHRva2VucyA9IHN0YXRlLnRva2VucyxcbiAgICAgIG1heCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgZm9yIChjdXJyID0gbGFzdCA9IDA7IGN1cnIgPCBtYXg7IGN1cnIrKykge1xuICAgIC8vIHJlLWNhbGN1bGF0ZSBsZXZlbHMgYWZ0ZXIgZW1waGFzaXMvc3RyaWtldGhyb3VnaCB0dXJucyBzb21lIHRleHQgbm9kZXNcbiAgICAvLyBpbnRvIG9wZW5pbmcvY2xvc2luZyB0YWdzXG4gICAgaWYgKHRva2Vuc1tjdXJyXS5uZXN0aW5nIDwgMCkgbGV2ZWwtLTsgLy8gY2xvc2luZyB0YWdcbiAgICB0b2tlbnNbY3Vycl0ubGV2ZWwgPSBsZXZlbDtcbiAgICBpZiAodG9rZW5zW2N1cnJdLm5lc3RpbmcgPiAwKSBsZXZlbCsrOyAvLyBvcGVuaW5nIHRhZ1xuXG4gICAgaWYgKHRva2Vuc1tjdXJyXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgY3VyciArIDEgPCBtYXggJiZcbiAgICAgICAgdG9rZW5zW2N1cnIgKyAxXS50eXBlID09PSAndGV4dCcpIHtcblxuICAgICAgLy8gY29sbGFwc2UgdHdvIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgIHRva2Vuc1tjdXJyICsgMV0uY29udGVudCA9IHRva2Vuc1tjdXJyXS5jb250ZW50ICsgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VyciAhPT0gbGFzdCkgeyB0b2tlbnNbbGFzdF0gPSB0b2tlbnNbY3Vycl07IH1cblxuICAgICAgbGFzdCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyICE9PSBsYXN0KSB7XG4gICAgdG9rZW5zLmxlbmd0aCA9IGxhc3Q7XG4gIH1cbn07XG4iLCIvLyBUb2tlbiBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBjbGFzcyBUb2tlblxuICoqL1xuXG4vKipcbiAqIG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpXG4gKlxuICogQ3JlYXRlIG5ldyB0b2tlbiBhbmQgZmlsbCBwYXNzZWQgcHJvcGVydGllcy5cbiAqKi9cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRhZywgbmVzdGluZykge1xuICAvKipcbiAgICogVG9rZW4jdHlwZSAtPiBTdHJpbmdcbiAgICpcbiAgICogVHlwZSBvZiB0aGUgdG9rZW4gKHN0cmluZywgZS5nLiBcInBhcmFncmFwaF9vcGVuXCIpXG4gICAqKi9cbiAgdGhpcy50eXBlICAgICA9IHR5cGU7XG5cbiAgLyoqXG4gICAqIFRva2VuI3RhZyAtPiBTdHJpbmdcbiAgICpcbiAgICogaHRtbCB0YWcgbmFtZSwgZS5nLiBcInBcIlxuICAgKiovXG4gIHRoaXMudGFnICAgICAgPSB0YWc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2F0dHJzIC0+IEFycmF5XG4gICAqXG4gICAqIEh0bWwgYXR0cmlidXRlcy4gRm9ybWF0OiBgWyBbIG5hbWUxLCB2YWx1ZTEgXSwgWyBuYW1lMiwgdmFsdWUyIF0gXWBcbiAgICoqL1xuICB0aGlzLmF0dHJzICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jbWFwIC0+IEFycmF5XG4gICAqXG4gICAqIFNvdXJjZSBtYXAgaW5mby4gRm9ybWF0OiBgWyBsaW5lX2JlZ2luLCBsaW5lX2VuZCBdYFxuICAgKiovXG4gIHRoaXMubWFwICAgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNuZXN0aW5nIC0+IE51bWJlclxuICAgKlxuICAgKiBMZXZlbCBjaGFuZ2UgKG51bWJlciBpbiB7LTEsIDAsIDF9IHNldCksIHdoZXJlOlxuICAgKlxuICAgKiAtICBgMWAgbWVhbnMgdGhlIHRhZyBpcyBvcGVuaW5nXG4gICAqIC0gIGAwYCBtZWFucyB0aGUgdGFnIGlzIHNlbGYtY2xvc2luZ1xuICAgKiAtIGAtMWAgbWVhbnMgdGhlIHRhZyBpcyBjbG9zaW5nXG4gICAqKi9cbiAgdGhpcy5uZXN0aW5nICA9IG5lc3Rpbmc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2xldmVsIC0+IE51bWJlclxuICAgKlxuICAgKiBuZXN0aW5nIGxldmVsLCB0aGUgc2FtZSBhcyBgc3RhdGUubGV2ZWxgXG4gICAqKi9cbiAgdGhpcy5sZXZlbCAgICA9IDA7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NoaWxkcmVuIC0+IEFycmF5XG4gICAqXG4gICAqIEFuIGFycmF5IG9mIGNoaWxkIG5vZGVzIChpbmxpbmUgYW5kIGltZyB0b2tlbnMpXG4gICAqKi9cbiAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NvbnRlbnQgLT4gU3RyaW5nXG4gICAqXG4gICAqIEluIGEgY2FzZSBvZiBzZWxmLWNsb3NpbmcgdGFnIChjb2RlLCBodG1sLCBmZW5jZSwgZXRjLiksXG4gICAqIGl0IGhhcyBjb250ZW50cyBvZiB0aGlzIHRhZy5cbiAgICoqL1xuICB0aGlzLmNvbnRlbnQgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21hcmt1cCAtPiBTdHJpbmdcbiAgICpcbiAgICogJyonIG9yICdfJyBmb3IgZW1waGFzaXMsIGZlbmNlIHN0cmluZyBmb3IgZmVuY2UsIGV0Yy5cbiAgICoqL1xuICB0aGlzLm1hcmt1cCAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2luZm8gLT4gU3RyaW5nXG4gICAqXG4gICAqIEFkZGl0aW9uYWwgaW5mb3JtYXRpb246XG4gICAqXG4gICAqIC0gSW5mbyBzdHJpbmcgZm9yIFwiZmVuY2VcIiB0b2tlbnNcbiAgICogLSBUaGUgdmFsdWUgXCJhdXRvXCIgZm9yIGF1dG9saW5rIFwibGlua19vcGVuXCIgYW5kIFwibGlua19jbG9zZVwiIHRva2Vuc1xuICAgKiAtIFRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIGl0ZW0gbWFya2VyIGZvciBvcmRlcmVkLWxpc3QgXCJsaXN0X2l0ZW1fb3BlblwiIHRva2Vuc1xuICAgKiovXG4gIHRoaXMuaW5mbyAgICAgPSAnJztcblxuICAvKipcbiAgICogVG9rZW4jbWV0YSAtPiBPYmplY3RcbiAgICpcbiAgICogQSBwbGFjZSBmb3IgcGx1Z2lucyB0byBzdG9yZSBhbiBhcmJpdHJhcnkgZGF0YVxuICAgKiovXG4gIHRoaXMubWV0YSAgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNibG9jayAtPiBCb29sZWFuXG4gICAqXG4gICAqIFRydWUgZm9yIGJsb2NrLWxldmVsIHRva2VucywgZmFsc2UgZm9yIGlubGluZSB0b2tlbnMuXG4gICAqIFVzZWQgaW4gcmVuZGVyZXIgdG8gY2FsY3VsYXRlIGxpbmUgYnJlYWtzXG4gICAqKi9cbiAgdGhpcy5ibG9jayAgICA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNoaWRkZW4gLT4gQm9vbGVhblxuICAgKlxuICAgKiBJZiBpdCdzIHRydWUsIGlnbm9yZSB0aGlzIGVsZW1lbnQgd2hlbiByZW5kZXJpbmcuIFVzZWQgZm9yIHRpZ2h0IGxpc3RzXG4gICAqIHRvIGhpZGUgcGFyYWdyYXBocy5cbiAgICoqL1xuICB0aGlzLmhpZGRlbiAgID0gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRySW5kZXgobmFtZSkgLT4gTnVtYmVyXG4gKlxuICogU2VhcmNoIGF0dHJpYnV0ZSBpbmRleCBieSBuYW1lLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJJbmRleCA9IGZ1bmN0aW9uIGF0dHJJbmRleChuYW1lKSB7XG4gIHZhciBhdHRycywgaSwgbGVuO1xuXG4gIGlmICghdGhpcy5hdHRycykgeyByZXR1cm4gLTE7IH1cblxuICBhdHRycyA9IHRoaXMuYXR0cnM7XG5cbiAgZm9yIChpID0gMCwgbGVuID0gYXR0cnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXR0cnNbaV1bMF0gPT09IG5hbWUpIHsgcmV0dXJuIGk7IH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0clB1c2goYXR0ckRhdGEpXG4gKlxuICogQWRkIGBbIG5hbWUsIHZhbHVlIF1gIGF0dHJpYnV0ZSB0byBsaXN0LiBJbml0IGF0dHJzIGlmIG5lY2Vzc2FyeVxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJQdXNoID0gZnVuY3Rpb24gYXR0clB1c2goYXR0ckRhdGEpIHtcbiAgaWYgKHRoaXMuYXR0cnMpIHtcbiAgICB0aGlzLmF0dHJzLnB1c2goYXR0ckRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYXR0cnMgPSBbIGF0dHJEYXRhIF07XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyU2V0KG5hbWUsIHZhbHVlKVxuICpcbiAqIFNldCBgbmFtZWAgYXR0cmlidXRlIHRvIGB2YWx1ZWAuIE92ZXJyaWRlIG9sZCB2YWx1ZSBpZiBleGlzdHMuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0clNldCA9IGZ1bmN0aW9uIGF0dHJTZXQobmFtZSwgdmFsdWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpLFxuICAgICAgYXR0ckRhdGEgPSBbIG5hbWUsIHZhbHVlIF07XG5cbiAgaWYgKGlkeCA8IDApIHtcbiAgICB0aGlzLmF0dHJQdXNoKGF0dHJEYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzW2lkeF0gPSBhdHRyRGF0YTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJHZXQobmFtZSlcbiAqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGF0dHJpYnV0ZSBgbmFtZWAsIG9yIG51bGwgaWYgaXQgZG9lcyBub3QgZXhpc3QuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckdldCA9IGZ1bmN0aW9uIGF0dHJHZXQobmFtZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSksIHZhbHVlID0gbnVsbDtcbiAgaWYgKGlkeCA+PSAwKSB7XG4gICAgdmFsdWUgPSB0aGlzLmF0dHJzW2lkeF1bMV07XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJKb2luKG5hbWUsIHZhbHVlKVxuICpcbiAqIEpvaW4gdmFsdWUgdG8gZXhpc3RpbmcgYXR0cmlidXRlIHZpYSBzcGFjZS4gT3IgY3JlYXRlIG5ldyBhdHRyaWJ1dGUgaWYgbm90XG4gKiBleGlzdHMuIFVzZWZ1bCB0byBvcGVyYXRlIHdpdGggdG9rZW4gY2xhc3Nlcy5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRySm9pbiA9IGZ1bmN0aW9uIGF0dHJKb2luKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKTtcblxuICBpZiAoaWR4IDwgMCkge1xuICAgIHRoaXMuYXR0clB1c2goWyBuYW1lLCB2YWx1ZSBdKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzW2lkeF1bMV0gPSB0aGlzLmF0dHJzW2lkeF1bMV0gKyAnICcgKyB2YWx1ZTtcbiAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFRva2VuO1xuIiwiXG4ndXNlIHN0cmljdCc7XG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG52YXIgZGVjb2RlQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVjb2RlQ2FjaGUoZXhjbHVkZSkge1xuICB2YXIgaSwgY2gsIGNhY2hlID0gZGVjb2RlQ2FjaGVbZXhjbHVkZV07XG4gIGlmIChjYWNoZSkgeyByZXR1cm4gY2FjaGU7IH1cblxuICBjYWNoZSA9IGRlY29kZUNhY2hlW2V4Y2x1ZGVdID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IDEyODsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgIGNhY2hlLnB1c2goY2gpO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjaCA9IGV4Y2x1ZGUuY2hhckNvZGVBdChpKTtcbiAgICBjYWNoZVtjaF0gPSAnJScgKyAoJzAnICsgY2gudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuXG4vLyBEZWNvZGUgcGVyY2VudC1lbmNvZGVkIHN0cmluZy5cbi8vXG5mdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBleGNsdWRlKSB7XG4gIHZhciBjYWNoZTtcblxuICBpZiAodHlwZW9mIGV4Y2x1ZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgZXhjbHVkZSA9IGRlY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBjYWNoZSA9IGdldERlY29kZUNhY2hlKGV4Y2x1ZGUpO1xuXG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKCVbYS1mMC05XXsyfSkrL2dpLCBmdW5jdGlvbihzZXEpIHtcbiAgICB2YXIgaSwgbCwgYjEsIGIyLCBiMywgYjQsIGNocixcbiAgICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gc2VxLmxlbmd0aDsgaSA8IGw7IGkgKz0gMykge1xuICAgICAgYjEgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDEsIGkgKyAzKSwgMTYpO1xuXG4gICAgICBpZiAoYjEgPCAweDgwKSB7XG4gICAgICAgIHJlc3VsdCArPSBjYWNoZVtiMV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhFMCkgPT09IDB4QzAgJiYgKGkgKyAzIDwgbCkpIHtcbiAgICAgICAgLy8gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgNikgJiAweDdDMCkgfCAoYjIgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RjApID09PSAweEUwICYmIChpICsgNiA8IGwpKSB7XG4gICAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcbiAgICAgICAgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjMgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgMTIpICYgMHhGMDAwKSB8ICgoYjIgPDwgNikgJiAweEZDMCkgfCAoYjMgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDgwMCB8fCAoY2hyID49IDB4RDgwMCAmJiBjaHIgPD0gMHhERkZGKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKGIxICYgMHhGOCkgPT09IDB4RjAgJiYgKGkgKyA5IDwgbCkpIHtcbiAgICAgICAgLy8gMTExMTEweHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgYjIgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDQsIGkgKyA2KSwgMTYpO1xuICAgICAgICBiMyA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNywgaSArIDkpLCAxNik7XG4gICAgICAgIGI0ID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxMCwgaSArIDEyKSwgMTYpO1xuXG4gICAgICAgIGlmICgoYjIgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjMgJiAweEMwKSA9PT0gMHg4MCAmJiAoYjQgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgIGNociA9ICgoYjEgPDwgMTgpICYgMHgxQzAwMDApIHwgKChiMiA8PCAxMikgJiAweDNGMDAwKSB8ICgoYjMgPDwgNikgJiAweEZDMCkgfCAoYjQgJiAweDNGKTtcblxuICAgICAgICAgIGlmIChjaHIgPCAweDEwMDAwIHx8IGNociA+IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcdWZmZmRcXHVmZmZkXFx1ZmZmZFxcdWZmZmQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RDgwMCArIChjaHIgPj4gMTApLCAweERDMDAgKyAoY2hyICYgMHgzRkYpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkJztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn1cblxuXG5kZWNvZGUuZGVmYXVsdENoYXJzICAgPSAnOy8/OkAmPSskLCMnO1xuZGVjb2RlLmNvbXBvbmVudENoYXJzID0gJyc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGU7XG4iLCJcbid1c2Ugc3RyaWN0JztcblxuXG52YXIgZW5jb2RlQ2FjaGUgPSB7fTtcblxuXG4vLyBDcmVhdGUgYSBsb29rdXAgYXJyYXkgd2hlcmUgYW55dGhpbmcgYnV0IGNoYXJhY3RlcnMgaW4gYGNoYXJzYCBzdHJpbmdcbi8vIGFuZCBhbHBoYW51bWVyaWMgY2hhcnMgaXMgcGVyY2VudC1lbmNvZGVkLlxuLy9cbmZ1bmN0aW9uIGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGVuY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcblxuICAgIGlmICgvXlswLTlhLXpdJC9pLnRlc3QoY2gpKSB7XG4gICAgICAvLyBhbHdheXMgYWxsb3cgdW5lbmNvZGVkIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICBjYWNoZS5wdXNoKGNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUucHVzaCgnJScgKyAoJzAnICsgaS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSkuc2xpY2UoLTIpKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgZXhjbHVkZS5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlW2V4Y2x1ZGUuY2hhckNvZGVBdChpKV0gPSBleGNsdWRlW2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5cbi8vIEVuY29kZSB1bnNhZmUgY2hhcmFjdGVycyB3aXRoIHBlcmNlbnQtZW5jb2RpbmcsIHNraXBwaW5nIGFscmVhZHlcbi8vIGVuY29kZWQgc2VxdWVuY2VzLlxuLy9cbi8vICAtIHN0cmluZyAgICAgICAtIHN0cmluZyB0byBlbmNvZGVcbi8vICAtIGV4Y2x1ZGUgICAgICAtIGxpc3Qgb2YgY2hhcmFjdGVycyB0byBpZ25vcmUgKGluIGFkZGl0aW9uIHRvIGEtekEtWjAtOSlcbi8vICAtIGtlZXBFc2NhcGVkICAtIGRvbid0IGVuY29kZSAnJScgaW4gYSBjb3JyZWN0IGVzY2FwZSBzZXF1ZW5jZSAoZGVmYXVsdDogdHJ1ZSlcbi8vXG5mdW5jdGlvbiBlbmNvZGUoc3RyaW5nLCBleGNsdWRlLCBrZWVwRXNjYXBlZCkge1xuICB2YXIgaSwgbCwgY29kZSwgbmV4dENvZGUsIGNhY2hlLFxuICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGVuY29kZShzdHJpbmcsIGtlZXBFc2NhcGVkKVxuICAgIGtlZXBFc2NhcGVkICA9IGV4Y2x1ZGU7XG4gICAgZXhjbHVkZSA9IGVuY29kZS5kZWZhdWx0Q2hhcnM7XG4gIH1cblxuICBpZiAodHlwZW9mIGtlZXBFc2NhcGVkID09PSAndW5kZWZpbmVkJykge1xuICAgIGtlZXBFc2NhcGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGNhY2hlID0gZ2V0RW5jb2RlQ2FjaGUoZXhjbHVkZSk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoa2VlcEVzY2FwZWQgJiYgY29kZSA9PT0gMHgyNSAvKiAlICovICYmIGkgKyAyIDwgbCkge1xuICAgICAgaWYgKC9eWzAtOWEtZl17Mn0kL2kudGVzdChzdHJpbmcuc2xpY2UoaSArIDEsIGkgKyAzKSkpIHtcbiAgICAgICAgcmVzdWx0ICs9IHN0cmluZy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPCAxMjgpIHtcbiAgICAgIHJlc3VsdCArPSBjYWNoZVtjb2RlXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REZGRikge1xuICAgICAgaWYgKGNvZGUgPj0gMHhEODAwICYmIGNvZGUgPD0gMHhEQkZGICYmIGkgKyAxIDwgbCkge1xuICAgICAgICBuZXh0Q29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgaWYgKG5leHRDb2RlID49IDB4REMwMCAmJiBuZXh0Q29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICByZXN1bHQgKz0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ1tpXSArIHN0cmluZ1tpICsgMV0pO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0ICs9ICclRUYlQkYlQkQnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZW5jb2RlLmRlZmF1bHRDaGFycyAgID0gXCI7Lz86QCY9KyQsLV8uIX4qJygpI1wiO1xuZW5jb2RlLmNvbXBvbmVudENoYXJzID0gXCItXy4hfionKClcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGVuY29kZTtcbiIsIlxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZm9ybWF0KHVybCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgcmVzdWx0ICs9IHVybC5wcm90b2NvbCB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5zbGFzaGVzID8gJy8vJyA6ICcnO1xuICByZXN1bHQgKz0gdXJsLmF1dGggPyB1cmwuYXV0aCArICdAJyA6ICcnO1xuXG4gIGlmICh1cmwuaG9zdG5hbWUgJiYgdXJsLmhvc3RuYW1lLmluZGV4T2YoJzonKSAhPT0gLTEpIHtcbiAgICAvLyBpcHY2IGFkZHJlc3NcbiAgICByZXN1bHQgKz0gJ1snICsgdXJsLmhvc3RuYW1lICsgJ10nO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCArPSB1cmwuaG9zdG5hbWUgfHwgJyc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLnBvcnQgPyAnOicgKyB1cmwucG9ydCA6ICcnO1xuICByZXN1bHQgKz0gdXJsLnBhdGhuYW1lIHx8ICcnO1xuICByZXN1bHQgKz0gdXJsLnNlYXJjaCB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5oYXNoIHx8ICcnO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzLmVuY29kZSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG5tb2R1bGUuZXhwb3J0cy5kZWNvZGUgPSByZXF1aXJlKCcuL2RlY29kZScpO1xubW9kdWxlLmV4cG9ydHMuZm9ybWF0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKTtcbm1vZHVsZS5leHBvcnRzLnBhcnNlICA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vXG4vLyBDaGFuZ2VzIGZyb20gam95ZW50L25vZGU6XG4vL1xuLy8gMS4gTm8gbGVhZGluZyBzbGFzaCBpbiBwYXRocyxcbi8vICAgIGUuZy4gaW4gYHVybC5wYXJzZSgnaHR0cDovL2Zvbz9iYXInKWAgcGF0aG5hbWUgaXMgYGAsIG5vdCBgL2Bcbi8vXG4vLyAyLiBCYWNrc2xhc2hlcyBhcmUgbm90IHJlcGxhY2VkIHdpdGggc2xhc2hlcyxcbi8vICAgIHNvIGBodHRwOlxcXFxleGFtcGxlLm9yZ1xcYCBpcyB0cmVhdGVkIGxpa2UgYSByZWxhdGl2ZSBwYXRoXG4vL1xuLy8gMy4gVHJhaWxpbmcgY29sb24gaXMgdHJlYXRlZCBsaWtlIGEgcGFydCBvZiB0aGUgcGF0aCxcbi8vICAgIGkuZS4gaW4gYGh0dHA6Ly9leGFtcGxlLm9yZzpmb29gIHBhdGhuYW1lIGlzIGA6Zm9vYFxuLy9cbi8vIDQuIE5vdGhpbmcgaXMgVVJMLWVuY29kZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsXG4vLyAgICAoaW4gam95ZW50L25vZGUgc29tZSBjaGFycyBpbiBhdXRoIGFuZCBwYXRocyBhcmUgZW5jb2RlZClcbi8vXG4vLyA1LiBgdXJsLnBhcnNlKClgIGRvZXMgbm90IGhhdmUgYHBhcnNlUXVlcnlTdHJpbmdgIGFyZ3VtZW50XG4vL1xuLy8gNi4gUmVtb3ZlZCBleHRyYW5lb3VzIHJlc3VsdCBwcm9wZXJ0aWVzOiBgaG9zdGAsIGBwYXRoYCwgYHF1ZXJ5YCwgZXRjLixcbi8vICAgIHdoaWNoIGNhbiBiZSBjb25zdHJ1Y3RlZCB1c2luZyBvdGhlciBwYXJ0cyBvZiB0aGUgdXJsLlxuLy9cblxuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyAnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCcgXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyAneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnIF0uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsgJ1xcJycgXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsgJyUnLCAnLycsICc/JywgJzsnLCAnIycgXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWyAnLycsICc/JywgJyMnIF0sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zY3JpcHQtdXJsICovXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9O1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2NyaXB0LXVybCAqL1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSB7IHJldHVybiB1cmw7IH1cblxuICB2YXIgdSA9IG5ldyBVcmwoKTtcbiAgdS5wYXJzZSh1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIHZhciBpLCBsLCBsb3dlclByb3RvLCBoZWMsIHNsYXNoZXMsXG4gICAgICByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IHByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBhdXRoO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yIChpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChyZXN0W2hvc3RFbmQgLSAxXSA9PT0gJzonKSB7IGhvc3RFbmQtLTsgfVxuICAgIHZhciBob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoaG9zdCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgeyBjb250aW51ZTsgfVxuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICB9XG4gIH1cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH1cbiAgaWYgKHJlc3QpIHsgdGhpcy5wYXRobmFtZSA9IHJlc3Q7IH1cbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnJztcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbihob3N0KSB7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB7IHRoaXMuaG9zdG5hbWUgPSBob3N0OyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybFBhcnNlO1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIm1vZHVsZS5leHBvcnRzPS9bXFwwLVxceDFGXFx4N0YtXFx4OUZdLyIsIm1vZHVsZS5leHBvcnRzPS9bXFx4QURcXHUwNjAwLVxcdTA2MDVcXHUwNjFDXFx1MDZERFxcdTA3MEZcXHUwOEUyXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2NFxcdTIwNjYtXFx1MjA2RlxcdUZFRkZcXHVGRkY5LVxcdUZGRkJdfFxcdUQ4MDRbXFx1RENCRFxcdURDQ0RdfFxcdUQ4MkZbXFx1RENBMC1cXHVEQ0EzXXxcXHVEODM0W1xcdURENzMtXFx1REQ3QV18XFx1REI0MFtcXHVEQzAxXFx1REMyMC1cXHVEQzdGXS8iLCJtb2R1bGUuZXhwb3J0cz0vWyEtIyUtXFwqLC1cXC86O1xcP0BcXFstXFxdX1xce1xcfVxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTA5RkRcXHUwQTc2XFx1MEFGMFxcdTBDODRcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNEVcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODAxXFx1REQ2RnxcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDNbXFx1REY1NS1cXHVERjU5XXxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzhcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDVbXFx1REM0Qi1cXHVEQzRGXFx1REM1QlxcdURDNURcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REU2MC1cXHVERTZDXFx1REYzQy1cXHVERjNFXXxcXHVEODA2W1xcdURDM0JcXHVERTNGLVxcdURFNDZcXHVERTlBLVxcdURFOUNcXHVERTlFLVxcdURFQTJdfFxcdUQ4MDdbXFx1REM0MS1cXHVEQzQ1XFx1REM3MFxcdURDNzFcXHVERUY3XFx1REVGOF18XFx1RDgwOVtcXHVEQzcwLVxcdURDNzRdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF18XFx1RDgxQltcXHVERTk3LVxcdURFOUFdfFxcdUQ4MkZcXHVEQzlGfFxcdUQ4MzZbXFx1REU4Ny1cXHVERThCXXxcXHVEODNBW1xcdURENUVcXHVERDVGXS8iLCJtb2R1bGUuZXhwb3J0cz0vWyBcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDI4XFx1MjAyOVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkFueSA9IHJlcXVpcmUoJy4vcHJvcGVydGllcy9BbnkvcmVnZXgnKTtcbmV4cG9ydHMuQ2MgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL0NjL3JlZ2V4Jyk7XG5leHBvcnRzLkNmICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9DZi9yZWdleCcpO1xuZXhwb3J0cy5QICAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvUC9yZWdleCcpO1xuZXhwb3J0cy5aICAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvWi9yZWdleCcpO1xuIiwibW9kdWxlLmV4cG9ydHM9L1tcXDAtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS8iLCIvLyBDb3B5cmlnaHQgKEMpIDIwMDktMjAyMyBMZW1vaW5lIEF1dG9tYXRpb24gVGVjaG5vbG9naWVzXG4vL1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuLyoqXG4gKiBAbW9kdWxlIHgtY2hlY2tjb25maWd1cGRhdGVcbiAqIEByZXF1aXJlcyBtb2R1bGU6cHVsc2VDb21wb25lbnRcbiAqIFxuICogQ2hlY2sgaWYgdGhlIGNvbmZpZyBPTiBUSEUgU0VSVkVSIGNoYW5nZWRcbiAqL1xudmFyIHB1bHNlQ29tcG9uZW50ID0gcmVxdWlyZSgncHVsc2Vjb21wb25lbnQnKTtcbnZhciBwdWxzZUNvbmZpZyA9IHJlcXVpcmUoJ3B1bHNlQ29uZmlnJyk7XG52YXIgZXZlbnRCdXMgPSByZXF1aXJlKCdldmVudEJ1cycpO1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gIGNsYXNzIGNoZWNrY29uZmlndXBkYXRlQ29tcG9uZW50IGV4dGVuZHMgcHVsc2VDb21wb25lbnQuUHVsc2VQYXJhbUF1dG9QYXRoUmVmcmVzaGluZ0NvbXBvbmVudCB7XG4gICAgaW5pdGlhbGl6ZSAoKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCdwdWxzZS1ub2Rpc3BsYXknKTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6YXRpb24gT0sgPT4gc3dpdGNoIHRvIHRoZSBuZXh0IGNvbnRleHRcbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhbGlkYXRlUGFyYW1ldGVycyAoKSB7XG4gICAgICB0aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5RXJyb3IgKG1lc3NhZ2UpIHtcbiAgICAgIC8vIERvIG5vdGhpbmdcbiAgICB9XG5cbiAgICByZW1vdmVFcnJvciAoKSB7XG4gICAgICAvLyBEbyBub3RoaW5nXG4gICAgICB0aGlzLmRpc3BsYXlFcnJvcignJyk7XG4gICAgfVxuXG4gICAgZ2V0IHJlZnJlc2hSYXRlICgpIHtcbiAgICAgIC8vIFJldHVybiBoZXJlIHRoZSByZWZyZXNoIHJhdGUgaW4gbXMuXG4gICAgICByZXR1cm4gMTAwMCAqIE51bWJlcih0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdyZWZyZXNoU2Vjb25kcycsIDMwMCkpO1xuICAgIH1cblxuICAgIGdldFNob3J0VXJsICgpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgV2ViIFNlcnZpY2UgVVJMIGhlcmUgd2l0aG91dCBwYXRoXG4gICAgICByZXR1cm4gJ0NvbmZpZy9MYXN0VXBkYXRlJztcbiAgICB9XG5cbiAgICByZWZyZXNoIChkYXRhKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIGNvbXBvbmVudFxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl91cGRhdGVEYXRlVGltZSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl91cGRhdGVEYXRlVGltZSA9IGRhdGEuVXBkYXRlRGF0ZVRpbWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IGNvbmZpZ0hhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkodGhpcy5fdXBkYXRlRGF0ZVRpbWUpID09PSBKU09OLnN0cmluZ2lmeShkYXRhLlVwZGF0ZURhdGVUaW1lKSkge1xuICAgICAgICAgIGNvbmZpZ0hhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnSGFzQ2hhbmdlZCkge1xuICAgICAgICAgIGxldCBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgICAgICAgaWYgKCdsaXZlJyA9PSBwdWxzZUNvbmZpZy5nZXRBcHBDb250ZXh0T3JSb2xlKCkpIHtcbiAgICAgICAgICAgIC8vIHJlbG9hZCBmb3IgbGl2ZVxuICAgICAgICAgICAgd2luZG93Lm9wZW4oaHJlZiwgJ19zZWxmJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRGlzcGxheSBhIG1lc3NhZ2VcbiAgICAgICAgICAgIGxldCBtZXNzYWdlSW5mbyA9IHtcbiAgICAgICAgICAgICAgJ2lkJzogJ0NPTkZJRyBTZXJ2ZXInLFxuICAgICAgICAgICAgICAnbWVzc2FnZSc6ICdDb25maWd1cmF0aW9uIG9uIHNlcnZlciBoYXMgY2hhbmdlZCAnLFxuICAgICAgICAgICAgICAnbGV2ZWwnOiAnaW5mbycsXG4gICAgICAgICAgICAgICdjbGlja1RvQ2xvc2UnOiBmYWxzZSxcbiAgICAgICAgICAgICAgJ3JlbG9hZFVSTCc6IGhyZWZcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBldmVudEJ1cy5FdmVudEJ1cy5kaXNwYXRjaFRvQWxsKCdzaG93TWVzc2FnZVNpZ25hbCcsXG4gICAgICAgICAgICAgIG1lc3NhZ2VJbmZvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWxzZUNvbXBvbmVudC5yZWdpc3RlckVsZW1lbnQoJ3gtY2hlY2tjb25maWd1cGRhdGUnLCBjaGVja2NvbmZpZ3VwZGF0ZUNvbXBvbmVudCk7XG59KSgpO1xuIiwiLy8gQ29weXJpZ2h0IChDKSAyMDA5LTIwMjMgTGVtb2luZSBBdXRvbWF0aW9uIFRlY2hub2xvZ2llc1xuLy9cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5cbi8qKlxuICogQG1vZHVsZSB4LWNoZWNrY3VycmVudHRpbWVcbiAqIEByZXF1aXJlcyBtb2R1bGU6cHVsc2VDb21wb25lbnRcbiAqL1xuXG52YXIgcHVsc2VDb21wb25lbnQgPSByZXF1aXJlKCdwdWxzZWNvbXBvbmVudCcpO1xudmFyIHB1bHNlQ29uZmlnID0gcmVxdWlyZSgncHVsc2VDb25maWcnKTtcbnZhciBldmVudEJ1cyA9IHJlcXVpcmUoJ2V2ZW50QnVzJyk7XG5cbi8qKlxuICogQnVpbGQgYSBjdXN0b20gdGFnIDx4LWNoZWNrY3VycmVudHRpbWU+IHRvIGNoZWNrIGN1cnJlbnR0aW1lLiAgXG4gKi9cbihmdW5jdGlvbiAoKSB7XG5cbiAgY2xhc3MgQ2hlY2tDdXJyZW50VGltZUNvbXBvbmVudCBleHRlbmRzIHB1bHNlQ29tcG9uZW50LlB1bHNlUGFyYW1BdXRvUGF0aFJlZnJlc2hpbmdDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSBzdXBlciguLi5hcmdzKTtcblxuICAgICAgLy8gRE9NIC0+IG5ldmVyIGluIGNvbnRydWN0b3JcbiAgICAgIHNlbGYuX2NvbnRlbnQgPSB1bmRlZmluZWQ7IC8vIE9wdGlvbmFsXG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRXaGVuQ29ubmVjdGVkT25jZSAoYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRXaGVuQ29ubmVjdGVkT25jZShhdHRyLCBvbGRWYWwsIG5ld1ZhbCk7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSAoKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCdwdWxzZS1ub2Rpc3BsYXknKTtcblxuICAgICAgLy8gVXBkYXRlIGhlcmUgc29tZSBpbnRlcm5hbCBwYXJhbWV0ZXJzXG5cbiAgICAgIC8vIGxpc3RlbmVyc1xuXG4gICAgICAvLyBJbiBjYXNlIG9mIGNsb25lLCBuZWVkIHRvIGJlIGVtcHR5IDpcbiAgICAgIC8vJCh0aGlzLmVsZW1lbnQpLmVtcHR5KCk7XG5cbiAgICAgIC8vIENyZWF0ZSBET00gLSBOTyBET01cblxuICAgICAgLy8gSW5pdGlhbGl6YXRpb24gT0sgPT4gc3dpdGNoIHRvIHRoZSBuZXh0IGNvbnRleHRcbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSAoZXZlbnQpIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICB2YWxpZGF0ZVBhcmFtZXRlcnMgKCkge1xuICAgICAgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcmxvYWQgdG8gYWx3YXlzIHJlZnJlc2ggdmFsdWVcbiAgICBnZXQgaXNWaXNpYmxlICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGdldCByZWZyZXNoUmF0ZSAoKSB7XG4gICAgICAvLyBSZXR1cm4gaGVyZSB0aGUgcmVmcmVzaCByYXRlIGluIG1zLiBcbiAgICAgIHJldHVybiAxMDAwICogNjAgKiA2MCAqIDI0OyAvLyAxIGRheVxuICAgIH1cblxuICAgIGdldFNob3J0VXJsICgpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgV2ViIFNlcnZpY2UgVVJMIGhlcmUgd2l0aG91dCBwYXRoXG4gICAgICBsZXQgdXJsID0gJ0N1cnJlbnRUaW1lLyc7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cblxuICAgIHJlZnJlc2ggKGRhdGEpIHtcbiAgICAgIGxldCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgbGV0IHNlcnZlckRhdGUgPSBuZXcgRGF0ZShkYXRhLlV0Yyk7XG5cbiAgICAgIC8vIEZpbmQgZGlmZiArIHN0b3JlXG4gICAgICBsZXQgZGlmZlNlcnZlclRpbWVNaW51c05vd01TZWMgPSBzZXJ2ZXJEYXRlLmdldFRpbWUoKSAtIG5vdy5nZXRUaW1lKCk7XG4gICAgICBwdWxzZUNvbmZpZy5zZXRHbG9iYWwoJ2RpZmZTZXJ2ZXJUaW1lTWludXNOb3dNU2VjJywgZGlmZlNlcnZlclRpbWVNaW51c05vd01TZWMpO1xuXG4gICAgICAvLyBkZWZhdWx0IDMwIHNlY29uZHMgKGNhbiBiZSBvdmVybG9hZClcbiAgICAgIGxldCBhbGxvd2VkRGlmZiA9IHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ3NlY29uZHMnLCAnMzAnKTtcbiAgICAgIGlmIChNYXRoLmFicyhkaWZmU2VydmVyVGltZU1pbnVzTm93TVNlYykgPiBhbGxvd2VkRGlmZiAqIDEwMDApIHtcbiAgICAgICAgbGV0IG1lc3NhZ2VJbmZvID0ge1xuICAgICAgICAgICdpZCc6ICdDdXJyZW50IFRpbWUnLFxuICAgICAgICAgICdtZXNzYWdlJzogcHVsc2VDb25maWcucHVsc2VUcmFuc2xhdGUoJ2NoZWNrLlBsZWFzZVN5bmNUaW1lJyxcbiAgICAgICAgICAgICdQbGVhc2Ugc3luY2hvbml6ZSBkYXRlIGFuZCB0aW1lICcpLFxuICAgICAgICAgICdsZXZlbCc6ICd3YXJuaW5nJyxcbiAgICAgICAgICAnY2xpY2tUb0Nsb3NlJzogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICAvL21lc3NhZ2VJbmZvLmlkID0gaWQ7XG4gICAgICAgIC8vICdwZXJtYW5lbnQnIC0+IE5PIG1lc3NhZ2VJbmZvLnRpbWVcbiAgICAgICAgbWVzc2FnZUluZm8uY2xpY2tUb0Nsb3NlID0gZmFsc2U7XG4gICAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ3Nob3dNZXNzYWdlU2lnbmFsJyxcbiAgICAgICAgICBtZXNzYWdlSW5mbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsbGJhY2sgZXZlbnRzXG4gIH1cblxuICBwdWxzZUNvbXBvbmVudC5yZWdpc3RlckVsZW1lbnQoJ3gtY2hlY2tjdXJyZW50dGltZScsXG4gICAgQ2hlY2tDdXJyZW50VGltZUNvbXBvbmVudCk7XG59KSgpO1xuIiwiLy8gQ29weXJpZ2h0IChDKSAyMDA5LTIwMjMgTGVtb2luZSBBdXRvbWF0aW9uIFRlY2hub2xvZ2llc1xuLy9cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5cbi8qKlxuICogQG1vZHVsZSB4LWNoZWNrbG9naW5cbiAqIEByZXF1aXJlcyBtb2R1bGU6cHVsc2VDb21wb25lbnRcbiAqL1xudmFyIHB1bHNlQ29tcG9uZW50ID0gcmVxdWlyZSgncHVsc2Vjb21wb25lbnQnKTtcbnZhciBwdWxzZUNvbmZpZyA9IHJlcXVpcmUoJ3B1bHNlQ29uZmlnJyk7XG52YXIgcHVsc2VMb2dpbiA9IHJlcXVpcmUoJ3B1bHNlTG9naW4nKTtcbnZhciBwdWxzZVNlcnZpY2UgPSByZXF1aXJlKCdwdWxzZVNlcnZpY2UnKTtcbi8vdmFyIHB1bHNlVXRpbGl0eSA9IHJlcXVpcmUoJ3B1bHNlVXRpbGl0eScpO1xudmFyIGV2ZW50QnVzID0gcmVxdWlyZSgnZXZlbnRCdXMnKTtcblxuKGZ1bmN0aW9uICgpIHtcblxuICBjbGFzcyBDaGVja0xvZ2luQ29tcG9uZW50IGV4dGVuZHMgcHVsc2VDb21wb25lbnQuUHVsc2VQYXJhbUF1dG9QYXRoU2luZ2xlUmVxdWVzdENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgY29uc3Qgc2VsZiA9IHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgICAvL3NlbGYuX2NvbnRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICBzZWxmLl9wZW5kaW5nUmVmcmVzaFRva2VuID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRXaGVuQ29ubmVjdGVkT25jZSAoYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRXaGVuQ29ubmVjdGVkT25jZShhdHRyLCBvbGRWYWwsIG5ld1ZhbCk7XG4gICAgICAvKnN3aXRjaCAoYXR0cikge1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfSovXG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSAoKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCdwdWxzZS1ub2Rpc3BsYXknKTtcbiAgICAgIC8vdGhpcy5hZGRDbGFzcygncHVsc2UtdGV4dCcpOyAvLyBNYW5kYXRvcnkgZm9yIGxvYWRlclxuICAgICAgXG4gICAgICAvLyBMaXN0ZW5lciBhbmQgZGlzcGF0Y2hlcnNcbiAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIodGhpcywgJ0F1dGhvcml6YXRpb25FcnJvckV2ZW50JyxcbiAgICAgICAgdGhpcy5vbkF1dGhvcml6YXRpb25FcnJvci5iaW5kKHRoaXMpKTtcblxuICAgICAgZXZlbnRCdXMuRXZlbnRCdXMuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0aGlzLCAnVG9rZW5IYXNDaGFuZ2VkRXZlbnQnLFxuICAgICAgICB0aGlzLm9uVG9rZW5IYXNjaGFuZ2VkLmJpbmQodGhpcykpO1xuXG4gICAgICAvLyBJbiBjYXNlIG9mIGNsb25lLCBuZWVkIHRvIGJlIGVtcHR5IDpcbiAgICAgICQodGhpcy5lbGVtZW50KS5lbXB0eSgpO1xuXG4gICAgICAvLyBObyBET01cblxuICAgICAgLy8gSW5pdGlhbGl6YXRpb24gT0sgPT4gc3dpdGNoIHRvIHRoZSBuZXh0IGNvbnRleHRcbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNsZWFySW5pdGlhbGl6YXRpb24gKCkge1xuICAgICAgc3VwZXIuY2xlYXJJbml0aWFsaXphdGlvbigpO1xuICAgIH1cblxuICAgIHZhbGlkYXRlUGFyYW1ldGVycyAoKSB7XG4gICAgICAvLyBJZiBjb25uZWN0aW9uIG5vdCBhbGxvd2VkIC0gcmV0dXJuIHRvIHBhZ2UgbG9naW5cblxuICAgICAgaWYgKCFwdWxzZUNvbmZpZy5pc0xvZ2luUGFnZSgpKSB7IC8vIElmIG5vdCBpbiBwYWdlIGxvZ2luIG9yIHZhbGlkYXRlXG4gICAgICAgIC8vIEZPUiBQdWxzZSBXZWIgQXBwIC0gYXBwIGNvbnRleHQgb3Igcm9sZSBpcyBtYW5kYXRvcnlcbiAgICAgICAgaWYgKHB1bHNlQ29uZmlnLmlzQ3VycmVudEFwcCgnUHVsc2VXZWJBcHAnKSkge1xuICAgICAgICAgIGlmICgnJyA9PSBwdWxzZUNvbmZpZy5nZXRBcHBDb250ZXh0T3JSb2xlKCkpIHtcbiAgICAgICAgICAgIC8vIENsZWFuIGFsbCBjb29raWVzIGxpbmtlZCB0byBsb2dpblxuICAgICAgICAgICAgcHVsc2VMb2dpbi5jbGVhbkxvZ2luUm9sZSgpO1xuXG4gICAgICAgICAgICAvLyBSb2xlIG9yIEFwcENvbnRleHQgaXMgbWFuZGF0b3J5IC0+IGdvIHRvIHBhZ2UgbG9naW4gKGlmIG5vdClcbiAgICAgICAgICAgIHB1bHNlQ29uZmlnLmdvVG9QYWdlTG9naW4oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGT1IgQUxMIGFwcHMsIGNoZWNrIGxvZ2luXG4gICAgICAgIHRoaXMuX2NoZWNrTG9naW5Jc1ZhbGlkKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3dpdGNoVG9Db250ZXh0KCdMb2FkZWQnKTsgLy8gVG8gc3RvcCByZWZyZXNoIFxuXG4gICAgICAvLyB0aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKTstPiB0byByZXN0b3JlIGlmIHdlYiBzZXJ2aWNlIGlzIHVzZWRcbiAgICB9XG5cbiAgICBfY2hlY2tMb2dpbklzVmFsaWQgKCkge1xuICAgICAgbGV0IHVzZUxvZ2luID0gcHVsc2VDb25maWcuZ2V0Qm9vbCgndXNlTG9naW4nLCBmYWxzZSk7XG4gICAgICBpZiAodXNlTG9naW4pIHtcbiAgICAgICAgaWYgKCcnID09IHB1bHNlTG9naW4uZ2V0TG9naW4oKSkge1xuICAgICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RBbmRHb1RvUGFnZUxvZ2luKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIENoZWNrIFRva2VuIGV4cGlyYXRpb25cbiAgICAgICAgICBpZiAodGhpcy5fY2hlY2tJZlRva2VuSXNFeHBpcmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2Nvbm5lY3RBbmRHb1RvUGFnZUxvZ2luKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU3RhcnQgdGltZXIgdG8gY2hlY2sgaWYgYW5vdGhlciBwYWdlIC8gdGFiIC8gYXBwIGFza2VkIGZvciBkZWNvbm5lY3Rpb25cbiAgICAgICAgICB0aGlzLl9jaGVja0xvZ2luSXNWYWxpZFRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrTG9naW5Jc1ZhbGlkLmJpbmQodGhpcyksXG4gICAgICAgICAgICA2MDAwMCk7IC8vIDEgbWluXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNwbGF5RXJyb3IgKG1lc3NhZ2UpIHtcbiAgICAgIC8vIE5vdGhpbmdcbiAgICB9XG5cbiAgICByZW1vdmVFcnJvciAoKSB7XG4gICAgICAvLyBOb3RoaW5nXG4gICAgfVxuXG4gICAgZ2V0U2hvcnRVcmwgKCkge1xuICAgICAgLy8gUmV0dXJuIHRoZSBXZWIgU2VydmljZSBVUkwgaGVyZSB3aXRob3V0IHBhdGhcbiAgICAgIC8vcmV0dXJuICdHZXQuLi4nICsgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbXlhdHRyJyk7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmVmcmVzaCAoZGF0YSkge1xuICAgICAgLy8gVXBkYXRlIHRoZSBjb21wb25lbnQgd2l0aCBkYXRhIHdoaWNoIGlzIHJldHVybmVkIGJ5IHRoZSB3ZWIgc2VydmljZSBpbiBjYXNlIG9mIHN1Y2Nlc3NcbiAgICAgIC8vIEZvciBleGFtcGxlOlxuICAgICAgLy8kKHRoaXMuX2NvbnRlbnQpLmh0bWwoZGF0YS5OYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBjYWxsYmFjayBpbiBjYXNlIGEgY29uZmlnIGlzIHVwZGF0ZWQ6IChyZS0pc3RhcnQgdGhlIGNvbXBvbmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBldmVudFxuICAgICAqL1xuICAgIG9uQ29uZmlnQ2hhbmdlIChldmVudCkge1xuICAgICAgLy8gRGVmYXVsdCA9IGRvIG5vdGhpbmdcbiAgICAgIC8vIE1heWJlIHJlIHN0YXJ0ID9cbiAgICB9XG5cbiAgICAvLyBUb2tlbiBjaGFuZ2VkIC0+IHByZXBhcmUgdGltZW91dCBmb3IgZGlzY29ubmVjdGlvbiAodXNlZnVsIGZvciBzdGF0aWMgZGlzcGxheSBsaWtlIHJlcG9ydGluZylcbiAgICBvblRva2VuSGFzY2hhbmdlZCAoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50YXJnZXQua2luZCAhPSAnQWNjZXNzVG9rZW4nKSB7XG4gICAgICAgIC8vIElnbm9yZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBUb2tlbiBleHBpcmF0aW9uXG4gICAgICBpZiAodGhpcy5fY2hlY2tJZlRva2VuSXNFeHBpcmVkKCkpIHtcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdEFuZEdvVG9QYWdlTG9naW4oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9jaGVja0lmVG9rZW5Jc0V4cGlyZWQgKCkge1xuICAgICAgbGV0IGFjY2Vzc190b2tlbl9leHAgPSBwdWxzZUxvZ2luLmdldEFjY2Vzc1Rva2VuRXhwaXJhdGlvbigpO1xuICAgICAgaWYgKGFjY2Vzc190b2tlbl9leHAgPT0gJycpIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBkb1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGxldCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgbGV0IHRva2VuRGF0ZSA9IG5ldyBEYXRlKGFjY2Vzc190b2tlbl9leHApO1xuXG4gICAgICAvLyBGaW5kIGRpZmYgKyBzdG9yZVxuICAgICAgbGV0IGRpZmZNU2VjID0gdG9rZW5EYXRlLmdldFRpbWUoKSAtIG5vdy5nZXRUaW1lKCk7XG4gICAgICBpZiAoZGlmZk1TZWMgPiAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gZXhwaXJlZFxuICAgICAgfVxuICAgIH1cblxuICAgIF9kaXNjb25uZWN0QW5kR29Ub1BhZ2VMb2dpbiAoKSB7XG4gICAgICAvLyBDbGVhbiBhbGwgY29va2llcyBsaW5rZWQgdG8gbG9naW5cbiAgICAgIHB1bHNlTG9naW4uY2xlYW5Mb2dpblJvbGUoKTtcblxuICAgICAgLy8gR290byBwYWdlIGxvZ2luIHdpdGggYW4gZXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWRcbiAgICAgIGlmICghcHVsc2VDb25maWcuaXNMb2dpblBhZ2UoKSkgeyAvLyBJZiBub3QgaW4gcGFnZSBsb2dpblxuICAgICAgICBwdWxzZUNvbmZpZy5nb1RvUGFnZUxvZ2luKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRva2VuIGV4cGlyZWQgLT4gR0xPQkFMIHJlZnJlc2ggdG9rZW5cbiAgICBvbkF1dGhvcml6YXRpb25FcnJvciAoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5fcGVuZGluZ1JlZnJlc2hUb2tlbikge1xuICAgICAgICB0aGlzLl9wZW5kaW5nUmVmcmVzaFRva2VuID0gdHJ1ZTtcblxuICAgICAgICBsZXQgbG9naW4gPSBwdWxzZUxvZ2luLmdldExvZ2luKCk7XG4gICAgICAgIGxldCByZWZyZXNoX3Rva2VuID0gcHVsc2VMb2dpbi5nZXRSZWZyZXNoVG9rZW4oKTtcblxuICAgICAgICBpZiAobG9naW4gPT0gJycgfHxcbiAgICAgICAgICByZWZyZXNoX3Rva2VuID09ICcnKSB7XG4gICAgICAgICAgLy8gRXJyb3JcbiAgICAgICAgICB0aGlzLl9yZW5ld1Rva2VuRXJyb3IuYmluZCh0aGlzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdXJsID0gdGhpcy5nZXRDb25maWdPckF0dHJpYnV0ZSgncGF0aCcsICcnKVxuICAgICAgICAgICsgJ1VzZXIvUmVuZXdUb2tlbic7XG5cbiAgICAgICAgbGV0IHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIHB1bHNlU2VydmljZS5wb3N0QWpheCgwLCB1cmwsXG4gICAgICAgICAge1xuICAgICAgICAgICAgJ0xvZ2luJzogbG9naW4sXG4gICAgICAgICAgICAnUmVmcmVzaFRva2VuJzogcmVmcmVzaF90b2tlblxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICB0aGlzLl9yZW5ld1Rva2VuU3VjY2Vzcy5iaW5kKHRoaXMpLFxuICAgICAgICAgIHRoaXMuX3JlbmV3VG9rZW5FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgICAgIHRoaXMuX3JlbmV3VG9rZW5GYWlsLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9yZW5ld1Rva2VuU3VjY2VzcyAodG9rZW4sIGRhdGEpIHtcbiAgICAgIHB1bHNlTG9naW4uc3RvcmVMb2dpblJvbGVGcm9tUmVmcmVzaERUTyhkYXRhLCB0cnVlKTtcbiAgICAgIHRoaXMuX3BlbmRpbmdSZWZyZXNoVG9rZW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfcmVuZXdUb2tlbkVycm9yICh0b2tlbiwgZXJyb3IpIHtcbiAgICAgIHB1bHNlQ29uZmlnLnNldEdsb2JhbCgnbG9naW5FcnJvcicsICdBdXRoZW50aWNhdGlvbiBFcnJvci4gUGxlYXNlIHJldHJ5Jyk7XG4gICAgICAvLyBDbGVhbiBhbGwgY29va2llcyBsaW5rZWQgdG8gbG9naW5cbiAgICAgIHB1bHNlTG9naW4uY2xlYW5Mb2dpblJvbGUoKTtcblxuICAgICAgLy8gR290byBwYWdlIGxvZ2luIHdpdGggYW4gZXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWRcbiAgICAgIGlmICghcHVsc2VDb25maWcuaXNMb2dpblBhZ2UoKSkgeyAvLyBJZiBub3QgaW4gcGFnZSBsb2dpblxuICAgICAgICBwdWxzZUNvbmZpZy5nb1RvUGFnZUxvZ2luKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGVuZGluZ1JlZnJlc2hUb2tlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIF9yZW5ld1Rva2VuRmFpbCAodG9rZW4sIHVybCwgaXNUaW1lb3V0LCB4aHJTdGF0dXMpIHtcbiAgICAgIHB1bHNlQ29uZmlnLnNldEdsb2JhbCgnbG9naW5FcnJvcicsICdBdXRoZW50aWNhdGlvbiBFcnJvci4gUGxlYXNlIHJldHJ5Jyk7XG4gICAgICAvLyBDbGVhbiBhbGwgY29va2llcyBsaW5rZWQgdG8gbG9naW5cbiAgICAgIHB1bHNlTG9naW4uY2xlYW5Mb2dpblJvbGUoKTtcblxuICAgICAgLy8gR290byBwYWdlIGxvZ2luIHdpdGggYW4gZXJyb3IgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWRcbiAgICAgIGlmICghcHVsc2VDb25maWcuaXNMb2dpblBhZ2UoKSkgeyAvLyBJZiBub3QgaW4gcGFnZSBsb2dpblxuICAgICAgICBwdWxzZUNvbmZpZy5nb1RvUGFnZUxvZ2luKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fcGVuZGluZ1JlZnJlc2hUb2tlbiA9IGZhbHNlO1xuICAgIH1cblxuICB9XG5cbiAgcHVsc2VDb21wb25lbnQucmVnaXN0ZXJFbGVtZW50KCd4LWNoZWNrbG9naW4nLCBDaGVja0xvZ2luQ29tcG9uZW50KTtcbn0pKCk7XG4iLCIvLyBDb3B5cmlnaHQgKEMpIDIwMDktMjAyMyBMZW1vaW5lIEF1dG9tYXRpb24gVGVjaG5vbG9naWVzXG4vL1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuLyoqXG4gKiBAbW9kdWxlIHgtY2hlY2twYXRoXG4gKiBAcmVxdWlyZXMgbW9kdWxlOnB1bHNlQ29tcG9uZW50XG4gKi9cbnZhciBwdWxzZUNvbXBvbmVudCA9IHJlcXVpcmUoJ3B1bHNlY29tcG9uZW50Jyk7XG52YXIgcHVsc2VDb25maWcgPSByZXF1aXJlKCdwdWxzZUNvbmZpZycpO1xudmFyIGV2ZW50QnVzID0gcmVxdWlyZSgnZXZlbnRCdXMnKTtcblxuKGZ1bmN0aW9uICgpIHtcblxuICBjbGFzcyBDaGVja1BhdGhDb21wb25lbnQgZXh0ZW5kcyBwdWxzZUNvbXBvbmVudC5QdWxzZVBhcmFtU2luZ2xlUmVxdWVzdENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgY29uc3Qgc2VsZiA9IHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgICBzZWxmLl9jb250ZW50ID0gdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkV2hlbkNvbm5lY3RlZE9uY2UgKGF0dHIsIG9sZFZhbCwgbmV3VmFsKSB7XG4gICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkV2hlbkNvbm5lY3RlZE9uY2UoYXR0ciwgb2xkVmFsLCBuZXdWYWwpO1xuICAgIH1cblxuICAgIGluaXRpYWxpemUgKCkge1xuICAgICAgdGhpcy5hZGRDbGFzcygncHVsc2Utbm9kaXNwbGF5Jyk7XG5cbiAgICAgIC8vdGhpcy5hZGRDbGFzcygncHVsc2UtYmlnZGlzcGxheScpO1xuXG4gICAgICAvLyBDcmVhdGUgRE9NIC0gTG9hZGVyIChETyBOT1QgUkVNT1ZFIGNvZGUgPT4gd2lsbCBiZSB1c2VkIG9uY2UgdGhlIGdsb2JhbCBlcnJvciBtZXNzYWdlIHdpbGwgZGlzcGxheSBpbmZvKVxuICAgICAgLy8gVG8gZGlzcGxheSBCSUcgTE9BRElORyBvbiB0aGUgd2hvbGUgcGFnZSAtIHJlbW92ZWQgRk9SIFRIRSBNT01FTlRcbiAgICAgIC8vIERPIE5PVCBSRU1PVkUgVEhFU0UgMiBMSU5FUyAhISFcbiAgICAgIC8qbGV0IGxvYWRlciA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3B1bHNlLWxvYWRlcicpLmh0bWwoJ0xvYWRpbmcuLi4nKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgbGV0IGxvYWRlckRpdiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3B1bHNlLWxvYWRlci1kaXYnKS5hcHBlbmQobG9hZGVyKTtcbiAgICAgICQodGhpcy5fY29udGVudCkuYXBwZW5kKGxvYWRlckRpdik7Ki9cbiAgICAgIC8vIENyZWF0ZSBET00gLSBDb250ZW50XG4gICAgICAvL3RoaXMuX2NvbnRlbnQgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdwdWxzZS1jaGVja3BhdGgtY29udGVudCcpO1xuXG4gICAgICAvLyBMaXN0ZW5lclxuXG4gICAgICAvLyBJbml0aWFsaXphdGlvbiBPSyA9PiBzd2l0Y2ggdG8gdGhlIG5leHQgY29udGV4dFxuICAgICAgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQYXJhbWV0ZXJzICgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgY2hlY2tzIHdpdGggYXR0cmlidXRlIHBhcmFtXG4gICAgIFxuICAgICAgbGV0IHNraXAgPSB0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdza2lwV2ViU2VydmljZUFkZHJlc3MnLCAnZmFsc2UnKTtcblxuICAgICAgaWYgKCBza2lwID09IHRydWUgfHwgc2tpcCA9PSAndHJ1ZScgKSB7XG4gICAgICAgIGxldCBtYWlucGF0aCA9IHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ21haW5wYXRoJywgJycpOyAvLyBQcm9iYWJseSBcIlwiXG4gICAgICAgIGlmIChtYWlucGF0aCAhPSAnJykge1xuICAgICAgICAgIC8vICcvJyBhdCB0aGUgZW5kID9cbiAgICAgICAgICBsZXQgbGFzdENoYXIgPSBtYWlucGF0aC5jaGFyQXQobWFpbnBhdGgubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgaWYgKGxhc3RDaGFyICE9ICcvJykge1xuICAgICAgICAgICAgbWFpbnBhdGggPSBtYWlucGF0aCArICcvJztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IG9sZHBhdGggPSB0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdwYXRoJywgJycpO1xuICAgICAgICAgIGlmIChvbGRwYXRoICE9IG1haW5wYXRoKSB7IC8vIFJlbG9hZCBvbmx5IGlmIGRpZmZlcmVudCwgZWxzZSBlbmRsZXNzIHJlbG9hZCBhdCBiZWdpbm5pbmcgd2hlbiBzZXJ2ZXIgaXMgc3RvcHBlZC5cbiAgICAgICAgICAgIHB1bHNlQ29uZmlnLnNldEdsb2JhbCgncGF0aCcsIG1haW5wYXRoKTsgLy8gU2Vzc2lvblN0b3JhZ2VcbiAgICAgICAgICAgIC8vIFdhcm4gYWxsIGNvbXBvbmVudHMgdG8gcmVsb2FkIDpcbiAgICAgICAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ3BhdGhDaGFuZ2VFdmVudCcsIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRFcnJvcignU2tpcCB3ZWIgc2VydmljZSBwYXRoJyk7XG4gICAgICB9XG4gICAgICBlbHNle1xuICAgICAgICB0aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPdmVybG9hZCB0byBhbHdheXMgcmVmcmVzaCB2YWx1ZVxuICAgIGdldCBpc1Zpc2libGUgKCkge1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHsgLy8gPT0gaXMgY29ubmVjdGVkXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGdldCB1cmwgKCkge1xuICAgICAgbGV0IG1haW5wYXRoID0gdGhpcy5nZXRDb25maWdPckF0dHJpYnV0ZSgnbWFpbnBhdGgnLCAnJyk7IC8vIFByb2JhYmx5IFwiXCJcbiAgICAgIGlmIChtYWlucGF0aCA9PSAnJykge1xuICAgICAgICBsZXQgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgICAvLyBIYWNrIGZvciBsb2NhbCBwYXRoIChvbiBkZXYgY29tcHV0ZXJzKVxuICAgICAgICBpZiAoJ2ZpbGUnID09IGhyZWYuc2xpY2UoMCwgNCkpIHtcbiAgICAgICAgICBtYWlucGF0aCA9ICdodHRwczovL2xjdHI6NTAwMS8nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIFNlYXJjaCBpbiBQYWdlIFVSTCA6IGh0dHA6Ly9sY3RyL1J0ZFdlYkFwcC8uLi5cbiAgICAgICAgICBsZXQgcG9zU2xhc2ggPSBocmVmLmluZGV4T2YoJy8nLCA4KTsgIC8vID0gbW9yZSB0aGFuIDc8LT5sZW5ndGggb2YgaHR0cDovL1xuICAgICAgICAgIGlmIChwb3NTbGFzaCAhPSAtMSkge1xuICAgICAgICAgICAgbWFpbnBhdGggPSBocmVmLnNsaWNlKDAsIHBvc1NsYXNoKSArICc6NTAwMS8nOyAvLyBodHRwczovL2xjdHI6NTAwMVxuICAgICAgICAgICAgaWYgKCBtYWlucGF0aC5pbmRleE9mKCdodHRwcycpICE9IC0xICkge1xuICAgICAgICAgICAgICAvLyBwYXRoIGRvIG5vdCBpbmNsdWRlICdodHRwcydcbiAgICAgICAgICAgICAgaWYgKCBtYWlucGF0aC5zdGFydHNXaXRoKCdodHRwJykgKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkICdzJyBhZnRlciBodHRwXG4gICAgICAgICAgICAgICAgbWFpbnBhdGggPSAnaHR0cHMnICsgbWFpbnBhdGguc2xpY2UoNCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vICcvJyBhdCB0aGUgZW5kID9cbiAgICAgIGxldCBsYXN0Q2hhciA9IG1haW5wYXRoLmNoYXJBdChtYWlucGF0aC5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChsYXN0Q2hhciAhPSAnLycpIHtcbiAgICAgICAgbWFpbnBhdGggKz0gJy8nO1xuICAgICAgfVxuICAgICAgLy8gUmV0dXJuIHRoZSBXZWIgU2VydmljZSBVUkwgaGVyZVxuICAgICAgcmV0dXJuIG1haW5wYXRoICsgJ1dlYlNlcnZpY2VBZGRyZXNzLyc7XG4gICAgfVxuXG4gICAgcmVmcmVzaCAoZGF0YSkge1xuICAgICAgbGV0IHByZXZpb3VzUGF0aCA9IHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ3BhdGgnLCAnJyk7XG5cbiAgICAgIGxldCBzZWNvbmRhcnlwYXRoID0gZGF0YS5Vcmw7XG4gICAgICBpZiAoc2Vjb25kYXJ5cGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vICcvJyBhdCB0aGUgZW5kID9cbiAgICAgICAgbGV0IGxhc3RDaGFyID0gc2Vjb25kYXJ5cGF0aC5jaGFyQXQoc2Vjb25kYXJ5cGF0aC5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGxhc3RDaGFyICE9ICcvJykge1xuICAgICAgICAgIHNlY29uZGFyeXBhdGggPSBzZWNvbmRhcnlwYXRoICsgJy8nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwdWxzZUNvbmZpZy5zZXRHbG9iYWwoJ3BhdGgnLCBzZWNvbmRhcnlwYXRoKTsgLy8gU2Vzc2lvblN0b3JhZ2VcbiAgICAgIGlmIChzZWNvbmRhcnlwYXRoICE9IHByZXZpb3VzUGF0aCkge1xuICAgICAgICAvLyBXYXJuIGFsbCBjb21wb25lbnRzIHRvIHJlbG9hZCA6XG4gICAgICAgIGNvbnNvbGUubG9nKCdkaXNwYXRjaCBwYXRoIGNoYW5nZSBldmVudCcpO1xuICAgICAgICBldmVudEJ1cy5FdmVudEJ1cy5kaXNwYXRjaFRvQWxsKCdwYXRoQ2hhbmdlRXZlbnQnLCB7fSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWFuYWdlRXJyb3IgKGRhdGEpIHtcbiAgICAgIC8qIE5PIE1lc3NhZ2UgaGVyZSwgYmVjYXVzZSBpdCBjYW4gaGFwcGVucyBpZiBXZWJTZXJ2aWNlQWRkcmVzcyBpcyBiYWRseSBjb25maWd1cmVkXG4gICAgICB2YXIgbWVzc2FnZUluZm8gPSB7XG4gICAgICAgICdpZCc6ICdNQUlOUEFUSCcsXG4gICAgICAgICdtZXNzYWdlJzogcHVsc2VDb25maWcucHVsc2VUcmFuc2xhdGUoJ2NoZWNrLlBsZWFzZUNoZWNrU2VydmVyT3JQYXRoJywgJ1BsZWFzZSBjaGVjayBzZXJ2ZXIgYWNjZXNzIChvciBwYXRoKScpLFxuICAgICAgICAvLyBLZWVwIG9yIG1haW5wYXRoIGhlcmUuIEJlY2F1c2UgaXQgaXMgcHJvYmFibHkgbGlua2VkIHRvIHBhdGggd2hlbiB0aGUgbWVzc2FnZSBjb21lcyBmcm9tIGhlcmUgLS1SUlxuICAgICAgICAnbGV2ZWwnOiAnZXJyb3InLFxuICAgICAgICAndGltZSc6IDIwIC8vIHNlY29uZHMgdG8gZGlzcGxheSBtZXNzYWdlXG4gICAgICB9O1xuICAgICAgbWVzc2FnZUluZm8uY2xpY2tUb0Nsb3NlID0gdHJ1ZTtcbiAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ3Nob3dNZXNzYWdlU2lnbmFsJyxcbiAgICAgICAgbWVzc2FnZUluZm8pOyovXG5cbiAgICAgIC8vIEluIGNhc2Ugb2YgZXJyb3IsIHRyeSB0byB1c2UgbWFpbnBhdGggZGVmaW5lZCBpbiBjb25maWdcbiAgICAgIGxldCBtYWlucGF0aCA9IHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ21haW5wYXRoJywgJycpOyAvLyBQcm9iYWJseSBcIlwiXG4gICAgICBpZiAobWFpbnBhdGggIT0gJycpIHtcbiAgICAgICAgLy8gJy8nIGF0IHRoZSBlbmQgP1xuICAgICAgICBsZXQgbGFzdENoYXIgPSBtYWlucGF0aC5jaGFyQXQobWFpbnBhdGgubGVuZ3RoIC0gMSk7XG4gICAgICAgIGlmIChsYXN0Q2hhciAhPSAnLycpIHtcbiAgICAgICAgICBtYWlucGF0aCA9IG1haW5wYXRoICsgJy8nO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvbGRwYXRoID0gdGhpcy5nZXRDb25maWdPckF0dHJpYnV0ZSgncGF0aCcsICcnKTtcbiAgICAgICAgaWYgKG9sZHBhdGggIT0gbWFpbnBhdGgpIHsgLy8gUmVsb2FkIG9ubHkgaWYgZGlmZmVyZW50LCBlbHNlIGVuZGxlc3MgcmVsb2FkIGF0IGJlZ2lubmluZyB3aGVuIHNlcnZlciBpcyBzdG9wcGVkLlxuICAgICAgICAgIHB1bHNlQ29uZmlnLnNldEdsb2JhbCgncGF0aCcsIG1haW5wYXRoKTsgLy8gU2Vzc2lvblN0b3JhZ2VcbiAgICAgICAgICAvLyBXYXJuIGFsbCBjb21wb25lbnRzIHRvIHJlbG9hZCA6XG4gICAgICAgICAgZXZlbnRCdXMuRXZlbnRCdXMuZGlzcGF0Y2hUb0FsbCgncGF0aENoYW5nZUV2ZW50Jywge30pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN1cGVyLm1hbmFnZUVycm9yKGRhdGEpO1xuICAgIH1cblxuICAgIG1hbmFnZUZhaWx1cmUgKGlzVGltZW91dCwgeGhyU3RhdHVzKSB7XG4gICAgICB2YXIgbWVzc2FnZUluZm8gPSB7XG4gICAgICAgICdpZCc6ICdQQVRIJyxcbiAgICAgICAgJ21lc3NhZ2UnOiBwdWxzZUNvbmZpZy5wdWxzZVRyYW5zbGF0ZSgnY2hlY2suUGxlYXNlQ2hlY2tTZXJ2ZXJPclBhdGgnLCAnUGxlYXNlIGNoZWNrIHNlcnZlciBhY2Nlc3MgKG9yIHBhdGgpJyksXG4gICAgICAgIC8vIEtlZXAgJ29yIHBhdGgnIGhlcmUuIEJlY2F1c2UgaXQgaXMgcHJvYmFibHkgbGlua2VkIHRvIHBhdGggd2hlbiB0aGUgbWVzc2FnZSBjb21lcyBmcm9tIGhlcmUgLS1SUlxuICAgICAgICAnbGV2ZWwnOiAnZXJyb3InLFxuICAgICAgICAndGltZSc6IDIwIC8vIHNlY29uZHMgdG8gZGlzcGxheSBtZXNzYWdlXG4gICAgICB9O1xuICAgICAgbWVzc2FnZUluZm8uY2xpY2tUb0Nsb3NlID0gdHJ1ZTtcbiAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ3Nob3dNZXNzYWdlU2lnbmFsJyxcbiAgICAgICAgbWVzc2FnZUluZm8pO1xuXG4gICAgICAvLyBJbiBjYXNlIG9mIGVycm9yLCB0cnkgdG8gdXNlIG1haW5wYXRoIGRlZmluZWQgaW4gY29uZmlnXG4gICAgICBsZXQgbWFpbnBhdGggPSB0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdtYWlucGF0aCcsICcnKTsgLy8gUHJvYmFibHkgXCJcIlxuICAgICAgaWYgKG1haW5wYXRoICE9ICcnKSB7XG4gICAgICAgIC8vICcvJyBhdCB0aGUgZW5kID9cbiAgICAgICAgbGV0IGxhc3RDaGFyID0gbWFpbnBhdGguY2hhckF0KG1haW5wYXRoLmxlbmd0aCAtIDEpO1xuICAgICAgICBpZiAobGFzdENoYXIgIT0gJy8nKSB7XG4gICAgICAgICAgbWFpbnBhdGggPSBtYWlucGF0aCArICcvJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2xkcGF0aCA9IHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ3BhdGgnLCAnJyk7XG4gICAgICAgIGlmIChvbGRwYXRoICE9IG1haW5wYXRoKSB7IC8vIFJlbG9hZCBvbmx5IGlmIGRpZmZlcmVudCwgZWxzZSBlbmRsZXNzIHJlbG9hZCBhdCBiZWdpbm5pbmcgd2hlbiBzZXJ2ZXIgaXMgc3RvcHBlZC5cbiAgICAgICAgICBwdWxzZUNvbmZpZy5zZXRHbG9iYWwoJ3BhdGgnLCBtYWlucGF0aCk7IC8vIFNlc3Npb25TdG9yYWdlXG4gICAgICAgICAgLy8gV2FybiBhbGwgY29tcG9uZW50cyB0byByZWxvYWQgOlxuICAgICAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ3BhdGhDaGFuZ2VFdmVudCcsIHt9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdXBlci5tYW5hZ2VGYWlsdXJlKGlzVGltZW91dCwgeGhyU3RhdHVzKTtcbiAgICB9XG4gIH1cblxuICBwdWxzZUNvbXBvbmVudC5yZWdpc3RlckVsZW1lbnQoJ3gtY2hlY2twYXRoJywgQ2hlY2tQYXRoQ29tcG9uZW50KTtcbn0pKCk7XG4iLCIvLyBDb3B5cmlnaHQgKEMpIDIwMDktMjAyMyBMZW1vaW5lIEF1dG9tYXRpb24gVGVjaG5vbG9naWVzXG4vL1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuLyoqXG4gKiBAbW9kdWxlIHgtY2hlY2tzZXJ2ZXJhY2Nlc3NcbiAqIEByZXF1aXJlcyBtb2R1bGU6cHVsc2VDb21wb25lbnRcbiAqL1xudmFyIHB1bHNlQ29tcG9uZW50ID0gcmVxdWlyZSgncHVsc2Vjb21wb25lbnQnKTtcbnZhciBldmVudEJ1cyA9IHJlcXVpcmUoJ2V2ZW50QnVzJyk7XG52YXIgcHVsc2VTdmcgPSByZXF1aXJlKCdwdWxzZVN2ZycpO1xudmFyIHB1bHNlQ29uZmlnID0gcmVxdWlyZSgncHVsc2VDb25maWcnKTtcblxuKGZ1bmN0aW9uICgpIHtcblxuICBjbGFzcyBDaGVja1NlcnZlckFjY2Vzc0NvbXBvbmVudCBleHRlbmRzIHB1bHNlQ29tcG9uZW50LlB1bHNlUGFyYW1BdXRvUGF0aFJlZnJlc2hpbmdDb21wb25lbnQge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgY29uc3Qgc2VsZiA9IHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgICBzZWxmLl9kYXRhYmFzZUlzRGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICBzZWxmLl9zZXJ2ZXJQcm9iYWJseU9mZiA9IGZhbHNlO1xuICAgICAgdGhpcy5fc2VydmVyUHJvYmFibHlEaXNjb25uZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG5cbiAgICBpbml0aWFsaXplICgpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3B1bHNlLW5vZGlzcGxheScpO1xuICAgICAgXG4gICAgICAvLyBJbiBjYXNlIG9mIGNsb25lLCBuZWVkIHRvIGJlIGVtcHR5IDpcbiAgICAgICQodGhpcy5lbGVtZW50KS5lbXB0eSgpO1xuICAgICAgdGhpcy5fZGF0YWJhc2VJc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBsaXN0ZW5lcnNcbiAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIodGhpcywgJ3NlcnZlclByb2JhYmx5RGlzY29ubmVjdGVkJyxcbiAgICAgICAgdGhpcy5vblNlcnZlclByb2JhYmx5RGlzY29ubmVjdGVkQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgZXZlbnRCdXMuRXZlbnRCdXMuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0aGlzLCAnZGF0YWJhc2VQcm9iYWJseURpc2Nvbm5lY3RlZCcsXG4gICAgICAgIHRoaXMub25EYXRhYmFzZURpc2Nvbm5lY3RlZENoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIodGhpcywgJ3B1bHNlTWFpbnRlbmFuY2UnLFxuICAgICAgICB0aGlzLm9uUHVsc2VNYWludGVuYW5jZS5iaW5kKHRoaXMpKTtcblxuICAgICAgLy8gQ3JlYXRlIERPTSAtIE5vbmVcblxuICAgICAgLy8gSW5pdGlhbGl6YXRpb24gT0sgPT4gc3dpdGNoIHRvIHRoZSBuZXh0IGNvbnRleHRcbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBDbGVhciBhbnl0aGluZyB0aGF0IHdhcyBkb25lIGR1cmluZyBpbnRpYWxpemF0aW9uLCBzbyB0aGF0IGluaXRpYWxpemUgY2FuIGJlIGNhbGxlZCBvbmNlIGFnYWluLlxuICAgICAgKiBSZW1vdmUgYWxsIHRoZSBkaXNwYXRjaGVycyBhbmQgbGlzdGVuZXJzLlxuICAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IG5vIHN0YXRlIHN3aXRjaCBpcyBkb25lIGhlcmVcbiAgICAqL1xuICAgIGNsZWFySW5pdGlhbGl6YXRpb24gKCkge1xuICAgICAgLy8gRE9NXG4gICAgICAkKHRoaXMuZWxlbWVudCkuZW1wdHkoKTtcblxuICAgICAgdGhpcy5fZGF0YWJhc2VJc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuXG4gICAgICBzdXBlci5jbGVhckluaXRpYWxpemF0aW9uKCk7XG4gICAgfVxuXG4gICAgcmVzZXQgKCkgeyAvLyBPcHRpb25hbCBpbXBsZW1lbnRhdGlvbiA9IGNhbGxlZCBhZnRlciAnc3RhcnQnXG4gICAgICAvLyBDb2RlIGhlcmUgdG8gY2xlYW4gdGhlIGNvbXBvbmVudCB3aGVuIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbiAgICAgIC8vIGZvciBleGFtcGxlIGFmdGVyIGEgcGFyYW1ldGVyIGNoYW5nZVxuICAgICAgLy90aGlzLnJlbW92ZUVycm9yKCk7XG4gICAgICAvLyBFbXB0eSB0aGlzLl9jb250ZW50XG5cbiAgICAgIC8vIHRoaXMuX2RhdGFiYXNlSXNEaXNjb25uZWN0ZWQgPSBmYWxzZTsuLi4gU3VydG91dCBwYXMgISBsZSByZXN0YXJ0IHBhc3NlIGljaVxuXG4gICAgICB0aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgKGV2ZW50KSBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgdmFsaWRhdGVQYXJhbWV0ZXJzICgpIHtcbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgIH1cblxuICAgIG1hbmFnZUVycm9yIChkYXRhKSB7XG4gICAgICBzdXBlci5tYW5hZ2VFcnJvcihkYXRhKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5RXJyb3IgKG1lc3NhZ2UpIHtcbiAgICAgIC8vIE5vdCBoZXJlICEhISBDYW4gYmUgY2FsbGVkIGFueXdoZXJlIGVsc2VcbiAgICB9XG5cbiAgICBkaXNwbGF5RXJyb3JBbmRTdG9wQWxsICgpIHtcbiAgICAgIC8vIE5vIGRpc3BsYXkgYnV0IHNlbmQgbWVzc2FnZSBmb3Igb3V0c2lkZSBkaXNwbGF5XG5cbiAgICAgIGxldCBtZXNzYWdlSW5mbyA9IHtcbiAgICAgICAgJ2lkJzogJ05PX1NFUlZFUicsIC8vIHNhbWUgYXMgY2xlYXJcbiAgICAgICAgJ21lc3NhZ2UnOiBwdWxzZUNvbmZpZy5wdWxzZVRyYW5zbGF0ZSgnY2hlY2suUGxlYXNlQ2hlY2tTZXJ2ZXInLFxuICAgICAgICAgICdQbGVhc2UgY2hlY2sgc2VydmVyIGFjY2VzcycpLCAvLyBzZXJ2ZXIgT1IgZGF0YWJhc2VcbiAgICAgICAgJ2xldmVsJzogJ2Vycm9yJywgLy8gb3IgJ3dhcm5pbmcnLCA/XG4gICAgICAgICdjbGlja1RvQ2xvc2UnOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX2RhdGFiYXNlSXNEaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgbWVzc2FnZUluZm8ubWVzc2FnZSA9IHB1bHNlQ29uZmlnLnB1bHNlVHJhbnNsYXRlKCdjaGVjay5QbGVhc2VEYXRhYmFzZUFjY2VzcycsXG4gICAgICAgICAgJ1BsZWFzZSBjaGVjayBkYXRhYmFzZSBhY2Nlc3MnKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRCdXMuRXZlbnRCdXMuZGlzcGF0Y2hUb0FsbCgnc2hvd01lc3NhZ2VTaWduYWwnLCBtZXNzYWdlSW5mbyk7XG5cbiAgICAgIC8vIFN0b3JlIHN0YXRlXG4gICAgICB0aGlzLl9zZXJ2ZXJQcm9iYWJseU9mZiA9IHRydWU7XG4gICAgICBldmVudEJ1cy5FdmVudEJ1cy5kaXNwYXRjaFRvQWxsKCdzZXJ2ZXJQcm9iYWJseU9mZlN0b3BSZWZyZXNoJywge30pO1xuICAgIH1cblxuICAgIHJlbW92ZUVycm9yICgpIHtcbiAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgIC8vdGhpcy5fZGF0YWJhc2VJc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlOyAuLi4gU3VydG91dCBwYXMgISBsZSByZXN0YXJ0IHBhc3NlIGljaVxuICAgIH1cblxuICAgIGdldCByZWZyZXNoUmF0ZSAoKSB7XG4gICAgICByZXR1cm4gMTAwMCAqIE51bWJlcih0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdyZWZyZXNoaW5nUmF0ZS5jdXJyZW50UmVmcmVzaFNlY29uZHMnLCAxMCkpO1xuICAgIH1cblxuICAgIGdldCB0cmFuc2llbnRFcnJvckRlbGF5ICgpIHtcbiAgICAgIC8vcmV0dXJuIE51bWJlcigxMDAwKTsgLy8gPT0gMXNlYyAvLyBETyBOT1QgVVNFIGZyZWV6ZU1pbnV0ZXMgPT0gdG9vIGxvbmcgKlxuICAgICAgbGV0IGJhc2ljRnJlZXplTWludXRlcyA9IHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ3N0b3BSZWZyZXNoaW5nUmF0ZS5mcmVlemVNaW51dGVzJywgdGhpcy5fZGVmYXVsdFRyYW5zaWVudEVycm9yRGVsYXkgLyA2MCAvIDEwMDApO1xuICAgICAgbGV0IGZhc3RSZWZyZXNoUmF0ZSA9IDEwMDAgKiBOdW1iZXIodGhpcy5nZXRDb25maWdPckF0dHJpYnV0ZSgncmVmcmVzaGluZ1JhdGUuY3VycmVudFJlZnJlc2hTZWNvbmRzJywgMTApKTtcbiAgICAgIHJldHVybiAoTnVtYmVyKGJhc2ljRnJlZXplTWludXRlcykgKiA2MCAqIDEwMDApXG4gICAgICAgIC0gMiAqIGZhc3RSZWZyZXNoUmF0ZTsgLy8gVG8gcmVmcmVzaCBmYXN0ZXIgdGhhbiBvdGhlciBjb21wb25lbnRzID0gYXZvaWQgbG9uZyAnTm90IENvbm5lY3RlZCcgZGlzcGxheVxuICAgIH1cblxuICAgIGdldFNob3J0VXJsICgpIHtcbiAgICAgIGxldCB1cmwgPSAnRGF0YS9Db21wdXRlci9HZXRMY3RyP0NhY2hlPU5vJzsgLy8gd2FzICdUZXN0JztcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgbWFuYWdlU3VjY2VzcyAoZGF0YSkge1xuICAgICAgLy8gSGlkZSBtZXNzYWdlXG4gICAgICBsZXQgbWVzc2FnZUluZm8gPSB7XG4gICAgICAgICdpZCc6ICdOT19TRVJWRVInIC8vIHNhbWUgYXMgc2hvd1xuICAgICAgfTtcbiAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ2NsZWFyTWVzc2FnZVNpZ25hbCcsIG1lc3NhZ2VJbmZvKTtcblxuICAgICAgLy8gSGlkZSAnTWFpbnRlbmFuY2UnIC0gYWx3YXlzIHRvIGJlIHN1cmUgIVxuICAgICAgcHVsc2VTdmcuaGlkZVB1bHNlTWFpbnRlbmFuY2UoKTtcblxuICAgICAgaWYgKHRoaXMuX2RhdGFiYXNlSXNEaXNjb25uZWN0ZWQgfHwgdGhpcy5fc2VydmVyUHJvYmFibHlPZmYpIHtcbiAgICAgICAgdGhpcy5fZGF0YWJhc2VJc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zZXJ2ZXJQcm9iYWJseU9mZiA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHN0YXJ0IHRvIGxvYWQgZGF0YSBhZ2FpbiAoZGF0YWJhc2UgLyBzZXJ2ZXIgb3IgbWFpbnRlbmFuY2UgRU5EIClcbiAgICAgICAgZXZlbnRCdXMuRXZlbnRCdXMuZGlzcGF0Y2hUb0FsbCgnc2VydmVyUHJvYmFibHlBdmFpbGFibGUnLCB7fSk7XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gQ2FsbCBoZXJlIHRvbyB0byBhdm9pZCBmcm96ZW4gZGlzcGxheVxuICAgICAgICAvLyBzdGFydCB0byBsb2FkIGRhdGEgYWdhaW4gKGRhdGFiYXNlIC8gc2VydmVyIG9yIG1haW50ZW5hbmNlIEVORCApXG4gICAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ3NlcnZlclByb2JhYmx5QXZhaWxhYmxlJywge30pO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2VydmVyUHJvYmFibHlEaXNjb25uZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgLy8gU3RvcCBjb250ZXh0XG4gICAgICB0aGlzLnN3aXRjaFRvQ29udGV4dCgnU3RvcCcpO1xuICAgIH1cblxuICAgIC8vIENhbGxiYWNrIGV2ZW50c1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgYnVzIGNhbGxiYWNrIHRyaWdnZXJlZCB3aGVuIHJlY2VpdnZpbmcgZXZlbnQgc2VydmVyIHByb2JhYmx5IGRpY29ubmVjdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblNlcnZlclByb2JhYmx5RGlzY29ubmVjdGVkQ2hhbmdlIChldmVudCkge1xuICAgICAgLyogRE8gTk9UIFJFTU9WRSA6IGhlcmUgaXMgaG93IHRvIGZpbmQgb3JpZ2luIG9mIGluZm8gOiAqL1xuICAgICAgLypsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgbGV0IHVybCA9IGV2ZW50LnRhcmdldC51cmw7XG4gICAgICBsZXQgc291cmNlID0gZXZlbnQudGFyZ2V0LnNvdXJjZTtcbiAgICAgIGxldCB3aGVuID0gZXZlbnQudGFyZ2V0LndoZW47Ki9cblxuICAgICAgaWYgKGZhbHNlID09IHRoaXMuX3NlcnZlclByb2JhYmx5RGlzY29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX3NlcnZlclByb2JhYmx5RGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2VydmVyUHJvYmFibHlEaXNjb25uZWN0ZWRTaW5jZSA9IG5ldyBEYXRlKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gPSBpZiAodGhpcy5fc2VydmVyUHJvYmFibHlEaXNjb25uZWN0ZWQgPT0gdHJ1ZSlcbiAgICAgICAgbGV0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGxldCBlbGFwc2VkTVNlYyA9IG5vdy5nZXRUaW1lKCkgLSB0aGlzLl9zZXJ2ZXJQcm9iYWJseURpc2Nvbm5lY3RlZFNpbmNlLmdldFRpbWUoKTtcblxuICAgICAgICAvLyBEaXNwbGF5IGFmdGVyIDEgbWludXRlID09IHdoZW4gd2UgYXJlIHN1cmUgdGhhdCBtYW55IHNlcnZpY2VzIGZhaWxlZCwgZm9yIGV4YW1wbGVcbiAgICAgICAgbGV0IE1pbiA9IDE7XG4gICAgICAgIGlmIChlbGFwc2VkTVNlYyA+PSBNaW4gKiA2MCAqIDEwMDApIHtcbiAgICAgICAgICAvLyBDaGVjayBteSBzZWxmIGlmIGl0IGlzIHRydWVcblxuICAgICAgICAgIC8vIERPIE5PVCByZW1vdmVkIGNvbW1lbnQgeWV0IC0tIDIwMjIgMDJcbiAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgd2lsbCBiZSBleGVjdXRlZCBpZiBzZXJ2ZXIgaXMgUkVBTExZIGRpc2Nvbm5lY3RlZCA9IG1hbmFnZUVycm9yXG4gICAgICAgICAgLy8gU3RvcmUgc3RhdGVcbiAgICAgICAgICAvL3RoaXMuX3NlcnZlclByb2JhYmx5T2ZmID0gdHJ1ZTtcbiAgICAgICAgICAvLyBTdG9wIEFsbCBjb21wb25lbnRzXG4gICAgICAgICAgLy9ldmVudEJ1cy5FdmVudEJ1cy5kaXNwYXRjaFRvQWxsKCdzZXJ2ZXJQcm9iYWJseU9mZlN0b3BSZWZyZXNoJywge30pOyAtPiBOT1xuICAgICAgICAgIC8vdGhpcy5kaXNwbGF5RXJyb3IoJycpOyAvLyA9PSBkaXNwbGF5IG1lc3NhZ2UgQU5EIENhbGwgb25TZXJ2ZXJPZmZTdG9wUmVmcmVzaFxuICAgICAgICAgIHRoaXMuZGlzcGxheUVycm9yQW5kU3RvcEFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlQ29udGV4dCA9PSAnU3RvcCcpIHtcbiAgICAgICAgICAvLyBTdGFydCBjaGVja2luZyBhZ2FpblxuICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGJ1cyBjYWxsYmFjayB0cmlnZ2VyZWQgd2hlbiByZWNlaXZ2aW5nIGV2ZW50IHNlcnZlciBwcm9iYWJseSBkaWNvbm5lY3RlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICovXG4gICAgb25EYXRhYmFzZURpc2Nvbm5lY3RlZENoYW5nZSAoZXZlbnQpIHtcbiAgICAgIC8qIERPIE5PVCBSRU1PVkUgOiBoZXJlIGlzIGhvdyB0byBmaW5kIG9yaWdpbiBvZiBpbmZvIDogKi9cbiAgICAgIC8qbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGxldCB1cmwgPSBldmVudC50YXJnZXQudXJsO1xuICAgICAgbGV0IHNvdXJjZSA9IGV2ZW50LnRhcmdldC5zb3VyY2U7XG4gICAgICBsZXQgd2hlbiA9IGV2ZW50LnRhcmdldC53aGVuOyovXG5cbiAgICAgIHRoaXMuX2RhdGFiYXNlSXNEaXNjb25uZWN0ZWQgPSB0cnVlO1xuXG4gICAgICAvL3RoaXMuZGlzcGxheUVycm9yKCcnKTsgLy8gPT0gZGlzcGxheSBtZXNzYWdlIEFORCBDYWxsIG9uU2VydmVyT2ZmU3RvcFJlZnJlc2hcbiAgICAgIHRoaXMuZGlzcGxheUVycm9yQW5kU3RvcEFsbCgpO1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZUNvbnRleHQgPT0gJ1N0b3AnKSB7XG4gICAgICAgIC8vIFN0YXJ0IGNoZWNraW5nIGFnYWluXG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgIH0gLy8gZWxzZSBjb250aW51ZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGJ1cyBjYWxsYmFjayB0cmlnZ2VyZWQgd2hlbiByZWNlaXZ2aW5nIGV2ZW50IHB1bHNlIG1haW50ZW5hbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKi9cbiAgICBvblB1bHNlTWFpbnRlbmFuY2UgKGV2ZW50KSB7XG4gICAgICAvKiBETyBOT1QgUkVNT1ZFIDogaGVyZSBpcyBob3cgdG8gZmluZCBvcmlnaW4gb2YgaW5mbyA6ICovXG4gICAgICAvKmxldCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICBsZXQgdXJsID0gZXZlbnQudGFyZ2V0LnVybDtcbiAgICAgIGxldCBzb3VyY2UgPSBldmVudC50YXJnZXQuc291cmNlO1xuICAgICAgbGV0IHdoZW4gPSBldmVudC50YXJnZXQud2hlbjsqL1xuXG4gICAgICAvLyBEaXNwbGF5ICdNYWludGVuYW5jZScgaWYgbm90IGFscmVhZHkgZG9uZVxuICAgICAgcHVsc2VTdmcuc2hvd1B1bHNlTWFpbnRlbmFuY2UoKTtcblxuICAgICAgLy8gU3RvcmUgc3RhdGVcbiAgICAgIHRoaXMuX3NlcnZlclByb2JhYmx5T2ZmID0gdHJ1ZTtcbiAgICAgIC8vIFN0b3AgQWxsIGNvbXBvbmVudHNcbiAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ3NlcnZlclByb2JhYmx5T2ZmU3RvcFJlZnJlc2gnLCB7fSk7XG4gICAgICBpZiAodGhpcy5zdGF0ZUNvbnRleHQgPT0gJ1N0b3AnKSB7XG4gICAgICAgIC8vIFN0YXJ0IGNoZWNraW5nIGFnYWluXG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgIH0gIC8vIGVsc2UgY29udGludWVcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZXZlbnQgY2FsbGJhY2sgaW4gY2FzZSBzZXJ2ZXIgaXMgb2ZmIDogT1ZFUkxPQUQgLSBEbyBub3RoaW5nXG4gICAgICogXG4gICAgICogQHBhcmFtIHsqfSBldmVudCBcbiAgICAgKi9cbiAgICBvblNlcnZlck9mZlN0b3BSZWZyZXNoIChldmVudCkge1xuICAgICAgLy8gTm90aGluZyAtPiB0byBrZWVwID09IG92ZXJsb2FkIGRlZmF1bHRcbiAgICAgIC8vY29uc29sZS5sb2coJ2NoZWNrc2VydmVyYWNjZXNzLm9uU2VydmVyT2ZmU3RvcFJlZnJlc2gnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGV2ZW50IGNhbGxiYWNrIGluIGNhc2Ugc2VydmVyIGlzIGF2YWlsYWJsZTogT1ZFUkxPQUQgLSBEbyBub3RoaW5nXG4gICAgICogXG4gICAgICogQHBhcmFtIHsqfSBldmVudCBcbiAgICAgKi9cbiAgICBvblNlcnZlckF2YWlsYWJsZUNoYW5nZSAoZXZlbnQpIHtcbiAgICAgIC8vIE5vdGhpbmcgLT4gdG8ga2VlcCA9PSBvdmVybG9hZCBkZWZhdWx0XG4gICAgfVxuXG4gICAgLy8gTm90IGFkZGVkLCBpbmNsdWRlZCBpbiBwcmV2aW91cyBvbmVzXG4gICAgLy8gb25EYXRhYmFzZU9mZlN0b3BSZWZyZXNoXG4gICAgLy8gb25EYXRhYmFzZUF2YWlsYWJsZUNoYW5nZSBcblxuICB9XG5cbiAgcHVsc2VDb21wb25lbnQucmVnaXN0ZXJFbGVtZW50KCd4LWNoZWNrc2VydmVyYWNjZXNzJywgQ2hlY2tTZXJ2ZXJBY2Nlc3NDb21wb25lbnQpO1xufSkoKTtcbiIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4vKipcbiAqIEBtb2R1bGUgeC1jaGVja3ZlcnNpb25cbiAqIEByZXF1aXJlcyBtb2R1bGU6cHVsc2VDb21wb25lbnRcbiAqL1xudmFyIHB1bHNlQ29tcG9uZW50ID0gcmVxdWlyZSgncHVsc2Vjb21wb25lbnQnKTtcbnZhciBwdWxzZVV0aWxpdHkgPSByZXF1aXJlKCdwdWxzZVV0aWxpdHknKTtcbnZhciBwdWxzZUNvbmZpZyA9IHJlcXVpcmUoJ3B1bHNlQ29uZmlnJyk7XG52YXIgZXZlbnRCdXMgPSByZXF1aXJlKCdldmVudEJ1cycpO1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gIGNsYXNzIGNoZWNrdmVyc2lvbkNvbXBvbmVudCBleHRlbmRzIHB1bHNlQ29tcG9uZW50LlB1bHNlUGFyYW1BdXRvUGF0aFJlZnJlc2hpbmdDb21wb25lbnQge1xuICAgIGluaXRpYWxpemUgKCkge1xuICAgICAgdGhpcy5hZGRDbGFzcygncHVsc2Utbm9kaXNwbGF5Jyk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemF0aW9uIE9LID0+IHN3aXRjaCB0byB0aGUgbmV4dCBjb250ZXh0XG4gICAgICB0aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdmFsaWRhdGVQYXJhbWV0ZXJzICgpIHtcbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgIH1cblxuICAgIGRpc3BsYXlFcnJvciAobWVzc2FnZSkge1xuICAgICAgLy8gRG8gbm90aGluZ1xuICAgIH1cblxuICAgIHJlbW92ZUVycm9yICgpIHtcbiAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgIHRoaXMuZGlzcGxheUVycm9yKCcnKTtcbiAgICB9XG5cbiAgICBnZXQgcmVmcmVzaFJhdGUgKCkge1xuICAgICAgLy8gUmV0dXJuIGhlcmUgdGhlIHJlZnJlc2ggcmF0ZSBpbiBtcy5cbiAgICAgIHJldHVybiA2MCAqIDYwICogMTAwMDsgLy8gQ2hlY2sgZXZlcnkgaG91clxuICAgIH1cblxuICAgIGdldFNob3J0VXJsICgpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgV2ViIFNlcnZpY2UgVVJMIGhlcmUgd2l0aG91dCBwYXRoXG4gICAgICByZXR1cm4gJ1B1bHNlVmVyc2lvbnMvR2V0JztcbiAgICB9XG5cbiAgICByZWZyZXNoIChkYXRhKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIGNvbXBvbmVudFxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jdXJyZW50VmVyc2lvbnMgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudFZlcnNpb25zID0gZGF0YS5WZXJzaW9ucztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgdmVyc2lvbnNIYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHRoaXMuX2N1cnJlbnRWZXJzaW9ucykgPT09IEpTT04uc3RyaW5naWZ5KGRhdGEuVmVyc2lvbnMpKSB7XG4gICAgICAgICAgdmVyc2lvbnNIYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnNpb25zSGFzQ2hhbmdlZCkgeyAvLyByZWxvYWRcbiAgICAgICAgICBsZXQgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICAgICAgICAgIGhyZWYgPSBwdWxzZVV0aWxpdHkuY2hhbmdlVVJMUGFyYW1ldGVyKGhyZWYsXG4gICAgICAgICAgICAncHVsc2VWZXJzaW9uJywgZGF0YS5WZXJzaW9ucy5QdWxzZSk7XG5cbiAgICAgICAgICBpZiAoJ2xpdmUnID09IHB1bHNlQ29uZmlnLmdldEFwcENvbnRleHRPclJvbGUoKSkge1xuICAgICAgICAgICAgLy8gZGlyZWN0IHJlbG9hZCBmb3IgbGl2ZVxuICAgICAgICAgICAgd2luZG93Lm9wZW4oaHJlZiwgJ19zZWxmJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRGlzcGxheSBhIG1lc3NhZ2VcbiAgICAgICAgICAgIGxldCBtZXNzYWdlSW5mbyA9IHtcbiAgICAgICAgICAgICAgJ2lkJzogJ1ZlcnNpb24nLFxuICAgICAgICAgICAgICAnbWVzc2FnZSc6ICdWZXJzaW9uIGhhcyBjaGFuZ2VkICcsXG4gICAgICAgICAgICAgICdsZXZlbCc6ICdpbmZvJyxcbiAgICAgICAgICAgICAgJ2NsaWNrVG9DbG9zZSc6IGZhbHNlLFxuICAgICAgICAgICAgICAncmVsb2FkVVJMJzogaHJlZlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ3Nob3dNZXNzYWdlU2lnbmFsJyxcbiAgICAgICAgICAgICAgbWVzc2FnZUluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1bHNlQ29tcG9uZW50LnJlZ2lzdGVyRWxlbWVudCgneC1jaGVja3ZlcnNpb24nLCBjaGVja3ZlcnNpb25Db21wb25lbnQpO1xufSkoKTtcbiIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4vKipcbiAqIEBtb2R1bGUgeC1jbG9ja1xuICogQHJlcXVpcmVzIG1vZHVsZTpwdWxzZUNvbXBvbmVudFxuICovXG5cbnZhciBwdWxzZUNvbXBvbmVudCA9IHJlcXVpcmUoJ3B1bHNlY29tcG9uZW50Jyk7XG5cblxuLyoqXG4gKiBCdWlsZCBhIGN1c3RvbSB0YWcgPHgtY2xvY2s+IHRvIGRpc3BsYXkgYW4gY2xvY2sgY29tcG9uZW50LiBUaGlzIHRhZyBnZXRzIGZvbGxvd2luZyBhdHRyaWJ1dGUgOiBcbiogIGRpc3BsYXktc2Vjb25kcyA6IEJvb2xlYW5cbiogIGRpc3BsYXktMjRoIDogQm9vbGVhblxuICovXG4oZnVuY3Rpb24gKCkge1xuXG4gIGNsYXNzIENsb2NrQ29tcG9uZW50IGV4dGVuZHMgcHVsc2VDb21wb25lbnQuUHVsc2VJbml0aWFsaXplZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgY29uc3Qgc2VsZiA9IHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgICAvLyBET01cbiAgICAgIHNlbGYuX3RleHRjbG9jayA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGYuX2NvbnRlbnQgPSB1bmRlZmluZWQ7XG5cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZFdoZW5Db25uZWN0ZWRPbmNlIChhdHRyLCBvbGRWYWwsIG5ld1ZhbCkge1xuICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZFdoZW5Db25uZWN0ZWRPbmNlKGF0dHIsIG9sZFZhbCwgbmV3VmFsKTtcbiAgICAgIHN3aXRjaCAoYXR0cikge1xuICAgICAgICBjYXNlICdkaXNwbGF5LXNlY29uZHMnOlxuICAgICAgICBjYXNlICdkaXNwbGF5LTI0aCc6XG4gICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluaXRpYWxpemUgKCkge1xuICAgICAgdGhpcy5hZGRDbGFzcygncHVsc2UtdGV4dCcpO1xuXG4gICAgICAvLyBJbiBjYXNlIG9mIGNsb25lLCBuZWVkIHRvIGJlIGVtcHR5IDpcbiAgICAgICQodGhpcy5lbGVtZW50KS5lbXB0eSgpO1xuXG4gICAgICAvLyBDcmVhdGUgRE9NIC0gTm8gTG9hZGVyIC8gbm8gZXJyb3JcblxuICAgICAgLy8gQ3JlYXRlIERPTSAtIENvbnRlbnRcbiAgICAgIHRoaXMuX3RleHRjbG9jayA9ICQoJzxkaXY+MDA6MDA6MDA8L2Rpdj4nKS5hZGRDbGFzcygnY2xvY2stdGV4dCcpO1xuICAgICAgdGhpcy5fY29udGVudCA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ2Nsb2NrLWRpdicpXG4gICAgICAgIC5hcHBlbmQodGhpcy5fdGV4dGNsb2NrKTtcbiAgICAgICQodGhpcy5lbGVtZW50KS5hcHBlbmQodGhpcy5fY29udGVudCk7XG5cbiAgICAgIHRoaXMuX3N0YXJ0VGltZSgpO1xuXG4gICAgICAvLyBJbml0aWFsaXphdGlvbiBPSyA9PiBzd2l0Y2ggdG8gdGhlIG5leHQgY29udGV4dFxuICAgICAgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJJbml0aWFsaXphdGlvbiAoKSB7XG4gICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAvLyBET01cbiAgICAgICQodGhpcy5lbGVtZW50KS5lbXB0eSgpO1xuICAgICAgdGhpcy5fdGV4dGNsb2NrID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fY29udGVudCA9IHVuZGVmaW5lZDtcbiAgICAgIFxuICAgICAgc3VwZXIuY2xlYXJJbml0aWFsaXphdGlvbigpO1xuICAgIH1cblxuICAgIF9zdGFydFRpbWUgKCkge1xuICAgICAgbGV0IG5vdyA9IG1vbWVudCgpO1xuXG4gICAgICBsZXQgc3RyaW5nVG9EaXNwbGF5ID0gJyc7XG4gICAgICBsZXQgbXNCZWZvcmVOZXh0Q2hhbmdlID0gMTAwMCAtIG5vdy5taWxsaXNlY29uZCgpO1xuICAgICAgaWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktc2Vjb25kcycpID09ICd0cnVlJ1xuICAgICAgICB8fCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXNwbGF5LXNlY29uZHMnKSA9PSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXNwbGF5LTI0aCcpID09ICd0cnVlJ1xuICAgICAgICAgIHx8IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktMjRoJykgPT0gdHJ1ZSkge1xuICAgICAgICAgIHN0cmluZ1RvRGlzcGxheSA9IG5vdy5mb3JtYXQoJ0hIOm1tOnNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3RyaW5nVG9EaXNwbGF5ID0gbm93LmZvcm1hdCgnaGg6bW06c3MgYScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy9sZXQgc3RyaW5nVG9EaXNwbGF5ID0gbm93LmZvcm1hdCgnTFQnKTtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXktMjRoJykgPT0gJ3RydWUnXG4gICAgICAgICAgfHwgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzcGxheS0yNGgnKSA9PSB0cnVlKSB7XG4gICAgICAgICAgc3RyaW5nVG9EaXNwbGF5ID0gbm93LmZvcm1hdCgnSEg6bW0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzdHJpbmdUb0Rpc3BsYXkgPSBub3cuZm9ybWF0KCdoaDptbSBhJyk7XG4gICAgICAgIH1cbiAgICAgICAgbXNCZWZvcmVOZXh0Q2hhbmdlICs9IDEwMDAgKiAoNjAgLSBub3cuc2Vjb25kKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGV4dGNsb2NrLmh0bWwoc3RyaW5nVG9EaXNwbGF5KTtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5fc3RhcnRUaW1lLmJpbmQodGhpcyksIG1zQmVmb3JlTmV4dENoYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgcHVsc2VDb21wb25lbnQucmVnaXN0ZXJFbGVtZW50KCd4LWNsb2NrJywgQ2xvY2tDb21wb25lbnQsIFsnZGlzcGxheS1zZWNvbmRzJywgJ2Rpc3BsYXktMjRoJ10pO1xufSkoKTtcbiIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4vKipcbiAqIEBtb2R1bGUgeC1kYXRlcGlja2VyXG4gKiBAcmVxdWlyZXMgbW9kdWxlOnB1bHNlQ29tcG9uZW50XG4gKi9cblxudmFyIHB1bHNlQ29tcG9uZW50ID0gcmVxdWlyZSgncHVsc2Vjb21wb25lbnQnKTtcbnZhciBwdWxzZVV0aWxpdHkgPSByZXF1aXJlKCdwdWxzZVV0aWxpdHknKTtcblxuLyoqXG4gKiBCdWlsZCBhIGN1c3RvbSB0YWcgPHgtZGF0ZXBpY2tlcj4gdG8gZGlzcGxheSBhIGRhdGUgc2VsZWN0b3IuIFRoaXMgdGFnIGdldHMgZm9sbG93aW5nIGF0dHJpYnV0ZSA6IFxuICogIGRlZmF1bHRkYXRlIDogU3RyaW5nIChJU08pXG4gKiAgbWluZGF0ZSA6IFN0cmluZ1xuICogIG1heGRhdGUgOiBTdHJpbmdcbiAqICBkaXNhYmxlZFxuICovXG4oZnVuY3Rpb24gKCkge1xuXG4gIGNsYXNzIERhdGVQaWNrZXJDb21wb25lbnQgZXh0ZW5kcyBwdWxzZUNvbXBvbmVudC5QdWxzZVBhcmFtSW5pdGlhbGl6ZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSBzdXBlciguLi5hcmdzKTtcblxuICAgICAgLy8gUGFyYW1ldGVycyAtIERlZmF1bHQgdmFsdWVzXG4gICAgICBzZWxmLl9kYXRlSW5wdXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHNlbGYubWV0aG9kcyA9IHtcbiAgICAgICAgaXNWYWxpZDogc2VsZi5pc1ZhbGlkLFxuICAgICAgICBnZXRJU09WYWx1ZTogc2VsZi5nZXRJU09WYWx1ZSxcbiAgICAgICAgZ2V0VmFsdWVBc0lzOiBzZWxmLmdldFZhbHVlQXNJc1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy9nZXQgY29udGVudCAoKSB7IHJldHVybiB0aGlzLl9jb250ZW50OyB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkV2hlbkNvbm5lY3RlZE9uY2UgKGF0dHIsIG9sZFZhbCwgbmV3VmFsKSB7XG4gICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkV2hlbkNvbm5lY3RlZE9uY2UoYXR0ciwgb2xkVmFsLCBuZXdWYWwpO1xuICAgICAgc3dpdGNoIChhdHRyKSB7XG4gICAgICAgIGNhc2UgJ2Rpc2FibGVkJzoge1xuICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJylcbiAgICAgICAgICAgICAgJiYgKG5ld1ZhbCA9PSAnZGlzYWJsZWQnIHx8IG5ld1ZhbCA9PSAndHJ1ZScpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RhdGVJbnB1dFswXS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fZGF0ZUlucHV0WzBdLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGJyZWFrO1xuICAgICAgICBjYXNlICdkZWZhdWx0ZGF0ZSc6XG4gICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXREZWZhdWx0RGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWF4ZGF0ZSc6XG4gICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsTWluTWF4RGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWluZGF0ZSc6XG4gICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsTWluTWF4RGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1VuaGFuZGxlZCBhdHRyaWJ1dGUgOiAnICsgYXR0cik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSAoKSB7XG4gICAgICAvL3RoaXMuYWRkQ2xhc3MoJ3B1bHNlLWJpZ2Rpc3BsYXknKTsgLT4gTm9cblxuICAgICAgLy8gQ3JlYXRlIERPTSAtIE5PIExvYWRlclxuICAgICAgbGV0IGRhdGVEaXYgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdkYXRlcGlja2VyLWRhdGVkaXYnKTtcbiAgICAgICQodGhpcy5lbGVtZW50KS5hcHBlbmQoZGF0ZURpdik7XG5cbiAgICAgIC8vIERPTSAtIGRhdGVcbiAgICAgIHRoaXMuX2RhdGVJbnB1dCA9ICQoJzxpbnB1dCB0eXBlPVwiZGF0ZVwiPjwvaW5wdXQ+JylcbiAgICAgICAgLmFkZENsYXNzKCdkYXRlcGlja2VyLWlucHV0LWRhdGUnKTtcbiAgICAgIGRhdGVEaXYuYXBwZW5kKHRoaXMuX2RhdGVJbnB1dCk7XG5cbiAgICAgIC8vIGlmIGRpc2FibGVkXG4gICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKVxuICAgICAgICAmJiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKSA9PSAnZGlzYWJsZWQnXG4gICAgICAgICAgfHwgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKSA9PSAndHJ1ZScpKSB7XG4gICAgICAgIHRoaXMuX2RhdGVJbnB1dFswXS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbGwgRGF0ZVxuICAgICAgdGhpcy5fc2V0RGVmYXVsdERhdGUoKTtcblxuICAgICAgLy8gU2V0IG1pbi9tYXggZGF0ZVxuICAgICAgdGhpcy5fZmlsbE1pbk1heERhdGUoKTtcblxuICAgICAgdGhpcy5fZGF0ZUlucHV0LmNoYW5nZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJlc3RvcmUgZGVmYXVsdCBpZiBlbXB0eVxuICAgICAgICBpZiAoJycgPT0gdGhpcy5fZGF0ZUlucHV0WzBdLnZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fc2V0RGVmYXVsdERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlbGwgcGFyZW50IGlmIG5lZWRlZFxuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2NoYW5nZScpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIE5PIC0gTGlzdGVuZXIgYW5kIGRpc3BhdGNoZXJcblxuICAgICAgLy8gSW5pdGlhbGl6YXRpb24gT0sgPT4gc3dpdGNoIHRvIHRoZSBuZXh0IGNvbnRleHRcbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNsZWFySW5pdGlhbGl6YXRpb24gKCkge1xuICAgICAgLy8gRE9NXG4gICAgICAkKHRoaXMuZWxlbWVudCkuZW1wdHkoKTtcblxuICAgICAgc3VwZXIuY2xlYXJJbml0aWFsaXphdGlvbigpO1xuICAgIH1cblxuICAgIHJlc2V0ICgpIHsgLy8gT3B0aW9uYWwgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIENvZGUgaGVyZSB0byBjbGVhbiB0aGUgY29tcG9uZW50IHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBpbml0aWFsaXplZCBmb3IgZXhhbXBsZSBhZnRlciBhIHBhcmFtZXRlciBjaGFuZ2VcbiAgICAgIHRoaXMucmVtb3ZlRXJyb3IoKTtcbiAgICAgIC8vIEVtcHR5IHRoaXMuX2NvbnRlbnRcblxuICAgICAgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQYXJhbWV0ZXJzICgpIHtcbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgIH1cblxuICAgIF9zZXREZWZhdWx0RGF0ZSAoKSB7XG4gICAgICAvLyBTZXQgZGVmYXVsdFxuICAgICAgbGV0IGRlZmF1bHREYXRlID0gdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGVmYXVsdGRhdGUnKVxuICAgICAgICA/IG5ldyBEYXRlKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RlZmF1bHRkYXRlJykpXG4gICAgICAgIDogbmV3IERhdGUoKTtcblxuICAgICAgaWYgKHVuZGVmaW5lZCA9PSBkZWZhdWx0RGF0ZSB8fCAnSW52YWxpZCBEYXRlJyA9PSBkZWZhdWx0RGF0ZSkge1xuICAgICAgICBkZWZhdWx0RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICB9XG4gICAgICBsZXQgZGlzcGxheWVkRGF0ZSA9IGRlZmF1bHREYXRlLmdldEZ1bGxZZWFyKCkgKyAnLSdcbiAgICAgICAgKyBwdWxzZVV0aWxpdHkubGVhZGluZ1plcm8oZGVmYXVsdERhdGUuZ2V0TW9udGgoKSArIDEpICsgJy0nXG4gICAgICAgICsgcHVsc2VVdGlsaXR5LmxlYWRpbmdaZXJvKGRlZmF1bHREYXRlLmdldERhdGUoKSk7XG4gICAgICBcbiAgICAgIHRoaXMuX2RhdGVJbnB1dFswXS52YWx1ZSA9IGRpc3BsYXllZERhdGU7XG4gICAgICAvL3RoaXMuX2RhdGVJbnB1dFswXS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgZGlzcGxheWVkRGF0ZSk7IC8vJzIwMTgtMDctMjInKTtcbiAgICAgIC8vdGhpcy5fZGF0ZUlucHV0WzBdLmRlZmF1bHRWYWx1ZSA9IGRpc3BsYXllZERhdGU7XG4gICAgfVxuXG4gICAgX2ZpbGxNaW5NYXhEYXRlICgpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdtaW5kYXRlJykpIHtcbiAgICAgICAgLy8gVXNlIGl0IGFzIGlzIGJlY2F1c2Ugb2YgY3V0LW9mZiBtYW5uYWdlbWVudFxuICAgICAgICBsZXQgbWluRGF0ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21pbmRhdGUnKTtcblxuICAgICAgICAvKiBsZXQgbWluRGF0ZVRpbWUgPSBuZXcgRGF0ZSh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtaW5kYXRlJykpO1xuICAgICAgICBsZXQgbWluRGF0ZSA9IG1pbkRhdGVUaW1lLmdldEZ1bGxZZWFyKCkgKyAnLSdcbiAgICAgICAgICArIHB1bHNlVXRpbGl0eS5sZWFkaW5nWmVybyhtaW5EYXRlVGltZS5nZXRNb250aCgpICsgMSkgKyAnLSdcbiAgICAgICAgICArIHB1bHNlVXRpbGl0eS5sZWFkaW5nWmVybyhtaW5EYXRlVGltZS5nZXREYXRlKCkpO1xuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kYXRlSW5wdXRbMF0uc2V0QXR0cmlidXRlKCdtaW4nLCBtaW5EYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdtYXhkYXRlJykpIHtcbiAgICAgICAgbGV0IG1heERhdGUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtYXhkYXRlJyk7XG4gICAgICAgIC8qXG4gICAgICAgIGxldCBtYXhEYXRlVGltZSA9IG5ldyBEYXRlKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21heGRhdGUnKSk7XG5cbiAgICAgICAgbGV0IG1heERhdGUgPSBtYXhEYXRlVGltZS5nZXRGdWxsWWVhcigpICsgJy0nXG4gICAgICAgICAgKyBwdWxzZVV0aWxpdHkubGVhZGluZ1plcm8obWF4RGF0ZVRpbWUuZ2V0TW9udGgoKSArIDEpICsgJy0nXG4gICAgICAgICAgKyBwdWxzZVV0aWxpdHkubGVhZGluZ1plcm8obWF4RGF0ZVRpbWUuZ2V0RGF0ZSgpKTtcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGF0ZUlucHV0WzBdLnNldEF0dHJpYnV0ZSgnbWF4JywgbWF4RGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNWYWxpZCAoKSB7XG4gICAgICBsZXQgY3J0RGF0ZSA9IG5ldyBEYXRlKHRoaXMuX2RhdGVJbnB1dFswXS52YWx1ZSk7XG4gICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbWluZGF0ZScpKSB7XG4gICAgICAgIGxldCBtaW5EYXRlID0gbmV3IERhdGUodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWluZGF0ZScpKTtcbiAgICAgICAgaWYgKGNydERhdGUgPCBtaW5EYXRlKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ21heGRhdGUnKSkge1xuICAgICAgICBsZXQgbWF4RGF0ZSA9IG5ldyBEYXRlKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21heGRhdGUnKSk7XG4gICAgICAgIGlmIChjcnREYXRlID4gbWF4RGF0ZSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGdldElTT1ZhbHVlICgpIHtcbiAgICAgIHJldHVybiBwdWxzZVV0aWxpdHkuY29udmVydERheUZvcldlYlNlcnZpY2UodGhpcy5fZGF0ZUlucHV0WzBdLnZhbHVlKTtcbiAgICB9XG5cbiAgICBnZXRWYWx1ZUFzSXMgKCkgeyAvLydZWVlZLU1NLUREXG4gICAgICByZXR1cm4gdGhpcy5fZGF0ZUlucHV0WzBdLnZhbHVlO1xuICAgIH1cblxuICAgIC8vIENhbGxiYWNrIGV2ZW50c1xuICB9XG5cbiAgcHVsc2VDb21wb25lbnQucmVnaXN0ZXJFbGVtZW50KCd4LWRhdGVwaWNrZXInLCBEYXRlUGlja2VyQ29tcG9uZW50LFxuICAgIFsnZGVmYXVsdGRhdGUnLCAnbWF4ZGF0ZScsICdtaW5kYXRlJywgJ2Rpc2FibGVkJ10pO1xufSkoKTtcbiIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4vKipcbiAqIEBtb2R1bGUgeC1kYXRldGltZXBpY2tlclxuICogQHJlcXVpcmVzIG1vZHVsZTpwdWxzZUNvbXBvbmVudFxuICovXG5cbnZhciBwdWxzZUNvbXBvbmVudCA9IHJlcXVpcmUoJ3B1bHNlY29tcG9uZW50Jyk7XG52YXIgcHVsc2VVdGlsaXR5ID0gcmVxdWlyZSgncHVsc2VVdGlsaXR5Jyk7XG5cbi8qKlxuICogQnVpbGQgYSBjdXN0b20gdGFnIDx4LWRhdGV0aW1lcGlja2VyPiB0byBkaXNwbGF5IGEgZGF0ZXRpbWUgc2VsZWN0b3IuIFRoaXMgdGFnIGdldHMgZm9sbG93aW5nIGF0dHJpYnV0ZSA6IFxuICogIGRlZmF1bHRkYXRldGltZSA6IFN0cmluZyAoSVNPKVxuICogIG1pbmRhdGV0aW1lIDogU3RyaW5nXG4gKiAgbWF4ZGF0ZXRpbWUgOiBTdHJpbmdcbiAqICBzaG93c2Vjb25kcyA6IEJvb2xlYW5cbiAqICBudWxsYWJsZSA6IEJvb2xlYW5cbiAqICBub3ZhbHVldGV4dCA6IFN0cmluZ1xuICogIGRpc2FibGVkXG4gKi9cbihmdW5jdGlvbiAoKSB7XG5cbiAgY2xhc3MgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQgZXh0ZW5kcyBwdWxzZUNvbXBvbmVudC5QdWxzZVBhcmFtSW5pdGlhbGl6ZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSBzdXBlciguLi5hcmdzKTtcblxuICAgICAgLy8gUGFyYW1ldGVycyAtIERlZmF1bHQgdmFsdWVzXG4gICAgICBzZWxmLl9kYXRlSW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICBzZWxmLl90aW1lSW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICBzZWxmLl9pbnB1dE51bGxhYmxlID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZi5faW5wdXROdWxsYWJsZVRleHQgPSB1bmRlZmluZWQ7XG4gICAgICBzZWxmLl9pbnB1dE51bGxhYmxlRGl2ID0gdW5kZWZpbmVkO1xuXG4gICAgICBzZWxmLm1ldGhvZHMgPSB7XG4gICAgICAgIGlzVmFsaWQ6IHNlbGYuaXNWYWxpZCxcbiAgICAgICAgZ2V0SVNPVmFsdWU6IHNlbGYuZ2V0SVNPVmFsdWUsXG4gICAgICAgIGdldFZhbHVlQXNJczogc2VsZi5nZXRWYWx1ZUFzSXNcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vZ2V0IGNvbnRlbnQgKCkgeyByZXR1cm4gdGhpcy5fY29udGVudDsgfVxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZFdoZW5Db25uZWN0ZWRPbmNlIChhdHRyLCBvbGRWYWwsIG5ld1ZhbCkge1xuICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZFdoZW5Db25uZWN0ZWRPbmNlKGF0dHIsIG9sZFZhbCwgbmV3VmFsKTtcbiAgICAgIHN3aXRjaCAoYXR0cikge1xuICAgICAgICBjYXNlICdkaXNhYmxlZCc6IHtcbiAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZWRpc2FibGVJbnB1dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBicmVhaztcbiAgICAgICAgY2FzZSAnZGVmYXVsdGRhdGV0aW1lJzpcbiAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldERlZmF1bHREYXRlKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXREZWZhdWx0VGltZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbWF4ZGF0ZXRpbWUnOlxuICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZmlsbE1pbk1heERhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxNaW5NYXhUaW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaW5kYXRldGltZSc6XG4gICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsTWluTWF4RGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fZmlsbE1pbk1heFRpbWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ25vdmFsdWV0ZXh0JzpcbiAgICAgICAgICBpZiAodGhpcy5faW5wdXROdWxsYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5faW5wdXROdWxsYWJsZVRleHQuaHRtbChuZXdWYWwpOyAvLyBPS1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2hvd3NlY29uZHMnOlxuICAgICAgICAgIC8vIFNob3cgc2Vjb25kcyBvciBub3RcbiAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdzaG93c2Vjb25kcycpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3RpbWVJbnB1dFswXS5zZXRBdHRyaWJ1dGUoJ3N0ZXAnLCAxKTsgLy8gMSBzZWMgPT0gc2hvdyBzZWNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl90aW1lSW5wdXRbMF0uc2V0QXR0cmlidXRlKCdzdGVwJywgNjApOyAvLyAxIG1pblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbnVsbGFibGUnOlxuICAgICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgaWYgKG5ld1ZhbCkge1xuICAgICAgICAgICAgICB0aGlzLl9pbnB1dE51bGxhYmxlRGl2LnNob3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9pbnB1dE51bGxhYmxlRGl2LmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS53YXJuKCdVbmhhbmRsZWQgYXR0cmlidXRlIDogJyArIGF0dHIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluaXRpYWxpemUgKCkge1xuICAgICAgdGhpcy5hZGRDbGFzcygncHVsc2UtYmlnZGlzcGxheScpO1xuXG4gICAgICAvLyBDcmVhdGUgRE9NIC0gTk8gTG9hZGVyXG4gICAgICBsZXQgZGF0ZXRpbWVEaXYgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdkYXRldGltZXBpY2tlci1kYXRldGltZWRpdicpO1xuICAgICAgJCh0aGlzLmVsZW1lbnQpLmFwcGVuZChkYXRldGltZURpdik7XG5cbiAgICAgIC8vIERPTSAtIGRhdGVcbiAgICAgIHRoaXMuX2RhdGVJbnB1dCA9ICQoJzxpbnB1dCB0eXBlPVwiZGF0ZVwiPjwvaW5wdXQ+JylcbiAgICAgICAgLmFkZENsYXNzKCdkYXRldGltZXBpY2tlci1pbnB1dC1kYXRlJyk7XG4gICAgICB0aGlzLl90aW1lSW5wdXQgPSAkKCc8aW5wdXQgdHlwZT1cInRpbWVcIj48L2lucHV0PicpXG4gICAgICAgIC5hZGRDbGFzcygnZGF0ZXRpbWVwaWNrZXItaW5wdXQtdGltZScpO1xuICAgICAgZGF0ZXRpbWVEaXYuYXBwZW5kKHRoaXMuX2RhdGVJbnB1dCkuYXBwZW5kKHRoaXMuX3RpbWVJbnB1dCk7XG5cbiAgICAgIC8vIFdpdGggb3Igd2l0aG91dCBzZWNvbmRzXG4gICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnc2hvd3NlY29uZHMnKSkge1xuICAgICAgICB0aGlzLl90aW1lSW5wdXRbMF0uc2V0QXR0cmlidXRlKCdzdGVwJywgMSk7IC8vIDEgc2VjID09IHNob3cgc2VjXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fdGltZUlucHV0WzBdLnNldEF0dHJpYnV0ZSgnc3RlcCcsIDYwKTsgLy8gMSBtaW5cbiAgICAgIH1cblxuICAgICAgLy8gRE9NIC0gTlVMTEFCTEVcbiAgICAgIHRoaXMuX2lucHV0TnVsbGFibGUgPSAkKCc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmFtZT1cImRhdGV0aW1lLW51bGxhYmxlXCI+PC9pbnB1dD4nKVxuICAgICAgICAuYWRkQ2xhc3MoJ2RhdGV0aW1lcGlja2VyLWlucHV0LW51bGxhYmxlJyk7XG4gICAgICB0aGlzLl9pbnB1dE51bGxhYmxlVGV4dCA9ICQoJzxsYWJlbCBmb3I9XCJkYXRldGltZS1udWxsYWJsZVwiPjwvbGFiZWw+JylcbiAgICAgICAgLmFkZENsYXNzKCdkYXRldGltZXBpY2tlci1pbnB1dC1udWxsYWJsZS1sYWJlbCcpXG4gICAgICAgIC5odG1sKCh0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdub3ZhbHVldGV4dCcpKSA/IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ25vdmFsdWV0ZXh0JykgOiAnTm8gdmFsdWUnKTtcbiAgICAgIHRoaXMuX2lucHV0TnVsbGFibGVEaXYgPSAkKCc8ZGl2XCI+PC9kaXY+JykuYWRkQ2xhc3MoJ2RhdGV0aW1lcGlja2VyLWlucHV0LW51bGxhYmxlLWRpdicpXG4gICAgICAgIC5hcHBlbmQodGhpcy5faW5wdXROdWxsYWJsZSkuYXBwZW5kKHRoaXMuX2lucHV0TnVsbGFibGVUZXh0KTtcbiAgICAgIGRhdGV0aW1lRGl2LmFwcGVuZCh0aGlzLl9pbnB1dE51bGxhYmxlRGl2KTtcbiAgICAgIGlmICgodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbnVsbGFibGUnKSkgPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5faW5wdXROdWxsYWJsZURpdi5oaWRlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbGwgRGF0ZVRpbWVcbiAgICAgIHRoaXMuX3NldERlZmF1bHREYXRlKCk7XG4gICAgICB0aGlzLl9zZXREZWZhdWx0VGltZSgpO1xuXG4gICAgICAvLyBTZXQgbWluL21heCBkYXRlXG4gICAgICB0aGlzLl9maWxsTWluTWF4RGF0ZSgpO1xuICAgICAgdGhpcy5fZmlsbE1pbk1heFRpbWUoKTtcblxuICAgICAgLy8gaWYgZGlzYWJsZWRcbiAgICAgIHRoaXMuX2VuYWJsZWRpc2FibGVJbnB1dCgpO1xuXG4gICAgICB0aGlzLl9kYXRlSW5wdXQuY2hhbmdlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVzdG9yZSBkZWZhdWx0IGlmIGVtcHR5XG4gICAgICAgIGlmICgnJyA9PSB0aGlzLl9kYXRlSW5wdXRbMF0udmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9zZXREZWZhdWx0RGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hbmFnZSBtaW4vbWF4IHRpbWVcbiAgICAgICAgdGhpcy5fZmlsbE1pbk1heFRpbWUoKTtcblxuICAgICAgICAvLyBUZWxsIHBhcmVudCBpZiBuZWVkZWRcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdjaGFuZ2UnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICB0aGlzLl90aW1lSW5wdXQuY2hhbmdlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVzdG9yZSBkZWZhdWx0IGlmIGVtcHR5XG4gICAgICAgIGlmICgnJyA9PSB0aGlzLl90aW1lSW5wdXRbMF0udmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9zZXREZWZhdWx0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlbGwgcGFyZW50IGlmIG5lZWRlZFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAvLyBJZiB1c2VyIGNsaWNrIHRvIHNldCBkYXRldGltZSB0byBudWxsXG4gICAgICB0aGlzLl9pbnB1dE51bGxhYmxlLmNoYW5nZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZWRpc2FibGVJbnB1dCgpO1xuICAgICAgICAvLyBUZWxsIHBhcmVudCBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgLy8gTk8gLSBMaXN0ZW5lciBhbmQgZGlzcGF0Y2hlclxuXG4gICAgICAvLyBJbml0aWFsaXphdGlvbiBPSyA9PiBzd2l0Y2ggdG8gdGhlIG5leHQgY29udGV4dFxuICAgICAgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJJbml0aWFsaXphdGlvbiAoKSB7XG4gICAgICAvLyBQYXJhbWV0ZXJzXG5cbiAgICAgIC8vIERPTVxuICAgICAgJCh0aGlzLmVsZW1lbnQpLmVtcHR5KCk7XG5cbiAgICAgIHRoaXMuX2lucHV0TnVsbGFibGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9pbnB1dE51bGxhYmxlVGV4dCA9IHVuZGVmaW5lZDtcblxuICAgICAgc3VwZXIuY2xlYXJJbml0aWFsaXphdGlvbigpO1xuICAgIH1cblxuICAgIHJlc2V0ICgpIHsgLy8gT3B0aW9uYWwgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIENvZGUgaGVyZSB0byBjbGVhbiB0aGUgY29tcG9uZW50IHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBpbml0aWFsaXplZCBmb3IgZXhhbXBsZSBhZnRlciBhIHBhcmFtZXRlciBjaGFuZ2VcbiAgICAgIHRoaXMucmVtb3ZlRXJyb3IoKTtcbiAgICAgIC8vIEVtcHR5IHRoaXMuX2NvbnRlbnRcblxuICAgICAgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQYXJhbWV0ZXJzICgpIHtcbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgIH1cblxuICAgIF9lbmFibGVkaXNhYmxlSW5wdXQgKCkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJylcbiAgICAgICAgJiYgKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgPT0gJ2Rpc2FibGVkJ1xuICAgICAgICAgIHx8IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgPT0gJ3RydWUnKSkge1xuICAgICAgICB0aGlzLl9kYXRlSW5wdXRbMF0uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl90aW1lSW5wdXRbMF0uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbnB1dE51bGxhYmxlWzBdLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoJCh0aGlzLl9pbnB1dE51bGxhYmxlKS5pcygnOmNoZWNrZWQnKSkge1xuICAgICAgICAgIHRoaXMuX2RhdGVJbnB1dFswXS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fdGltZUlucHV0WzBdLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kYXRlSW5wdXRbMF0uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl90aW1lSW5wdXRbMF0uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnB1dE51bGxhYmxlWzBdLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3NldERlZmF1bHREYXRlICgpIHtcbiAgICAgIC8vIG51bGxhYmxlID9cbiAgICAgIGlmICgodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbnVsbGFibGUnKSlcbiAgICAgICAgJiYgIXRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RlZmF1bHRkYXRldGltZScpKSB7XG4gICAgICAgIC8vIFNldCBJUyBOVUxMXG4gICAgICAgICQodGhpcy5faW5wdXROdWxsYWJsZSlbMF0uY2hlY2tlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICAvLyBzYW1lIGFzIGNoZWNrIGNoYW5nZWRcbiAgICAgIHRoaXMuX2VuYWJsZWRpc2FibGVJbnB1dCgpO1xuXG4gICAgICAvLyBTZXQgZGVmYXVsdFxuICAgICAgbGV0IGRlZmF1bHREYXRldGltZSA9IHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RlZmF1bHRkYXRldGltZScpXG4gICAgICAgID8gbmV3IERhdGUodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGVmYXVsdGRhdGV0aW1lJykpXG4gICAgICAgIDogbmV3IERhdGUoKTtcbiAgICAgIGlmICgnSW52YWxpZCBEYXRlJyA9PSBkZWZhdWx0RGF0ZXRpbWUpXG4gICAgICAgIGRlZmF1bHREYXRldGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgIGxldCBkaXNwbGF5ZWREYXRlID0gZGVmYXVsdERhdGV0aW1lLmdldEZ1bGxZZWFyKCkgKyAnLSdcbiAgICAgICAgKyBwdWxzZVV0aWxpdHkubGVhZGluZ1plcm8oZGVmYXVsdERhdGV0aW1lLmdldE1vbnRoKCkgKyAxKSArICctJ1xuICAgICAgICArIHB1bHNlVXRpbGl0eS5sZWFkaW5nWmVybyhkZWZhdWx0RGF0ZXRpbWUuZ2V0RGF0ZSgpKTtcblxuICAgICAgdGhpcy5fZGF0ZUlucHV0WzBdLnZhbHVlID0gZGlzcGxheWVkRGF0ZTtcbiAgICAgIC8vdGhpcy5fZGF0ZUlucHV0WzBdLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBkaXNwbGF5ZWREYXRlKTsgLy8nMjAxOC0wNy0yMicpO1xuICAgICAgLy90aGlzLl9kYXRlSW5wdXRbMF0uZGVmYXVsdFZhbHVlID0gZGlzcGxheWVkRGF0ZTtcbiAgICB9XG5cbiAgICBfc2V0RGVmYXVsdFRpbWUgKCkge1xuICAgICAgbGV0IGRlZmF1bHREYXRldGltZSA9IHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RlZmF1bHRkYXRldGltZScpXG4gICAgICAgID8gbmV3IERhdGUodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGVmYXVsdGRhdGV0aW1lJykpXG4gICAgICAgIDogbmV3IERhdGUoKTtcbiAgICAgIGlmICgnSW52YWxpZCBEYXRlJyA9PSBkZWZhdWx0RGF0ZXRpbWUpXG4gICAgICAgIGRlZmF1bHREYXRldGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgIGRlZmF1bHREYXRldGltZS5zZXRNaWxsaXNlY29uZHMoMCk7XG4gICAgICAvLyBSZW1vdmUgc2Vjb25kcyBpZiBub3QgdXNlZnVsXG4gICAgICAvKmlmICghdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnc2hvd3NlY29uZHMnKSkge1xuICAgICAgICBkZWZhdWx0RGF0ZXRpbWUuc2V0U2Vjb25kcygwKTtcbiAgICAgIH0qL1xuXG4gICAgICBsZXQgZGlzcGxheWVkVGltZSA9IGRlZmF1bHREYXRldGltZS50b0xvY2FsZVRpbWVTdHJpbmcoJ2VuLUdCJywvLyBBbmQgTk9UIDogW10sXG4gICAgICAgIHsgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0Jywgc2Vjb25kOiAnMi1kaWdpdCcgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSBzZWNvbmRzIGlmIG5vdCB1c2VmdWwgLSBcbiAgICAgIGlmICghdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnc2hvd3NlY29uZHMnKSkge1xuICAgICAgICBkaXNwbGF5ZWRUaW1lID0gZGVmYXVsdERhdGV0aW1lLnRvTG9jYWxlVGltZVN0cmluZygnZW4tR0InLC8vIEFuZCBOT1QgOiBbXSxcbiAgICAgICAgICB7IGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vICcyLWRpZ2l0JyBkaXNwbGF5cyBvbmx5IDEgZGlnaXQgZm9yIGhvdXIuLi4gc29tZXRpbWVzXG4gICAgICBpZiAoMSA9PSBkaXNwbGF5ZWRUaW1lLmluZGV4T2YoJzonKSkge1xuICAgICAgICBkaXNwbGF5ZWRUaW1lID0gJzAnICsgZGlzcGxheWVkVGltZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdGltZUlucHV0WzBdLnZhbHVlID0gZGlzcGxheWVkVGltZTsgLy8gRm9uY3Rpb25uZSBwb3VyIExBVCwgbWFpcyBwYXMgUGFyYWdvbiBNZXRhbFxuICAgICAgLy90aGlzLl90aW1lSW5wdXRbMF0uc2V0QXR0cmlidXRlKCd2YWx1ZScsIGRpc3BsYXllZFRpbWUpOyAvLycwODowMCcpO1xuICAgICAgLy90aGlzLl90aW1lSW5wdXRbMF0uZGVmYXVsdFZhbHVlID0gZGlzcGxheWVkVGltZTtcbiAgICB9XG5cbiAgICBfZmlsbE1pbk1heERhdGUgKCkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ21pbmRhdGV0aW1lJykpIHtcbiAgICAgICAgbGV0IG1pbkRhdGV0aW1lID0gbmV3IERhdGUodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWluZGF0ZXRpbWUnKSk7XG5cbiAgICAgICAgbGV0IG1pbkRhdGUgPSBtaW5EYXRldGltZS5nZXRGdWxsWWVhcigpICsgJy0nXG4gICAgICAgICAgKyBwdWxzZVV0aWxpdHkubGVhZGluZ1plcm8obWluRGF0ZXRpbWUuZ2V0TW9udGgoKSArIDEpICsgJy0nXG4gICAgICAgICAgKyBwdWxzZVV0aWxpdHkubGVhZGluZ1plcm8obWluRGF0ZXRpbWUuZ2V0RGF0ZSgpKTtcblxuICAgICAgICB0aGlzLl9kYXRlSW5wdXRbMF0uc2V0QXR0cmlidXRlKCdtaW4nLCBtaW5EYXRlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdtYXhkYXRldGltZScpKSB7XG4gICAgICAgIGxldCBtYXhEYXRldGltZSA9IG5ldyBEYXRlKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21heGRhdGV0aW1lJykpO1xuXG4gICAgICAgIGxldCBtYXhEYXRlID0gbWF4RGF0ZXRpbWUuZ2V0RnVsbFllYXIoKSArICctJ1xuICAgICAgICAgICsgcHVsc2VVdGlsaXR5LmxlYWRpbmdaZXJvKG1heERhdGV0aW1lLmdldE1vbnRoKCkgKyAxKSArICctJ1xuICAgICAgICAgICsgcHVsc2VVdGlsaXR5LmxlYWRpbmdaZXJvKG1heERhdGV0aW1lLmdldERhdGUoKSk7XG5cbiAgICAgICAgdGhpcy5fZGF0ZUlucHV0WzBdLnNldEF0dHJpYnV0ZSgnbWF4JywgbWF4RGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2ZpbGxNaW5NYXhUaW1lICgpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdtaW5kYXRldGltZScpKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIG1pbiBkYXRlID49IHZhbHVlXG4gICAgICAgIGxldCBtaW5EYXRlID0gbmV3IERhdGUodGhpcy5fZGF0ZUlucHV0WzBdLmdldEF0dHJpYnV0ZSgnbWluJykpO1xuICAgICAgICBsZXQgY3J0RGF0ZSA9IG5ldyBEYXRlKHRoaXMuX2RhdGVJbnB1dFswXS52YWx1ZSk7XG4gICAgICAgIGlmIChtaW5EYXRlIDwgY3J0RGF0ZSkge1xuICAgICAgICAgIHRoaXMuX3RpbWVJbnB1dFswXS5yZW1vdmVBdHRyaWJ1dGUoJ21pbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxldCBtaW5EYXRldGltZSA9IG5ldyBEYXRlKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21pbmRhdGV0aW1lJykpO1xuICAgICAgICAgIC8vIFJlbW92ZSBtcywgbm90IGNvbXBhdGlibGVcbiAgICAgICAgICBtaW5EYXRldGltZS5zZXRNaWxsaXNlY29uZHMoMCk7XG5cbiAgICAgICAgICAvLyBGaW5kICYgZm9ybWF0IG1pbiB0aW1lXG4gICAgICAgICAgbGV0IG1pblRpbWUgPSBtaW5EYXRldGltZS50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbiAgICAgICAgICAvLyBSZW1vdmUgc2Vjb25kcyBpZiBub3QgdXNlZnVsXG4gICAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdzaG93c2Vjb25kcycpKSB7XG4gICAgICAgICAgICBtaW5UaW1lID0gbWluVGltZS5zdWJzdHJpbmcoMCwgNSk7IC8vIEhpZGUgc2VjLCBub3QgY29tcGF0aWJsZVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl90aW1lSW5wdXRbMF0uc2V0QXR0cmlidXRlKCdtaW4nLCBtaW5UaW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ21heGRhdGV0aW1lJykpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbWluIGRhdGUgPj0gdmFsdWVcbiAgICAgICAgbGV0IG1heERhdGUgPSBuZXcgRGF0ZSh0aGlzLl9kYXRlSW5wdXRbMF0uZ2V0QXR0cmlidXRlKCdtYXgnKSk7XG4gICAgICAgIGxldCBjcnREYXRlID0gbmV3IERhdGUodGhpcy5fZGF0ZUlucHV0WzBdLnZhbHVlKTtcbiAgICAgICAgaWYgKGNydERhdGUgPCBtYXhEYXRlKSB7XG4gICAgICAgICAgdGhpcy5fdGltZUlucHV0WzBdLnJlbW92ZUF0dHJpYnV0ZSgnbWF4Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbGV0IG1heERhdGV0aW1lID0gbmV3IERhdGUodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWF4ZGF0ZXRpbWUnKSk7XG4gICAgICAgICAgLy8gUmVtb3ZlIG1zLCBub3QgY29tcGF0aWJsZVxuICAgICAgICAgIG1heERhdGV0aW1lLnNldE1pbGxpc2Vjb25kcygwKTtcblxuICAgICAgICAgIC8vIEZpbmQgJiBmb3JtYXQgbWF4IHRpbWVcbiAgICAgICAgICBsZXQgbWF4VGltZSA9IG1heERhdGV0aW1lLnRvTG9jYWxlVGltZVN0cmluZygpO1xuICAgICAgICAgIC8vIFJlbW92ZSBzZWNvbmRzIGlmIG5vdCB1c2VmdWxcbiAgICAgICAgICBpZiAoIXRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3Nob3dzZWNvbmRzJykpIHtcbiAgICAgICAgICAgIG1heFRpbWUgPSBtYXhUaW1lLnN1YnN0cmluZygwLCA1KTsgLy8gSGlkZSBzZWMsIG5vdCBjb21wYXRpYmxlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fdGltZUlucHV0WzBdLnNldEF0dHJpYnV0ZSgnbWF4JywgbWF4VGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc1ZhbGlkICgpIHtcbiAgICAgIGlmICgodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbnVsbGFibGUnKSkgJiYgKHRoaXMuX2lucHV0TnVsbGFibGUuaXMoJzpjaGVja2VkJykpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgY3J0RGF0ZVRpbWUgPSBuZXcgRGF0ZSh0aGlzLl9kYXRlSW5wdXRbMF0udmFsdWUgKyAnICcgKyB0aGlzLl90aW1lSW5wdXRbMF0udmFsdWUpO1xuICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ21pbmRhdGV0aW1lJykpIHtcbiAgICAgICAgbGV0IG1pbkRhdGV0aW1lID0gbmV3IERhdGUodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWluZGF0ZXRpbWUnKSk7XG4gICAgICAgIGlmIChjcnREYXRlVGltZSA8IG1pbkRhdGV0aW1lKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ21heGRhdGV0aW1lJykpIHtcbiAgICAgICAgbGV0IG1heERhdGV0aW1lID0gbmV3IERhdGUodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWF4ZGF0ZXRpbWUnKSk7XG4gICAgICAgIGlmIChjcnREYXRlVGltZSA+IG1heERhdGV0aW1lKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZ2V0SVNPVmFsdWUgKCkge1xuICAgICAgaWYgKCh0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdudWxsYWJsZScpKSAmJiAodGhpcy5faW5wdXROdWxsYWJsZS5pcygnOmNoZWNrZWQnKSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IGNydERhdGVUaW1lID0gbmV3IERhdGUodGhpcy5fZGF0ZUlucHV0WzBdLnZhbHVlICsgJyAnICsgdGhpcy5fdGltZUlucHV0WzBdLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGNydERhdGVUaW1lLnRvSVNPU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VmFsdWVBc0lzICgpIHsgLy8nWVlZWS1NTS1ERCBISDptbTpzcyBcbiAgICAgIHJldHVybiAodGhpcy5fZGF0ZUlucHV0WzBdLnZhbHVlICsgJyAnICsgdGhpcy5fdGltZUlucHV0WzBdLnZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsYmFjayBldmVudHNcbiAgfVxuXG4gIHB1bHNlQ29tcG9uZW50LnJlZ2lzdGVyRWxlbWVudCgneC1kYXRldGltZXBpY2tlcicsIERhdGVUaW1lUGlja2VyQ29tcG9uZW50LFxuICAgIFsnZGVmYXVsdGRhdGV0aW1lJywgJ21heGRhdGV0aW1lJywgJ21pbmRhdGV0aW1lJywgJ25vdmFsdWV0ZXh0JywgJ3Nob3dzZWNvbmRzJywgJ251bGxhYmxlJywgJ2Rpc2FibGVkJ10pO1xufSkoKTtcbiIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4vKipcbiAqIEBtb2R1bGUgeC1mcmVldGV4dFxuICogQHJlcXVpcmVzIG1vZHVsZTpwdWxzZUNvbXBvbmVudFxuICogQHJlcXVpcmVzIG1vZHVsZTpwdWxzZVJhbmdlXG4gKi9cbnZhciBwdWxzZUNvbXBvbmVudCA9IHJlcXVpcmUoJ3B1bHNlY29tcG9uZW50Jyk7XG52YXIgcHVsc2VVdGlsaXR5ID0gcmVxdWlyZSgncHVsc2VVdGlsaXR5Jyk7XG52YXIgZXZlbnRCdXMgPSByZXF1aXJlKCdldmVudEJ1cycpO1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gIGNsYXNzIGZyZWV0ZXh0Q29tcG9uZW50IGV4dGVuZHMgcHVsc2VDb21wb25lbnQuUHVsc2VJbml0aWFsaXplZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgY29uc3Qgc2VsZiA9IHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgICBzZWxmLm1ldGhvZHMgPSB7XG4gICAgICAgIGNsZWFuRGlzcGxheTogc2VsZi5jbGVhbkRpc3BsYXkgLy8gdXNlZCBieSBtYWNoaW5lc2VsZWN0aW9uXG4gICAgICB9O1xuXG4gICAgICAvLyBET00gLSBub3QgaGVyZVxuICAgICAgc2VsZi5fY29udGVudCA9IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgY2xlYW5EaXNwbGF5ICgpIHtcbiAgICAgICQodGhpcy5fY29udGVudCkuZW1wdHkoKTtcbiAgICB9XG5cbiAgICAvL2dldCBjb250ZW50ICgpIHsgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7IH0gLy8gT3B0aW9uYWxcblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRXaGVuQ29ubmVjdGVkT25jZSAoYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRXaGVuQ29ubmVjdGVkT25jZShhdHRyLCBvbGRWYWwsIG5ld1ZhbCk7XG4gICAgICBzd2l0Y2ggKGF0dHIpIHtcbiAgICAgICAgY2FzZSAnbWFjaGluZS1pZCc6XG4gICAgICAgIGNhc2UgJ2dyb3VwJzogLy8gTm90IGZ1bGx5IGRlZmluZWQgeWV0XG4gICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICAvLyBDaGVjayAndGV4dGNoYW5nZS1jb250ZXh0J1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RleHRjaGFuZ2UtY29udGV4dCcpKSB7XG4gICAgICAgICAgICAgIGxldCB0ZXh0Y2hhbmdlY29udGV4dCA9IHB1bHNlVXRpbGl0eS5nZXRUZXh0Q2hhbmdlQ29udGV4dCh0aGlzKTtcbiAgICAgICAgICAgICAgZXZlbnRCdXMuRXZlbnRCdXMucmVtb3ZlRXZlbnRMaXN0ZW5lckJ5U2lnbmFsKHRoaXMsXG4gICAgICAgICAgICAgICAgJ3RleHRDaGFuZ2VFdmVudCcpO1xuICAgICAgICAgICAgICBldmVudEJ1cy5FdmVudEJ1cy5hZGRFdmVudExpc3RlbmVyKHRoaXMsXG4gICAgICAgICAgICAgICAgJ3RleHRDaGFuZ2VFdmVudCcsIHRleHRjaGFuZ2Vjb250ZXh0LFxuICAgICAgICAgICAgICAgIHRoaXMub25UZXh0Q2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFydCgpOyAvLyA9PSByZSBsb2FkXG4gICAgICAgICAgfSBicmVhaztcbiAgICAgICAgY2FzZSAndGV4dGNoYW5nZS1jb250ZXh0JzpcbiAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0Y2hhbmdlY29udGV4dCA9IHB1bHNlVXRpbGl0eS5nZXRUZXh0Q2hhbmdlQ29udGV4dCh0aGlzKTtcbiAgICAgICAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLnJlbW92ZUV2ZW50TGlzdGVuZXJCeVNpZ25hbCh0aGlzLFxuICAgICAgICAgICAgICAndGV4dENoYW5nZUV2ZW50Jyk7XG4gICAgICAgICAgICBldmVudEJ1cy5FdmVudEJ1cy5hZGRFdmVudExpc3RlbmVyKHRoaXMsXG4gICAgICAgICAgICAgICd0ZXh0Q2hhbmdlRXZlbnQnLCB0ZXh0Y2hhbmdlY29udGV4dCxcbiAgICAgICAgICAgICAgdGhpcy5vblRleHRDaGFuZ2UuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9Db250ZXh0KCdhc2tGb3JUZXh0Q2hhbmdlRXZlbnQnLCB0ZXh0Y2hhbmdlY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vdGhpcy5zdGFydCgpOyAvLyBUbyByZS12YWxpZGF0ZSBwYXJhbWV0ZXJzXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSAoKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCdwdWxzZS10ZXh0Jyk7IC8vIE1hbmRhdG9yeSBmb3IgbG9hZGVyXG5cbiAgICAgIC8vIFVwZGF0ZSBoZXJlIHNvbWUgaW50ZXJuYWwgcGFyYW1ldGVyc1xuXG4gICAgICAvLyBJbiBjYXNlIG9mIGNsb25lLCBuZWVkIHRvIGJlIGVtcHR5IDpcbiAgICAgICQodGhpcy5lbGVtZW50KS5lbXB0eSgpO1xuXG4gICAgICAvLyBDcmVhdGUgRE9NIC0gQ29udGVudFxuICAgICAgdGhpcy5fY29udGVudCA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ2ZyZWV0ZXh0LWNvbnRlbnQnKTtcbiAgICAgICQodGhpcy5lbGVtZW50KS5hcHBlbmQodGhpcy5fY29udGVudCk7XG5cbiAgICAgIC8vIENyZWF0ZSBET00gLSBOTyBMb2FkZXIgLyBObyBtZXNzYWdlXG5cbiAgICAgIC8vIGxpc3RlbmVycy9kaXNwYXRjaGVyc1xuICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RleHRjaGFuZ2UtY29udGV4dCcpKSB7XG4gICAgICAgIGxldCB0ZXh0Y2hhbmdlY29udGV4dCA9IHB1bHNlVXRpbGl0eS5nZXRUZXh0Q2hhbmdlQ29udGV4dCh0aGlzKTtcbiAgICAgICAgZXZlbnRCdXMuRXZlbnRCdXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLFxuICAgICAgICAgICd0ZXh0Q2hhbmdlRXZlbnQnLCB0ZXh0Y2hhbmdlY29udGV4dCxcbiAgICAgICAgICB0aGlzLm9uVGV4dENoYW5nZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBldmVudEJ1cy5FdmVudEJ1cy5kaXNwYXRjaFRvQ29udGV4dCgnYXNrRm9yVGV4dENoYW5nZUV2ZW50JywgdGV4dGNoYW5nZWNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0aWFsaXphdGlvbiBPSyA9PiBzd2l0Y2ggdG8gdGhlIG5leHQgY29udGV4dFxuICAgICAgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJJbml0aWFsaXphdGlvbiAoKSB7XG4gICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAvLyBET01cbiAgICAgICQodGhpcy5lbGVtZW50KS5lbXB0eSgpO1xuXG4gICAgICAvL3RoaXMuX21lc3NhZ2VTcGFuID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fY29udGVudCA9IHVuZGVmaW5lZDtcblxuICAgICAgc3VwZXIuY2xlYXJJbml0aWFsaXphdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogRXZlbnQgYnVzIGNhbGxiYWNrIHRyaWdnZXJlZCB3aGVuIHRoZSB0ZXh0IGNoYW5nZXNcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgICAqL1xuICAgIG9uVGV4dENoYW5nZSAoZXZlbnQpIHtcbiAgICAgIGlmICgnJyA9PSBldmVudC50YXJnZXQudGV4dCkge1xuICAgICAgICAkKHRoaXMuX2NvbnRlbnQpLmVtcHR5KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgJCh0aGlzLl9jb250ZW50KS5lbXB0eSgpO1xuICAgICAgICAkKHRoaXMuX2NvbnRlbnQpLmFwcGVuZCgkKCc8c3Bhbj48L3NwYW4+JykuaHRtbChldmVudC50YXJnZXQudGV4dCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1bHNlQ29tcG9uZW50LnJlZ2lzdGVyRWxlbWVudCgneC1mcmVldGV4dCcsIGZyZWV0ZXh0Q29tcG9uZW50LCBbJ21hY2hpbmUtaWQnLCAnZ3JvdXAnLCAndGV4dGNoYW5nZS1jb250ZXh0J10pO1xufSkoKTtcbiIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4vKipcbiAqIEBtb2R1bGUgeC1ncm91cGFycmF5XG4gKiBAcmVxdWlyZXMgbW9kdWxlOnB1bHNlQ29tcG9uZW50XG4gKiBAcmVxdWlyZXMgbW9kdWxlOnB1bHNlUmFuZ2VcbiAqL1xudmFyIHB1bHNlQ29tcG9uZW50ID0gcmVxdWlyZSgncHVsc2Vjb21wb25lbnQnKTtcbnZhciBwdWxzZVV0aWxpdHkgPSByZXF1aXJlKCdwdWxzZVV0aWxpdHknKTtcbnZhciBwdWxzZUxvZ2luID0gcmVxdWlyZSgncHVsc2VMb2dpbicpO1xudmFyIHB1bHNlQ29uZmlnID0gcmVxdWlyZSgncHVsc2VDb25maWcnKTtcbnZhciBzdGF0ZSA9IHJlcXVpcmUoJ3N0YXRlJyk7XG52YXIgZXZlbnRCdXMgPSByZXF1aXJlKCdldmVudEJ1cycpO1xuXG4vKlxuICoqIEF0dHJpYnV0ZXMgOlxuIC0gdGVtcGxhdGVpZFxuIC0gbWFjaGluZVxuIC0gZ3JvdXBcbiAtIGNvbHVtbiAoZ2V0Q29uZmlnT3JBdHRyaWJ1dGUpXG4gLSByb3cgKGdldENvbmZpZ09yQXR0cmlidXRlKVxuIC0gY2FuVXNlUm93c1RvU2V0SGVpZ2h0XG4gLSBhbGxvd3BhZ2Vyb3RhdGlvbiA6IGJvb2wgdHJ1ZSB0byBzdGFydCBwYWdlIHJvdGF0aW9uXG4gLSByb3RhdGlvbiAoZ2V0Q29uZmlnT3JBdHRyaWJ1dGUpID0gcm90YXRpb24gZGVsYXlcbiAtIHJlZnJlc2hyYXRlIChFTFNFIHJvdGF0aW9uKm5iUGFnZXMgRUxTRSAxaHIpXG4gKi9cbihmdW5jdGlvbiAoKSB7XG5cbiAgY2xhc3MgR3JvdXBDb21wb25lbnQgZXh0ZW5kcyBwdWxzZUNvbXBvbmVudC5QdWxzZVBhcmFtQXV0b1BhdGhSZWZyZXNoaW5nQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBjb25zdCBzZWxmID0gc3VwZXIoLi4uYXJncyk7XG5cbiAgICAgIC8vIERlZmF1bHRcbiAgICAgIHNlbGYuX2xhc3RVcGRhdGVEYXRlID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBET00gLT4gbmV2ZXIgaW4gY29udHJ1Y3RvclxuICAgICAgc2VsZi5fY29udGVudCA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGYuX2R5bmFtaWMgPSBmYWxzZTtcbiAgICAgIHNlbGYuX2N1cnJlbnREaXNwbGF5ZWRQYWdlID0gMTtcbiAgICAgIHNlbGYuX25iUGFnZXNUb3RhbCA9IDE7XG4gICAgICBzZWxmLl9zaG93SGlkZVRpbWVyID0gbnVsbDtcblxuICAgICAgc2VsZi5fbWFjaGluZUlkc0FycmF5ID0gW107XG4gICAgICBzZWxmLm1ldGhvZHMgPSB7XG4gICAgICAgICdnZXRNYWNoaW5lc0xpc3QnOiBzZWxmLmdldE1hY2hpbmVzTGlzdFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLy8gT3ZlcmxvYWQgdG8gYWx3YXlzIHJlZnJlc2ggdmFsdWVcbiAgICBnZXQgaXNWaXNpYmxlICgpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7IC8vID09IGlzIGNvbm5lY3RlZFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiogR2V0IGxpc3Qgb2YgbWFjaGluZXMgYXMgc3RyaW5nXG4gICAgICovXG4gICAgZ2V0TWFjaGluZXNMaXN0ICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYWNoaW5lSWRzQXJyYXkuam9pbigpO1xuICAgIH1cblxuICAgIGdldCBjb250ZW50ICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuICAgIH1cblxuICAgIF9kaXNwbGF5T3JVcGRhdGVNYWNoaW5lTGlzdCAoKSB7XG4gICAgICAvLyQodGhpcy5fY29udGVudCkuZW1wdHkoKTsgTm8gIVxuXG4gICAgICBpZiAoKGZhbHNlID09IHRoaXMuX2R5bmFtaWMpXG4gICAgICAgICYmICh0aGlzLl9tYWNoaW5lSWRzQXJyYXkubGVuZ3RoID09IDApKSB7XG4gICAgICAgIGxldCBub01hY2hpbmVzID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnbm8tbWFjaGluZXMnKVxuICAgICAgICAgIC5odG1sKCdObyBtYWNoaW5lIGluIHNlbGVjdGlvbicpOy8vIEkxOE4gP1xuICAgICAgICAkKHRoaXMuX2NvbnRlbnQpLmFwcGVuZChub01hY2hpbmVzKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAkKHRoaXMuX2NvbnRlbnQpLmZpbmQoJy5uby1tYWNoaW5lcycpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBpbml0IHBvc3NpYmxlIHJvdGF0aW9uXG4gICAgICB0aGlzLl9jdXJyZW50RGlzcGxheWVkUGFnZSA9IDE7XG5cbiAgICAgIC8vIEdldCB0aGUgYm94IHRvIGNsb25lIGVsZW1lbnQgZnJvbSBET01cbiAgICAgIGxldCBib3h0b2Nsb25laWQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0ZW1wbGF0ZWlkJyk7XG4gICAgICBpZiAocHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChib3h0b2Nsb25laWQpKVxuICAgICAgICBib3h0b2Nsb25laWQgPSAnYm94dG9jbG9uZSc7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB3aWR0aCBmb3IgbXVsdGktY29sdW1uIChhbmQgaGVpZ2h0KVxuICAgICAgbGV0IGNvbHVtbl93aWR0aCA9IG51bGw7XG4gICAgICBsZXQgcm93X2hlaWdodCA9IG51bGw7XG4gICAgICBsZXQgbmJDb2x1bW5Ub0Rpc3BsYXkgPSB0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdjb2x1bW4nKTtcbiAgICAgIGxldCBuYlJvd1RvRGlzcGxheSA9IHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ3JvdycsIDIpO1xuICAgICAgbGV0IGNhblVzZVJvd3NUb1NldEhlaWdodCA9IHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ2NhblVzZVJvd3NUb1NldEhlaWdodCcsICdmYWxzZScpO1xuICAgICAgbGV0IGFsbG93cGFnZXJvdGF0aW9uID0gdGhpcy5nZXRDb25maWdPckF0dHJpYnV0ZSgnYWxsb3dwYWdlcm90YXRpb24nLCAnZmFsc2UnKTtcblxuICAgICAgaWYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKG5iQ29sdW1uVG9EaXNwbGF5KSkge1xuICAgICAgICBjb2x1bW5fd2lkdGggPSAxMDAuMCAvIG5iQ29sdW1uVG9EaXNwbGF5ICsgJyUnO1xuICAgICAgICBpZiAoYWxsb3dwYWdlcm90YXRpb24gPT0gJ3RydWUnKSB7IC8vIE5vIHBhZ2Ugcm90YXRpb24gPT0gYXV0by1zaXplXG4gICAgICAgICAgaWYgKChjYW5Vc2VSb3dzVG9TZXRIZWlnaHQgPT0gJ3RydWUnKSB8fCAoY2FuVXNlUm93c1RvU2V0SGVpZ2h0ID09IHRydWUpKSB7XG4gICAgICAgICAgICBpZiAoIXB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQobmJSb3dUb0Rpc3BsYXkpKSB7XG4gICAgICAgICAgICAgIHJvd19oZWlnaHQgPSAxMDAuMCAvIG5iUm93VG9EaXNwbGF5ICsgJyUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGhlIGNvbXBvbmVudCB3aXRoIGRhdGEgcmV0dXJuZWQgYnkgdGhlIHdlYiBzZXJ2aWNlXG4gICAgICBmdW5jdGlvbiBtYWNoaW5lSWRJc0luTGlzdCAobWFjaGluZUlkLCBMaXN0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChOdW1iZXIobWFjaGluZUlkKSA9PSBOdW1iZXIoTGlzdFtpXSkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFJFTU9WRSBtYWNoaW5lIG5vdCBpbiBsaXN0IGFueW1vcmVcbiAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICQodGhpcy5lbGVtZW50KS5maW5kKCcuZ3JvdXAtc2luZ2xlJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBtYWNoaW5lSWQgPSAkKHRoaXMpLmF0dHIoJ21hY2hpbmUtaWQnKTsgLy8gdGhpcyA9IGdyb3VwLXNpbmdsZVxuICAgICAgICBpZiAoZmFsc2UgPT0gbWFjaGluZUlkSXNJbkxpc3QobWFjaGluZUlkLCBzZWxmLl9tYWNoaW5lSWRzQXJyYXkpKSB7IC8vIHNlbGYgPSB4LWdyb3VwYXJyYXlcbiAgICAgICAgICAkKHRoaXMpLnJlbW92ZSgpOyAvLyB0aGlzID0gZ3JvdXAtc2luZ2xlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgJCh0aGlzKS5maW5kKCcqJykuYWRkQ2xhc3MoJ2Rpc2FibGVEZWxldGVXaGVuRGlzY29ubmVjdCcpO1xuICAgICAgICAgIC8qIERPIE5PVCB1c2VkIHRoaXMuZWxlbWVudCA6IG5vdCBkZWZpbmVkIGhlcmUgISB0aGlzID09ICcuZ3JvdXAtc2luZ2xlJyAqL1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVzZXQgcGFnZXNcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMuX25iUGFnZXNUb3RhbDsgaSsrKSB7XG4gICAgICAgIGxldCBwYWdlX2NsYXNzID0gJ2xpLXBhZ2UtJyArIGk7XG4gICAgICAgICQodGhpcy5lbGVtZW50KS5maW5kKCcuJyArIHBhZ2VfY2xhc3MpLnJlbW92ZUNsYXNzKHBhZ2VfY2xhc3MpO1xuICAgICAgfVxuXG4gICAgICAvLyQodGhpcy5lbGVtZW50KS5maW5kKCcqJykuYWRkQ2xhc3MoJ2Rpc2FibGVEZWxldGVXaGVuRGlzY29ubmVjdCcpO1xuXG4gICAgICAvLyBVcGRhdGUgbGlzdCBvZiBtYWNoaW5lcyAtIEFkZCBST1dTXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX21hY2hpbmVJZHNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc2luZ2xlaWQgPSB0aGlzLl9tYWNoaW5lSWRzQXJyYXlbaV07XG4gICAgICAgIGxldCBsaTtcblxuICAgICAgICAvLyBGaW5kIGlmIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGxldCBtYWNoaW5lUm93ID0gJCh0aGlzLl9jb250ZW50KS5maW5kKFwiLmdyb3VwLXNpbmdsZVttYWNoaW5lLWlkPSdcIiArIHNpbmdsZWlkICsgXCInXVwiKTtcbiAgICAgICAgLy8gTk8gcmVtb3ZlIEVMU0UgZGlzcGxheSBjYW4gYmVjb21lIG5vdCBzbW9vdGggZW5vdWdoXG4gICAgICAgIGlmIChtYWNoaW5lUm93Lmxlbmd0aCAhPSAwKSB7IC8vIGlmIGV4aXN0c1xuICAgICAgICAgIC8vIGRpc2FibGVEZWxldGVXaGVuRGlzY29ubmVjdFxuICAgICAgICAgIC8vbWFjaGluZVJvd1swXS5maW5kICgnKicpLmFkZENsYXNzKCdkaXNhYmxlRGVsZXRlV2hlbkRpc2Nvbm5lY3QnKTtcblxuICAgICAgICAgIC8vIE1vdmUgYXQgZW5kIG9mIHRoZSBsaXN0IHRvIG9yZGVyIGFsbFxuICAgICAgICAgIC8vJCh0aGlzLl9jb250ZW50KS5hcHBlbmQobWFjaGluZVJvd1swXSk7XG4gICAgICAgICAgbGkgPSBtYWNoaW5lUm93WzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIEVsc2UgQ3JlYXRlIE5FVyA9IGNvcHkgdGhlIGVsZW1lbnQgYW5kIGl0cyBjaGlsZCBub2Rlc1xuICAgICAgICAgIGxldCBjb3B5ID0gcHVsc2VVdGlsaXR5LmNsb25lV2l0aE5ld01hY2hpbmVJZChib3h0b2Nsb25laWQsIHNpbmdsZWlkKTtcbiAgICAgICAgICAvKmxldCBjb3B5ID0gJCgnIycgKyBib3h0b2Nsb25laWQpLmNsb25lKHRydWUpO1xuICAgICAgICAgICQoY29weSkucmVtb3ZlQXR0cignaWQnKTtcbiAgICAgICAgICAkKGNvcHkpLmF0dHIoJ21hY2hpbmUtaWQnLCBzaW5nbGVpZCk7XG4gICAgICAgICAgJChjb3B5KS5maW5kKCcqJykuYXR0cignbWFjaGluZS1pZCcsIHNpbmdsZWlkKTsqL1xuXG4gICAgICAgICAgLy8gQXBwZW5kIHRoZSBjbG9uZWQgZWxlbWVudCB0byB0aGUgbGlzdFxuICAgICAgICAgIGxpID0gJCgnPGxpPjwvbGk+JykuYWRkQ2xhc3MoJ2dyb3VwLXNpbmdsZScpO1xuICAgICAgICAgIGxpLmF0dHIoJ21hY2hpbmUtaWQnLCBzaW5nbGVpZCk7XG4gICAgICAgICAgbGkuYXBwZW5kKGNvcHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5iQ29sdW1uVG9EaXNwbGF5ICE9IDAgJiYgbmJSb3dUb0Rpc3BsYXkgIT0gMCkge1xuICAgICAgICAgIC8vIEFkZCBwYWdlIGNsYXNzIHRvIGVhc2UgcGFnZSByb3RhdGlvblxuICAgICAgICAgIGxldCBwYWdlX2NsYXNzID0gJ2xpLXBhZ2UtJyArIE1hdGguY2VpbCgoaSArIDEpIC8gKG5iQ29sdW1uVG9EaXNwbGF5ICogbmJSb3dUb0Rpc3BsYXkpKTtcbiAgICAgICAgICAkKGxpKS5hZGRDbGFzcyhwYWdlX2NsYXNzKTtcblxuICAgICAgICAgIC8vIFNldCBoZWlnaHQgLyB3aWR0aFxuICAgICAgICAgIGlmIChudWxsICE9IGNvbHVtbl93aWR0aClcbiAgICAgICAgICAgICQobGkpLmNzcyh7XG4gICAgICAgICAgICAgICd3aWR0aCc6IGNvbHVtbl93aWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG51bGwgIT0gcm93X2hlaWdodClcbiAgICAgICAgICAgICQobGkpLmNzcyh7XG4gICAgICAgICAgICAgICdoZWlnaHQnOiByb3dfaGVpZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgICQodGhpcy5fY29udGVudCkuYXBwZW5kKGxpKTtcblxuICAgICAgICAvKmlmIChtYWNoaW5lUm93Lmxlbmd0aCAhPSAwKSB7IC8vIGlmIGV4aXN0c1xuICAgICAgICAgIC8vIHJlc3RvcmVEZWxldGVXaGVuRGlzY29ubmVjdCBcbiAgICAgICAgICBtYWNoaW5lUm93WzBdLmZpbmQgKCcqJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVEZWxldGVXaGVuRGlzY29ubmVjdCcpO1xuICAgICAgICB9Ki9cbiAgICAgIH1cbiAgICAgIC8vJCh0aGlzLmVsZW1lbnQpLmZpbmQoJy5kaXNhYmxlRGVsZXRlV2hlbkRpc2Nvbm5lY3QnKS5yZW1vdmVDbGFzcygnZGlzYWJsZURlbGV0ZVdoZW5EaXNjb25uZWN0Jyk7IC8vIHRvbyBlYXJseVxuXG4gICAgICAvLyBXYXJuIGZpZWxkbGVnZW5kIDogbWFjaGluZSBsaXN0IGhhcyBjaGFuZ2VkXG4gICAgICBpZiAoJ2ZhbHNlJyA9PSB0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdkb25vdHdhcm5ncm91cHJlbG9hZCcsICdmYWxzZScpKSB7XG4gICAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ2dyb3VwSXNSZWxvYWRlZCcsIHtcbiAgICAgICAgICBuZXdNYWNoaW5lc0xpc3Q6IHRoaXMuX21hY2hpbmVJZHNBcnJheS5qb2luKCcsJylcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RlYWxXaXRoUm90YXRpb24oKTtcblxuICAgICAgLy8gVElNRU9VVCB0byBiZSBzdXJlIHRoYXQgYWxsIGlzIGNsZWFyZWRcbiAgICAgIC8vIChlbHNlIHRoZSBtZWNhbmlzbSBpcyBub3Qgd29ya2luZyBhcyBpdCBzaG91bGQpXG4gICAgICBsZXQgcm90YXRpb25EZWxheSA9IE51bWJlcih0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdyb3RhdGlvbicsICc5MCcpKTtcbiAgICAgIHNldFRpbWVvdXQodGhpcy5fcmVtb3ZlRGlzYWJsZS5iaW5kKHRoaXMpLFxuICAgICAgICByb3RhdGlvbkRlbGF5IC8gMiAqIDEwMDApO1xuXG4gICAgfSAvLyBfZGlzcGxheU9yVXBkYXRlTWFjaGluZUxpc3RcblxuICAgIF9yZW1vdmVEaXNhYmxlICgpIHtcbiAgICAgICQodGhpcy5lbGVtZW50KS5maW5kKCcuZGlzYWJsZURlbGV0ZVdoZW5EaXNjb25uZWN0JylcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdkaXNhYmxlRGVsZXRlV2hlbkRpc2Nvbm5lY3QnKTtcbiAgICB9XG5cbiAgICBfZGVhbFdpdGhSb3RhdGlvbiAoKSB7XG4gICAgICBsZXQgbmJDb2x1bW5Ub0Rpc3BsYXkgPSBOdW1iZXIodGhpcy5nZXRDb25maWdPckF0dHJpYnV0ZSgnY29sdW1uJywgJzMnKSk7XG4gICAgICBsZXQgbmJSb3dUb0Rpc3BsYXkgPSBOdW1iZXIodGhpcy5nZXRDb25maWdPckF0dHJpYnV0ZSgncm93JywgJzInKSk7XG5cbiAgICAgIHRoaXMuX2N1cnJlbnREaXNwbGF5ZWRQYWdlID0gMTsgLy9yZS1pbml0XG5cbiAgICAgIGxldCBhbGxvd3BhZ2Vyb3RhdGlvbiA9IHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ2FsbG93cGFnZXJvdGF0aW9uJywgJ2ZhbHNlJyk7XG4gICAgICBpZiAoYWxsb3dwYWdlcm90YXRpb24gPT0gJ3RydWUnICYmXG4gICAgICAgIG5iQ29sdW1uVG9EaXNwbGF5ID4gMCAmJlxuICAgICAgICBuYlJvd1RvRGlzcGxheSA+IDApIHtcblxuICAgICAgICAvL3RoaXMuX2N1cnJlbnREaXNwbGF5ZWRQYWdlID0gMTsgLy9yZS1pbml0XG4gICAgICAgIGxldCBuYk1hY2hpbmUgPSB0aGlzLl9tYWNoaW5lSWRzQXJyYXkubGVuZ3RoO1xuICAgICAgICB0aGlzLl9uYlBhZ2VzVG90YWwgPSBNYXRoLmNlaWwobmJNYWNoaW5lIC8gKG5iQ29sdW1uVG9EaXNwbGF5ICogbmJSb3dUb0Rpc3BsYXkpKTtcbiAgICAgICAgaWYgKHRoaXMuX25iUGFnZXNUb3RhbCA9PSAwKVxuICAgICAgICAgIHRoaXMuX25iUGFnZXNUb3RhbCA9IDE7IC8vIFRvIGF2b2lkIHRvbyBsb2cgcmVmcmVzaCByYXRlXG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gTk8gcm90YXRpb25cbiAgICAgICAgdGhpcy5fbmJQYWdlc1RvdGFsID0gMTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JvdGF0aW9uQW5kUHJvZ3Jlc3NEaXNwbGF5KCk7XG4gICAgfVxuXG4gICAgX3JvdGF0aW9uQW5kUHJvZ3Jlc3NEaXNwbGF5ICgpIHtcbiAgICAgIC8vIENsZWFyIHRpbWVyIGlmIGV4aXN0ICEgVG8gYXZvaWQgbWFueSBsaXZpbmcgdGltZXJzXG4gICAgICBpZiAodGhpcy5fc2hvd0hpZGVUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2hvd0hpZGVUaW1lcik7XG4gICAgICAgIHRoaXMuX3Nob3dIaWRlVGltZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBsZXQgYWxsb3dwYWdlcm90YXRpb24gPSB0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdhbGxvd3BhZ2Vyb3RhdGlvbicsICdmYWxzZScpO1xuICAgICAgaWYgKGFsbG93cGFnZXJvdGF0aW9uID09ICd0cnVlJykge1xuICAgICAgICB0aGlzLl9zaG93SGlkZVBhZ2VzKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX25iUGFnZXNUb3RhbCA+IDEpIHtcbiAgICAgICAgICBsZXQgcm90YXRpb25EZWxheSA9IE51bWJlcih0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdyb3RhdGlvbicsICc5MCcpKTtcblxuICAgICAgICAgIC8vIERpc3BsYXkgcGFnaW5hdGlvbiBhbmQgcHJvZ3Jlc3MgbGluZVxuICAgICAgICAgICQoJy5wdWxzZS1oZWFkZXItcm90YXRpb24tcHJvZ3Jlc3MnKS5odG1sKCc8c3BhbiBzdHlsZT1cIndpZHRoOjBcIj48L3NwYW4+Jyk7IC8vIEluaXRpYWxpc2F0aW9uIGEgMHB4IGxpbmVcbiAgICAgICAgICAkKCcucHVsc2UtaGVhZGVyLXJvdGF0aW9uLXByb2dyZXNzID4gc3BhbicpLmFuaW1hdGUoe1xuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgICAgIH0sIHJvdGF0aW9uRGVsYXkgKiAxMDAwLCAnbGluZWFyJyk7IC8vIEluY3JlYXNlIGl0cyB3aWR0aCB1bnRpbCAxMDAlXG4gICAgICAgICAgJCgnI3B1bHNlLXBhZ2luYXRpb24nKS5odG1sKCh0aGlzLl9jdXJyZW50RGlzcGxheWVkUGFnZSkgKyAnIC8gJyArIHRoaXMuX25iUGFnZXNUb3RhbCk7XG5cbiAgICAgICAgICAvLyBQcmVwYXJlIG5leHQgcGFnZSByb3RhdGlvblxuICAgICAgICAgIHRoaXMuX2N1cnJlbnREaXNwbGF5ZWRQYWdlKys7XG4gICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnREaXNwbGF5ZWRQYWdlID4gdGhpcy5fbmJQYWdlc1RvdGFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50RGlzcGxheWVkUGFnZSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Nob3dIaWRlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdGF0aW9uQW5kUHJvZ3Jlc3NEaXNwbGF5KCk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpLCByb3RhdGlvbkRlbGF5ICogMTAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIDEgcGFnZSBvbmx5XG4gICAgICAgICAgLy8gUmVzZXQgcm90YXRpb25cbiAgICAgICAgICAkKCcucHVsc2UtaGVhZGVyLXJvdGF0aW9uLXByb2dyZXNzJykuaHRtbCgnJyk7XG4gICAgICAgICAgJCgnI3B1bHNlLXBhZ2luYXRpb24nKS5odG1sKCcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9zaG93SGlkZVBhZ2VzICgpIHtcbiAgICAgIC8vIEhpZGUgb3Igc2hvdyBwYWdlc1xuICAgICAgZm9yIChsZXQgaW5kZXhfcGFnZSA9IDE7IGluZGV4X3BhZ2UgPD0gdGhpcy5fbmJQYWdlc1RvdGFsOyBpbmRleF9wYWdlKyspIHtcbiAgICAgICAgbGV0IHBhZ2VfY2xhc3MgPSAnLmxpLXBhZ2UtJyArIGluZGV4X3BhZ2UudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGxpID0gJCh0aGlzLmVsZW1lbnQpLmZpbmQocGFnZV9jbGFzcyk7XG4gICAgICAgIGlmIChpbmRleF9wYWdlID09IHRoaXMuX2N1cnJlbnREaXNwbGF5ZWRQYWdlKSB7XG4gICAgICAgICAgLy8gJChsaSkuY3NzKCdkaXNwbGF5JywgJ2lubGluZS1ibG9jaycpOyAvL05PICEgQmVjYXVzZSBvZiBNYW5hZ2VyV2lldyBQYWdlXG4gICAgICAgICAgJChsaSkuc2hvdygpO1xuICAgICAgICAgICQobGkpLmZpbmQoJ3gtZGF0ZXRpbWVncmFkdWF0aW9uJykubG9hZCgpOyAvLyBkYXRldGltZWdyYWR1YXRpb24gY2FuIG5vdCBtYW5hZ2UgJ3dpZHRoJyB3aGVuIGhpZGRlblxuICAgICAgICAgIC8vIGEgYmVzdCBzb2x1dGlvbiBpcyB0byBtYW5hZ2Ugb25TaG93IEV2ZW50Li4gb25jZSBpdCBleGlzdHNcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAkKGxpKS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZW5kIGZvclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gY29udGV4dCAtIENvbnRleHRcbiAgICAgKiBAcmV0dXJuIHshc3RyaW5nfSBrZXlcbiAgICAgKi9cbiAgICBnZXRTdGFydEtleSAoY29udGV4dCkge1xuICAgICAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgICAgIGNhc2UgJ0xvYWRlZCc6XG4gICAgICAgICAgcmV0dXJuICdTdGFuZGFyZCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHN1cGVyLmdldFN0YXJ0S2V5KGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gY29udGV4dCAtIENvbnRleHRcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGtleSAtIEtleVxuICAgICAqIEByZXR1cm5zIHshU3RhdGV9IENyZWF0ZWQgc3RhdGVzXG4gICAgICovXG4gICAgZGVmaW5lU3RhdGUgKGNvbnRleHQsIGtleSkge1xuICAgICAgc3dpdGNoIChjb250ZXh0KSB7XG4gICAgICAgIGNhc2UgJ0xvYWRlZCc6IC8vID09IE5vIFJlZnJlc2ggdW50aWwgY2xpY2sgb24gYnV0dG9uICdTdGFydCdcbiAgICAgICAgICByZXR1cm4gbmV3IHN0YXRlLlN0YXRpY1N0YXRlKGNvbnRleHQsIGtleSwgdGhpcyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHN1cGVyLmRlZmluZVN0YXRlKGNvbnRleHQsIGtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZFdoZW5Db25uZWN0ZWRPbmNlIChhdHRyLCBvbGRWYWwsIG5ld1ZhbCkge1xuICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZFdoZW5Db25uZWN0ZWRPbmNlKGF0dHIsIG9sZFZhbCwgbmV3VmFsKTtcbiAgICAgIHN3aXRjaCAoYXR0cikge1xuICAgICAgICBjYXNlICd0ZW1wbGF0ZWlkJzpcbiAgICAgICAgY2FzZSAnZ3JvdXAnOlxuICAgICAgICBjYXNlICdtYWNoaW5lJzpcbiAgICAgICAgY2FzZSAnY29sdW1uJzpcbiAgICAgICAgY2FzZSAncm93JzpcbiAgICAgICAgY2FzZSAnY2FuVXNlUm93c1RvU2V0SGVpZ2h0JzpcbiAgICAgICAgY2FzZSAnYWxsb3dwYWdlcm90YXRpb24nOlxuICAgICAgICAgIC8vY2FzZSAncm90YXRpb24nOlxuICAgICAgICAgIC8vY2FzZSAncmVmcmVzaHJhdGUnOlxuICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0aWFsaXplICgpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3B1bHNlLWJpZ2Rpc3BsYXknKTtcblxuICAgICAgLy8gVXBkYXRlIGhlcmUgc29tZSBpbnRlcm5hbCBwYXJhbWV0ZXJzXG5cbiAgICAgIC8vIGxpc3RlbmVyc1xuXG4gICAgICAvLyBFbXB0eSBkaXNwbGF5IGlmIGFscmVhZHkgZmlsbGVkXG4gICAgICAkKHRoaXMuZWxlbWVudCkuZW1wdHkoKTtcblxuICAgICAgLy8gQ3JlYXRlIERPTSAtIENvbnRlbnRcbiAgICAgIHRoaXMuX2NvbnRlbnQgPSAkKCc8b2w+PC9vbD4nKS5hZGRDbGFzcygnZ3JvdXAtbWFpbicpO1xuICAgICAgJCh0aGlzLmVsZW1lbnQpXG4gICAgICAgIC5hZGRDbGFzcygnZ3JvdXAnKVxuICAgICAgICAuYXBwZW5kKHRoaXMuX2NvbnRlbnQpO1xuICAgICAgLy8gQ3JlYXRlIERPTSAtIExvYWRlclxuICAgICAgbGV0IGxvYWRlciA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3B1bHNlLWxvYWRlcicpLmh0bWwoJ0xvYWRpbmcuLi4nKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgbGV0IGxvYWRlckRpdiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3B1bHNlLWxvYWRlci1kaXYnKS5hcHBlbmQobG9hZGVyKTtcbiAgICAgICQodGhpcy5fY29udGVudCkuYXBwZW5kKGxvYWRlckRpdik7XG4gICAgICAvLyBDcmVhdGUgRE9NIC0gbWVzc2FnZSBmb3IgZXJyb3JcbiAgICAgIHRoaXMuX21lc3NhZ2VTcGFuID0gJCgnPHNwYW4+PC9zcGFuPicpXG4gICAgICAgIC5hZGRDbGFzcygncHVsc2UtbWVzc2FnZScpLmh0bWwoJycpO1xuICAgICAgbGV0IG1lc3NhZ2VEaXYgPSAkKCc8ZGl2PjwvZGl2PicpXG4gICAgICAgIC5hZGRDbGFzcygncHVsc2UtbWVzc2FnZS1kaXYnKVxuICAgICAgICAuYXBwZW5kKHRoaXMuX21lc3NhZ2VTcGFuKTtcbiAgICAgICQodGhpcy5fY29udGVudCkuYXBwZW5kKG1lc3NhZ2VEaXYpO1xuXG4gICAgICAvLyBJbml0aWFsaXphdGlvbiBPSyA9PiBzd2l0Y2ggdG8gdGhlIG5leHQgY29udGV4dFxuICAgICAgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJJbml0aWFsaXphdGlvbiAoKSB7XG4gICAgICAvLyBTVE9QIHRpbWVyXG4gICAgICBpZiAodGhpcy5fc2hvd0hpZGVUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2hvd0hpZGVUaW1lcik7XG4gICAgICAgIHRoaXMuX3Nob3dIaWRlVGltZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICAvLyBET01cbiAgICAgICQodGhpcy5lbGVtZW50KS5lbXB0eSgpO1xuXG4gICAgICB0aGlzLnJlbW92ZUVycm9yKCk7XG4gICAgICB0aGlzLl9tZXNzYWdlU3BhbiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2NvbnRlbnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHN1cGVyLmNsZWFySW5pdGlhbGl6YXRpb24oKTtcbiAgICB9XG5cbiAgICAvKnJlc2V0ICgpIHsgLy8gT3B0aW9uYWwgaW1wbGVtZW50YXRpb24gLSBSRU1PVkVEIGVsc2UgdG9vIG1hbnkgcmVmcmVzaHMgb24gTENUUiBhbmQgbWVtb3J5IGdyb3dzIGVuZGxlc3NseVxuICAgICAgLy8gQ29kZSBoZXJlIHRvIGNsZWFuIHRoZSBjb21wb25lbnQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIGluaXRpYWxpemVkIGZvciBleGFtcGxlIGFmdGVyIGEgcGFyYW1ldGVyIGNoYW5nZVxuICAgICAgLyp0aGlzLnJlbW92ZUVycm9yKCk7XG4gICAgICAvLyBFbXB0eSB0aGlzLl9jb250ZW50XG4gICAgICAkKHRoaXMuY29udGVudCkuZW1wdHkoKTtcblxuICAgICAgLy8gU1RPUCB0aW1lclxuICAgICAgaWYgKHRoaXMuX3Nob3dIaWRlVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dIaWRlVGltZXIpO1xuICAgICAgICB0aGlzLl9zaG93SGlkZVRpbWVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgfSovXG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgKGV2ZW50KSBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgdmFsaWRhdGVQYXJhbWV0ZXJzICgpIHtcbiAgICAgIGxldCBncm91cHMgPSB0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdncm91cCcpO1xuICAgICAgbGV0IG1hY2hpbmVzID0gdGhpcy5nZXRDb25maWdPckF0dHJpYnV0ZSgnbWFjaGluZScpO1xuICAgICAgaWYgKChncm91cHMgPT0gbnVsbCB8fCBncm91cHMgPT0gJycpICYmXG4gICAgICAgIChtYWNoaW5lcyA9PSBudWxsIHx8IG1hY2hpbmVzID09ICcnKSkge1xuICAgICAgICAvKm1pc3NpbmdDb25maWdzLnB1c2goe1xuICAgICAgICAgIHNlbGVjdG9yOiAneC1tYWNoaW5lc2VsZWN0aW9uLCAjZWRpdG1hY2hpbmVzJyxcbiAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIHNlbGVjdCBhdCBsZWFzdCBvbmUgbWFjaGluZSBiZWZvcmUgbGF1bmNoaW5nIHRoZSBwYWdlLidcbiAgICAgICAgfSk7ICovXG4gICAgICAgIGNvbnNvbGUud2FybignbWlzc2luZyBhdHRyaWJ1dGUgZ3JvdXBzIG9yIG1hY2hpbmVzIGluIHgtZ3JvdXBhcnJheScpO1xuICAgICAgICAvLyBEZWxheWVkIGRpc3BsYXkgOlxuICAgICAgICAvL3RoaXMuc2V0RXJyb3IoJ1BsZWFzZSBzZWxlY3QgYSBtYWNoaW5lJyk7IC8vIGRlbGF5ZWQgZXJyb3IgbWVzc2FnZVxuICAgICAgICAvLyBJbW1lZGlhdCBkaXNwbGF5IDpcbiAgICAgICAgdGhpcy5zd2l0Y2hUb0tleSgnRXJyb3InLCAoKSA9PiB0aGlzLmRpc3BsYXlFcnJvcignUGxlYXNlIHNlbGVjdCBhIG1hY2hpbmUnKSwgKCkgPT4gdGhpcy5yZW1vdmVFcnJvcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGRpdGlvbmFsIGNoZWNrcyB3aXRoIGF0dHJpYnV0ZSBwYXJhbVxuXG4gICAgICB0aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5RXJyb3IgKG1lc3NhZ2UpIHtcbiAgICAgICQodGhpcy5fbWVzc2FnZVNwYW4pLmh0bWwobWVzc2FnZSk7XG5cbiAgICAgICQoJy5ncm91cGFycmF5LWRlcGVuZGFudCcpLmFkZENsYXNzKCdncm91cGFycmF5LWluLWVycm9yJyk7IC8vKS5oaWRlKCk7XG5cbiAgICAgIC8vIFNUT1AgdGltZXJcbiAgICAgIGlmICh0aGlzLl9zaG93SGlkZVRpbWVyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaG93SGlkZVRpbWVyKTtcbiAgICAgICAgdGhpcy5fc2hvd0hpZGVUaW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlRXJyb3IgKCkge1xuICAgICAgJCh0aGlzLl9tZXNzYWdlU3BhbikuaHRtbCgnJyk7XG5cbiAgICAgICQoJy5ncm91cGFycmF5LWRlcGVuZGFudCcpLnJlbW92ZUNsYXNzKCdncm91cGFycmF5LWluLWVycm9yJyk7IC8vLnNob3coKTtcbiAgICB9XG5cbiAgICBnZXQgcmVmcmVzaFJhdGUgKCkge1xuICAgICAgLy8gUmV0dXJuIGhlcmUgdGhlIHJlZnJlc2ggcmF0ZSBpbiBtcy5cbiAgICAgIGlmICh0aGlzLl9uYlBhZ2VzVG90YWwgPj0gMSkge1xuICAgICAgICBsZXQgcm90YXRpb25EZWxheSA9IE51bWJlcih0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdyb3RhdGlvbicsICc5MCcpKTtcbiAgICAgICAgcmV0dXJuIHJvdGF0aW9uRGVsYXkgKiB0aGlzLl9uYlBhZ2VzVG90YWwgKiAxMDAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmVmcmVzaHJhdGUnKSkge1xuICAgICAgICByZXR1cm4gMTAwMCAqIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlZnJlc2hyYXRlJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDEwMDAgKiA2MCAqIDYwOyAvLyAxIGhyXG4gICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICAgIFJlcGxhY2UgX3J1bkFqYXhXaGVuSXNWaXNpYmxlIHdoZW4gTk8gdXJsIHNob3VsZCBiZSBjYWxsZWRcbiAgICAgIHJldHVybiB0cnVlIGlmIHNvbWV0aGluZyBpcyBkb25lLCBmYWxzZSBpZiBfcnVuQWpheFdoZW5Jc1Zpc2libGUgc2hvdWxkIGJlIGNhbGxlZFxuICAgICovXG4gICAgX3J1bkFsdGVybmF0ZUdldERhdGEgKCkge1xuICAgICAgbGV0IGdyb3VwcyA9IHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ2dyb3VwJyk7IC8vdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZ3JvdXBzJyk7XG4gICAgICBpZiAoKHB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQoZ3JvdXBzKSkgfHxcbiAgICAgICAgKGdyb3VwcyA9PSAnJykpIHtcblxuICAgICAgICB0aGlzLnJlbW92ZUVycm9yKCk7XG5cbiAgICAgICAgdGhpcy5fZHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAvLyBNYW5hZ2UgbGlzdCBvZiBtYWNoaW5lcyBOT1dcbiAgICAgICAgbGV0IG1hY2hpbmVzID0gdGhpcy5nZXRDb25maWdPckF0dHJpYnV0ZSgnbWFjaGluZScpO1xuICAgICAgICB0aGlzLl9tYWNoaW5lSWRzQXJyYXkgPSBtYWNoaW5lcy5zcGxpdCgnLCcpO1xuICAgICAgICB0aGlzLl9kaXNwbGF5T3JVcGRhdGVNYWNoaW5lTGlzdCgpO1xuXG4gICAgICAgIHRoaXMuX2xhc3RVcGRhdGVEYXRlID0gRGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGV4dGNoYW5nZS1jb250ZXh0JykpIHtcbiAgICAgICAgICAvLyBTZW5kIGVtcHR5IHN0cmluZ1xuICAgICAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9Db250ZXh0KCd0ZXh0Q2hhbmdlRXZlbnQnLFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgndGV4dGNoYW5nZS1jb250ZXh0JyksXG4gICAgICAgICAgICB7IHRleHQ6ICcnIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQkVDQVVTRSB0aGlzLl9keW5hbWljID09IGZhbHNlOyAvLyBTVE9QIGNhbGxpbmcgQWpheCByZXF1ZXN0XG4gICAgICAgIHRoaXMuc3dpdGNoVG9Db250ZXh0KCdMb2FkZWQnKTtcbiAgICAgICAgLy8gQU5EIE5PVCB0aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBlbHNlIENhbGwgV2ViU2VydmljZVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGdldFNob3J0VXJsICgpIHtcbiAgICAgIC8vIFJldHVybiB0aGUgV2ViIFNlcnZpY2UgVVJMIGhlcmUgd2l0aG91dCBwYXRoXG4gICAgICBsZXQgZ3JvdXBzID0gdGhpcy5nZXRDb25maWdPckF0dHJpYnV0ZSgnZ3JvdXAnKTtcbiAgICAgIGxldCB1cmwgPSAnTWFjaGluZXNGcm9tR3JvdXBzP0dyb3VwSWRzPScgKyBncm91cHM7XG4gICAgICAvLyBMb2dpbiBpcyBzZXQgaW4gZ2xvYmFsIHNlcnZpY2UgY2FsbFxuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICByZWZyZXNoIChkYXRhKSB7XG4gICAgICB0aGlzLl9kaXNwbGF5T3JVcGRhdGVNYWNoaW5lTGlzdCgpO1xuICAgIH1cblxuICAgIG1hbmFnZVN1Y2Nlc3MgKGRhdGEpIHtcbiAgICAgIC8qIHB1YmxpYyBMaXN0PGludD4gTWFjaGluZUlkcyB7IGdldDsgc2V0OyB9XG4gICAgICBwdWJsaWMgaW50PyBTb3J0S2luZCB7IGdldDsgc2V0OyB9XG4gICAgICBwdWJsaWMgc3RyaW5nIFNvcnRLaW5kVGlwIHsgZ2V0OyBzZXQ7IH0qL1xuICAgICAgdGhpcy5yZW1vdmVFcnJvcigpO1xuXG4gICAgICB0aGlzLl9tYWNoaW5lSWRzQXJyYXkgPSBkYXRhLk1hY2hpbmVJZHM7XG4gICAgICB0aGlzLl9keW5hbWljID0gZGF0YS5EeW5hbWljO1xuICAgICAgaWYgKHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ2ZvcmNlc3RhdGljbGlzdCcpID09ICd0cnVlJyB8fFxuICAgICAgICB0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdmb3JjZXN0YXRpY2xpc3QnKSA9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2R5bmFtaWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xhc3RVcGRhdGVEYXRlID0gRGF0ZSgpO1xuICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RleHRjaGFuZ2UtY29udGV4dCcpKSB7XG4gICAgICAgIGxldCB0ZXh0VG9TZW5kID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl9keW5hbWljKSB7XG4gICAgICAgICAgLy8gRm9ybWF0IERhdGUgYW5kIHNlbmRcbiAgICAgICAgICBsZXQgX2xhc3RNb21lbnQgPSBwdWxzZVV0aWxpdHkuY29udmVydERhdGVUb01vbWVudCh0aGlzLl9sYXN0VXBkYXRlRGF0ZSk7XG4gICAgICAgICAgdGV4dFRvU2VuZCA9IF9sYXN0TW9tZW50LmZvcm1hdCgnTFRTJylcbiAgICAgICAgfVxuICAgICAgICBldmVudEJ1cy5FdmVudEJ1cy5kaXNwYXRjaFRvQ29udGV4dCgndGV4dENoYW5nZUV2ZW50JyxcbiAgICAgICAgICB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0ZXh0Y2hhbmdlLWNvbnRleHQnKSxcbiAgICAgICAgICB7IHRleHQ6IHRleHRUb1NlbmQgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmYWxzZSA9PSB0aGlzLl9keW5hbWljKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BsYXlPclVwZGF0ZU1hY2hpbmVMaXN0KCk7XG5cbiAgICAgICAgLy8gU1RPUCBjYWxsaW5nIEFqYXggcmVxdWVzdFxuICAgICAgICB0aGlzLnN3aXRjaFRvQ29udGV4dCgnTG9hZGVkJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gU3VjY2VzczpcbiAgICAgICAgc3VwZXIubWFuYWdlU3VjY2VzcyhkYXRhKTtcbiAgICAgICAgLy8gb3IgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCgpID0+IHRoaXMucmVmcmVzaChkYXRhKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2FsbGJhY2sgZXZlbnRzXG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBjYWxsYmFjayBpbiBjYXNlIGEgY29uZmlnIGlzIHVwZGF0ZWQ6IChyZS0pc3RhcnQgdGhlIGNvbXBvbmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBldmVudFxuICAgICAqL1xuICAgIG9uQ29uZmlnQ2hhbmdlIChldmVudCkge1xuICAgICAgaWYgKChldmVudC50YXJnZXQuY29uZmlnID09ICdtYWNoaW5lJylcbiAgICAgICAgfHwgKGV2ZW50LnRhcmdldC5jb25maWcgPT0gJ2dyb3VwJykpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgfVxuICAgICAgaWYgKChldmVudC50YXJnZXQuY29uZmlnID09ICdyb3cnKVxuICAgICAgICB8fCAoZXZlbnQudGFyZ2V0LmNvbmZpZyA9PSAnY29sdW1uJykpIHtcbiAgICAgICAgdGhpcy5fZGlzcGxheU9yVXBkYXRlTWFjaGluZUxpc3QoKTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC50YXJnZXQuY29uZmlnID09ICdyb3RhdGlvbicpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudERpc3BsYXllZFBhZ2UgPSAxO1xuICAgICAgICB0aGlzLl9yb3RhdGlvbkFuZFByb2dyZXNzRGlzcGxheSgpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcHVsc2VDb21wb25lbnQucmVnaXN0ZXJFbGVtZW50KCd4LWdyb3VwYXJyYXknLCBHcm91cENvbXBvbmVudCwgWyd0ZW1wbGF0ZWlkJywgJ2dyb3VwJywgJ21hY2hpbmUnLCAnY29sdW1uJywgJ3JvdycsICdjYW5Vc2VSb3dzVG9TZXRIZWlnaHQnLCAnYWxsb3dwYWdlcm90YXRpb24nXSk7XG59KSgpO1xuIiwiLy8gQ29weXJpZ2h0IChDKSAyMDA5LTIwMjMgTGVtb2luZSBBdXRvbWF0aW9uIFRlY2hub2xvZ2llc1xuLy9cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5cbi8qKlxuICogQG1vZHVsZSB4LWxvZ2luZGlzcGxheVxuICogQHJlcXVpcmVzIG1vZHVsZTpwdWxzZUNvbXBvbmVudFxuICovXG5cbnZhciBwdWxzZUNvbXBvbmVudCA9IHJlcXVpcmUoJ3B1bHNlY29tcG9uZW50Jyk7XG52YXIgcHVsc2VDb25maWcgPSByZXF1aXJlKCdwdWxzZUNvbmZpZycpO1xudmFyIHB1bHNlTG9naW4gPSByZXF1aXJlKCdwdWxzZUxvZ2luJyk7XG52YXIgcHVsc2VTdmcgPSByZXF1aXJlKCdwdWxzZVN2ZycpO1xuXG4vKipcbiAqIEJ1aWxkIGEgY3VzdG9tIHRhZyA8eC1sb2dpbmRpc3BsYXk+IFxuICovXG4oZnVuY3Rpb24gKCkge1xuXG4gIGNsYXNzIExvZ2luRGlzcGxheUNvbXBvbmVudCBleHRlbmRzIHB1bHNlQ29tcG9uZW50LlB1bHNlSW5pdGlhbGl6ZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSBzdXBlciguLi5hcmdzKTtcblxuICAgICAgLy8gRE9NOiBuZXZlciBpbiBjb25zdHJ1Y3RvciwgdXNlIHRoZSBpbml0aWFsaXplIG1ldGhvZCBpbnN0ZWFkXG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZFdoZW5Db25uZWN0ZWRPbmNlIChhdHRyLCBvbGRWYWwsIG5ld1ZhbCkge1xuICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZFdoZW5Db25uZWN0ZWRPbmNlKGF0dHIsIG9sZFZhbCwgbmV3VmFsKTtcbiAgICB9XG5cbiAgICBfZmlsbERpc3BsYXkgKCkge1xuICAgICAgaWYgKHB1bHNlQ29uZmlnLmN1cnJlbnRSb2xlT3JBcHBDb250ZXh0SXNEZWZpbmVkKCkpIHtcbiAgICAgICAgJCh0aGlzLl9zcGFuKS5odG1sKHB1bHNlQ29uZmlnLmdldEN1cnJlbnRVc2VyRGlzcGxheSgpKTtcbiAgICAgICAgJCh0aGlzLl9jb250ZW50KS5zaG93KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gRGlzYWJsZSB0aGUgbmF2aWdhdGlvbiBwYW5lbCwgYSByb2xlIG11c3QgYmUgY2hvc2VuIGZpcnN0XG4gICAgICAgICQodGhpcy5fY29udGVudCkuaGlkZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9kZWZpbmVDbGljayAoKSB7XG4gICAgICAvLyBMb2dvdXQgYnV0dG9uXG4gICAgICAkKHRoaXMuX2NvbnRlbnQpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgY3VycmVudCByb2xlXG4gICAgICAgIHB1bHNlTG9naW4uY2xlYW5Mb2dpblJvbGUoKTtcblxuICAgICAgICBwdWxzZUNvbmZpZy5nb1RvUGFnZUxvZ2luKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpbml0aWFsaXplICgpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3B1bHNlLXRleHQnKTtcblxuICAgICAgLy8gSW4gY2FzZSBvZiBjbG9uZSwgbmVlZCB0byBiZSBlbXB0eSA6XG4gICAgICAkKHRoaXMuZWxlbWVudCkuZW1wdHkoKTtcblxuICAgICAgLy8gQ3JlYXRlIERPTSAtIExvYWRlciAtPiBOb3QgbmVlZGVkIGhlcmVcblxuICAgICAgLy8gQ3JlYXRlIERPTSAtIENvbnRlbnRcbiAgICAgIHRoaXMuX3NwYW4gPSAkKCc8c3Bhbj48L3NwYW4+JykuYWRkQ2xhc3MoJ2xvZ2luZGlzcGxheS1zcGFuJyk7XG4gICAgICB0aGlzLl9pY29uID0gJCgnPHNwYW4+PC9zcGFuPicpLmFkZENsYXNzKCdsb2dpbmRpc3BsYXktaWNvbicpO1xuICAgICAgdGhpcy5fY29udGVudCA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ2xvZ2luZGlzcGxheS1jb250ZW50JylcbiAgICAgICAgLmFwcGVuZCh0aGlzLl9zcGFuKS5hcHBlbmQodGhpcy5faWNvbik7XG4gICAgICAkKHRoaXMuZWxlbWVudCkuYXBwZW5kKHRoaXMuX2NvbnRlbnQpO1xuXG4gICAgICB0aGlzLl9maWxsRGlzcGxheSgpO1xuXG4gICAgICB0aGlzLl9kZWZpbmVDbGljaygpO1xuXG4gICAgICAvLyBDcmVhdGUgRE9NIC0gbWVzc2FnZSBmb3IgZXJyb3IgLT4gTm90IG5lZWRlZCBoZXJlXG4gICAgICBcbiAgICAgIC8vIERpc2FibGUgaW5saW5lIGZvciByZXBvcnRpbmcgLSB0aGUgbGF0ZXN0IHRvIGhvcGUgZGlzcGxheWluZyBjb2xvcnMgYWx3YXlzXG4gICAgICBpZiAoIHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ2Rvbm90dXNlaW5saW5lJywgJ2ZhbHNlJykgPT0gJ2ZhbHNlJyApe1xuICAgICAgICAvLyBpbmxpbmUgaWNvblxuICAgICAgICBwdWxzZVN2Zy5pbmxpbmVCYWNrZ3JvdW5kU3ZnKHRoaXMuX2ljb24pO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0aWFsaXphdGlvbiBPSyA9PiBzd2l0Y2ggdG8gdGhlIG5leHQgY29udGV4dFxuICAgICAgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlzcGxheUVycm9yIChtZXNzYWdlKSB7XG4gICAgICAvLyBDb2RlIGhlcmUgdG8gZGlzcGxheSB0aGUgZXJyb3IgbWVzc2FnZVxuICAgIH1cblxuICAgIHJlbW92ZUVycm9yICgpIHtcbiAgICAgIC8vIENvZGUgaGVyZSB0byByZW1vdmUgdGhlIGVycm9yIG1lc3NhZ2VcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBjYWxsYmFjayBpbiBjYXNlIGEgY29uZmlnIGlzIHVwZGF0ZWQ6IChyZS0pc3RhcnQgdGhlIGNvbXBvbmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBldmVudFxuICAgICAqL1xuICAgIG9uQ29uZmlnQ2hhbmdlIChldmVudCkge1xuICAgICAgLy8gRGVmYXVsdCA9IGRvIG5vdGhpbmdcbiAgICAgIC8vIEV4YW1wbGUgOlxuICAgICAgLy9pZiAoIGV2ZW50LnRhcmdldC5jb25maWcgPT0gJ215Q29uZmlnJylcbiAgICAgIC8vICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuXG4gIH1cblxuICBwdWxzZUNvbXBvbmVudC5yZWdpc3RlckVsZW1lbnQoJ3gtbG9naW5kaXNwbGF5JywgTG9naW5EaXNwbGF5Q29tcG9uZW50LCBbXSk7XG59KSgpO1xuIiwiLy8gQ29weXJpZ2h0IChDKSAyMDA5LTIwMjMgTGVtb2luZSBBdXRvbWF0aW9uIFRlY2hub2xvZ2llc1xuLy9cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5cbi8qKlxuICogQG1vZHVsZSB4LW1hY2hpbmVkaXNwbGF5XG4gKiBAcmVxdWlyZXMgbW9kdWxlOnB1bHNlQ29tcG9uZW50XG4gKiBAcmVxdWlyZXMgbW9kdWxlOnB1bHNlVXRpbGl0eVxuICovXG52YXIgcHVsc2VVdGlsaXR5ID0gcmVxdWlyZSgncHVsc2VVdGlsaXR5Jyk7XG52YXIgcHVsc2VDb21wb25lbnQgPSByZXF1aXJlKCdwdWxzZWNvbXBvbmVudCcpO1xudmFyIGV2ZW50QnVzID0gcmVxdWlyZSgnZXZlbnRCdXMnKTtcblxuKGZ1bmN0aW9uICgpIHtcblxuICBjbGFzcyBNYWNoaW5lRGlzcGxheUNvbXBvbmVudCBleHRlbmRzIHB1bHNlQ29tcG9uZW50LlB1bHNlUGFyYW1BdXRvUGF0aFNpbmdsZVJlcXVlc3RDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSBzdXBlciguLi5hcmdzKTtcblxuICAgICAgc2VsZi5fZGF0YUVsZW1lbnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRXaGVuQ29ubmVjdGVkT25jZSAoYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRXaGVuQ29ubmVjdGVkT25jZShhdHRyLCBvbGRWYWwsIG5ld1ZhbCk7XG4gICAgICBzd2l0Y2ggKGF0dHIpIHtcbiAgICAgICAgY2FzZSAnZ3JvdXAnOiAvLyBOb3QgZ3JvdXAtaWQgYmVjYXVzZSBvZiB1cmwgY29tcGF0aWJpbGl0eVxuICAgICAgICBjYXNlICdtYWNoaW5lLWlkJzpcbiAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21hY2hpbmUtY29udGV4dCc6XG4gICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICBldmVudEJ1cy5FdmVudEJ1cy5yZW1vdmVFdmVudExpc3RlbmVyQnlTaWduYWwodGhpcywgJ21hY2hpbmVJZENoYW5nZVNpZ25hbCcpO1xuICAgICAgICAgICAgZXZlbnRCdXMuRXZlbnRCdXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLFxuICAgICAgICAgICAgICAnbWFjaGluZUlkQ2hhbmdlU2lnbmFsJyxcbiAgICAgICAgICAgICAgbmV3VmFsLFxuICAgICAgICAgICAgICB0aGlzLm9uTWFjaGluZUlkQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0aWFsaXplICgpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3B1bHNlLXRleHQnKTtcblxuICAgICAgLy8gSW4gY2FzZSBvZiBjbG9uZSwgbmVlZCB0byBiZSBlbXB0eSA6XG4gICAgICAkKHRoaXMuZWxlbWVudCkuZW1wdHkoKTtcblxuICAgICAgLy8gQ3JlYXRlIERPTSAtIENvbnRlbnRcbiAgICAgIHRoaXMuX2RhdGFFbGVtZW50ID0gJCgnPHNwYW4+PC9zcGFuPicpLmFkZENsYXNzKCdtYWNoaW5lZGlzcGxheS1kYXRhJyk7XG4gICAgICAkKHRoaXMuZWxlbWVudCkuYXBwZW5kKHRoaXMuX2RhdGFFbGVtZW50KTtcbiAgICAgIC8vIENyZWF0ZSBET00gLSBMb2FkZXJcbiAgICAgIGxldCBsb2FkZXIgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdwdWxzZS1sb2FkZXInKS5odG1sKCdMb2FkaW5nLi4uJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgIGxldCBsb2FkZXJEaXYgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdwdWxzZS1sb2FkZXItZGl2JykuYXBwZW5kKGxvYWRlcik7XG4gICAgICAkKHRoaXMuZWxlbWVudCkuYXBwZW5kKGxvYWRlckRpdik7XG5cbiAgICAgIC8vIENyZWF0ZSBET00gLSBtZXNzYWdlIGZvciBlcnJvclxuICAgICAgdGhpcy5fbWVzc2FnZVNwYW4gPSAkKCc8c3Bhbj48L3NwYW4+JylcbiAgICAgICAgLmFkZENsYXNzKCdwdWxzZS1tZXNzYWdlJykuaHRtbCgnJyk7XG4gICAgICBsZXQgbWVzc2FnZURpdiA9ICQoJzxkaXY+PC9kaXY+JylcbiAgICAgICAgLmFkZENsYXNzKCdwdWxzZS1tZXNzYWdlLWRpdicpXG4gICAgICAgIC5hcHBlbmQodGhpcy5fbWVzc2FnZVNwYW4pO1xuICAgICAgJCh0aGlzLmVsZW1lbnQpLmFwcGVuZChtZXNzYWdlRGl2KTtcblxuICAgICAgLy8gTGlzdGVuZXIgYW5kIGRpc3BhdGNoZXJzXG4gICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbWFjaGluZS1jb250ZXh0JykpIHtcbiAgICAgICAgZXZlbnRCdXMuRXZlbnRCdXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLFxuICAgICAgICAgICdtYWNoaW5lSWRDaGFuZ2VTaWduYWwnLFxuICAgICAgICAgIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21hY2hpbmUtY29udGV4dCcpLFxuICAgICAgICAgIHRoaXMub25NYWNoaW5lSWRDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgIH1cblxuICAgIGNsZWFySW5pdGlhbGl6YXRpb24gKCkge1xuICAgICAgLy8gUGFyYW1ldGVyc1xuICAgICAgLy8gRE9NXG4gICAgICAkKHRoaXMuZWxlbWVudCkuZW1wdHkoKTtcblxuICAgICAgdGhpcy5fbWVzc2FnZVNwYW4gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9kYXRhRWxlbWVudCA9IHVuZGVmaW5lZDtcblxuICAgICAgc3VwZXIuY2xlYXJJbml0aWFsaXphdGlvbigpO1xuICAgIH1cblxuICAgIHJlc2V0ICgpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXJyb3IoKTtcbiAgICAgICQodGhpcy5fZGF0YUVsZW1lbnQpLmh0bWwoJycpO1xuXG4gICAgICB0aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZVBhcmFtZXRlcnMgKCkge1xuICAgICAgaWYgKCF0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdtYWNoaW5lLWlkJykpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdncm91cCcpKSB7XG4gICAgICAgICAgaWYgKCcnID09PSB0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdncm91cCcpKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSkgeyAvLyBUbyBhdm9pZCBkaXNwbGF5ZWQgZXJyb3IgaW4gaGlkZGVuIGR1cGxpY2F0ZWQgcGFydFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdtaXNzaW5nIGF0dHJpYnV0ZSBtYWNoaW5lIG9yIGdyb3VwIGluIE1hY2hpbmVEaXNwbGF5Q29tcG9uZW50LmVsZW1lbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdGhpcy5zZXRFcnJvcignbWlzc2luZyBtYWNoaW5lLWlkJyk7IC8vIGRlbGF5ZWQgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgdGhpcy5zd2l0Y2hUb0tleSgnRXJyb3InLCAoKSA9PiB0aGlzLmRpc3BsYXlFcnJvcignaW52YWxpZCBtYWNoaW5lIG9yIGdyb3VwJyksICgpID0+IHRoaXMucmVtb3ZlRXJyb3IoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKTtcbiAgICB9XG5cbiAgICBnZXRTaG9ydFVybCAoKSB7XG4gICAgICBsZXQgdXJsID0gJ01hY2hpbmUvTmFtZSc7XG4gICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbWFjaGluZS1pZCcpKSB7XG4gICAgICAgIHVybCArPSAnP01hY2hpbmVJZD0nICsgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWFjaGluZS1pZCcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBncm91cCA9ICcnO1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZ3JvdXAnKSkge1xuICAgICAgICAgIGdyb3VwID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBncm91cCA9IHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoJ2dyb3VwJyk7IC8vIGNvbmZpZyBmaXJzdCAtIGtlZXAgZ2V0QXR0cmlidXRlIGJlZm9yZVxuICAgICAgICB9XG4gICAgICAgIHVybCArPSAnP0dyb3VwSWQ9JyArIGdyb3VwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG5cbiAgICByZWZyZXNoIChkYXRhKSB7XG4gICAgICBpZiAoIXB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQoZGF0YS5EaXNwbGF5KSlcbiAgICAgICAgJCh0aGlzLl9kYXRhRWxlbWVudCkuaHRtbChkYXRhLkRpc3BsYXkpO1xuICAgICAgZWxzZVxuICAgICAgICAkKHRoaXMuX2RhdGFFbGVtZW50KS5odG1sKGRhdGEuTmFtZSk7XG5cbiAgICAgIC8vIHN0cmluZyBJZFxuICAgICAgLy8gc3RyaW5nIFRyZWVOYW1lXG4gICAgICAvLyBib29sIEdyb3VwIC8vIElzIGl0IGEgZ3JvdXAgP1xuICAgIH1cblxuICAgIGRpc3BsYXlFcnJvciAobWVzc2FnZSkge1xuICAgICAgJCh0aGlzLl9kYXRhRWxlbWVudCkuaHRtbCgnJyk7XG4gICAgICAkKHRoaXMuX21lc3NhZ2VTcGFuKS5odG1sKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJlbW92ZUVycm9yICgpIHtcbiAgICAgIHRoaXMuZGlzcGxheUVycm9yKCcnKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsYmFjayBldmVudHNcbiAgICBvbk1hY2hpbmVJZENoYW5nZSAoZXZlbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21hY2hpbmUtaWQnLCBldmVudC50YXJnZXQubmV3TWFjaGluZUlkKTtcbiAgICB9XG4gIH1cblxuICBwdWxzZUNvbXBvbmVudC5yZWdpc3RlckVsZW1lbnQoJ3gtbWFjaGluZWRpc3BsYXknLCBNYWNoaW5lRGlzcGxheUNvbXBvbmVudCwgWydncm91cCcsICdtYWNoaW5lLWlkJywgJ21hY2hpbmUtY29udGV4dCddKTtcbn0pKCk7XG4iLCIvLyBDb3B5cmlnaHQgKEMpIDIwMDktMjAyMyBMZW1vaW5lIEF1dG9tYXRpb24gVGVjaG5vbG9naWVzXG4vL1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuLyoqXG4gKiBAbW9kdWxlIHgtbWFjaGluZXNlbGVjdGlvblxuICogQHJlcXVpcmVzIG1vZHVsZTpwdWxzZUNvbXBvbmVudFxuICogQHJlcXVpcmVzIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqIEByZXF1aXJlcyBtb2R1bGU6cHVsc2VjdXN0b21kaWFsb2dcbiAqL1xudmFyIHB1bHNlVXRpbGl0eSA9IHJlcXVpcmUoJ3B1bHNlVXRpbGl0eScpO1xudmFyIHB1bHNlU3ZnID0gcmVxdWlyZSgncHVsc2VTdmcnKTtcbnZhciBwdWxzZUNvbXBvbmVudCA9IHJlcXVpcmUoJ3B1bHNlY29tcG9uZW50Jyk7XG52YXIgcHVsc2VDdXN0b21EaWFsb2cgPSByZXF1aXJlKCdwdWxzZUN1c3RvbURpYWxvZycpO1xudmFyIHB1bHNlTG9naW4gPSByZXF1aXJlKCdwdWxzZUxvZ2luJyk7XG52YXIgcHVsc2VDb25maWcgPSByZXF1aXJlKCdwdWxzZUNvbmZpZycpO1xudmFyIGV2ZW50QnVzID0gcmVxdWlyZSgnZXZlbnRCdXMnKTtcblxuXG5yZXF1aXJlKCd4LWdyb3VwYXJyYXkveC1ncm91cGFycmF5Jyk7XG5yZXF1aXJlKCd4LW1hY2hpbmVkaXNwbGF5L3gtbWFjaGluZWRpc3BsYXknKTtcbnJlcXVpcmUoJ3gtZnJlZXRleHQveC1mcmVldGV4dCcpO1xuXG5cbi8qKlxuICogQnVpbGQgYSBjdXN0b20gdGFnIDx4LW1hY2hpbmVzZWxlY3Rpb24+XG4gKiBDQU4gQkUgVXNlZCBieSByZXBvcnQgd2ViIGFwcCBPUiBwdWxzZSB3ZWIgYXBwXG4gKiBcbiAqIEF0dHJpYnV0ZXMgOlxuICogdW5pcXVlLW1hY2hpbmUgOiBib29sIGlmIHNpbmdsZSBtYWNoaW5lIGlzIG1hbmRhdG9yeSAocmFyZWx5IHVzZWQpXG4gKiBcbiAqIC8vIFNwZWNpYWwgZm9yIHJlcG9ydHNcbiAqIGluLXJlcG9ydCA9IHByZXNlbnQgaWYgcmVwb3J0IHZlcnNpb24gaXMgZW5hYmxlZFxuICogZ3JvdXBEaXNwbGF5Rm9ybSA9IE1BQ0hJTkVTR1JPVVBTXG4gKiBncm91cE5hbWUuIGV4ID0gXG4gKiBwdWxzZS1tYWNoaW5lcyAoc3RvcmFnZSBpbiBsb2NhbHN0b3JhZ2UgdXNpbmcgcHVsc2VDb25maWcgZm9yIHB1bHNld2ViYXBwKVxuICogcHVsc2UtZ3JvdXBzIChzdG9yYWdlIGluIGxvY2Fsc3RvcmFnZSB1c2luZyBwdWxzZUNvbmZpZyBmb3IgcHVsc2V3ZWJhcHApXG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgY2xhc3MgTWFjaGluZVNlbGVjdGlvbkNvbXBvbmVudCBleHRlbmRzIHB1bHNlQ29tcG9uZW50LlB1bHNlUGFyYW1BdXRvUGF0aFNpbmdsZVJlcXVlc3RDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSBzdXBlciguLi5hcmdzKTtcblxuICAgICAgLy8gTGlua2VkIHRvIGNvbmZpZyA6XG4gICAgICBzZWxmLl9jb25maWdNYWNoaW5lcyA9ICdtYWNoaW5lJztcbiAgICAgIHNlbGYuX2NvbmZpZ0dyb3VwcyA9ICdncm91cCc7XG5cbiAgICAgIC8vIGN1cnJlbnQgU0VMRUNUSU9OIHN0b3JhZ2UgKGluIGNvbmZpZyBvciBsb2NhbCwgYmVmb3JlIGNsaWNrIG9uIE9LKVxuICAgICAgc2VsZi5fZ3JvdXBTZWxlY3Rpb25BcnJheSA9IFtdO1xuICAgICAgc2VsZi5fbWFjaGluZVNlbGVjdGlvbkFycmF5ID0gW107XG4gICAgICBzZWxmLl91c2VNYWNoaW5lU2VsZWN0aW9uID0gZmFsc2U7IC8vIG1hY2hpbmUgT1IgZ3JvdXBcblxuICAgICAgLy8gPT0gZGF0YS4gZnJvbSB3ZWIgc2VydmljZVxuICAgICAgc2VsZi5fZ3JvdXBzID0gW107XG5cbiAgICAgIC8vIE1hcCBbaWRdID0gZ3JvdXAgb3IgbWFjaGluZSBkaXNwbGF5XG4gICAgICAvLyBIb3cgdG8gdXNlIG1hcCA6IGh0dHBzOi8vd3d3LnplbmRldnMueHl6L2xlcy1ub3V2ZWF1eC1vYmpldHMtc2V0LWV0LW1hcC1lbi1qYXZhc2NyaXB0LWVzNi9cbiAgICAgIHNlbGYuX2dyb3VwRGlzcGxheXMgPSBuZXcgTWFwKCk7IC8vID09IGZyb20gZGF0YSBpbiB3ZWIgc2VydmljZXMgPSBbaWRdIGRpc3BsYXllZFxuICAgICAgLy8gQXR0ZW50aW9uLCBsYSBrZXkgZGUgbGEgbWFwIGVzdCB1bmUgc3RyaW5nLCBkb25jIGhhcyhpbnRlZ2VyKSBuZSBmb25jdGlvbm5lIHBhc1xuXG4gICAgICAvLyBQYWdlIGNhcGFiaWxpdGllc1xuICAgICAgc2VsZi5fdW5pcXVlbWFjaGluZSA9IGZhbHNlOyAvLyBpZ25vcmVkLCBvbmx5IGZvciBlcnJvciBtZXNzYWdlXG5cbiAgICAgIC8vIERPTSBkZWZhdWx0XG4gICAgICBzZWxmLl9kaWFsb2dQYWdlMSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGYuX2NhdGVnb3J5TGlzdCA9IHVuZGVmaW5lZDsgLy8gPT0gZ3JvdXAgc2VsZWN0aW9uXG5cbiAgICAgIHNlbGYuX2RpYWxvZ1BhZ2UyID0gdW5kZWZpbmVkO1xuICAgICAgLy8gTWFjaGluZSBzZWxlY3Rpb25cbiAgICAgIHNlbGYuX21hY2hpbmVzU2VhcmNoRGl2ID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZi5fbWFjaGluZXNMaXN0ID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZi5fbWFjaGluZXNMaXN0Q29udGFpbmVyID0gdW5kZWZpbmVkO1xuICAgICAgLy8gU2VsZWN0aW9uXG4gICAgICBzZWxmLl9zZWxlY3Rpb25UaXRsZSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGYuX3NlbGVjdGlvbkhlYWRlciA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGYuX3NlbGVjdGlvbkxpc3QgPSB1bmRlZmluZWQ7XG4gICAgICBzZWxmLl9zZWxlY3Rpb25MaXN0Q29udGFpbmVyID0gdW5kZWZpbmVkO1xuICAgICAgLy8gUHJldmlld1xuICAgICAgc2VsZi5fdXNlTWFjaGluZUJ1dHRvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGYuX3ByZXZpZXdIZWFkZXIgPSB1bmRlZmluZWQ7XG4gICAgICBzZWxmLl9wcmV2aWV3TGlzdCA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGYuX3ByZXZpZXdMaXN0Q29udGFpbmVyID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBFcnJvclxuICAgICAgc2VsZi5fbWVzc2FnZVNwYW4gPSB1bmRlZmluZWQ7XG4gICAgICAvLyBET00gOiBEaXNwbGF5IGluIG1haW4gcGFnZSwgcmlnaHQgcGFuZWwgY29uZmlnXG4gICAgICBzZWxmLl9lZGl0YnV0dG9uID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZi5fc3VtbWFyeSA9IHVuZGVmaW5lZDtcblxuICAgICAgc2VsZi5fZGlhbG9nSWQgPSB1bmRlZmluZWQ7XG4gICAgICBzZWxmLm1ldGhvZHMgPSB7XG4gICAgICAgICdjaGFuZ2VNYWNoaW5lU2VsZWN0aW9uJzogc2VsZi5jaGFuZ2VNYWNoaW5lU2VsZWN0aW9uLFxuICAgICAgICAvLywnZ2V0TWFjaGluZVNlbGVjdGlvbic6IHNlbGYuZ2V0TWFjaGluZVNlbGVjdGlvbixcbiAgICAgICAgJ2ZpbGxFeHRlcm5hbFN1bW1hcnlEaXNwbGF5Jzogc2VsZi5maWxsRXh0ZXJuYWxTdW1tYXJ5RGlzcGxheSxcbiAgICAgICAgJ2dldE1hY2hpbmVzQXJyYXknOiBzZWxmLmdldE1hY2hpbmVzQXJyYXksXG4gICAgICAgICdnZXRHcm91cHNBcnJheSc6IHNlbGYuZ2V0R3JvdXBzQXJyYXksXG4gICAgICAgICdnZXRNYWNoaW5lc1N0cmluZyc6IHNlbGYuZ2V0TWFjaGluZXNTdHJpbmcsXG4gICAgICAgICdnZXRHcm91cHNTdHJpbmcnOiBzZWxmLmdldEdyb3Vwc1N0cmluZ1xuXG4gICAgICB9O1xuXG4gICAgICBpZiAoIXRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2luLXJlcG9ydCcpKSB7XG4gICAgICAgIC8vIENsZWFuIG9sZCBzdG9yYWdlIDIwMjAtMTIgKGNhbiBiZSByZW1vdmVkIGxhdGVyKVxuICAgICAgICBwdWxzZUNvbmZpZy5zZXRHbG9iYWwodGhpcy5fY29uZmlnTWFjaGluZXMsICcnKTtcbiAgICAgICAgcHVsc2VDb25maWcuc2V0R2xvYmFsKHRoaXMuX2NvbmZpZ0dyb3VwcywgJycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkV2hlbkNvbm5lY3RlZE9uY2UgKGF0dHIsIG9sZFZhbCwgbmV3VmFsKSB7XG4gICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkV2hlbkNvbm5lY3RlZE9uY2UoYXR0ciwgb2xkVmFsLCBuZXdWYWwpO1xuICAgICAgc3dpdGNoIChhdHRyKSB7XG4gICAgICAgIC8vY2FzZSAnZW5hYmxlR3JvdXBzJzogLy8gUHJvYmFibHkgaW4gY29uZmlnIC0+IGFsd2F5c1xuICAgICAgICBjYXNlICd1bmlxdWUtbWFjaGluZSc6IHtcbiAgICAgICAgICB0aGlzLl91bmlxdWVtYWNoaW5lID0gKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3VuaXF1ZS1tYWNoaW5lJylcbiAgICAgICAgICAgICYmIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3VuaXF1ZS1tYWNoaW5lJykgPT0gJ3RydWUnKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH0gYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQYXJhbWV0ZXJzICgpIHtcbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgIH1cblxuICAgIGNsZWFySW5pdGlhbGl6YXRpb24gKCkge1xuICAgICAgJCh0aGlzLmVsZW1lbnQpLmVtcHR5KCk7XG5cbiAgICAgIHRoaXMuX2VkaXRidXR0b24gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9zdW1tYXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fbWVzc2FnZVNwYW4gPSB1bmRlZmluZWQ7XG5cbiAgICAgIHN1cGVyLmNsZWFySW5pdGlhbGl6YXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm4gdmFsdWUgaW5wdXQgLSBtYXliZSBkZWZpbmUgdGhpcyBmdW5jdGlvbiBpbiBhIGNvbW1vbiBsaWJcbiAgICBpbml0UGFyYW1Gb3JSZXBvcnQgKGRpdlRvRmlsbCwgbmFtZSwgcGFyYW1ldGVya2V5LCBkYXRhVHlwZSwgcGFyYW1ldGVyVHlwZSxcbiAgICAgIGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHJlcXVpcmVkLCBoaWRkZW4sIGhlbHB0ZXh0KSB7XG4gICAgICAkKGRpdlRvRmlsbCkuYWRkQ2xhc3MoJ3BhcmFtZXRlcicpO1xuICAgICAgJChkaXZUb0ZpbGwpLmFwcGVuZChcIjxpbnB1dCB0eXBlPSdoaWRkZW4nIGlkPSduYW1lJyB2YWx1ZT0nXCIgKyBuYW1lICsgXCInIC8+XCIpO1xuICAgICAgJChkaXZUb0ZpbGwpLmFwcGVuZChcIjxpbnB1dCB0eXBlPSdoaWRkZW4nIGlkPSdwYXJhbWV0ZXJrZXknIHZhbHVlPSdcIiArIHBhcmFtZXRlcmtleSArIFwiJyAvPlwiKTtcbiAgICAgICQoZGl2VG9GaWxsKS5hcHBlbmQoXCI8aW5wdXQgdHlwZT0naGlkZGVuJyBpZD0nZGVmYXVsdHZhbHVlJyB2YWx1ZT0nXCIgKyBkZWZhdWx0VmFsdWUgKyBcIicgLz5cIik7XG4gICAgICBsZXQgcmV0SW5wdXQgPSAkKFwiPGlucHV0IHR5cGU9J2hpZGRlbicgaWQ9J3ZhbHVlJyB2YWx1ZT0nXCIgKyB2YWx1ZSArIFwiJyAvPlwiKTtcbiAgICAgICQoZGl2VG9GaWxsKS5hcHBlbmQocmV0SW5wdXQpO1xuICAgICAgJChkaXZUb0ZpbGwpLmFwcGVuZChcIjxpbnB1dCB0eXBlPSdoaWRkZW4nIGlkPSdkYXRhdHlwZScgdmFsdWU9J1wiICsgZGF0YVR5cGUgKyBcIicgLz5cIik7XG4gICAgICAkKGRpdlRvRmlsbCkuYXBwZW5kKFwiPGlucHV0IHR5cGU9J2hpZGRlbicgaWQ9J3BhcmFtZXRlcnR5cGUnIHZhbHVlPSdcIiArIHBhcmFtZXRlclR5cGUgKyBcIicgLz5cIik7XG4gICAgICAkKGRpdlRvRmlsbCkuYXBwZW5kKFwiPGlucHV0IHR5cGU9J2hpZGRlbicgaWQ9J3JlcXVpcmVkJyB2YWx1ZT0nXCIgKyByZXF1aXJlZCArIFwiJyAvPlwiKTtcbiAgICAgICQoZGl2VG9GaWxsKS5hcHBlbmQoXCI8aW5wdXQgdHlwZT0naGlkZGVuJyBpZD0naGVscHRleHQnIHZhbHVlPSdcIiArIGhlbHB0ZXh0ICsgXCInIC8+XCIpO1xuICAgICAgJChkaXZUb0ZpbGwpLmFwcGVuZChcIjxpbnB1dCB0eXBlPSdoaWRkZW4nIGlkPSdoaWRkZW4nIHZhbHVlPSdcIiArIGhpZGRlbiArIFwiJyAvPlwiKTtcbiAgICAgIGlmIChwYXJhbWV0ZXJrZXkgPT0gJ1dFQkFQUCcpIHtcbiAgICAgICAgJChkaXZUb0ZpbGwpLmFwcGVuZChcIjxpbnB1dCB0eXBlPSdoaWRkZW4nIGlkPSd3aWRnZXQnIHZhbHVlPSdURVhUQk9YJyAvPlwiKTtcbiAgICAgICAgcmV0SW5wdXQgPSAkKFwiPGlucHV0IHR5cGU9J2hpZGRlbicgaWQ9J1wiICsgbmFtZSArIFwiX3ZhbHVlJyB2YWx1ZT0gLz5cIik7XG4gICAgICAgICQoZGl2VG9GaWxsKS5hcHBlbmQocmV0SW5wdXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldElucHV0O1xuICAgIH1cblxuICAgIC8vIENyZWF0aW9uIG9mIHRoZSBjb21wb25lbnQgKGVtcHR5KVxuICAgIGluaXRpYWxpemUgKCkge1xuICAgICAgdGhpcy5hZGRDbGFzcygncHVsc2UtdGV4dCcpOyAvLyBNYW5kYXRvcnkgZm9yIGxvYWRlclxuXG4gICAgICAvLyBQYXJhbWV0ZXJzXG4gICAgICB0aGlzLl91bmlxdWVtYWNoaW5lID1cbiAgICAgICAgKCd0cnVlJyA9PSB0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCd1bmlxdWUtbWFjaGluZScsICdmYWxzZScpKTtcblxuICAgICAgLy8gSW4gY2FzZSBvZiBjbG9uZSwgbmVlZCB0byBiZSBlbXB0eSA6XG4gICAgICAkKHRoaXMuZWxlbWVudCkuZW1wdHkoKTtcblxuICAgICAgLy8gQ3JlYXRlIERPTSAtIENvbnRlbnQgLSBCeSBkZWZhdWx0LCBidXR0b24gZW5hYmxlZFxuICAgICAgdGhpcy5fZWRpdGJ1dHRvbiA9ICQoJzxidXR0b24gdGl0bGU9XCJDaGFuZ2UgbWFjaGluZXNcIiByb2xlPVwiYnV0dG9uXCIgPjwvYnV0dG9uPicpXG4gICAgICAgIC5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1lZGl0YnV0dG9uJylcbiAgICAgICAgLmh0bWwoJ2VkaXQnKVxuICAgICAgICAuY2xpY2soXG4gICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYWNoaW5lU2VsZWN0aW9uKCk7XG4gICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgICk7XG4gICAgICB0aGlzLl9zdW1tYXJ5ID0gJCgnPGRpdj48L2Rpdj4nKVxuICAgICAgICAuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tc3VtbWFyeScpO1xuICAgICAgJCh0aGlzLmVsZW1lbnQpXG4gICAgICAgIC5hcHBlbmQodGhpcy5fZWRpdGJ1dHRvbikuYXBwZW5kKHRoaXMuX3N1bW1hcnkpO1xuXG4gICAgICAvLyBDcmVhdGUgRE9NIC0gTG9hZGVyXG4gICAgICBsZXQgbG9hZGVyID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygncHVsc2UtbG9hZGVyJykuaHRtbCgnTG9hZGluZy4uLicpLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICBsZXQgbG9hZGVyRGl2ID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygncHVsc2UtbG9hZGVyLWRpdicpLmFwcGVuZChsb2FkZXIpO1xuICAgICAgJCh0aGlzLmVsZW1lbnQpLmFwcGVuZChsb2FkZXJEaXYpO1xuICAgICAgLy8gQ3JlYXRlIERPTSAtIG1lc3NhZ2UgZm9yIGVycm9yXG4gICAgICB0aGlzLl9tZXNzYWdlU3BhbiA9ICQoJzxzcGFuPjwvc3Bhbj4nKVxuICAgICAgICAuYWRkQ2xhc3MoJ3B1bHNlLW1lc3NhZ2UnKS5odG1sKCcnKTtcbiAgICAgIGxldCBtZXNzYWdlRGl2ID0gJCgnPGRpdj48L2Rpdj4nKVxuICAgICAgICAuYWRkQ2xhc3MoJ3B1bHNlLW1lc3NhZ2UtZGl2JylcbiAgICAgICAgLmFwcGVuZCh0aGlzLl9tZXNzYWdlU3Bhbik7XG4gICAgICAkKHRoaXMuZWxlbWVudCkuYXBwZW5kKG1lc3NhZ2VEaXYpO1xuXG5cbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdpbi1yZXBvcnQnKSkge1xuICAgICAgICAvLyBIaWRkZW4gZGl2IGZvciByZXBvcnRcbiAgICAgICAgbGV0IHJlcG9ydERpdiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3B1bHNlLXJlcG9ydC1oaWRkZW4nKTtcbiAgICAgICAgJCh0aGlzLmVsZW1lbnQpLmFwcGVuZChyZXBvcnREaXYpO1xuXG4gICAgICAgIGxldCBncm91cFJlcG9ydERpdiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3B1bHNlLXJlcG9ydC1oaWRkZW4nKTtcbiAgICAgICAgdGhpcy5pbml0UGFyYW1Gb3JSZXBvcnQoZ3JvdXBSZXBvcnREaXYsXG4gICAgICAgICAgJ1B1bHNlR3JvdXBzJywgJ0dST1VQUE9TJywgLy8gbmFtZSwgcGFyYW1ldGVya2V5XG4gICAgICAgICAgJ1NUUklORycsIC8vIGRhdGFUeXBlID0gJ1NUUklORydcbiAgICAgICAgICAnU0lNUExFJywgJycsICcnLCAvLyAsIHBhcmFtZXRlclR5cGUsIGRlZmF1bHRWYWx1ZSwgdmFsdWUsIFxuICAgICAgICAgICdmYWxzZScsICdmYWxzZScsICcnKTsgLy8gcmVxdWlyZWQsIGhpZGRlbiwgaGVscHRleHRcbiAgICAgICAgcmVwb3J0RGl2LmFwcGVuZChncm91cFJlcG9ydERpdik7XG5cbiAgICAgICAgbGV0IG1hY2hpbmVSZXBvcnREaXYgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdwdWxzZS1yZXBvcnQtaGlkZGVuJyk7XG4gICAgICAgIHRoaXMuaW5pdFBhcmFtRm9yUmVwb3J0KG1hY2hpbmVSZXBvcnREaXYsXG4gICAgICAgICAgJ1B1bHNlTWFjaGluZXMnLCAnTUFDSElORVMnLCAvLyBub3QgJ01BQ0hJTkVQT1MnLCBiZWNhdXNlIG9mIGhpc3RvcnkgY29tcGF0aWJpbGl0eSAvLyBuYW1lLCBwYXJhbWV0ZXJrZXlcbiAgICAgICAgICAnU1RSSU5HJywgLy8gZGF0YVR5cGUgPSAnU1RSSU5HJ1xuICAgICAgICAgICdTSU1QTEUnLCAnJywgJycsIC8vIHBhcmFtZXRlclR5cGUsIGRlZmF1bHRWYWx1ZSwgdmFsdWUsIFxuICAgICAgICAgICdmYWxzZScsICdmYWxzZScsICcnKTsgLy8gcmVxdWlyZWQsIGhpZGRlbiwgaGVscHRleHRcbiAgICAgICAgcmVwb3J0RGl2LmFwcGVuZChtYWNoaW5lUmVwb3J0RGl2KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgZGlzcGxheUVycm9yIChtZXNzYWdlKSB7XG4gICAgICAvL3RoaXMuX2Rpc2FibGUobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcmxvYWQgdG8gYWx3YXlzIHJlZnJlc2ggdmFsdWVcbiAgICBnZXQgaXNWaXNpYmxlICgpIHtcbiAgICAgIC8vIFNpIHBhZ2UgbG9naW4gPSBIaWRkZW4gPSBEbyBub3QgY2FsbCB3ZWIgc2VydmljZVxuICAgICAgaWYgKHB1bHNlQ29uZmlnLmlzTG9naW5QYWdlKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gTm9ybWFsIGJlaGF2aW9yXG4gICAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkgeyAvLyA9PSBpcyBjb25uZWN0ZWRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBXZWIgU2VydmljZSBVUkwgaGVyZVxuICAgIGdldFNob3J0VXJsICgpIHtcbiAgICAgIGxldCB1cmwgPSAnTWFjaGluZS9Hcm91cHM/Wm9vbT10cnVlJk1hY2hpbmVMaXN0PXRydWUnO1xuICAgICAgLy8gTG9naW4gaXMgc2V0IGluIGdsb2JhbCBzZXJ2aWNlIGNhbGxcbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBjb21wb25lbnQgd2l0aCBkYXRhIHdoaWNoIGlzIHJldHVybmVkIGJ5IHRoZSB3ZWIgc2VydmljZSBpbiBjYXNlIG9mIHN1Y2Nlc3NcbiAgICByZWZyZXNoIChkYXRhKSB7XG4gICAgICAvLyBTdG9yZSBsaXN0cyBvZiBhdmFpbGFibGUgY2F0ZWdvcmllcyAoPWdyb3VwcylcbiAgICAgIHRoaXMuX2dyb3VwcyA9IGRhdGEuR3JvdXBDYXRlZ29yaWVzO1xuICAgICAgdGhpcy5fbWFjaGluZXNGcm9tU2VydmljZSA9IGRhdGEuTWFjaGluZUxpc3Q7XG4gICAgICB0aGlzLl9zdG9yZURpc3BsYXlzKCk7XG5cbiAgICAgIC8vIExvYWQgY3VycmVudCBzZWxlY3Rpb25zXG4gICAgICB0aGlzLl9sb2FkU2VsZWN0aW9uKCk7XG5cbiAgICAgIC8vIEZpbGwgY2F0ZWdvcmllcyBsaXN0IChsZWZ0IHBhbmVsKVxuICAgICAgdGhpcy5fZmlsbENhdGVnb3J5TGlzdCgpO1xuICAgICAgLy8gRmlsbCBzdW1tYXJ5XG4gICAgICB0aGlzLl9maWxsU3VtbWFyeURpc3BsYXkoKTtcblxuICAgICAgLy8gRmlsbCBsaXN0IG9mIG1hY2hpbmVzIFxuICAgICAgdGhpcy5fZmlsbE1hY2hpbmVzTGlzdCgpO1xuICAgIH0gLy8gZW5kIHJlZnJlc2hcblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIHB1YmxpYyBGVU5DVElPTlMgRk9SIFVQREFUSU5HIFRIRSBTRUxFQ1RJT04gPSBvcGVuIGRpYWxvZyAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGNoYW5nZU1hY2hpbmVTZWxlY3Rpb24gKCkge1xuICAgICAgdGhpcy5fY3JlYXRlRGlhbG9nSWZOb3REb25lKCk7XG5cbiAgICAgIC8vIG9wZW4gRGlhbG9nXG4gICAgICBpZiAodW5kZWZpbmVkID09IHRoaXMuX2RpYWxvZ0lkKVxuICAgICAgICByZXR1cm47XG4gICAgICBwdWxzZUN1c3RvbURpYWxvZy5vcGVuKHRoaXMuX2RpYWxvZ1BhZ2UxLCB0aGlzLl9kaWFsb2dJZCk7XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gRlVOQ1RJT05TIEZPUiBESUFMT0cgICAgICAgICAgICAgICAgIC8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgX2NyZWF0ZURpYWxvZ0lmTm90RG9uZSAoKSB7XG4gICAgICBpZiAodW5kZWZpbmVkICE9IHRoaXMuX2RpYWxvZ0lkKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vLy8vLy8vLy8gLy8vLy8vLy8vL1xuICAgICAgLy8gUGFnZSAxICAvLy8vLy8vLy8vXG4gICAgICB0aGlzLl9kaWFsb2dQYWdlMSA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVTZWxlY3Rpb25EaWFsb2dQYXJ0MScpO1xuICAgICAgbGV0IHBhZ2UxID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1wYWdlMScpO1xuICAgICAgdGhpcy5fZGlhbG9nUGFnZTEuYXBwZW5kKHBhZ2UxKTtcblxuICAgICAgLy8gRklSU1QgZGl2IC0gZm9yIGJ1dHRvbnMgQ0xFQVIgLSBTd2l0Y2ggdG8gbWFjaGllbiBzZWxlY3Rpb25cbiAgICAgIGxldCBkaXZfYnV0dG9ucyA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tYnV0dG9ucycpOyAvLyA9IG1haW5cbiAgICAgIC8vIEJ1dHRvbiBDTEVBUlxuICAgICAgdGhpcy5fY2xlYXJGaWx0ZXJzX2J1dHRvbiA9ICQoJzxidXR0b24+PC9idXR0b24+JylcbiAgICAgICAgLmFkZENsYXNzKCdtYWNoaW5lc2VsZWN0aW9uLWJ1dHRvbicpXG4gICAgICAgIC5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1jbGVhcmZpbHRlcnMnKS5odG1sKCdDTEVBUicpO1xuICAgICAgdGhpcy5fY2xlYXJGaWx0ZXJzX2J1dHRvbi5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyU2VsZWN0aW9uKCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgZGl2X2J1dHRvbnMuYXBwZW5kKHRoaXMuX2NsZWFyRmlsdGVyc19idXR0b24pO1xuICAgICAgLy8gQnV0dG9uIHN3aXRjaCB0byBncm91cCBvciBtYWNoaW5lIHNlbGVjdGlvbiAoID0gd2l0aCBlbXB0eSBzZWxlY3Rpb24pXG4gICAgICBsZXQgZGl2X3N3aXRjaF9idXR0b25zID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1zd2l0Y2gtZ3JvdXAtbWFjaGluZXMnKTtcbiAgICAgIC8vIEdcbiAgICAgIHRoaXMuX3N3aXRjaFRvR3JvdXBzX2J1dHRvbiA9ICQoJzxidXR0b24+PC9idXR0b24+JylcbiAgICAgICAgLmFkZENsYXNzKCdtYWNoaW5lc2VsZWN0aW9uLWJ1dHRvbicpXG4gICAgICAgIC5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1zd2l0Y2gtdG8tZ3JvdXBzJykuaHRtbCgnR1JPVVBTJyk7XG4gICAgICB0aGlzLl9zd2l0Y2hUb0dyb3Vwc19idXR0b24uY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9ncm91cFNlbGVjdGlvbkFycmF5ID0gW107XG4gICAgICAgIHRoaXMuX21hY2hpbmVTZWxlY3Rpb25BcnJheSA9IFtdO1xuICAgICAgICB0aGlzLl9zd2l0Y2hUb0dyb3VwU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVNlbGVjdGlvbkluQ2F0ZWdvcnlMaXN0KCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgZGl2X3N3aXRjaF9idXR0b25zLmFwcGVuZCh0aGlzLl9zd2l0Y2hUb0dyb3Vwc19idXR0b24pO1xuICAgICAgLy8gTVxuICAgICAgdGhpcy5fc3dpdGNoVG9NYWNoaW5lc19idXR0b24gPSAkKCc8YnV0dG9uPjwvYnV0dG9uPicpXG4gICAgICAgIC5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1idXR0b24nKVxuICAgICAgICAuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tc3dpdGNoLXRvLW1hY2hpbmVzJykuaHRtbCgnTUFDSElORVMnKTtcbiAgICAgIHRoaXMuX3N3aXRjaFRvTWFjaGluZXNfYnV0dG9uLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3Rpb25BcnJheSA9IFtdO1xuICAgICAgICB0aGlzLl9tYWNoaW5lU2VsZWN0aW9uQXJyYXkgPSBbXTtcbiAgICAgICAgdGhpcy5fc3dpdGNoVG9NYWNoaW5lU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuX2NoYW5nZVNlbGVjdGlvbkluTWFjaGluZUxpc3QoKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICBkaXZfc3dpdGNoX2J1dHRvbnMuYXBwZW5kKHRoaXMuX3N3aXRjaFRvTWFjaGluZXNfYnV0dG9uKTtcbiAgICAgIC8vIGFwcGVuZCBidXR0b25zXG4gICAgICBkaXZfYnV0dG9ucy5hcHBlbmQoZGl2X3N3aXRjaF9idXR0b25zKTtcbiAgICAgIHBhZ2UxLmFwcGVuZChkaXZfYnV0dG9ucyk7XG4gICAgICAvLyBFTkQgLSBGSVJTVCBkaXYgLSBmb3IgYnV0dG9uc1xuXG4gICAgICAvLyBHUk9VUFNcbiAgICAgIHRoaXMuX2NhdGVnb3J5TGlzdCA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tY2F0ZWdvcnlsaXN0Jyk7XG4gICAgICBwYWdlMS5hcHBlbmQodGhpcy5fY2F0ZWdvcnlMaXN0KTtcblxuICAgICAgLy8gTUFDSElORVNcbiAgICAgIHRoaXMuX21hY2hpbmVzTGlzdCA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tbWFjaGluZXMtbGlzdCcpO1xuICAgICAgdGhpcy5fbWFjaGluZXNMaXN0Q29udGFpbmVyID0gJCgnPGRpdj48L2Rpdj4nKVxuICAgICAgICAuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tbWFjaGluZXMtbGlzdC1jb250YWluZXInKSAvLyBGb3Igc2Nyb2xsXG4gICAgICAgIC5hcHBlbmQodGhpcy5fbWFjaGluZXNMaXN0KTtcblxuICAgICAgdGhpcy5fbWFjaGluZXNTZWFyY2hEaXYgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdtYWNoaW5lc2VsZWN0aW9uLW1hY2hpbmVzLXNlYXJjaC1kaXYnKTtcblxuICAgICAgdGhpcy5fY2xlYXJTZWFyY2hCdXR0b24gPSAkKCc8YnV0dG9uIHRpdGxlPVwiQ2xlYXIgc2VhcmNoXCIgcm9sZT1cImJ1dHRvblwiPjwvYnV0dG9uPicpXG4gICAgICAgIC5hZGRDbGFzcygnYnV0dG9uRGlhbG9nJylcbiAgICAgICAgLmFkZENsYXNzKCdtYWNoaW5lc2VsZWN0aW9uLWNsZWFyLXNlYXJjaCcpO1xuICAgICAgdGhpcy5fbWFjaGluZXNTZWFyY2hEaXYuYXBwZW5kKHRoaXMuX2NsZWFyU2VhcmNoQnV0dG9uKTtcblxuICAgICAgdGhpcy5faW5wdXRTZWFyY2ggPSAkKCc8aW5wdXQ+PC9pbnB1dD4nKS5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1tYWNoaW5lcy1zZWFyY2gtaW5wdXQnKVxuICAgICAgICAuYXR0cigndHlwZScsICd0ZXh0JykuYXR0cigncGxhY2Vob2xkZXInLCAnU2VhcmNoLi4uJyk7XG4gICAgICAvKmxldCBzcGFuU2VhcmNoID0gJCgnPHNwYW4+PC9zcGFuPicpLmFkZENsYXNzKCdtYWNoaW5lc2VsZWN0aW9uLW1hY2hpbmVzLXNlYXJjaC1zcGFuJylcbiAgICAgICAgLmFwcGVuZCh0aGlzLl9pbnB1dFNlYXJjaCk7Ki9cbiAgICAgIHRoaXMuX21hY2hpbmVzU2VhcmNoRGl2LmFwcGVuZCh0aGlzLl9pbnB1dFNlYXJjaCk7XG5cbiAgICAgIC8vIEZJTEwgbXVzdCBiZSBvbmUgQUZURVIgZGlhbG9nIGNyZWF0aW9uIHRvIGRpc3BsYXkgaWNvbnMgXG4gICAgICAvL3RoaXMuX2ZpbGxNYWNoaW5lc0xpc3QoKTtcblxuICAgICAgcGFnZTEuYXBwZW5kKHRoaXMuX21hY2hpbmVzTGlzdENvbnRhaW5lcikuYXBwZW5kKHRoaXMuX21hY2hpbmVzU2VhcmNoRGl2KTtcblxuICAgICAgLy8gVXNlIGZpbHRlclxuICAgICAgJCh0aGlzLl9pbnB1dFNlYXJjaCkub24oJ2lucHV0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zaG93SGlkZU1hY2hpbmVzSW5MaXN0KCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAvLyBDbGVhciBmaWx0ZXJcbiAgICAgICQodGhpcy5fY2xlYXJTZWFyY2hCdXR0b24pLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCh0aGlzLl9pbnB1dFNlYXJjaCkudmFsKCcnKTtcbiAgICAgICAgdGhpcy5fc2hvd0hpZGVNYWNoaW5lc0luTGlzdCgpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcblxuXG4gICAgICAvLy8vLy8vLy8vIC8vLy8vLy8vLy9cbiAgICAgIC8vIFBhZ2UgMiAgLy8vLy8vLy8vL1xuICAgICAgdGhpcy5fZGlhbG9nUGFnZTIgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdtYWNoaW5lU2VsZWN0aW9uRGlhbG9nUGFydDInKTtcbiAgICAgIGxldCBwYWdlMiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tcGFnZTInKTtcbiAgICAgIHRoaXMuX2RpYWxvZ1BhZ2UyLmFwcGVuZChwYWdlMik7XG5cbiAgICAgIC8vIFNFTEVDVElPTlxuICAgICAgdGhpcy5fc2VsZWN0aW9uVGl0bGUgPSAkKCc8c3Bhbj48L3NwYW4+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tdGl0bGUnKVxuICAgICAgICAuaHRtbCgnU2VsZWN0ZWQnKTtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkhlYWRlciA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tc2VsZWN0aW9uLWhlYWRlcicpXG4gICAgICAgIC5hcHBlbmQodGhpcy5fc2VsZWN0aW9uVGl0bGUpO1xuICAgICAgdGhpcy5fc2VsZWN0aW9uTGlzdCA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tc2VsZWN0aW9uLWxpc3QnKTtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkxpc3RDb250YWluZXIgPSAkKCc8ZGl2PjwvZGl2PicpXG4gICAgICAgIC5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1zZWxlY3Rpb24tbGlzdC1jb250YWluZXInKSAvLyBGb3Igc2Nyb2xsXG4gICAgICAgIC5hcHBlbmQodGhpcy5fc2VsZWN0aW9uTGlzdCk7XG5cbiAgICAgIHBhZ2UyLmFwcGVuZCh0aGlzLl9zZWxlY3Rpb25IZWFkZXIpLmFwcGVuZCh0aGlzLl9zZWxlY3Rpb25MaXN0Q29udGFpbmVyKTtcblxuICAgICAgLy8gUFJFVklFV1xuICAgICAgbGV0IHByZXZpZXdUaXRsZSA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1wcmV2aWV3LXRpdGxlJylcbiAgICAgICAgLmh0bWwoJ3ByZXZpZXcgbWFjaGluZXMnKTtcbiAgICAgIHRoaXMuX2ZyZWVUZXh0TGFzdFVwZGF0ZSA9IHB1bHNlVXRpbGl0eS5jcmVhdGVqUXVlcnlFbGVtZW50V2l0aEF0dHJpYnV0ZSgneC1mcmVldGV4dCcsIHtcbiAgICAgICAgJ3RleHRjaGFuZ2UtY29udGV4dCc6ICdtYWNoaW5lc2VsZWN0aW9uJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLl91c2VNYWNoaW5lQnV0dG9uID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi11c2VtYWNoaW5lcy1idXR0b24nKVxuICAgICAgICAuYXR0cigndGl0bGUnLCAnU3dpdGNoIHRvIG1hY2hpbmUgc2VsZWN0aW9uJyk7XG4gICAgICB0aGlzLl9wcmV2aWV3SGVhZGVyID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1wcmV2aWV3LWhlYWRlcicpXG4gICAgICAgIC5hcHBlbmQocHJldmlld1RpdGxlKS5hcHBlbmQodGhpcy5fZnJlZVRleHRMYXN0VXBkYXRlKS5hcHBlbmQodGhpcy5fdXNlTWFjaGluZUJ1dHRvbik7XG4gICAgICB0aGlzLl9wcmV2aWV3TGlzdCA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tcHJldmlldy1saXN0Jyk7XG4gICAgICB0aGlzLl9wcmV2aWV3TGlzdENvbnRhaW5lciA9ICQoJzxkaXY+PC9kaXY+JylcbiAgICAgICAgLmFkZENsYXNzKCdtYWNoaW5lc2VsZWN0aW9uLXByZXZpZXctbGlzdC1jb250YWluZXInKSAvLyBGb3Igc2Nyb2xsXG4gICAgICAgIC5hcHBlbmQodGhpcy5fcHJldmlld0xpc3QpO1xuXG4gICAgICBwYWdlMi5hcHBlbmQodGhpcy5fcHJldmlld0hlYWRlcikuYXBwZW5kKHRoaXMuX3ByZXZpZXdMaXN0Q29udGFpbmVyKTtcblxuICAgICAgcHVsc2VTdmcuaW5saW5lQmFja2dyb3VuZFN2Zyh0aGlzLl91c2VNYWNoaW5lQnV0dG9uKTtcblxuICAgICAgdGhpcy5fdXNlTWFjaGluZUJ1dHRvbi5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBncm91cGFycmF5cyA9ICQodGhpcy5fcHJldmlld0xpc3QpLmZpbmQoJ3gtZ3JvdXBhcnJheScpO1xuICAgICAgICBpZiAoZ3JvdXBhcnJheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBtYWNoaW5lc0xpc3QgPSBncm91cGFycmF5c1swXS5nZXRNYWNoaW5lc0xpc3QoKTtcbiAgICAgICAgICAvL3RoaXMuX2dyb3VwU2VsZWN0aW9uQXJyYXkgPSBtYWNoaW5lc0xpc3Quc3BsaXQoJywnKTsgLy8gd2FzIFtdO1xuICAgICAgICAgIHRoaXMuX21hY2hpbmVTZWxlY3Rpb25BcnJheSA9IG1hY2hpbmVzTGlzdC5zcGxpdCgnLCcpO1xuICAgICAgICAgIC8vIENoYW5nZSBzZWxlY3Rpb24gb24gbGVmdCBkaXNwbGF5XG4gICAgICAgICAgdGhpcy5fY2hhbmdlU2VsZWN0aW9uSW5NYWNoaW5lTGlzdCgpO1xuICAgICAgICAgIC8vdGhpcy5fY2hhbmdlU2VsZWN0aW9uSW5DYXRlZ29yeUxpc3QoKTtcblxuICAgICAgICAgIC8vdGhpcy5fZmlsbFNlbGVjdGlvbigpOyA9PSBkb25lIGluIF9zd2l0Y2hUb01hY2hpbmVTZWxlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zd2l0Y2hUb01hY2hpbmVTZWxlY3Rpb24oKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgIHRoaXMuX2ZpbGxDYXRlZ29yeUxpc3QoKTtcblxuICAgICAgLy8gQ3JlYXRlIGEgZGlhbG9nXG4gICAgICB0aGlzLl9kaWFsb2dJZCA9IHB1bHNlQ3VzdG9tRGlhbG9nLmluaXRpYWxpemUodGhpcy5fZGlhbG9nUGFnZTEsIHtcbiAgICAgICAgdGl0bGU6IHRoaXMuX3VuaXF1ZW1hY2hpbmUgPyAnU2VsZWN0IGEgbWFjaGluZScgOiAnU2VsZWN0IG1hY2hpbmVzJyxcbiAgICAgICAgYXV0b0Nsb3NlOiBmYWxzZSxcbiAgICAgICAgb25PcGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gUmVpbml0aWFsaXplIHNlbGVjdGlvbiBhbmQgdmlld1xuICAgICAgICAgIC8vIElmIGl0IGNhbiBiZSBjaGFuZ2VkIGFueXdoZXJlIGVsc2UgOlxuICAgICAgICAgIC8vIExvYWQgY3VycmVudCBzZWxlY3Rpb25zXG4gICAgICAgICAgdGhpcy5fbG9hZFNlbGVjdGlvbigpO1xuXG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgb25PazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGlzLl91c2VNYWNoaW5lU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWFjaGluZVNlbGVjdGlvbkFycmF5Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIHB1bHNlQ3VzdG9tRGlhbG9nLm9wZW5FcnJvcihcbiAgICAgICAgICAgICAgICB0aGlzLl91bmlxdWVtYWNoaW5lXG4gICAgICAgICAgICAgICAgICA/ICdQbGVhc2Ugc2VsZWN0IG9uZSBtYWNoaW5lLidcbiAgICAgICAgICAgICAgICAgIDogJ1BsZWFzZSBzZWxlY3QgYXQgbGVhc3Qgb25lIG1hY2hpbmUuJyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZ3JvdXBTZWxlY3Rpb25BcnJheS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICBwdWxzZUN1c3RvbURpYWxvZy5vcGVuRXJyb3IoXG4gICAgICAgICAgICAgICAgJ1BsZWFzZSBzZWxlY3QgYXQgbGVhc3Qgb25lIGdyb3VwJyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmICdubyBtYWNoaW5lJyBpbiBzdGF0aWMgZ3JvdXBzXG4gICAgICAgICAgICBpZiAoJCh0aGlzLl9wcmV2aWV3TGlzdCkuZmluZCgnLm5vLW1hY2hpbmVzJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBGaW5kIGlmIHN0YXRpYyBvbmx5XG4gICAgICAgICAgICAgIGxldCBzdGF0aWNPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaUdyb3VwID0gMDsgaUdyb3VwIDwgdGhpcy5fZ3JvdXBTZWxlY3Rpb25BcnJheS5sZW5ndGg7IGlHcm91cCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwSWQgPSB0aGlzLl9ncm91cFNlbGVjdGlvbkFycmF5W2lHcm91cF0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZ3JvdXBEaXNwbGF5cy5oYXMoZ3JvdXBJZCkpIHtcbiAgICAgICAgICAgICAgICAgIGxldCBkaXNwbGF5Q2xhc3MgPSB0aGlzLl9ncm91cERpc3BsYXlzLmdldChncm91cElkKTtcbiAgICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5Q2xhc3MuZHluYW1pYylcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljT25seSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSAvLyBlbmQgZm9yXG5cbiAgICAgICAgICAgICAgaWYgKHN0YXRpY09ubHkpIHtcbiAgICAgICAgICAgICAgICBwdWxzZUN1c3RvbURpYWxvZy5vcGVuRXJyb3IoXG4gICAgICAgICAgICAgICAgICAnUGxlYXNlIHNlbGVjdCBncm91cHMgaW5jbHVkaW5nIGF0IGxlYXN0IG9uZSBtYWNoaW5lLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTdG9yZSB0aGUgbmV3IGRpc3BsYXllZCBwYXJhbWV0ZXJzIGluIENPTkZJR1xuICAgICAgICAgIHRoaXMuX3N0b3JlU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgc3VtbWFyeSBmcm9tIHNlbGVjdGlvblxuICAgICAgICAgIHRoaXMuX2ZpbGxTdW1tYXJ5RGlzcGxheSgpO1xuXG4gICAgICAgICAgcHVsc2VDdXN0b21EaWFsb2cuY2xvc2UodGhpcy5fZGlhbG9nUGFnZTEpO1xuICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgIG9uQ2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHVsc2VDdXN0b21EaWFsb2cuY2xvc2UodGhpcy5fZGlhbG9nUGFnZTEpO1xuICAgICAgICB9LmJpbmQodGhpcyksXG4gICAgICAgIGZ1bGxTY3JlZW5PblNtYXJ0cGhvbmU6IHRydWUsXG4gICAgICAgIGZpeGVkSGVpZ2h0OiB0cnVlLFxuICAgICAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICAgICAgaGVscE5hbWU6ICdtYWNoaW5lc2VsZWN0aW9uJ1xuICAgICAgfSk7XG4gICAgICBwdWxzZUN1c3RvbURpYWxvZy5hZGRQYWdlKHRoaXMuX2RpYWxvZ1BhZ2UxLCB0aGlzLl9kaWFsb2dQYWdlMik7XG4gICAgICAvLyB0aGlzLl9hZGREcmFnQW5kRHJvcEV2ZW50cygpOyBOby4gTm90IGhlcmUgIVxuXG4gICAgICAvLyBGSUxMIG11c3QgYmUgb25lIEFGVEVSIGRpYWxvZyBjcmVhdGlvbiB0byBkaXNwbGF5IGljb25zIFxuICAgICAgdGhpcy5fZmlsbE1hY2hpbmVzTGlzdCgpO1xuXG4gICAgICAvLyBEZWZhdWx0ID0gdXNlR3JvdXBTZWxlY3Rpb24gLT4gbGlzdCBvZiBtYWNoaW5lcyA9PSBoaWRkZW5cbiAgICAgIHRoaXMuX3N3aXRjaFRvR3JvdXBTZWxlY3Rpb24oKTtcbiAgICB9XG5cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFRvZ2dsZSBiZXR3ZWVuIG1hY2hpbmUgYW5kIGdyb3VwIHNlbGVjdGlvbiAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIF9zd2l0Y2hUb01hY2hpbmVTZWxlY3Rpb24gKCkge1xuICAgICAgdGhpcy5fdXNlTWFjaGluZVNlbGVjdGlvbiA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLl9tYWNoaW5lc0xpc3RDb250YWluZXIgPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl9wcmV2aWV3SGVhZGVyLmhpZGUoKTtcbiAgICAgIHRoaXMuX3ByZXZpZXdMaXN0Q29udGFpbmVyLmhpZGUoKTtcblxuICAgICAgdGhpcy5fc2VsZWN0aW9uVGl0bGUuaHRtbCgnU2VsZWN0ZWQgbWFjaGluZXMnKTtcblxuICAgICAgdGhpcy5fbWFjaGluZXNTZWFyY2hEaXYuc2hvdygpO1xuICAgICAgdGhpcy5fbWFjaGluZXNMaXN0Q29udGFpbmVyLnNob3coKTtcblxuICAgICAgdGhpcy5fZ3JvdXBTZWxlY3Rpb25BcnJheSA9IFtdOyAvLyBDTEVBUiBHUk9VUFMgIVxuICAgICAgLy8gVXBkYXRlIGNoZWNrIGJveGVzIGluIGxlZnQgcGFuZWwgaW5jbHVkaW5nIF9maWxsU2VsZWN0aW9uLCBpbmNsdWRpbmcgQ2xlYXIgcHJldmlld1xuICAgICAgdGhpcy5fY2hhbmdlU2VsZWN0aW9uSW5DYXRlZ29yeUxpc3QoKTtcbiAgICAgIHRoaXMuX2NhdGVnb3J5TGlzdC5oaWRlKCk7XG5cbiAgICAgIHRoaXMuX2NoYW5nZVNlbGVjdGlvbkluTWFjaGluZUxpc3QoKTtcblxuICAgICAgdGhpcy5fc3dpdGNoVG9NYWNoaW5lc19idXR0b24uYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICB0aGlzLl9zd2l0Y2hUb0dyb3Vwc19idXR0b24ucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICB0aGlzLl9zd2l0Y2hUb01hY2hpbmVzX2J1dHRvbi5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgICAgdGhpcy5fc3dpdGNoVG9Hcm91cHNfYnV0dG9uLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgIH1cblxuICAgIF9zd2l0Y2hUb0dyb3VwU2VsZWN0aW9uICgpIHtcbiAgICAgIHRoaXMuX3VzZU1hY2hpbmVTZWxlY3Rpb24gPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuX21hY2hpbmVzTGlzdENvbnRhaW5lciA9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX3ByZXZpZXdIZWFkZXIuc2hvdygpO1xuICAgICAgdGhpcy5fcHJldmlld0xpc3RDb250YWluZXIuc2hvdygpO1xuXG4gICAgICB0aGlzLl9zZWxlY3Rpb25UaXRsZS5odG1sKCdTZWxlY3RlZCBncm91cHMnKTtcblxuICAgICAgdGhpcy5fbWFjaGluZXNTZWFyY2hEaXYuaGlkZSgpO1xuICAgICAgdGhpcy5fbWFjaGluZXNMaXN0Q29udGFpbmVyLmhpZGUoKTtcblxuICAgICAgdGhpcy5fY2F0ZWdvcnlMaXN0LnNob3coKTtcblxuICAgICAgdGhpcy5fc3dpdGNoVG9NYWNoaW5lc19idXR0b24ucmVtb3ZlQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICB0aGlzLl9zd2l0Y2hUb0dyb3Vwc19idXR0b24uYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICB0aGlzLl9zd2l0Y2hUb01hY2hpbmVzX2J1dHRvbi5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgIHRoaXMuX3N3aXRjaFRvR3JvdXBzX2J1dHRvbi5wcm9wKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBBREQgRVZFTlRTIC8vXG4gICAgLy8vLy8vLy8vLy8vLy8vL1xuICAgIF9hZGRNb3ZlVXBEb3duRXZlbnRzICgpIHtcbiAgICAgIHZhciBtYWNoaW5lc2VsZWN0aW9uID0gdGhpcztcblxuICAgICAgJCh0aGlzLl9zZWxlY3Rpb25MaXN0KS5maW5kKCcucmVvcmRlckRvd25CdXR0b24nKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICQodGhpcykucGFyZW50KCcubWFjaGluZXNlbGVjdGlvbi1zZWxlY3Rpb24nKTtcbiAgICAgICAgbGV0IGRyYWdnZWRPcmRlciA9IHBhcnNlSW50KCQodGhpcykucGFyZW50KCkucGFyZW50KCkuY3NzKCdvcmRlcicpKTtcbiAgICAgICAgbGV0IG5ld09yZGVyID0gZHJhZ2dlZE9yZGVyICsgMTtcblxuICAgICAgICBpZiAobWFjaGluZXNlbGVjdGlvbi5fdXNlTWFjaGluZVNlbGVjdGlvbikge1xuICAgICAgICAgIGlmIChtYWNoaW5lc2VsZWN0aW9uLl9tYWNoaW5lU2VsZWN0aW9uQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IG1vdmVkSXRlbSA9IG1hY2hpbmVzZWxlY3Rpb24uX21hY2hpbmVTZWxlY3Rpb25BcnJheVtkcmFnZ2VkT3JkZXJdO1xuICAgICAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fbWFjaGluZVNlbGVjdGlvbkFycmF5LnNwbGljZShkcmFnZ2VkT3JkZXIsIDEpO1xuICAgICAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fbWFjaGluZVNlbGVjdGlvbkFycmF5LnNwbGljZShuZXdPcmRlciwgMCwgbW92ZWRJdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKG1hY2hpbmVzZWxlY3Rpb24uX2dyb3VwU2VsZWN0aW9uQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IG1vdmVkSXRlbSA9IG1hY2hpbmVzZWxlY3Rpb24uX2dyb3VwU2VsZWN0aW9uQXJyYXlbZHJhZ2dlZE9yZGVyXTtcbiAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX2dyb3VwU2VsZWN0aW9uQXJyYXkuc3BsaWNlKGRyYWdnZWRPcmRlciwgMSk7XG4gICAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl9ncm91cFNlbGVjdGlvbkFycmF5LnNwbGljZShuZXdPcmRlciwgMCwgbW92ZWRJdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hhbmdlIG9yZGVyIGluIGRpc3BsYXlcbiAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fZmlsbFNlbGVjdGlvbigpO1xuICAgICAgfSk7XG5cbiAgICAgICQodGhpcy5fc2VsZWN0aW9uTGlzdCkuZmluZCgnLnJlb3JkZXJVcEJ1dHRvbicpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IGRyYWdnZWRPcmRlciA9IHBhcnNlSW50KCQodGhpcykucGFyZW50KCkucGFyZW50KCkuY3NzKCdvcmRlcicpKTtcbiAgICAgICAgbGV0IG5ld09yZGVyID0gZHJhZ2dlZE9yZGVyIC0gMTtcblxuICAgICAgICBpZiAobWFjaGluZXNlbGVjdGlvbi5fdXNlTWFjaGluZVNlbGVjdGlvbikge1xuICAgICAgICAgIGlmIChtYWNoaW5lc2VsZWN0aW9uLl9tYWNoaW5lU2VsZWN0aW9uQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IG1vdmVkSXRlbSA9IG1hY2hpbmVzZWxlY3Rpb24uX21hY2hpbmVTZWxlY3Rpb25BcnJheVtkcmFnZ2VkT3JkZXJdO1xuICAgICAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fbWFjaGluZVNlbGVjdGlvbkFycmF5LnNwbGljZShkcmFnZ2VkT3JkZXIsIDEpO1xuICAgICAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fbWFjaGluZVNlbGVjdGlvbkFycmF5LnNwbGljZShuZXdPcmRlciwgMCwgbW92ZWRJdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKG1hY2hpbmVzZWxlY3Rpb24uX2dyb3VwU2VsZWN0aW9uQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IG1vdmVkSXRlbSA9IG1hY2hpbmVzZWxlY3Rpb24uX2dyb3VwU2VsZWN0aW9uQXJyYXlbZHJhZ2dlZE9yZGVyXTtcbiAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX2dyb3VwU2VsZWN0aW9uQXJyYXkuc3BsaWNlKGRyYWdnZWRPcmRlciwgMSk7XG4gICAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl9ncm91cFNlbGVjdGlvbkFycmF5LnNwbGljZShuZXdPcmRlciwgMCwgbW92ZWRJdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hhbmdlIG9yZGVyIGluIGRpc3BsYXlcbiAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fZmlsbFNlbGVjdGlvbigpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2FkZERyYWdBbmREcm9wRXZlbnRzICgpIHtcbiAgICAgIHZhciBtYWNoaW5lc2VsZWN0aW9uID0gdGhpcztcbiAgICAgIHZhciBkcmFnU3JjRWwgPSBudWxsO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVEcmFnU3RhcnQgKGUpIHtcbiAgICAgICAgLy8gVGFyZ2V0ICh0aGlzKSBlbGVtZW50IGlzIHRoZSBzb3VyY2Ugbm9kZS5cbiAgICAgICAgZHJhZ1NyY0VsID0gdGhpcztcblxuICAgICAgICBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gJ21vdmUnO1xuICAgICAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKCd0ZXh0L2h0bWwnLCB0aGlzLm91dGVySFRNTCk7XG5cbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdkcmFnRWxlbScpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaGFuZGxlRHJhZ092ZXIgKGUpIHtcbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIE5lY2Vzc2FyeS4gQWxsb3dzIHVzIHRvIGRyb3AuXG4gICAgICAgIH1cbiAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJzsgIC8vIFNlZSB0aGUgc2VjdGlvbiBvbiB0aGUgRGF0YVRyYW5zZmVyIG9iamVjdC5cblxuICAgICAgICBpZiAoZS5jbGllbnRZIC0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgPCB0aGlzLmNsaWVudEhlaWdodCAvIDIpIHtcbiAgICAgICAgICAvLyBJbnNlcnQgYWJvdmVcbiAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdPdmVyQm90dG9tJyk7XG4gICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdkcmFnT3ZlclRvcCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIEluc2VydCBiZWxvd1xuICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ092ZXJUb3AnKTtcbiAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2RyYWdPdmVyQm90dG9tJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVEcmFnRW50ZXIgKGUpIHtcbiAgICAgICAgLy8gdGhpcyAvIGUudGFyZ2V0IGlzIHRoZSBjdXJyZW50IGhvdmVyIHRhcmdldC5cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlRHJhZ0xlYXZlIChlKSB7XG4gICAgICAgIC8vIHRoaXMgLyBlLnRhcmdldCBpcyBwcmV2aW91cyB0YXJnZXQgZWxlbWVudC5cbiAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdkcmFnT3ZlclRvcCcpO1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdPdmVyQm90dG9tJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZURyb3AgKGUpIHtcbiAgICAgICAgLy8gdGhpcy9lLnRhcmdldCBpcyBjdXJyZW50IHRhcmdldCBlbGVtZW50LlxuXG4gICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIFN0b3BzIHNvbWUgYnJvd3NlcnMgZnJvbSByZWRpcmVjdGluZy5cbiAgICAgICAgfVxuICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBkcm9wcGluZyB0aGUgc2FtZSBjb2x1bW4gd2UncmUgZHJhZ2dpbmcuXG4gICAgICAgIGlmIChkcmFnU3JjRWwgIT0gdGhpcykge1xuICAgICAgICAgIGxldCBkcmFnZ2VkT3JkZXIgPSBwYXJzZUludCgkKGRyYWdTcmNFbCkuY3NzKCdvcmRlcicpKTtcbiAgICAgICAgICBsZXQgZHJhZ1RvVG9wT3JkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbGV0IGRyYWdUb0JvdHRvbU9yZGVyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgbGV0IHRvVG9wID0gJCh0aGlzKS5oYXNDbGFzcygnZHJhZ092ZXJUb3AnKTtcbiAgICAgICAgICBpZiAodG9Ub3ApIHtcbiAgICAgICAgICAgIGRyYWdUb1RvcE9yZGVyID0gcGFyc2VJbnQoJCh0aGlzKS5jc3MoJ29yZGVyJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgdG9Cb3R0b20gPSAkKHRoaXMpLmhhc0NsYXNzKCdkcmFnT3ZlckJvdHRvbScpO1xuICAgICAgICAgIGlmICh0b0JvdHRvbSkge1xuICAgICAgICAgICAgZHJhZ1RvQm90dG9tT3JkZXIgPSBwYXJzZUludCgkKHRoaXMpLmNzcygnb3JkZXInKSk7XG4gICAgICAgICAgICBpZiAoZHJhZ1RvVG9wT3JkZXIgPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICBkcmFnVG9Ub3BPcmRlciA9IGRyYWdUb0JvdHRvbU9yZGVyICsgMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZHJhZ1RvVG9wT3JkZXIgPT0gdW5kZWZpbmVkICYmIGRyYWdUb0JvdHRvbU9yZGVyID09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjsgLy8gTmV2ZXJcblxuICAgICAgICAgIC8vIENoZWNrIHRvcCAvIGJvdHRvbSAmIHVuaWZ5XG4gICAgICAgICAgbGV0IG5ld09yZGVyO1xuICAgICAgICAgIGlmIChkcmFnVG9Ub3BPcmRlciA8IGRyYWdnZWRPcmRlcikgeyAvLyBNb3ZlIHRvIFRvcFxuICAgICAgICAgICAgbmV3T3JkZXIgPSBkcmFnVG9Ub3BPcmRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7IC8vIE1vdmUgVG8gQm90dG9tXG4gICAgICAgICAgICBuZXdPcmRlciA9IHBhcnNlSW50KGRyYWdUb1RvcE9yZGVyKSAtIDE7IC8vZHJhZ1RvQm90dG9tT3JkZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYWNoaW5lc2VsZWN0aW9uLl91c2VNYWNoaW5lU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAobWFjaGluZXNlbGVjdGlvbi5fbWFjaGluZVNlbGVjdGlvbkFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgbGV0IG1vdmVkSXRlbSA9IG1hY2hpbmVzZWxlY3Rpb24uX21hY2hpbmVTZWxlY3Rpb25BcnJheVtkcmFnZ2VkT3JkZXJdO1xuICAgICAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl9tYWNoaW5lU2VsZWN0aW9uQXJyYXkuc3BsaWNlKGRyYWdnZWRPcmRlciwgMSk7XG4gICAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX21hY2hpbmVTZWxlY3Rpb25BcnJheS5zcGxpY2UobmV3T3JkZXIsIDAsIG1vdmVkSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1hY2hpbmVzZWxlY3Rpb24uX2dyb3VwU2VsZWN0aW9uQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBsZXQgbW92ZWRJdGVtID0gbWFjaGluZXNlbGVjdGlvbi5fZ3JvdXBTZWxlY3Rpb25BcnJheVtkcmFnZ2VkT3JkZXJdO1xuICAgICAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl9ncm91cFNlbGVjdGlvbkFycmF5LnNwbGljZShkcmFnZ2VkT3JkZXIsIDEpO1xuICAgICAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl9ncm91cFNlbGVjdGlvbkFycmF5LnNwbGljZShuZXdPcmRlciwgMCwgbW92ZWRJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ2hhbmdlIG9yZGVyIGluIGRpc3BsYXlcbiAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl9maWxsU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3RoaXMuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ092ZXJUb3AnKTtcbiAgICAgICAgLy90aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdPdmVyQm90dG9tJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlRHJhZ0VuZCAoZSkge1xuICAgICAgICAvLyB0aGlzL2UudGFyZ2V0IGlzIHRoZSBzb3VyY2Ugbm9kZS5cbiAgICAgICAgdGhpcy5jbGFzc0xpc3QucmVtb3ZlKCdkcmFnT3ZlclRvcCcpO1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdPdmVyQm90dG9tJyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBhZGRFdmVudHMgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnZHJhZ2dhYmxlJywgdHJ1ZSk7XG5cbiAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnU3RhcnQsIGZhbHNlKTtcbiAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBoYW5kbGVEcmFnRW50ZXIsIGZhbHNlKVxuICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgaGFuZGxlRHJhZ092ZXIsIGZhbHNlKTtcbiAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCBoYW5kbGVEcmFnTGVhdmUsIGZhbHNlKTtcbiAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgaGFuZGxlRHJvcCwgZmFsc2UpO1xuICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCBoYW5kbGVEcmFnRW5kLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgICQobWFjaGluZXNlbGVjdGlvbi5fc2VsZWN0aW9uTGlzdCkuZmluZCgnLm1hY2hpbmVzZWxlY3Rpb24tc2VsZWN0aW9uJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkZEV2ZW50cyh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEZVTkNUSU9OUyBGT1IgVVBEQVRJTkcgTWFjaGluZSBMaXN0IEFORCBzaG93L2hpZGUgbWFjaGluZXMgaW4gbGlzdCAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLy8gRmlsbCBtYWNoaW5lcyBsaXN0XG4gICAgX2ZpbGxNYWNoaW5lc0xpc3QgKCkge1xuICAgICAgaWYgKHRoaXMuX21hY2hpbmVzTGlzdCA9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgICQodGhpcy5fbWFjaGluZXNMaXN0KS5lbXB0eSgpO1xuXG4gICAgICBmb3IgKGxldCBkaXNwbGF5Q2xhc3Mgb2YgdGhpcy5fZ3JvdXBEaXNwbGF5cykge1xuICAgICAgICBpZiAoZGlzcGxheUNsYXNzWzFdLnNpbmdsZW1hY2hpbmUpIHtcbiAgICAgICAgICBsZXQgaWQgPSBkaXNwbGF5Q2xhc3NbMF07XG4gICAgICAgICAgbGV0IGRpc3BsYXlTdHIgPSBkaXNwbGF5Q2xhc3NbMV0uZGlzcGxheTtcblxuICAgICAgICAgIC8vIEJ1dHRvbiB0byBhZGQgXG4gICAgICAgICAgbGV0IGFkZEJ1dHRvbiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tYWRkLW1hY2hpbmUtYnV0dG9uJylcbiAgICAgICAgICAgIC5hdHRyKCdtYWNoaW5lLWlkJywgaWQpO1xuICAgICAgICAgIGxldCByZW1vdmVCdXR0b24gPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdtYWNoaW5lc2VsZWN0aW9uLXJlbW92ZS1tYWNoaW5lLWJ1dHRvbicpXG4gICAgICAgICAgICAuYXR0cignbWFjaGluZS1pZCcsIGlkKTtcblxuICAgICAgICAgIGxldCBtYWNoU3BhbiA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5hZGRDbGFzcygnbWFjaGluZXMtZGlzcGxheScpXG4gICAgICAgICAgICAuaHRtbChkaXNwbGF5U3RyKTtcbiAgICAgICAgICBsZXQgbWFjaERpdiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzLWRpdicpXG4gICAgICAgICAgICAuYXR0cignbWFjaGluZS1pZCcsIGlkKS5hcHBlbmQobWFjaFNwYW4pXG4gICAgICAgICAgICAuYXBwZW5kKGFkZEJ1dHRvbikuYXBwZW5kKHJlbW92ZUJ1dHRvbik7XG5cbiAgICAgICAgICBpZiAoZGlzcGxheUNsYXNzWzFdLnNvcnRwcmlvcml0eSAhPSB1bmRlZmluZWQpXG4gICAgICAgICAgICBtYWNoRGl2LmNzcygnb3JkZXInLCBkaXNwbGF5Q2xhc3NbMV0uc29ydHByaW9yaXR5KTtcblxuICAgICAgICAgICQodGhpcy5fbWFjaGluZXNMaXN0KS5hcHBlbmQobWFjaERpdik7XG5cbiAgICAgICAgICBwdWxzZVN2Zy5pbmxpbmVCYWNrZ3JvdW5kU3ZnKGFkZEJ1dHRvbik7XG4gICAgICAgICAgcHVsc2VTdmcuaW5saW5lQmFja2dyb3VuZFN2ZyhyZW1vdmVCdXR0b24pO1xuXG4gICAgICAgICAgbWFjaERpdi5jbGljayhmdW5jdGlvbiAobWFjaGluZXNlbGVjdGlvbikgeyAvLyB0byBhdm9pZCBjbG9zdXJlXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBsZXQgbWFjaGlkID0gJCh0aGlzKS5hdHRyKCdtYWNoaW5lLWlkJyk7XG5cbiAgICAgICAgICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3MoJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgICAgICAgICAvLyBSRU1PVkUgTUFDSElORVxuICAgICAgICAgICAgICAgIGlmIChtYWNoaW5lc2VsZWN0aW9uLl9tYWNoaW5lU2VsZWN0aW9uQXJyYXkuaW5jbHVkZXMobWFjaGlkKSkge1xuICAgICAgICAgICAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fbWFjaGluZVNlbGVjdGlvbkFycmF5ID1cbiAgICAgICAgICAgICAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fbWFjaGluZVNlbGVjdGlvbkFycmF5LmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAodmFsdWUsIGluZGV4LCBhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBtYWNoaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBREQgTUFDSElORVxuICAgICAgICAgICAgICAgIGlmICghbWFjaGluZXNlbGVjdGlvbi5fbWFjaGluZVNlbGVjdGlvbkFycmF5LmluY2x1ZGVzKG1hY2hpZCkpXG4gICAgICAgICAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl9tYWNoaW5lU2VsZWN0aW9uQXJyYXkucHVzaChtYWNoaWQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQWx3YXlzXG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSBsZWZ0IHBhbmVsXG4gICAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX2NoYW5nZVNlbGVjdGlvbkluTWFjaGluZUxpc3QoKTtcbiAgICAgICAgICAgICAgLy8gVXBkYXRlIHJpZ2h0IHBhbmVsXG4gICAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX2ZpbGxTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KHRoaXMpKTtcbiAgICAgICAgICAvL3NlbGVjdGVkID9cbiAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBhZGRCdXR0b24uY2xpY2soZnVuY3Rpb24gKG1hY2hpbmVzZWxlY3Rpb24pIHsgLy8gdG8gYXZvaWQgY2xvc3VyZVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWFjaGlkID0gJCh0aGlzKS5hdHRyKCdtYWNoaW5lLWlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBREQgTUFDSElORVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYWNoaW5lc2VsZWN0aW9uLl9tYWNoaW5lU2VsZWN0aW9uQXJyYXkuaW5jbHVkZXMobWFjaGlkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fbWFjaGluZVNlbGVjdGlvbkFycmF5LnB1c2gobWFjaGlkKTtcbiAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBsZWZ0IHBhbmVsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl9jaGFuZ2VTZWxlY3Rpb25Jbk1hY2hpbmVMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcmlnaHQgcGFuZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX2ZpbGxTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0odGhpcykpO1xuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVCdXR0b24uY2xpY2soZnVuY3Rpb24gKG1hY2hpbmVzZWxlY3Rpb24pIHsgLy8gdG8gYXZvaWQgY2xvc3VyZVxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWFjaGlkID0gJCh0aGlzKS5hdHRyKCdtYWNoaW5lLWlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSRU1PVkUgTUFDSElORVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hY2hpbmVzZWxlY3Rpb24uX21hY2hpbmVTZWxlY3Rpb25BcnJheS5pbmNsdWRlcyhtYWNoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX21hY2hpbmVTZWxlY3Rpb25BcnJheSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fbWFjaGluZVNlbGVjdGlvbkFycmF5LmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGFycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbWFjaGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbGVmdCBwYW5lbFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fY2hhbmdlU2VsZWN0aW9uSW5NYWNoaW5lTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHJpZ2h0IHBhbmVsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl9maWxsU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9zaG93SGlkZU1hY2hpbmVzSW5MaXN0ICgpIHtcbiAgICAgIGxldCBzZWFyY2hTdHJpbmcgPSAkKHRoaXMuX2lucHV0U2VhcmNoKVswXS52YWx1ZTtcbiAgICAgIC8vIFVzZSBhcyBmaWx0ZXJcblxuICAgICAgbGV0IG1hY2hpbmVzRGl2ID0gJCh0aGlzLl9tYWNoaW5lc0xpc3QpLmZpbmQoJy5tYWNoaW5lcy1kaXYnKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFjaGluZXNEaXYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG1hY2hpbmVEaXNwbGF5ID0gJChtYWNoaW5lc0RpdltpXSkuZmluZCgnLm1hY2hpbmVzLWRpc3BsYXknKS5odG1sKCk7XG4gICAgICAgIGlmIChtYWNoaW5lRGlzcGxheS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFN0cmluZy50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICQobWFjaGluZXNEaXZbaV0pLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAkKG1hY2hpbmVzRGl2W2ldKS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfY2hhbmdlU2VsZWN0aW9uSW5NYWNoaW5lTGlzdCAoKSB7XG4gICAgICBpZiAodGhpcy5fZGlhbG9nUGFnZTEgPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIFJlbW92ZSBhbGwgc2VsZWN0aW9uc1xuICAgICAgJCh0aGlzLl9tYWNoaW5lc0xpc3QpLmZpbmQoJy5tYWNoaW5lcy1kaXYuc2VsZWN0ZWQnKS5yZW1vdmVDbGFzcygnc2VsZWN0ZWQnKTtcblxuICAgICAgLy8gQWRkIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX21hY2hpbmVTZWxlY3Rpb25BcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbWFjaGlkID0gdGhpcy5fbWFjaGluZVNlbGVjdGlvbkFycmF5W2ldO1xuXG4gICAgICAgIGxldCBtYWNoRGl2cyA9ICQodGhpcy5fbWFjaGluZXNMaXN0KS5maW5kKCcubWFjaGluZXMtZGl2W21hY2hpbmUtaWQ9JyArIG1hY2hpZCArICddJyk7XG4gICAgICAgIGlmIChtYWNoRGl2cy5sZW5ndGggPiAwKSB7Ly8gQWx3YXlzXG4gICAgICAgICAgbWFjaERpdnMuYWRkQ2xhc3MoJ3NlbGVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hhbmdlIHByZXZpZXcgaW4gcmlnaHQgcGFuZWxcbiAgICAgIC8vdGhpcy5fZmlsbFNlbGVjdGlvbigpO1xuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEZVTkNUSU9OUyBGT1IgVVBEQVRJTkcgVEhFIFNFTEVDVElPTiA6IHN0b3JhZ2UgLT4gZGlzcGxheSAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgX2ZpbGxTZWxlY3Rpb24gKCkgey8vIC0+IHRvIGZpbGwgcmlnaHQgcGFuZWwgKFdhcm5pbmcgISBDaGFuZ2UgX2ZpbGxTdW1tYXJ5RGlzcGxheSBhY2NvcmRpbmdseSlcbiAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25MaXN0ID09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgJCh0aGlzLl9zZWxlY3Rpb25MaXN0KS5lbXB0eSgpO1xuXG4gICAgICBsZXQgYXJyYXlUb0Rpc3BsYXk7XG4gICAgICBpZiAoZmFsc2UgPT0gdGhpcy5fdXNlTWFjaGluZVNlbGVjdGlvbilcbiAgICAgICAgYXJyYXlUb0Rpc3BsYXkgPSB0aGlzLl9ncm91cFNlbGVjdGlvbkFycmF5O1xuICAgICAgZWxzZVxuICAgICAgICBhcnJheVRvRGlzcGxheSA9IHRoaXMuX21hY2hpbmVTZWxlY3Rpb25BcnJheTtcblxuICAgICAgaWYgKGFycmF5VG9EaXNwbGF5Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGxldCBub1NlbCA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5hZGRDbGFzcygnbm8tc2VsZWN0aW9uJylcbiAgICAgICAgICAuaHRtbCgnTm8gc2VsZWN0aW9uJyk7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbkxpc3QuYXBwZW5kKG5vU2VsKTtcblxuICAgICAgICAvLyBVcGRhdGUgcHJldmlldyA9IGVtcHR5XG4gICAgICAgIHRoaXMuX2ZpbGxNYWNoaW5lUHJldmlldygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGlHcm91cCA9IDA7IGlHcm91cCA8IGFycmF5VG9EaXNwbGF5Lmxlbmd0aDsgaUdyb3VwKyspIHtcbiAgICAgICAgbGV0IGdyb3VwSWQgPSBhcnJheVRvRGlzcGxheVtpR3JvdXBdLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tc2VsZWN0aW9uJylcbiAgICAgICAgICAuYXR0cignZ3JvdXBJZCcsIGdyb3VwSWQpO1xuXG4gICAgICAgIGlmICghdGhpcy5fZ3JvdXBEaXNwbGF5cy5oYXMoZ3JvdXBJZCkpXG4gICAgICAgICAgY29udGludWU7IC8vIFByb2JhYmx5IGVycm9yIHdoZW4gbG9hZGluZ1xuICAgICAgICBsZXQgZGlzcGxheUNsYXNzID0gdGhpcy5fZ3JvdXBEaXNwbGF5cy5nZXQoZ3JvdXBJZCk7XG5cbiAgICAgICAgbGV0IGhpZ2hsaWdodCA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3Jlb3JkZXJIaWdobGlnaHQnKTtcbiAgICAgICAgbGV0IHVwQnV0dG9uID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygncmVvcmRlclVwQnV0dG9uJyk7ICAgICAgICAgLy8gc21hcnRwaG9uZSA/XG4gICAgICAgIGxldCBkb3duQnV0dG9uID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygncmVvcmRlckRvd25CdXR0b24nKTsgICAgIC8vIHNtYXJ0cGhvbmUgP1xuICAgICAgICBsZXQgcmVvcmRlckJ1dHRvbiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3Jlb3JkZXJCdXR0b24nKTtcblxuICAgICAgICBsZXQgcm93ID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnc2VsZWN0aW9uLXBvc2l0aW9uJyk7XG4gICAgICAgIHJvdy5hcHBlbmQoaGlnaGxpZ2h0KS5hcHBlbmQodXBCdXR0b24pLmFwcGVuZChkb3duQnV0dG9uKVxuICAgICAgICAgIC5hcHBlbmQocmVvcmRlckJ1dHRvbik7XG5cbiAgICAgICAgbGV0IHNwYW5EaXNwbGF5ID0gJCgnPHNwYW4+PC9zcGFuPicpLmFkZENsYXNzKCdzZWxlY3Rpb24tZGlzcGxheScpXG4gICAgICAgICAgLmh0bWwoZGlzcGxheUNsYXNzLmRpc3BsYXkpO1xuICAgICAgICBsZXQgcmVtb3ZlQnV0dG9uID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygncmVtb3ZlLWJ1dHRvbicpXG4gICAgICAgICAgLmF0dHIoJ2dyb3VwSWQnLCBncm91cElkKTtcbiAgICAgICAgcm93LmFwcGVuZChzcGFuRGlzcGxheSkuYXBwZW5kKHJlbW92ZUJ1dHRvbik7XG4gICAgICAgIGlmIChkaXNwbGF5Q2xhc3Muc2luZ2xlbWFjaGluZSkge1xuICAgICAgICAgIGxldCBzcGFuTWFjaGluZSA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1tYWNoaW5lLWxhYmVsJylcbiAgICAgICAgICAgIC5odG1sKCdNJyk7XG4gICAgICAgICAgcm93LmFwcGVuZChzcGFuTWFjaGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbGV0IHNwYW5Hcm91cCA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1ncm91cC1sYWJlbCcpXG4gICAgICAgICAgICAuaHRtbCgnRycpO1xuICAgICAgICAgIHJvdy5hcHBlbmQoc3Bhbkdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcGxheUNsYXNzLmR5bmFtaWMpIHtcbiAgICAgICAgICBsZXQgc3BhbkR5bmFtaWMgPSAkKCc8c3Bhbj48L3NwYW4+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tZHluYW1pYy1sYWJlbCcpXG4gICAgICAgICAgICAuaHRtbCgnRFlOQU1JQycpO1xuICAgICAgICAgIHJvdy5hcHBlbmQoc3BhbkR5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5hcHBlbmQocm93KTtcblxuICAgICAgICAkKHNlbGVjdGlvbikuY3NzKCdvcmRlcicsIGlHcm91cCk7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbkxpc3QuYXBwZW5kKHNlbGVjdGlvbik7XG5cbiAgICAgICAgcHVsc2VTdmcuaW5saW5lQmFja2dyb3VuZFN2Zyh1cEJ1dHRvbik7XG4gICAgICAgIHB1bHNlU3ZnLmlubGluZUJhY2tncm91bmRTdmcoZG93bkJ1dHRvbik7XG4gICAgICAgIC8vcHVsc2VTdmcuaW5saW5lQmFja2dyb3VuZFN2ZyhyZW9yZGVyQnV0dG9uKTsgLy8gSXMgUE5HLi4uIG5vdCBwb3NzaWJsZSBmb3IgdGhlIG1vbWVudFxuXG4gICAgICAgIHB1bHNlU3ZnLmlubGluZUJhY2tncm91bmRTdmcocmVtb3ZlQnV0dG9uKTtcblxuICAgICAgICByZW1vdmVCdXR0b24uY2xpY2soZnVuY3Rpb24gKG1hY2hpbmVzZWxlY3Rpb24pIHsgLy8gdG8gYXZvaWQgY2xvc3VyZVxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXAgPSAkKHRoaXMpLmF0dHIoJ2dyb3VwaWQnKTtcblxuICAgICAgICAgICAgaWYgKGZhbHNlID09IG1hY2hpbmVzZWxlY3Rpb24uX3VzZU1hY2hpbmVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgLy8gcmVtb3ZlIGdyb3VwXG4gICAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX2dyb3VwU2VsZWN0aW9uQXJyYXkgPVxuICAgICAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX2dyb3VwU2VsZWN0aW9uQXJyYXkuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgYXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBncm91cDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvLyBDaGFuZ2Ugc2VsZWN0aW9uIG9uIGxlZnQgZGlzcGxheVxuICAgICAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl9jaGFuZ2VTZWxlY3Rpb25JbkNhdGVnb3J5TGlzdCgpO1xuICAgICAgICAgICAgICAvLyBVcGRhdGUgKG5iIG9mIHNlbGVjdGlvbikgLT4gdXNlZnVsIHdoZW4gdW5jaGVja2VkICFcbiAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkQ2F0ZWdvcnkgPSAkKG1hY2hpbmVzZWxlY3Rpb24uX2RpYWxvZ1BhZ2UxKS5maW5kKCdpbnB1dFtncm91cGlkPScgKyBncm91cCArICddJyk7XG4gICAgICAgICAgICAgIGxldCBwYXJlbnRzQ2F0ZWdvcmllcyA9ICQoc2VsZWN0ZWRDYXRlZ29yeSkucGFyZW50cygnLm1hY2hpbmVzZWxlY3Rpb24tY2F0ZWdvcnknKTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaUNhdCA9IDA7IGlDYXQgPCBwYXJlbnRzQ2F0ZWdvcmllcy5sZW5ndGg7IGlDYXQrKylcbiAgICAgICAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl91cGRhdGVOdW1iZXJPZlNlbGVjdGlvbnMocGFyZW50c0NhdGVnb3JpZXNbaUNhdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHJlbW92ZSBtYWNoaW5lXG4gICAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX21hY2hpbmVTZWxlY3Rpb25BcnJheSA9XG4gICAgICAgICAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fbWFjaGluZVNlbGVjdGlvbkFycmF5LmZpbHRlcihcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGFycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gZ3JvdXA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl9jaGFuZ2VTZWxlY3Rpb25Jbk1hY2hpbmVMaXN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgcmlnaHQgcGFuZWxcbiAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX2ZpbGxTZWxlY3Rpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0odGhpcykpO1xuXG4gICAgICB9IC8vIGFuZCBmb3IgXG4gICAgICB0aGlzLl9hZGREcmFnQW5kRHJvcEV2ZW50cygpO1xuICAgICAgdGhpcy5fYWRkTW92ZVVwRG93bkV2ZW50cygpO1xuXG4gICAgICB0aGlzLl9maWxsTWFjaGluZVByZXZpZXcoKTtcbiAgICB9XG5cbiAgICBfZmlsbE1hY2hpbmVQcmV2aWV3ICgpIHtcbiAgICAgIHRoaXMuX3ByZXZpZXdMaXN0LmVtcHR5KCk7XG4gICAgICB0aGlzLl9mcmVlVGV4dExhc3RVcGRhdGVbMF0uY2xlYW5EaXNwbGF5KCk7XG5cbiAgICAgIGlmIChmYWxzZSA9PSB0aGlzLl91c2VNYWNoaW5lU2VsZWN0aW9uKSB7XG4gICAgICAgIC8vIGFuZCBSRUFMIGZpbGxcbiAgICAgICAgaWYgKHRoaXMuX2dyb3VwU2VsZWN0aW9uQXJyYXkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIC5oaWRkZW4tY29udGVudFxuICAgICAgICAgIGxldCBzaW5nbGVNYWNoaW5lID0gcHVsc2VVdGlsaXR5LmNyZWF0ZWpRdWVyeUVsZW1lbnRXaXRoQXR0cmlidXRlKCd4LW1hY2hpbmVkaXNwbGF5Jywge30pO1xuICAgICAgICAgIGxldCB0b0Nsb25lID0gJCgnPGRpdiBpZD1tYWNoaW5ldG9jbG9uZT48L2RpdicpLmFkZENsYXNzKCdwcmV2aWV3LW1hY2hpbmUtcG9zaXRpb24nKS5hcHBlbmQoc2luZ2xlTWFjaGluZSk7XG4gICAgICAgICAgbGV0IGhpZGRlbiA9ICQoJzxkaXY+PC9kaXYnKS5hZGRDbGFzcygnaGlkZGVuLWNvbnRlbnQnKS5hcHBlbmQodG9DbG9uZSk7XG4gICAgICAgICAgdGhpcy5fcHJldmlld0xpc3QuYXBwZW5kKGhpZGRlbik7XG5cbiAgICAgICAgICAvLyBncm91cCB0byBkaXNwbGF5IG1hbnkgdGltZXMgaGlkZGVuIGNvbnRlbnRcbiAgICAgICAgICBsZXQgZ3JvdXBhcnJheSA9IHB1bHNlVXRpbGl0eS5jcmVhdGVqUXVlcnlFbGVtZW50V2l0aEF0dHJpYnV0ZSgneC1ncm91cGFycmF5Jywge1xuICAgICAgICAgICAgJ3RlbXBsYXRlaWQnOiAnbWFjaGluZXRvY2xvbmUnLFxuICAgICAgICAgICAgJ2dyb3VwJzogdGhpcy5fZ3JvdXBTZWxlY3Rpb25BcnJheS5qb2luKCksXG4gICAgICAgICAgICAvLydtYWNoaW5lJzogdGhpcy5fbWFjaGluZVNlbGVjdGlvbkFycmF5LmpvaW4oKSwgLT4gTm8gTkVWRVIgIVxuICAgICAgICAgICAgJ2NhblVzZVJvd3NUb1NldEhlaWdodCc6IGZhbHNlLFxuICAgICAgICAgICAgJ2FsbG93cGFnZXJvdGF0aW9uJzogJ2ZhbHNlJyxcbiAgICAgICAgICAgICdyb3RhdGlvbic6IDEwLCAvLyBzZWMgPSByZWZyZXNocmF0ZVxuICAgICAgICAgICAgJ3Jvdyc6IDk5OSwgLy8gVG8gYXZvaWQgZGlzcGxheWluZyBvbmx5IHNvbWUgcm93c1xuICAgICAgICAgICAgJ3RleHRjaGFuZ2UtY29udGV4dCc6ICdtYWNoaW5lc2VsZWN0aW9uJyxcbiAgICAgICAgICAgICdkb25vdHdhcm5ncm91cHJlbG9hZCc6ICd0cnVlJyAvLyB0byBhdm9pZCB1bndhbnRlZCBmaWVsZCBsZWdlbmQgcmVsb2FkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5fcHJldmlld0xpc3QuYXBwZW5kKGdyb3VwYXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEZVTkNUSU9OUyBGT1IgVVBEQVRJTkcgVEhFIFNFTEVDVElPTiA6IGF0dHJpYnV0ZXMgLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvLyBBcnJheSAtPiBDT05GSUdcbiAgICBfc3RvcmVTZWxlY3Rpb24gKCkge1xuICAgICAgaWYgKGZhbHNlID09IHRoaXMuX3VzZU1hY2hpbmVTZWxlY3Rpb24pIHtcbiAgICAgICAgLy8gVXBkYXRlIG1hY2hpbmVzIGxpc3RcbiAgICAgICAgbGV0IGdyb3VwYXJyYXlzID0gJCh0aGlzLl9wcmV2aWV3TGlzdCkuZmluZCgneC1ncm91cGFycmF5Jyk7XG4gICAgICAgIGlmIChncm91cGFycmF5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IG1hY2hpbmVzTGlzdCA9IGdyb3VwYXJyYXlzWzBdLmdldE1hY2hpbmVzTGlzdCgpO1xuICAgICAgICAgIHRoaXMuX21hY2hpbmVTZWxlY3Rpb25BcnJheSA9IG1hY2hpbmVzTGlzdC5zcGxpdCgnLCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX21hY2hpbmVTZWxlY3Rpb25BcnJheSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gU3RvcmUgbWFjaGluZXMgb25seVxuICAgICAgICAvLyBXYXJuaW5nICEgRG8gbm90IGNvcHkgdXNpbmcgJz0nICFcbiAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3Rpb25BcnJheSA9IFtdLmNvbmNhdCh0aGlzLl9tYWNoaW5lU2VsZWN0aW9uQXJyYXkpO1xuICAgICAgfVxuXG5cbiAgICAgIGxldCBqb2luZWRNYWNoaW5lcyA9IHRoaXMuX21hY2hpbmVTZWxlY3Rpb25BcnJheS5qb2luKCk7XG4gICAgICBsZXQgam9pbmVkR3JvdXBzID0gdGhpcy5fZ3JvdXBTZWxlY3Rpb25BcnJheS5qb2luKCk7XG4gICAgICBpZiAoIXRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2luLXJlcG9ydCcpKSB7XG4gICAgICAgIC8vIHN0b3JlIG1hY2hpbmVzXG4gICAgICAgIHB1bHNlQ29uZmlnLnNldCh0aGlzLl9jb25maWdNYWNoaW5lcywgam9pbmVkTWFjaGluZXMsIHRydWUpO1xuXG4gICAgICAgIC8vIFN0b3JlIGdyb3Vwc1xuICAgICAgICBpZiAoKGpvaW5lZEdyb3VwcyA9PSBqb2luZWRNYWNoaW5lcylcbiAgICAgICAgICB8fCAodGhpcy5fZ3JvdXBTZWxlY3Rpb25BcnJheSA9PSBbXSkpXG4gICAgICAgICAgcHVsc2VDb25maWcuc2V0KHRoaXMuX2NvbmZpZ0dyb3VwcywgJycsIHRydWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcHVsc2VDb25maWcuc2V0KHRoaXMuX2NvbmZpZ0dyb3Vwcywgam9pbmVkR3JvdXBzLCB0cnVlKTtcblxuICAgICAgICAvLyBDb25maWcgY2hhbmdlZCA6IHdhcm4geHRhZ3NcbiAgICAgICAgZXZlbnRCdXMuRXZlbnRCdXMuZGlzcGF0Y2hUb0FsbCgnY29uZmlnQ2hhbmdlRXZlbnQnLFxuICAgICAgICAgIHsgJ2NvbmZpZyc6IHRoaXMuX2NvbmZpZ01hY2hpbmVzIH0pO1xuICAgICAgICAvLyBEbyBuZWFybHkgdGhlIHNhbWUgYXMgcHJldmlvdXMgbGluZVxuICAgICAgICBldmVudEJ1cy5FdmVudEJ1cy5kaXNwYXRjaFRvQWxsKCdjb25maWdDaGFuZ2VFdmVudCcsXG4gICAgICAgICAgeyAnY29uZmlnJzogdGhpcy5fY29uZmlnR3JvdXBzIH0pO1xuXG4gICAgICAgIC8vIENoZWNrIExFR0VORCBkaXNwbGF5IC0gc2hvdWxkIGJlIHNvbWV3aGVyZSBlbHNlLCBidXQgd2hlcmUgP1xuICAgICAgICAkKCcubGVnZW5kLWNvbnRlbnQnKS5yZXNpemUoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBGb3IgcmVwb3J0IG9ubHkuIEJ1dCBjYW4gYmUgYWx3YXlzXG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3B1bHNlLW1hY2hpbmVzJywgam9pbmVkTWFjaGluZXMpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdwdWxzZS1ncm91cHMnLCBqb2luZWRHcm91cHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRTZWxlY3RlZEluZGV4ZXMgKGF0dHJpYnV0ZSkge1xuICAgICAgbGV0IGFyciA9IFtdO1xuICAgICAgbGV0IGFyclN0cmluZyA9IHRoaXMuZ2V0Q29uZmlnT3JBdHRyaWJ1dGUoYXR0cmlidXRlLCAnJylcbiAgICAgIGlmIChhcnJTdHJpbmcgIT0gJycpIHtcbiAgICAgICAgYXJyID0gYXJyU3RyaW5nLnNwbGl0KCcsJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIC8vIENPTkZJRyAtPiB0aGlzLl9ncm91cFNlbGVjdGlvbkFycmF5IC8gdGhpcy5fbWFjaGluZVNlbGVjdGlvbkFycmF5XG4gICAgX2xvYWRTZWxlY3Rpb24gKCkge1xuICAgICAgbGV0IGpvaW5lZE1hY2hpbmVzID0gXCJcIjtcbiAgICAgIGxldCBqb2luZWRHcm91cHMgPSBcIlwiO1xuXG4gICAgICBpZiAoIXRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2luLXJlcG9ydCcpKSB7XG4gICAgICAgIC8vIGdldCBDT05GSUcgKyBzdG9yZSBoZXJlIC0gUFdBIHZlcnNpb25cbiAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3Rpb25BcnJheSA9IHRoaXMuX2dldFNlbGVjdGVkSW5kZXhlcyh0aGlzLl9jb25maWdHcm91cHMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fbWFjaGluZVNlbGVjdGlvbkFycmF5ID0gdGhpcy5fZ2V0U2VsZWN0ZWRJbmRleGVzKHRoaXMuX2NvbmZpZ01hY2hpbmVzLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2dyb3VwU2VsZWN0aW9uQXJyYXkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAvLyBXYXJuaW5nICEgRG8gbm90IGNvcHkgdXNpbmcgPSAhXG4gICAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3Rpb25BcnJheSA9IFtdLmNvbmNhdCh0aGlzLl9tYWNoaW5lU2VsZWN0aW9uQXJyYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgam9pbmVkTWFjaGluZXMgPSB0aGlzLl9tYWNoaW5lU2VsZWN0aW9uQXJyYXkuam9pbigpO1xuICAgICAgICBqb2luZWRHcm91cHMgPSB0aGlzLl9ncm91cFNlbGVjdGlvbkFycmF5LmpvaW4oKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBsb2FkIGluaXRpYWwgZGF0YSAtIGZvciByZXBvcnQgdXNlXG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdwdWxzZS1tYWNoaW5lcycpKSB7XG4gICAgICAgICAgam9pbmVkTWFjaGluZXMgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwdWxzZS1tYWNoaW5lcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdwdWxzZS1ncm91cHMnKSkge1xuICAgICAgICAgIGpvaW5lZEdyb3VwcyA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3B1bHNlLWdyb3VwcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGpvaW5lZEdyb3VwcyA9PSBcIlwiKSB7XG4gICAgICAgICAgLy8gQ29weVxuICAgICAgICAgIGpvaW5lZEdyb3VwcyA9IGpvaW5lZE1hY2hpbmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGpvaW5lZEdyb3VwcyA9PSBcIlwiKSB7XG4gICAgICAgICAgLy8gRW1wdHlcbiAgICAgICAgICB0aGlzLl9ncm91cFNlbGVjdGlvbkFycmF5ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZ3JvdXBTZWxlY3Rpb25BcnJheSA9IGpvaW5lZEdyb3Vwcy5zcGxpdCgnLCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGpvaW5lZE1hY2hpbmVzID09IFwiXCIpIHtcbiAgICAgICAgICAvLyBFbXB0eVxuICAgICAgICAgIHRoaXMuX21hY2hpbmVTZWxlY3Rpb25BcnJheSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuX21hY2hpbmVTZWxlY3Rpb25BcnJheSA9IGpvaW5lZE1hY2hpbmVzLnNwbGl0KCcsJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGpvaW5lZEdyb3VwcyA9PSBqb2luZWRNYWNoaW5lc1xuICAgICAgICAmJiB0aGlzLl9tYWNoaW5lU2VsZWN0aW9uQXJyYXkubGVuZ3RoICE9IDApIHtcbiAgICAgICAgdGhpcy5fc3dpdGNoVG9NYWNoaW5lU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlU2VsZWN0aW9uSW5NYWNoaW5lTGlzdCgpO1xuICAgICAgICB0aGlzLl9maWxsU2VsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3dpdGNoVG9Hcm91cFNlbGVjdGlvbigpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBjaGVjayBib3hlcyBpbiBsZWZ0IHBhbmVsIGluY2x1ZGluZyBfZmlsbFNlbGVjdGlvblxuICAgICAgICB0aGlzLl9jaGFuZ2VTZWxlY3Rpb25JbkNhdGVnb3J5TGlzdCh0cnVlKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlU2VsZWN0aW9uSW5NYWNoaW5lTGlzdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9jbGVhclNlbGVjdGlvbiAoKSB7XG4gICAgICAkKHRoaXMuX2RpYWxvZ1BhZ2UxKS5maW5kKCdpbnB1dDpjaGVja2JveCcpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XG4gICAgICAvL3RoaXMuX3N3aXRjaFRvR3JvdXBTZWxlY3Rpb24oKTsgLy8gU2hvdyAvIEhpZGUgLT4gTm90IGFueW1vcmVcblxuICAgICAgdGhpcy5fZ3JvdXBTZWxlY3Rpb25BcnJheSA9IFtdO1xuICAgICAgdGhpcy5fbWFjaGluZVNlbGVjdGlvbkFycmF5ID0gW107XG5cbiAgICAgIC8vIFVwZGF0ZSBjaGVjayBib3hlcyBpbiBsZWZ0IHBhbmVsIGluY2x1ZGluZyBfZmlsbFNlbGVjdGlvblxuICAgICAgdGhpcy5fY2hhbmdlU2VsZWN0aW9uSW5DYXRlZ29yeUxpc3QoKTtcbiAgICAgIC8vIEFuZCBzZWxlY3Rpb24gaW4gbWFjaGluZSBsaXN0XG4gICAgICB0aGlzLl9jaGFuZ2VTZWxlY3Rpb25Jbk1hY2hpbmVMaXN0KCk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZU51bWJlck9mU2VsZWN0aW9ucyAobWFpbkNhdGVnb3J5KSB7XG4gICAgICBsZXQgc2VsZWN0aW9ucyA9ICQobWFpbkNhdGVnb3J5KS5maW5kKCdpbnB1dDpjaGVja2JveCcpO1xuICAgICAgbGV0IG5iU2VsID0gMDtcbiAgICAgIGZvciAobGV0IGlTZWwgPSAwOyBpU2VsIDwgc2VsZWN0aW9ucy5sZW5ndGg7IGlTZWwrKykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uc1tpU2VsXS5jaGVja2VkKSB7XG4gICAgICAgICAgbmJTZWwrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5iU2VsID09IDApIHtcbiAgICAgICAgJChtYWluQ2F0ZWdvcnkpLmNoaWxkcmVuKCcubWFjaGluZXNlbGVjdGlvbi1jYXRlZ29yeS1yb3cnKS5maW5kKCcubnVtYmVyLW9mLXNlbGVjdGlvbnMnKS5odG1sKCcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuXG4gICAgICAgICQobWFpbkNhdGVnb3J5KS5jaGlsZHJlbignLm1hY2hpbmVzZWxlY3Rpb24tY2F0ZWdvcnktcm93JykuZmluZCgnLm51bWJlci1vZi1zZWxlY3Rpb25zJykuaHRtbCgnKCcgKyBuYlNlbCArICcpJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBfc3RvcmVEaXNwbGF5cyAoKSB7XG4gICAgICB0aGlzLl9ncm91cERpc3BsYXlzLmNsZWFyKCk7XG5cbiAgICAgIGxldCBzdG9yZVN1Ykdyb3VwcyA9IGZ1bmN0aW9uIChtYWNoaW5lc2VsZWN0aW9uLCBncm91cHMpIHtcbiAgICAgICAgZm9yIChsZXQgaUdyb3VwID0gMDsgaUdyb3VwIDwgZ3JvdXBzLmxlbmd0aDsgaUdyb3VwKyspIHtcbiAgICAgICAgICBpZiAoZ3JvdXBzW2lHcm91cF0uRGlzcGxheSAhPSAnJykge1xuICAgICAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fZ3JvdXBEaXNwbGF5cy5zZXQoZ3JvdXBzW2lHcm91cF0uSWQudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBncm91cHNbaUdyb3VwXS5EaXNwbGF5LFxuICAgICAgICAgICAgICBkeW5hbWljOiAoZ3JvdXBzW2lHcm91cF0uRHluYW1pYyA9PSB0cnVlKSwgLy8gdW5rbm93biA9PiBmYWxzZVxuICAgICAgICAgICAgICBzaW5nbGVtYWNoaW5lOiAoZ3JvdXBzW2lHcm91cF0uU2luZ2xlTWFjaGluZSA9PSB0cnVlKSxcbiAgICAgICAgICAgICAgc29ydHByaW9yaXR5OiBncm91cHNbaUdyb3VwXS5Tb3J0UHJpb3JpdHlcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBZGQgU3ViIFN1YiBncm91cHNcbiAgICAgICAgICAgIGlmICghcHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChncm91cHNbaUdyb3VwXS5ab29tKSkge1xuICAgICAgICAgICAgICBzdG9yZVN1Ykdyb3VwcyhtYWNoaW5lc2VsZWN0aW9uLCBncm91cHNbaUdyb3VwXS5ab29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgY2F0SW5kZXggPSAwOyBjYXRJbmRleCA8IHRoaXMuX2dyb3Vwcy5sZW5ndGg7IGNhdEluZGV4KyspIHtcbiAgICAgICAgbGV0IGdyb3VwcyA9IHRoaXMuX2dyb3Vwc1tjYXRJbmRleF0uR3JvdXBzO1xuICAgICAgICBpZiAoZ3JvdXBzICE9IG51bGwpIHtcbiAgICAgICAgICBzdG9yZVN1Ykdyb3Vwcyh0aGlzLCBncm91cHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGluIHRoaXMuX21hY2hpbmVzRnJvbVNlcnZpY2UgPSBkYXRhLk1hY2hpbmVMaXN0IGlmIG1hY2hpbmVzIGFyZSBtaXNzaW5nXG4gICAgICBmb3IgKGxldCBtYWNoSW5kZXggPSAwOyBtYWNoSW5kZXggPCB0aGlzLl9tYWNoaW5lc0Zyb21TZXJ2aWNlLmxlbmd0aDsgbWFjaEluZGV4KyspIHtcbiAgICAgICAgbGV0IG1hY2ggPSB0aGlzLl9tYWNoaW5lc0Zyb21TZXJ2aWNlW21hY2hJbmRleF07XG4gICAgICAgIGlmICghdGhpcy5fZ3JvdXBEaXNwbGF5cy5oYXMobWFjaC5JZC50b1N0cmluZygpKSkge1xuICAgICAgICAgIC8vIGlmIG5vdCBleGlzdHMgLSBBREQgKFNob3VsZCByYXJlbHkgaGFwcGVuKVxuICAgICAgICAgIHRoaXMuX2dyb3VwRGlzcGxheXMuc2V0KG1hY2guSWQudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgZGlzcGxheTogbWFjaC5EaXNwbGF5LFxuICAgICAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgICAgICBzaW5nbGVtYWNoaW5lOiB0cnVlLFxuICAgICAgICAgICAgc29ydHByaW9yaXR5OiBtYWNoLkRpc3BsYXlQcmlvcml0eVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnNvbGUud2FybigneC1tYWNoaW5lc2VsZWN0aW9uIDogbWFjaGluZSAnXG4gICAgICAgICAgICArIG1hY2guRGlzcGxheSArICcgaXMgbm90IGluIGdyb3VwcycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEZVTkNUSU9OUyBGT1IgRElTUExBWUlORyBncm91cHMgYW5kIHNlbGVjdGlvbiBpbiBsZWZ0IHBhbmVsICAgICAgIC8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBfZmlsbENhdGVnb3J5TGlzdCAoKSB7XG4gICAgICBpZiAodGhpcy5fY2F0ZWdvcnlMaXN0ID09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuOyAvLyBDYW4gaGFwcGVuIGJlZm9yZSBkaWFsb2cgY3JlYXRpb25cblxuICAgICAgbGV0IGdldFN1Ykdyb3VwcyA9IGZ1bmN0aW9uIChtYWNoaW5lc2VsZWN0aW9uLCBjb250YWluZXIsIGdyb3VwcywgaXNNYWluKSB7XG5cbiAgICAgICAgbGV0IG5iU3ViR3JvdXBzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZ3JvdXBzW2ldLkRpc3BsYXkgIT0gJycpIHtcbiAgICAgICAgICAgIC8vIFNob3cgLyBIaWRlIEljb25cbiAgICAgICAgICAgIGxldCBzdmdTaG93ID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnc2hvdy1zdWInKTtcbiAgICAgICAgICAgIGxldCBzdmdIaWRlID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnaGlkZS1zdWInKTtcbiAgICAgICAgICAgIGxldCBzaG93SGlkZSA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tc3ViY2F0ZWdvcnktdmlzaWJpbGl0eScpXG4gICAgICAgICAgICAgIC8vLmFkZENsYXNzKCdjbG9zZWQnKSBub3QgaGVyZVxuICAgICAgICAgICAgICAuYXBwZW5kKHN2Z1Nob3cpLmFwcGVuZChzdmdIaWRlKTtcbiAgICAgICAgICAgIHB1bHNlU3ZnLmlubGluZUJhY2tncm91bmRTdmcoc3ZnU2hvdyk7XG4gICAgICAgICAgICBwdWxzZVN2Zy5pbmxpbmVCYWNrZ3JvdW5kU3ZnKHN2Z0hpZGUpO1xuXG4gICAgICAgICAgICAvLyBkaXNwbGF5IC8gKHgpIC8gY2hlY2sgLyBzaG93SGlkZSAvIGlzU3ViXG4gICAgICAgICAgICBsZXQgc3BhbkRpc3BsYXkgPSAkKCc8c3Bhbj48L3NwYW4+JykuYWRkQ2xhc3MoJ2NhdGVnb3J5LWRpc3BsYXknKVxuICAgICAgICAgICAgICAuaHRtbChncm91cHNbaV0uVHJlZU5hbWUpO1xuICAgICAgICAgICAgbGV0IG5iU2VsID0gJCgnPHNwYW4+PC9zcGFuPicpLmFkZENsYXNzKCdudW1iZXItb2Ytc2VsZWN0aW9ucycpLmh0bWwoJycpO1xuICAgICAgICAgICAgbGV0IGNoZWNrYm94ID0gJCgnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGdyb3VwaWQ9XCInICsgZ3JvdXBzW2ldLklkICsgJ1wiIGR5bmFtaWM9XCInICsgZ3JvdXBzW2ldLkR5bmFtaWMgKyAnXCI+Jyk7XG4gICAgICAgICAgICBsZXQgZGl2Um93ID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1jYXRlZ29yeS1yb3cnKVxuICAgICAgICAgICAgICAuYXBwZW5kKHNwYW5EaXNwbGF5KS5hcHBlbmQobmJTZWwpO1xuICAgICAgICAgICAgaWYgKGlzTWFpbilcbiAgICAgICAgICAgICAgZGl2Um93LmFkZENsYXNzKCdpcy1tYWluJyk7XG4gICAgICAgICAgICBkaXZSb3cuYXBwZW5kKHNob3dIaWRlKS5hcHBlbmQoY2hlY2tib3gpO1xuICAgICAgICAgICAgaWYgKGdyb3Vwc1tpXS5EeW5hbWljKSB7XG4gICAgICAgICAgICAgIGxldCBzcGFuRHluYW1pYyA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1keW5hbWljLWxhYmVsJylcbiAgICAgICAgICAgICAgICAuaHRtbCgnRFlOQU1JQycpO1xuICAgICAgICAgICAgICBkaXZSb3cuYXBwZW5kKHNwYW5EeW5hbWljKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjYXRlZ29yeSA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tY2F0ZWdvcnknKS5hcHBlbmQoZGl2Um93KTtcblxuICAgICAgICAgICAgLy8gQ29sbGFwc2UgLyBFeHBhbmQgbWFjaGluZSBjYXRlZ29yaWVzXG4gICAgICAgICAgICBzaG93SGlkZS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKCdjbG9zZWQnKSkge1xuICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ29wZW5lZCcpO1xuXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCcubWFjaGluZXNlbGVjdGlvbi1jYXRlZ29yeScpXG4gICAgICAgICAgICAgICAgICAuY2hpbGRyZW4oJy5tYWNoaW5lc2VsZWN0aW9uLWNhdGVnb3J5LWNvbnRlbnQnKS50b2dnbGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICgkKHRoaXMpLmhhc0NsYXNzKCdvcGVuZWQnKSkge1xuICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ29wZW5lZCcpO1xuICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoJ2Nsb3NlZCcpO1xuXG4gICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCcubWFjaGluZXNlbGVjdGlvbi1jYXRlZ29yeScpXG4gICAgICAgICAgICAgICAgICAuY2hpbGRyZW4oJy5tYWNoaW5lc2VsZWN0aW9uLWNhdGVnb3J5LWNvbnRlbnQnKS50b2dnbGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGNsaWNrIG9uIGNoZWNrYm94XG4gICAgICAgICAgICBjaGVja2JveC5jaGFuZ2UoZnVuY3Rpb24gKG1hY2hpbmVzZWxlY3Rpb24pIHsgLy8gdG8gYXZvaWQgY2xvc3VyZVxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX3N3aXRjaFRvR3JvdXBTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgICAgIGxldCBncm91cCA9ICQodGhpcykuYXR0cignZ3JvdXBpZCcpO1xuICAgICAgICAgICAgICAgIGxldCBpc0NoZWNrZWQgPSAkKHRoaXMpLmlzKCc6Y2hlY2tlZCcpO1xuICAgICAgICAgICAgICAgIGlmIChpc0NoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGFkZCBncm91cCBpZiBub3QgZXhpc3RzXG4gICAgICAgICAgICAgICAgICBpZiAoIW1hY2hpbmVzZWxlY3Rpb24uX2dyb3VwU2VsZWN0aW9uQXJyYXkuaW5jbHVkZXMoZ3JvdXApKVxuICAgICAgICAgICAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl9ncm91cFNlbGVjdGlvbkFycmF5LnB1c2goZ3JvdXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBncm91cFxuICAgICAgICAgICAgICAgICAgbWFjaGluZXNlbGVjdGlvbi5fZ3JvdXBTZWxlY3Rpb25BcnJheSA9XG4gICAgICAgICAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX2dyb3VwU2VsZWN0aW9uQXJyYXkuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGFycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9IGdyb3VwO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmluZCBhbGwgZGlzcGxheXMgZm9yIGdyb3VwaWRcbiAgICAgICAgICAgICAgICBsZXQgY2hhbmdlZENhdGVnb3J5ID0gJChtYWNoaW5lc2VsZWN0aW9uLl9kaWFsb2dQYWdlMSkuZmluZCgnaW5wdXRbZ3JvdXBpZD0nICsgZ3JvdXAgKyAnXScpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrL1VuY2hlY2sgc2ltaWxhciBncm91cHNcbiAgICAgICAgICAgICAgICBjaGFuZ2VkQ2F0ZWdvcnkucHJvcCgnY2hlY2tlZCcsIGlzQ2hlY2tlZCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpQ2hhbmdlZCA9IDA7IGlDaGFuZ2VkIDwgY2hhbmdlZENhdGVnb3J5Lmxlbmd0aDsgaUNoYW5nZWQrKykge1xuICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIChuYiBvZiBzZWxlY3Rpb24pIGhlcmUgQU5EIGluIHBhcmVudHNcbiAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnRzQ2F0ID0gJChjaGFuZ2VkQ2F0ZWdvcnlbaUNoYW5nZWRdKS5wYXJlbnRzKCcubWFjaGluZXNlbGVjdGlvbi1jYXRlZ29yeScpO1xuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaVBhcmVudCA9IDA7IGlQYXJlbnQgPCBwYXJlbnRzQ2F0Lmxlbmd0aDsgaVBhcmVudCsrKVxuICAgICAgICAgICAgICAgICAgICBtYWNoaW5lc2VsZWN0aW9uLl91cGRhdGVOdW1iZXJPZlNlbGVjdGlvbnMocGFyZW50c0NhdFtpUGFyZW50XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vaWYgKGZhbHNlID09IG1hY2hpbmVzZWxlY3Rpb24uX3VzZU1hY2hpbmVTZWxlY3Rpb24pID8/P1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSByaWdodCBwYW5lbFxuICAgICAgICAgICAgICAgIG1hY2hpbmVzZWxlY3Rpb24uX2ZpbGxTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfShtYWNoaW5lc2VsZWN0aW9uKSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBTdWIgU3ViIGdyb3VwcyBpbiBsaVxuICAgICAgICAgICAgaWYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKGdyb3Vwc1tpXS5ab29tKSkge1xuICAgICAgICAgICAgICBsZXQgaGlkZGVuU3ViR3JvdXAgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdtYWNoaW5lc2VsZWN0aW9uLWNhdGVnb3J5LWNvbnRlbnQnKTtcbiAgICAgICAgICAgICAgbGV0IG5iU3ViU3ViR3JvdXBzID0gZ2V0U3ViR3JvdXBzKG1hY2hpbmVzZWxlY3Rpb24sIGhpZGRlblN1Ykdyb3VwLCBncm91cHNbaV0uWm9vbSk7XG4gICAgICAgICAgICAgIGlmIChuYlN1YlN1Ykdyb3VwcyA+IDApIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeS5hcHBlbmQoaGlkZGVuU3ViR3JvdXApO1xuICAgICAgICAgICAgICAgIC8vaWYgKG5iU3ViU3ViR3JvdXBzID49IDIpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yeS5hZGRDbGFzcygnZXhwYW5kYWJsZScpO1xuICAgICAgICAgICAgICAgIGhpZGRlblN1Ykdyb3VwLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICAgICAgICAgICAgc2hvd0hpZGUuYWRkQ2xhc3MoJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgIC8qfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2hvd0hpZGUuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgIHNob3dIaWRlLmFkZENsYXNzKCdub0NoaWxkJyk7XG4gICAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBzaG93SGlkZS5lbXB0eSgpO1xuICAgICAgICAgICAgICBzaG93SGlkZS5hZGRDbGFzcygnbm9DaGlsZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kKGNhdGVnb3J5KTtcbiAgICAgICAgICAgIG5iU3ViR3JvdXBzKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYlN1Ykdyb3VwcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2F0ZWdvcnlMaXN0LmVtcHR5KCk7XG5cbiAgICAgIC8vIFJlYWwgbGlzdFxuICAgICAgbGV0IGZ1bGxMaXN0VG9TY3JvbGwgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdtYWNoaW5lc2VsZWN0aW9uLWNhdGVnb3J5bGlzdC1mdWxsJyk7XG4gICAgICBsZXQgbGlzdCA9ICcnO1xuICAgICAgZm9yIChsZXQgY2F0SW5kZXggPSAwOyBjYXRJbmRleCA8IHRoaXMuX2dyb3Vwcy5sZW5ndGg7IGNhdEluZGV4KyspIHtcbiAgICAgICAgbGV0IGdyb3VwcyA9IHRoaXMuX2dyb3Vwc1tjYXRJbmRleF0uR3JvdXBzO1xuICAgICAgICBsZXQgb21pdENhdCA9IHRoaXMuX2dyb3Vwc1tjYXRJbmRleF0uT21pdEdyb3VwQ2F0ZWdvcnk7XG4gICAgICAgIGlmIChncm91cHMgIT0gbnVsbCAmJiBncm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmICghcHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChvbWl0Q2F0KSAmJiBvbWl0Q2F0ID09IHRydWVcbiAgICAgICAgICAgICYmIGdyb3Vwcy5sZW5ndGggPT0gMSAmJiBncm91cHNbMF0uRGlzcGxheSAhPSAnJykge1xuICAgICAgICAgICAgLy8gSWdub3JlIE9ORSBMRVZFTFxuICAgICAgICAgICAgbGV0IGNhdGVnb3J5ID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnbWFjaGluZXNlbGVjdGlvbi1jYXRlZ29yeScpO1xuICAgICAgICAgICAgbGV0IG5iU3ViR3JvdXBzID0gZ2V0U3ViR3JvdXBzKHRoaXMsIGNhdGVnb3J5LCBncm91cHMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKG5iU3ViR3JvdXBzID09IDEpXG4gICAgICAgICAgICAgIGZ1bGxMaXN0VG9TY3JvbGwuYXBwZW5kKGNhdGVnb3J5KTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNob3cgLyBIaWRlIEljb25cbiAgICAgICAgICAgIGxldCBzdmdTaG93ID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnc2hvdy1zdWInKTtcbiAgICAgICAgICAgIGxldCBzdmdIaWRlID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygnaGlkZS1zdWInKTtcbiAgICAgICAgICAgIGxldCBzaG93SGlkZSA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tc3ViY2F0ZWdvcnktdmlzaWJpbGl0eScpXG4gICAgICAgICAgICAgIC8vLmFkZENsYXNzKCdjbG9zZWQnKSBOb3QgaGVyZVxuICAgICAgICAgICAgICAuYXBwZW5kKHN2Z1Nob3cpLmFwcGVuZChzdmdIaWRlKTtcbiAgICAgICAgICAgIHB1bHNlU3ZnLmlubGluZUJhY2tncm91bmRTdmcoc3ZnU2hvdyk7XG4gICAgICAgICAgICBwdWxzZVN2Zy5pbmxpbmVCYWNrZ3JvdW5kU3ZnKHN2Z0hpZGUpO1xuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgbGV0IHNwYW4gPSAkKCc8c3Bhbj48L3NwYW4+JykuYWRkQ2xhc3MoJ2NhdGVnb3J5LWRpc3BsYXknKVxuICAgICAgICAgICAgICAuaHRtbCh0aGlzLl9ncm91cHNbY2F0SW5kZXhdLkRpc3BsYXkpOyAvLyBUcmVlTmFtZSA9IG5vdCBkZWZpbmVkXG4gICAgICAgICAgICBsZXQgbmJTZWwgPSAkKCc8c3Bhbj48L3NwYW4+JykuYWRkQ2xhc3MoJ251bWJlci1vZi1zZWxlY3Rpb25zJykuaHRtbCgnJyk7XG4gICAgICAgICAgICBsZXQgZGl2SGVhZGVyID0gJCgnPGRpdj48L2Rpdj4nKVxuICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tY2F0ZWdvcnktcm93JykuYWRkQ2xhc3MoJ2lzLW1haW4nKVxuICAgICAgICAgICAgICAuYXBwZW5kKHNwYW4pLmFwcGVuZChuYlNlbCkuYXBwZW5kKHNob3dIaWRlKTtcbiAgICAgICAgICAgIGxldCBjYXRlZ29yeSA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hY2hpbmVzZWxlY3Rpb24tY2F0ZWdvcnknKVxuICAgICAgICAgICAgICAuYXBwZW5kKGRpdkhlYWRlcik7XG5cbiAgICAgICAgICAgIC8vIENvbGxhcHNlIC8gRXhwYW5kIG1hY2hpbmUgY2F0ZWdvcmllc1xuICAgICAgICAgICAgc2hvd0hpZGUuY2xpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5oYXNDbGFzcygnY2xvc2VkJykpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdvcGVuZWQnKTtcblxuICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnLm1hY2hpbmVzZWxlY3Rpb24tY2F0ZWdvcnknKVxuICAgICAgICAgICAgICAgICAgLmNoaWxkcmVuKCcubWFjaGluZXNlbGVjdGlvbi1jYXRlZ29yeS1jb250ZW50JykudG9nZ2xlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoJCh0aGlzKS5oYXNDbGFzcygnb3BlbmVkJykpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCdvcGVuZWQnKTtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdjbG9zZWQnKTtcblxuICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnLm1hY2hpbmVzZWxlY3Rpb24tY2F0ZWdvcnknKVxuICAgICAgICAgICAgICAgICAgLmNoaWxkcmVuKCcubWFjaGluZXNlbGVjdGlvbi1jYXRlZ29yeS1jb250ZW50JykudG9nZ2xlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsZXQgaGlkZGVuU3ViR3JvdXAgPSAkKCc8ZGl2IHN0eWxlPVwiZGlzcGxheTpub25lO1wiPjwvZGl2PicpLmFkZENsYXNzKCdtYWNoaW5lc2VsZWN0aW9uLWNhdGVnb3J5LWNvbnRlbnQnKTtcbiAgICAgICAgICAgIGxldCBuYlN1Ykdyb3VwcyA9IGdldFN1Ykdyb3Vwcyh0aGlzLCBoaWRkZW5TdWJHcm91cCwgZ3JvdXBzKTtcbiAgICAgICAgICAgIGlmIChuYlN1Ykdyb3VwcyA+IDApIHtcbiAgICAgICAgICAgICAgY2F0ZWdvcnkuYXBwZW5kKGhpZGRlblN1Ykdyb3VwKTtcbiAgICAgICAgICAgICAgY2F0ZWdvcnkuYWRkQ2xhc3MoJ2V4cGFuZGFibGUnKTtcbiAgICAgICAgICAgICAgc2hvd0hpZGUuYWRkQ2xhc3MoJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVsbExpc3RUb1Njcm9sbC5hcHBlbmQoY2F0ZWdvcnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVsbExpc3RUb1Njcm9sbC5hcHBlbmQobGlzdCk7XG5cbiAgICAgIHRoaXMuX2NhdGVnb3J5TGlzdC5hcHBlbmQoZnVsbExpc3RUb1Njcm9sbCk7XG4gICAgfVxuXG4gICAgLy8gX2dyb3VwU2VsZWN0aW9uQXJyYXkgLT4gZmlsbCBjaGVjayBib3hlcyBhY2NvcmRpbmdseVxuICAgIC8vIChhbmRPcGVuID09IHRydWUpIC0+IG9wZW4gc2VsZWN0aW9uXG4gICAgX2NoYW5nZVNlbGVjdGlvbkluQ2F0ZWdvcnlMaXN0IChhbmRPcGVuKSB7XG4gICAgICBpZiAodGhpcy5fZGlhbG9nUGFnZTEgPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIFJlbW92ZSBhbGwgY2hlY2tzXG4gICAgICAkKHRoaXMuX2RpYWxvZ1BhZ2UxKS5maW5kKCdpbnB1dDpjaGVja2JveCcpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XG5cbiAgICAgIC8vIEFkZCBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ncm91cFNlbGVjdGlvbkFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBncm91cCA9IHRoaXMuX2dyb3VwU2VsZWN0aW9uQXJyYXlbaV07XG4gICAgICAgIGxldCBzZWxlY3RlZENhdGVnb3J5ID0gJCh0aGlzLl9kaWFsb2dQYWdlMSkuZmluZCgnaW5wdXRbZ3JvdXBpZD0nICsgZ3JvdXAgKyAnXScpO1xuICAgICAgICBpZiAoc2VsZWN0ZWRDYXRlZ29yeS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIC8vIEVycm9yIGluIGNvbmZpZyAhIC0+IFxuICAgICAgICAgIGNvbnNvbGUud2FybignQ2hlY2sgZ3JvdXAgY29uZmlndXJhdGlvbiBmb3IgJyArIGdyb3VwKTtcbiAgICAgICAgICAvLyBSZW1vdmUgZ3JvdXAgZnJvbSBzZWxlY3Rpb25cbiAgICAgICAgICB0aGlzLl9ncm91cFNlbGVjdGlvbkFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAvLyBSZS1zdGFydCB0aGlzIG1ldGhvZFxuICAgICAgICAgIHRoaXMuX2NoYW5nZVNlbGVjdGlvbkluQ2F0ZWdvcnlMaXN0KGFuZE9wZW4pO1xuICAgICAgICAgIC8vIEV4aXRcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZWN0ZWRDYXRlZ29yeS5wcm9wKCdjaGVja2VkJywgdHJ1ZSk7XG5cbiAgICAgICAgICBmb3IgKGxldCBpQ2F0ID0gMDsgaUNhdCA8IHNlbGVjdGVkQ2F0ZWdvcnkubGVuZ3RoOyBpQ2F0KyspIHtcbiAgICAgICAgICAgIGlmIChhbmRPcGVuID09IHRydWUpIHtcbiAgICAgICAgICAgICAgLy8gT3BlbiBwYXJlbnRcbiAgICAgICAgICAgICAgJChzZWxlY3RlZENhdGVnb3J5W2lDYXRdKS5wYXJlbnRzKCcubWFjaGluZXNlbGVjdGlvbi1jYXRlZ29yeScpXG4gICAgICAgICAgICAgICAgLmZpbmQoJy5tYWNoaW5lc2VsZWN0aW9uLWNhdGVnb3J5LWNvbnRlbnQnKS5zaG93KCk7XG4gICAgICAgICAgICAgIC8vIENoYW5nZSBTaG93SGlkZSBpY29uXG4gICAgICAgICAgICAgICQoc2VsZWN0ZWRDYXRlZ29yeVtpQ2F0XSkucGFyZW50cygnY2xvc2VkJylcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ29wZW5lZCcpLnJlbW92ZUNsYXNzKCdjbG9zZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFVwZGF0ZSAobmIgb2Ygc2VsZWN0aW9uKSBmb3IgQUxMIGNhdGVnb3JpZXNcbiAgICAgIGxldCBwYXJlbnRzQ2F0ID0gJCh0aGlzLl9kaWFsb2dQYWdlMSkuZmluZCgnLm1hY2hpbmVzZWxlY3Rpb24tY2F0ZWdvcnknKTtcbiAgICAgIGZvciAobGV0IGlQYXJlbnQgPSAwOyBpUGFyZW50IDwgcGFyZW50c0NhdC5sZW5ndGg7IGlQYXJlbnQrKylcbiAgICAgICAgdGhpcy5fdXBkYXRlTnVtYmVyT2ZTZWxlY3Rpb25zKHBhcmVudHNDYXRbaVBhcmVudF0pO1xuXG4gICAgICAvLyBDaGFuZ2UgcHJldmlldyBpbiByaWdodCBwYW5lbFxuICAgICAgdGhpcy5fZmlsbFNlbGVjdGlvbigpO1xuICAgIH1cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEZVTkNUSU9OUyBGT1IgRElTUExBWUlORyBzZWxlY3RlZCBtYWNoaW5lcyAvIGdyb3VwcyAvL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIHRoaXMuX21hY2hpbmVzICYmIHRoaXMuX2NhdGVnb3JpZXMgLT4gdGhpcy5fc3VtbWFyeVxuICAgIF9maWxsU3VtbWFyeURpc3BsYXkgKCkgeyAvLyBJbnBpcmVkIGZyb20gX2ZpbGxTZWxlY3Rpb25cbiAgICAgIGlmICh0aGlzLl9zdW1tYXJ5ID09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgJCh0aGlzLl9zdW1tYXJ5KS5lbXB0eSgpO1xuXG4gICAgICBsZXQgdWwgPSAkKCc8ZGl2PjwvZGl2PicpO1xuXG4gICAgICBsZXQgYXJyYXlUb0Rpc3BsYXk7XG4gICAgICBpZiAoZmFsc2UgPT0gdGhpcy5fdXNlTWFjaGluZVNlbGVjdGlvbilcbiAgICAgICAgYXJyYXlUb0Rpc3BsYXkgPSB0aGlzLl9ncm91cFNlbGVjdGlvbkFycmF5O1xuICAgICAgZWxzZVxuICAgICAgICBhcnJheVRvRGlzcGxheSA9IHRoaXMuX21hY2hpbmVTZWxlY3Rpb25BcnJheTtcblxuICAgICAgbGV0IG9uZUdyb3VwSXNBZGRlZCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaUdyb3VwID0gMDsgaUdyb3VwIDwgYXJyYXlUb0Rpc3BsYXkubGVuZ3RoOyBpR3JvdXArKykge1xuICAgICAgICBsZXQgZ3JvdXBJZCA9IGFycmF5VG9EaXNwbGF5W2lHcm91cF0udG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGRpc3BsYXkgPSAnTm8gbWFjaGluZSBzZWxlY3Rpb24nO1xuICAgICAgICBpZiAodGhpcy5fZ3JvdXBEaXNwbGF5cy5oYXMoZ3JvdXBJZCkpIHtcbiAgICAgICAgICBsZXQgZGlzcGxheUNsYXNzID0gdGhpcy5fZ3JvdXBEaXNwbGF5cy5nZXQoZ3JvdXBJZCk7XG4gICAgICAgICAgZGlzcGxheSA9IGRpc3BsYXlDbGFzcy5kaXNwbGF5O1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaSA9ICQoJzxkaXY+PC9kaXY+Jyk7XG4gICAgICAgIGxldCBzcGFuID0gJCgnPHNwYW4+PC9zcGFuPicpLmh0bWwoZGlzcGxheSk7XG4gICAgICAgIGxpLmFwcGVuZChzcGFuKTtcbiAgICAgICAgdWwuYXBwZW5kKGxpKTtcbiAgICAgICAgb25lR3JvdXBJc0FkZGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTWlzc2luZyBjb25maWcgb3Igbm90IDpcbiAgICAgIGlmICghb25lR3JvdXBJc0FkZGVkKSB7XG4gICAgICAgIC8vaWYgKGZhbHNlID09IHRoaXMuX3VzZU1hY2hpbmVTZWxlY3Rpb24pIHtcbiAgICAgICAgLyp0aGlzLl9zdW1tYXJ5Lmh0bWwoXG4gICAgICAgICAgKHRoaXMuX3VuaXF1ZW1hY2hpbmUpXG4gICAgICAgICAgICA/ICdObyBtYWNoaW5lcyBzZWxlY3RlZCdcbiAgICAgICAgICAgIDogJ0FsbCBtYWNoaW5lcyBzZWxlY3RlZCcpOyovXG4gICAgICAgIHRoaXMuX3N1bW1hcnkuaHRtbCgnTm8gbWFjaGluZXMgc2VsZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5fc3VtbWFyeS5hZGRDbGFzcygnbWlzc2luZy1jb25maWcnKTtcbiAgICAgICAgJCh0aGlzLmVsZW1lbnQpLnBhcmVudCgpLmFkZENsYXNzKCdtaXNzaW5nLWNvbmZpZycpO1xuICAgICAgICAkKHRoaXMuZWxlbWVudCkucGFyZW50KCkucGFyZW50KCkuYWRkQ2xhc3MoJ21pc3NpbmctY29uZmlnJyk7XG4gICAgICAgIC8qfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zdW1tYXJ5Lmh0bWwoJ05vIGdyb3VwIHNlbGVjdGVkJyk7XG4gICAgICAgICAgdGhpcy5fc3VtbWFyeS5hZGRDbGFzcygnbWlzc2luZy1jb25maWcnKTtcbiAgICAgICAgICAkKHRoaXMuZWxlbWVudCkucGFyZW50KCkuYWRkQ2xhc3MoJ21pc3NpbmctY29uZmlnJyk7XG4gICAgICAgICAgJCh0aGlzLmVsZW1lbnQpLnBhcmVudCgpLnBhcmVudCgpLmFkZENsYXNzKCdtaXNzaW5nLWNvbmZpZycpO1xuICAgICAgICB9Ki9cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9zdW1tYXJ5LmFwcGVuZCh1bCk7XG5cbiAgICAgICAgdGhpcy5fc3VtbWFyeS5yZW1vdmVDbGFzcygnbWlzc2luZy1jb25maWcnKTtcbiAgICAgICAgJCh0aGlzLmVsZW1lbnQpLnBhcmVudCgpLnJlbW92ZUNsYXNzKCdtaXNzaW5nLWNvbmZpZycpO1xuICAgICAgICAkKHRoaXMuZWxlbWVudCkucGFyZW50KCkucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ21pc3NpbmctY29uZmlnJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEVYVEVSTkFMIEZVTkNUSU9OIFRPIERJU1BMQVkgc2VsZWN0ZWQgbWFjaGluZXMgLyBncm91cHMgLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gc3VtbWFyeSA9IGV4aXN0aW5nIGRpdlxuICAgIGZpbGxFeHRlcm5hbFN1bW1hcnlEaXNwbGF5IChzdW1tYXJ5KSB7IC8vIElucGlyZWQgZnJvbSBfZmlsbFNlbGVjdGlvblxuICAgICAgaWYgKHN1bW1hcnkgPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgICAkKHN1bW1hcnkpLmVtcHR5KCk7XG5cbiAgICAgIGxldCB1bCA9ICQoJzxkaXY+PC9kaXY+Jyk7XG5cbiAgICAgIGxldCBhcnJheVRvRGlzcGxheTtcbiAgICAgIGlmIChmYWxzZSA9PSB0aGlzLl91c2VNYWNoaW5lU2VsZWN0aW9uKVxuICAgICAgICBhcnJheVRvRGlzcGxheSA9IHRoaXMuX2dyb3VwU2VsZWN0aW9uQXJyYXk7XG4gICAgICBlbHNlXG4gICAgICAgIGFycmF5VG9EaXNwbGF5ID0gdGhpcy5fbWFjaGluZVNlbGVjdGlvbkFycmF5O1xuXG4gICAgICBsZXQgb25lR3JvdXBJc0FkZGVkID0gZmFsc2U7XG4gICAgICBmb3IgKGxldCBpR3JvdXAgPSAwOyBpR3JvdXAgPCBhcnJheVRvRGlzcGxheS5sZW5ndGg7IGlHcm91cCsrKSB7XG4gICAgICAgIGxldCBncm91cElkID0gYXJyYXlUb0Rpc3BsYXlbaUdyb3VwXTtcbiAgICAgICAgbGV0IGRpc3BsYXkgPSAnTm8gbWFjaGluZSBzZWxlY3Rpb24nO1xuICAgICAgICBpZiAodGhpcy5fZ3JvdXBEaXNwbGF5cy5oYXMoZ3JvdXBJZCkpIHtcbiAgICAgICAgICBsZXQgZGlzcGxheUNsYXNzID0gdGhpcy5fZ3JvdXBEaXNwbGF5cy5nZXQoZ3JvdXBJZCk7XG4gICAgICAgICAgZGlzcGxheSA9IGRpc3BsYXlDbGFzcy5kaXNwbGF5O1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaSA9ICQoJzxkaXY+PC9kaXY+Jyk7XG4gICAgICAgIGxldCBzcGFuID0gJCgnPHNwYW4+PC9zcGFuPicpLmh0bWwoZGlzcGxheSk7XG4gICAgICAgIGxpLmFwcGVuZChzcGFuKTtcbiAgICAgICAgdWwuYXBwZW5kKGxpKTtcbiAgICAgICAgb25lR3JvdXBJc0FkZGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gTWlzc2luZyBjb25maWcgb3Igbm90IDpcbiAgICAgIGlmICghb25lR3JvdXBJc0FkZGVkKSB7XG4gICAgICAgIHN1bW1hcnkuaHRtbCgnTm8gbWFjaGluZXMgc2VsZWN0ZWQnKTtcbiAgICAgICAgc3VtbWFyeS5hZGRDbGFzcygnbWlzc2luZy1jb25maWcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdW1tYXJ5LmFwcGVuZCh1bCk7XG4gICAgICAgIHN1bW1hcnkucmVtb3ZlQ2xhc3MoJ21pc3NpbmctY29uZmlnJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEVYVEVSTkFMIEZVTkNUSU9OUyBUTyBnZXQgc2VsZWN0ZWQgbWFjaGluZXMgLyBncm91cHMgICAgLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgZ2V0TWFjaGluZXNBcnJheSAoKSB7XG4gICAgICByZXR1cm4gKFtdLmNvbmNhdCh0aGlzLl9tYWNoaW5lU2VsZWN0aW9uQXJyYXkpKTtcbiAgICB9XG4gICAgZ2V0R3JvdXBzQXJyYXkgKCkge1xuICAgICAgcmV0dXJuIChbXS5jb25jYXQodGhpcy5fZ3JvdXBTZWxlY3Rpb25BcnJheSkpO1xuICAgIH1cbiAgICBnZXRNYWNoaW5lc1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFjaGluZVNlbGVjdGlvbkFycmF5LmpvaW4oKTtcbiAgICB9XG4gICAgZ2V0R3JvdXBzU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ncm91cFNlbGVjdGlvbkFycmF5LmpvaW4oKTtcbiAgICB9XG5cbiAgfVxuXG4gIHB1bHNlQ29tcG9uZW50LnJlZ2lzdGVyRWxlbWVudCgneC1tYWNoaW5lc2VsZWN0aW9uJywgTWFjaGluZVNlbGVjdGlvbkNvbXBvbmVudCwgWyd1bmlxdWUtbWFjaGluZSddKTtcbn0pKCk7XG4iLCIvLyBDb3B5cmlnaHQgKEMpIDIwMDktMjAyMyBMZW1vaW5lIEF1dG9tYXRpb24gVGVjaG5vbG9naWVzXG4vL1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuLyoqXG4gKiBAbW9kdWxlIHgtbWFya2Rvd250ZXh0XG4gKiBAcmVxdWlyZXMgbW9kdWxlOnB1bHNlQ29tcG9uZW50XG4gKi9cblxudmFyIHB1bHNlQ29tcG9uZW50ID0gcmVxdWlyZSgncHVsc2Vjb21wb25lbnQnKTtcbi8vdmFyIHB1bHNlVXRpbGl0eSA9IHJlcXVpcmUoJ3B1bHNlVXRpbGl0eScpO1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gIGNsYXNzIG1hcmtEb3duVGV4dENvbXBvbmVudCBleHRlbmRzIHB1bHNlQ29tcG9uZW50LlB1bHNlSW5pdGlhbGl6ZWRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICogXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHNlbGYgPSBzdXBlciguLi5hcmdzKTtcblxuICAgICAgc2VsZi5tZXRob2RzID0ge1xuICAgICAgICBzZXRUZXh0OiBzZWxmLnNldFRleHQgLy8gdXNlZCBieSByZXBvcnRpbmdcbiAgICAgIH07XG5cbiAgICAgIC8vIERPTSAtIG5vdCBoZXJlXG4gICAgICBzZWxmLl9jb250ZW50ID0gdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICBzZXRUZXh0ICh0ZXh0VG9EaXNwbGF5KSB7XG4gICAgICAkKHRoaXMuX2NvbnRlbnQpLmVtcHR5KCk7XG5cbiAgICAgIGlmICh0ZXh0VG9EaXNwbGF5ID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQbGVhc2UgRklMTCBtYXJrZG93biB0ZXh0ICEgJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gU2VlIHVzZSBoZXJlIDogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbWFya2Rvd24taXRcbiAgICAgICAgdmFyIE1hcmtkb3duSXQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpO1xuICAgICAgICBsZXQgbWQgPSBuZXcgTWFya2Rvd25JdCgpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWQucmVuZGVyKHRleHRUb0Rpc3BsYXkpO1xuXG4gICAgICAgICQodGhpcy5fY29udGVudCkuYXBwZW5kKFxuICAgICAgICAgICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hcmtkb3dudGV4dC1tYWluZGl2JykuaHRtbChyZXN1bHQpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9nZXQgY29udGVudCAoKSB7IHJldHVybiB0aGlzLl9jb250ZW50OyB9IC8vIE9wdGlvbmFsXG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkV2hlbkNvbm5lY3RlZE9uY2UgKGF0dHIsIG9sZFZhbCwgbmV3VmFsKSB7XG4gICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkV2hlbkNvbm5lY3RlZE9uY2UoYXR0ciwgb2xkVmFsLCBuZXdWYWwpO1xuICAgICAgLypcbiAgICAgIHN3aXRjaCAoYXR0cikge1xuICAgICAgICBjYXNlICdtYWNoaW5lLWlkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgICovXG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSAoKSB7XG4gICAgICB0aGlzLmFkZENsYXNzKCdwdWxzZS10ZXh0Jyk7IC8vIE1hbmRhdG9yeSBmb3IgbG9hZGVyXG5cbiAgICAgIC8vIFVwZGF0ZSBoZXJlIHNvbWUgaW50ZXJuYWwgcGFyYW1ldGVyc1xuXG4gICAgICAvLyBJbiBjYXNlIG9mIGNsb25lLCBuZWVkIHRvIGJlIGVtcHR5IDpcbiAgICAgICQodGhpcy5lbGVtZW50KS5lbXB0eSgpO1xuXG4gICAgICAvLyBDcmVhdGUgRE9NIC0gQ29udGVudFxuICAgICAgdGhpcy5fY29udGVudCA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21hcmtkb3dudGV4dC1jb250ZW50Jyk7XG4gICAgICAkKHRoaXMuZWxlbWVudCkuYXBwZW5kKHRoaXMuX2NvbnRlbnQpO1xuXG4gICAgICAvLyBDcmVhdGUgRE9NIC0gTk8gTG9hZGVyIC8gTm8gbWVzc2FnZVxuXG4gICAgICAvLyBsaXN0ZW5lcnMvZGlzcGF0Y2hlcnMgLyBOb25lXG5cbiAgICAgIC8vIEluaXRpYWxpemF0aW9uIE9LID0+IHN3aXRjaCB0byB0aGUgbmV4dCBjb250ZXh0XG4gICAgICB0aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjbGVhckluaXRpYWxpemF0aW9uICgpIHtcbiAgICAgIC8vIFBhcmFtZXRlcnNcbiAgICAgIC8vIERPTVxuICAgICAgJCh0aGlzLmVsZW1lbnQpLmVtcHR5KCk7XG5cbiAgICAgIC8vdGhpcy5fbWVzc2FnZVNwYW4gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jb250ZW50ID0gdW5kZWZpbmVkO1xuXG4gICAgICBzdXBlci5jbGVhckluaXRpYWxpemF0aW9uKCk7XG4gICAgfVxuXG4gIH1cblxuICBwdWxzZUNvbXBvbmVudC5yZWdpc3RlckVsZW1lbnQoJ3gtbWFya2Rvd250ZXh0JywgbWFya0Rvd25UZXh0Q29tcG9uZW50LCBbXSk7XG59KSgpO1xuIiwiLy8gQ29weXJpZ2h0IChDKSAyMDA5LTIwMjMgTGVtb2luZSBBdXRvbWF0aW9uIFRlY2hub2xvZ2llc1xuLy9cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5cbi8qKlxuICogQG1vZHVsZSB4LW1lc3NhZ2VcbiAqIEByZXF1aXJlcyBtb2R1bGU6cHVsc2VDb21wb25lbnRcbiAqL1xuXG52YXIgcHVsc2VDb21wb25lbnQgPSByZXF1aXJlKCdwdWxzZWNvbXBvbmVudCcpO1xudmFyIHB1bHNlQ29uZmlnID0gcmVxdWlyZSgncHVsc2VDb25maWcnKTtcbnZhciBwdWxzZVN2ZyA9IHJlcXVpcmUoJ3B1bHNlU3ZnJyk7XG52YXIgcHVsc2VVdGlsaXR5ID0gcmVxdWlyZSgncHVsc2VVdGlsaXR5Jyk7XG52YXIgZXZlbnRCdXMgPSByZXF1aXJlKCdldmVudEJ1cycpO1xuXG4vKipcbiAqIEJ1aWxkIGEgY3VzdG9tIHRhZyA8eC1tZXNzYWdlPiB0byBkaXNwbGF5IGEgZmxvYXRpbmcgbWVzc2FnZS5cbiAqICBcbiAqIExpc3RlbiBtZXNzYWdlcyBvbiBjb250ZXh0IDogJ01FU1NBR0UnXG4gKiBcbiAqIHZhciBtZXNzYWdlSW5mbyA9IHtcbiAgICAgICAgJ2lkJzoge1N0cmluZ30gdG8gYWxsb3cgcmVtb3ZlIGFuZCBhdm9pZCBkdXBsaWNhdGVkIG1lc3NhZ2VzIFxuICAgICAgICAnbWVzc2FnZSc6IHtTdHJpbmd9ICdNZXNzYWdlIHRvIGRpc3BsYXknLFxuICAgICAgICAndGltZScgOiB7SW50ZWdlcn0gdGltZSBkdXJhdGlvbiB0byBkaXNwbGF5IHRoZSBtZXNzYWdlIGluIHNlY29uZC4gKGRlZmF1bHQgcGVybWFuZW50KVxuICAgICAgICAnbGV2ZWwnOiB7U3RyaW5nfSAnZXJyb3InIHwgJ3dhcm5pbmcnIHwgJ2luZm8nfCAnZGVmYXVsdCdcbiAgICAgICAgJ2NsaWNrVG9DbG9zZScge0Jvb2xlYW59IDogVGVsbHMgaWYgdXNlciBtYXkgY2xpY2sgb24gcGFuZWwgdG8gY2xvc2UgaXQuIERlZmF1bHQgPSBmYWxzZVxuICAgICAgICAncmVsb2FkVVJMJyB7U3RyaW5nfSA6IE5ldyBVUkwgdG8gdXNlIHRvIHJlbG9hZCBwYWdlLiBEZWZhdWx0ID0gbm8gcmVsb2FkXG4gICAgICAgICdpbnRlcm5hbExBVCc6IGludGVybmFsIG1lc3NhZ2UgdG8gZXhwbGFpbiB3aGVyZSBpdCBjb21lcyBmcm9tXG4gICAgICB9O1xuICAgZXZlbnRCdXMuRXZlbnRCdXMuZGlzcGF0Y2hUb0FsbCgnc2hvd01lc3NhZ2VTaWduYWwnLCBtZXNzYWdlSW5mbyk7XG4gKi9cbihmdW5jdGlvbiAoKSB7XG5cbiAgY2xhc3MgTWVzc2FnZUNvbXBvbmVudCBleHRlbmRzIHB1bHNlQ29tcG9uZW50LlB1bHNlUGFyYW1Jbml0aWFsaXplZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgY29uc3Qgc2VsZiA9IHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgICBzZWxmLl9jb250ZW50ID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZi5fdGltZXJJZCA9IG51bGw7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRXaGVuQ29ubmVjdGVkT25jZSAoYXR0ciwgb2xkVmFsLCBuZXdWYWwpIHtcbiAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRXaGVuQ29ubmVjdGVkT25jZShhdHRyLCBvbGRWYWwsIG5ld1ZhbCk7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSAoKSB7XG4gICAgICAvLyBMaXN0ZW5lciBhbmQgZGlzcGF0Y2hlcnNcbiAgICAgIGV2ZW50QnVzLkV2ZW50QnVzLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIodGhpcyxcbiAgICAgICAgJ3Nob3dNZXNzYWdlU2lnbmFsJyxcbiAgICAgICAgdGhpcy5vblNob3dNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgICAgZXZlbnRCdXMuRXZlbnRCdXMuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcih0aGlzLFxuICAgICAgICAnY2xlYXJNZXNzYWdlU2lnbmFsJyxcbiAgICAgICAgdGhpcy5vbkNsZWFyTWVzc2FnZS5iaW5kKHRoaXMpKTtcblxuICAgICAgLy8gSW4gY2FzZSBvZiBjbG9uZSwgbmVlZCB0byBiZSBlbXB0eSA6XG4gICAgICAkKHRoaXMuZWxlbWVudCkuZW1wdHkoKTtcblxuICAgICAgLy8gQ3JlYXRlIERPTSAtIENvbnRlbnRcbiAgICAgIHRoaXMuX2NvbnRlbnQgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCd4bWVzc2FnZScpO1xuICAgICAgLy8gQ3JlYXRlIERPTSAtIE5vIExvYWRlclxuICAgICAgLy8gQ3JlYXRlIERPTSAtIE5vIG1lc3NhZ2UgZm9yIGVycm9yXG5cbiAgICAgICQodGhpcy5lbGVtZW50KS5hcHBlbmQodGhpcy5fY29udGVudCk7XG5cbiAgICAgIC8vIENoZWNrIGlmIGxvZ2luIGVycm9yIGV4aXN0c1xuICAgICAgbGV0IGVyciA9IHB1bHNlQ29uZmlnLmdldCgnbG9naW5FcnJvcicsICcnKTtcbiAgICAgIGlmIChlcnIgIT0gJycpIHtcbiAgICAgICAgLy8gRGlzcGxheVxuICAgICAgICBsZXQgbWVzc2FnZUluZm8gPSB7XG4gICAgICAgICAgJ2lkJzogJ0xPR0lOX0VSUk9SJyxcbiAgICAgICAgICAnbWVzc2FnZSc6IGVycixcbiAgICAgICAgICAnbGV2ZWwnOiAnZXJyb3InLFxuICAgICAgICAgICdjbGlja1RvQ2xvc2UnOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIC8vIFNhbWUgYXMgOiBldmVudEJ1cy5FdmVudEJ1cy5kaXNwYXRjaFRvQWxsKCdzaG93TWVzc2FnZVNpZ25hbCcsIG1lc3NhZ2VJbmZvKTtcbiAgICAgICAgdGhpcy5zaG93TWVzc2FnZShtZXNzYWdlSW5mbyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRtcCBzdG9yYWdlXG4gICAgICAgIHB1bHNlQ29uZmlnLnNldEdsb2JhbCgnbG9naW5FcnJvcicsICcnKTtcbiAgICAgIH1cblxuICAgICAgLy8gSW5pdGlhbGl6YXRpb24gT0sgPT4gc3dpdGNoIHRvIHRoZSBuZXh0IGNvbnRleHRcbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNsZWFySW5pdGlhbGl6YXRpb24gKCkge1xuICAgICAgLy8gU1RPUCB0aW1lclxuICAgICAgaWYgKHRoaXMuX3RpbWVySWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVySWQpO1xuICAgICAgICB0aGlzLl90aW1lcklkID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gUGFyYW1ldGVyc1xuICAgICAgLy8gRE9NXG4gICAgICAkKHRoaXMuZWxlbWVudCkuZW1wdHkoKTtcblxuICAgICAgLy90aGlzLl9tZXNzYWdlU3BhbiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2NvbnRlbnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHN1cGVyLmNsZWFySW5pdGlhbGl6YXRpb24oKTtcbiAgICB9XG5cblxuICAgIHZhbGlkYXRlUGFyYW1ldGVycyAoKSB7XG4gICAgICB0aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gc2hvd01lc3NhZ2VcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gZGF0YSBpbmNsdWRpbmcgc2hvdyBoZWFkZXIgZm9yIGRldGFpbHNcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dNZXNzYWdlIChkYXRhKSB7XG4gICAgICBjb25zb2xlLmxvZygnY29tcG9uZW50IHgtbWVzc2FnZSBzaG93TWVzc2FnZSBmdW5jdGlvbiEnKTtcbiAgICAgIGxldCBub3RGb3VuZCA9IHRydWU7XG4gICAgICBpZiAoIXB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQoZGF0YS5pZCkpIHtcbiAgICAgICAgLy8gaWYgYSBtZXNzYWdlIHdpdGggc2FtZSBpZCBhbHJlYWR5IGV4aXN0cywgZ2V0IGl0IGFuZCByZXBsYWNlIHRleHRcbiAgICAgICAgbGV0IGFsbEFsZXJ0cyA9ICQoJy5tZXNzYWdlLWFsZXJ0Jyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsQWxlcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFsbEFsZXJ0c1tpXS5oYXNBdHRyaWJ1dGUoJ21lc3NhZ2UtaWQnKSlcbiAgICAgICAgICAgIGlmIChhbGxBbGVydHNbaV0uZ2V0QXR0cmlidXRlKCdtZXNzYWdlLWlkJykgPT0gZGF0YS5pZCkge1xuICAgICAgICAgICAgICBub3RGb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGxldCBlbGVtID0gYWxsQWxlcnRzW2ldO1xuICAgICAgICAgICAgICBpZiAoZGF0YS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgLy9lbGVtLmh0bWwoZGF0YS5tZXNzYWdlLnJlcGxhY2UoL1xcbi9nLCAnPGJyIC8+JykpO1xuICAgICAgICAgICAgICAgIGxldCBtc2dzcGFuID0gJChlbGVtKS5maW5kKCcubWVzc2FnZS1zcGFuJyk7XG4gICAgICAgICAgICAgICAgaWYgKG1zZ3NwYW4ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIG1zZ3NwYW4gPSAkKCc8c3Bhbj48L3NwYW4+JykuYWRkQ2xhc3MoJ21lc3NhZ2Utc3BhbicpO1xuICAgICAgICAgICAgICAgICAgZWxlbS5hcHBlbmQobXNnc3Bhbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICQobXNnc3BhbikuaHRtbChkYXRhLm1lc3NhZ2UucmVwbGFjZSgvXFxuL2csICc8YnIgLz4nKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZGF0YS5pbnRlcm5hbExBVCkge1xuICAgICAgICAgICAgICAgIGxldCBpbnRlcm5zcGFuID0gJChlbGVtKS5maW5kKCcuaGlkZGVuLXNwYW4nKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuc3Bhbi5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgaW50ZXJuc3BhbiA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5hZGRDbGFzcygnaGlkZGVuLXNwYW4nKTtcbiAgICAgICAgICAgICAgICAgIGVsZW0uYXBwZW5kKGludGVybnNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkKGludGVybnNwYW4pLmh0bWwoZGF0YS5pbnRlcm5hbExBVC5yZXBsYWNlKC9cXG4vZywgJzxiciAvPicpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm90Rm91bmQpIHtcbiAgICAgICAgLy8gaWYgbm90IGZvdW5kIGNyZWF0ZSBuZXdcbiAgICAgICAgbGV0IGVsZW0gPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdtZXNzYWdlLWFsZXJ0Jyk7XG5cbiAgICAgICAgLy8gVW5pcXVlIElkXG4gICAgICAgIGxldCBlbGVtSWQgPSAncHVsc2VNZXNzYWdlJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgJycgKyBwYXJzZUludChNYXRoLnJhbmRvbSgpICogMTAwMDAsIDEwKTtcbiAgICAgICAgZWxlbS5pZCA9IGVsZW1JZDtcbiAgICAgICAgJCh0aGlzLl9jb250ZW50KS5hcHBlbmQoZWxlbSk7XG5cbiAgICAgICAgLy9sZXQgY2xvc2VCdXR0b24gPSAkKCc8c3Bhbj48L3NwYW4+JykuYWRkQ2xhc3MoJ21lc3NhZ2UtY2xvc2VidG4nKTtcbiAgICAgICAgLy9vbmNsaWNrPVwidGhpcy5wYXJlbnRFbGVtZW50LnN0eWxlLmRpc3BsYXk9J25vbmUnO1wiXG4gICAgICAgIC8vZWxlbS5hcHBlbmQoY2xvc2VCdXR0b24pO1xuXG4gICAgICAgIGlmIChkYXRhLm1lc3NhZ2UpIHtcbiAgICAgICAgICBsZXQgbXNnc3BhbiA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5hZGRDbGFzcygnbWVzc2FnZS1zcGFuJyk7XG4gICAgICAgICAgbXNnc3Bhbi5odG1sKGRhdGEubWVzc2FnZS5yZXBsYWNlKC9cXG4vZywgJzxiciAvPicpKTtcbiAgICAgICAgICBlbGVtLmFwcGVuZChtc2dzcGFuKTtcbiAgICAgICAgICAvL2VsZW0uaHRtbChkYXRhLm1lc3NhZ2UucmVwbGFjZSgvXFxuL2csICc8YnIgLz4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChkYXRhLmludGVybmFsTEFUKSB7XG4gICAgICAgICAgbGV0IGludGVybnNwYW4gPSAkKCc8c3Bhbj48L3NwYW4+JykuYWRkQ2xhc3MoJ2hpZGRlbi1zcGFuJyk7XG4gICAgICAgICAgaW50ZXJuc3Bhbi5odG1sKGRhdGEuaW50ZXJuYWxMQVQucmVwbGFjZSgvXFxuL2csICc8YnIgLz4nKSk7XG4gICAgICAgICAgZWxlbS5hcHBlbmQoaW50ZXJuc3Bhbik7XG4gICAgICAgIH0gICAgICAgICAgICAgIFxuXG4gICAgICAgIGxldCBjbGFzc05hbWUgPSAneG1lc3NhZ2UtZGVmYXVsdCc7XG4gICAgICAgIHN3aXRjaCAoZGF0YS5sZXZlbCkge1xuICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9ICd4bWVzc2FnZS1lcnJvcic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9ICd4bWVzc2FnZS13YXJuaW5nJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICAgICAgY2xhc3NOYW1lID0gJ3htZXNzYWdlLWluZm8nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9ICd4bWVzc2FnZS1kZWZhdWx0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW0uYWRkQ2xhc3MoY2xhc3NOYW1lKTtcblxuICAgICAgICBpZiAoZGF0YS5pZClcbiAgICAgICAgICBlbGVtLmF0dHIoJ21lc3NhZ2UtaWQnLCBkYXRhLmlkKTtcblxuICAgICAgICBpZiAoZGF0YS5jbGlja1RvQ2xvc2UgPT0gdHJ1ZSkge1xuICAgICAgICAgIGVsZW0uYWRkQ2xhc3MoJ2Nsb3NhYmxlJyk7XG4gICAgICAgICAgZWxlbS5iaW5kKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQodGhpcykucmVtb3ZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gQnV0dG9uIFwiY2xvc2VcIlxuICAgICAgICAgIHZhciBjbG9zZUJ0biA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21lc3NhZ2UtY2xvc2UnKTtcbiAgICAgICAgICBlbGVtLmFwcGVuZChjbG9zZUJ0bik7ICAgICAgXG4gICAgICAgICAgcHVsc2VTdmcuaW5saW5lQmFja2dyb3VuZFN2ZyhjbG9zZUJ0bik7ICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKGRhdGEucmVsb2FkVVJMKSkge1xuICAgICAgICAgIGxldCBidXR0b24gPSAkKCc8YT48L2E+JykuYWRkQ2xhc3MoJ21lc3NhZ2UtcmVsb2FkLWJ1dHRvbicpLmh0bWwoJ1JlbG9hZCcpO1xuICAgICAgICAgIGJ1dHRvbi5hdHRyKCdocmVmJywgZGF0YS5yZWxvYWRVUkwpO1xuICAgICAgICAgIC8qYnV0dG9uLmJpbmQoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUkVMT0FEXG4gICAgICAgICAgICB3aW5kb3cub3BlbihkYXRhLnJlbG9hZFVSTCwgJ19zZWxmJyk7XG4gICAgICAgICAgfSk7Ki9cbiAgICAgICAgICBlbGVtLmFwcGVuZChidXR0b24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEudGltZSkge1xuICAgICAgICAgIHZhciBhbGVydCA9IGVsZW07XG4gICAgICAgICAgdGhpcy5fdGltZXJJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJChhbGVydCkucmVtb3ZlKCk7XG4gICAgICAgICAgfSwgZGF0YS50aW1lICogMTAwMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbGVhck1lc3NhZ2UgKGlkKSB7XG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgLy8gaWYgYSBtZXNzYWdlIHdpdGggc2FtZSBpZCBhbHJlYWR5IGV4aXN0cywgcmVtb3ZlIGl0XG4gICAgICAgIGxldCBhbGxBbGVydHMgPSAkKCcubWVzc2FnZS1hbGVydCcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbEFsZXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChhbGxBbGVydHNbaV0uaGFzQXR0cmlidXRlKCdtZXNzYWdlLWlkJykpXG4gICAgICAgICAgICBpZiAoYWxsQWxlcnRzW2ldLmdldEF0dHJpYnV0ZSgnbWVzc2FnZS1pZCcpID09IGlkKSB7XG4gICAgICAgICAgICAgIGxldCBlbGVtID0gYWxsQWxlcnRzW2ldO1xuICAgICAgICAgICAgICAkKGVsZW0pLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXJBbGxNZXNzYWdlICgpIHtcbiAgICAgICQoJ21lc3NhZ2UtYWxlcnQnKS5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsYmFjayBldmVudHNcbiAgICBvblNob3dNZXNzYWdlIChldmVudCkge1xuICAgICAgbGV0IGRhdGEgPSBldmVudC50YXJnZXQ7XG4gICAgICB0aGlzLnNob3dNZXNzYWdlKGRhdGEpO1xuICAgIH1cblxuICAgIG9uQ2xlYXJNZXNzYWdlIChldmVudCkge1xuICAgICAgbGV0IGRhdGEgPSBldmVudC50YXJnZXQ7XG4gICAgICB0aGlzLmNsZWFyTWVzc2FnZShkYXRhLmlkKTtcbiAgICB9XG4gIH1cblxuICBwdWxzZUNvbXBvbmVudC5yZWdpc3RlckVsZW1lbnQoJ3gtbWVzc2FnZScsIE1lc3NhZ2VDb21wb25lbnQpO1xufSkoKTtcbiIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4vKipcbiAqIEBtb2R1bGUgeC1tb2RpZmljYXRpb25tYW5hZ2VyXG4gKiBAcmVxdWlyZXMgbW9kdWxlOnB1bHNlQ29tcG9uZW50XG4gKi9cblxudmFyIHB1bHNlQ29tcG9uZW50ID0gcmVxdWlyZSgncHVsc2Vjb21wb25lbnQnKTtcbnZhciBwdWxzZVV0aWxpdHkgPSByZXF1aXJlKCdwdWxzZVV0aWxpdHknKTtcbnZhciBwdWxzZVNlcnZpY2UgPSByZXF1aXJlKCdwdWxzZVNlcnZpY2UnKTtcbnZhciBldmVudEJ1cyA9IHJlcXVpcmUoJ2V2ZW50QnVzJyk7XG52YXIgcHVsc2VSYW5nZSA9IHJlcXVpcmUoJ3B1bHNlUmFuZ2UnKTtcblxuLyoqXG4gKiBCdWlsZCBhIGN1c3RvbSB0YWcgPHgtbW9kaWZpY2F0aW9ubWFuYWdlcj4gd2l0aCAwIGF0dHJpYnV0ZVxuICovXG4oZnVuY3Rpb24gKCkge1xuXG4gIGNsYXNzIFNpbmdsZU1vZGlmaWNhdGlvbiB7XG4gICAgLyoqXG4gICAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAgICogQHBhcmFtIHttb2RpZn0gPT0gcmV2aXNpb25pZCxyYW5nZSxraW5kLG1hY2hpbmVpZCxpbml0TW9kaWZpY2F0aW9ucyxwZW5kaW5nTW9kaWZpY2F0aW9uc31cbiAgICAgICAqIEBwYXJhbSB7bW9kaWZpY2F0aW9uTWFuYWdlcn0gPT0gcGFyZW50XG4gICAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RpZiwgbW9kaWZpY2F0aW9uTWFuYWdlciwgcGF0aCkge1xuICAgICAgdGhpcy5tb2RpZiA9IG1vZGlmO1xuICAgICAgdGhpcy5fbW9kaWZpY2F0aW9uTWFuYWdlciA9IG1vZGlmaWNhdGlvbk1hbmFnZXI7XG4gICAgICB0aGlzLl9wYXRoID0gcGF0aDtcblxuICAgICAgdGhpcy5fcG9zc2libGVOYkZhaWxzID0gMTUwOyAvLyA9PSAxNTAgc2Vjb25kcyBiZWZvcmUgaWdub3JpbmcgaW4gY2FzZSBvZiBlcnJvclxuICAgICAgdGhpcy5fcmVmcmVzaFJhdGUgPSAxMDAwOyAvLyAxIHNlY29uZFxuXG4gICAgICAvLyBsb2cgOiBORVcgbW9kaWZpY2F0aW9uXG4gICAgICBjb25zb2xlLmxvZygnbW9kaWZpY2F0aW9ubWFuYWdlciA6IE5FVyAobWFjaD0nICsgbW9kaWYubWFjaGluZWlkXG4gICAgICAgICsgJyxraW5kPScgKyBtb2RpZi5raW5kICsgJyxyZXY9JyArIG1vZGlmLnJldmlzaW9uaWQpO1xuICAgICAgLy8rICcscmFuZ2U9JyArIHRoaXMubW9kaWYucmFuZ2VzWzBdOyAtPiBOTyBiZWNhdXNzZSByYW5nZS50b1N0cmluZyBpcyBiYWRseSBkZWZpbmVkXG5cbiAgICAgIC8vIFRlbGwgYWxsIHh0YWdzXG4gICAgICBldmVudEJ1cy5FdmVudEJ1cy5kaXNwYXRjaFRvQWxsKCdtb2RpZmljYXRpb25FdmVudCcsIG1vZGlmKTtcblxuICAgICAgdGhpcy5tZXRob2RzID0geyAvLyBUbyBwcmVwYXJlIGV4cG9ydFxuICAgICAgICBhZGRNb2RpZmljYXRpb246IHRoaXMuYWRkTW9kaWZpY2F0aW9uLFxuICAgICAgICBnZXRNb2RpZmljYXRpb25zOiB0aGlzLmdldE1vZGlmaWNhdGlvbnNcbiAgICAgIH07IFxuXG4gICAgICB0aGlzLl9hc2tXZWJTZXJ2aWNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAqIEFzayB3ZWIgc2VydmljZSBmb3IgbW9kaWZpY2F0aW9uc1xuICAgKiBAcGFyYW0geyFPYmplY3R9IG1vZGlmIFxuICAgKi9cbiAgICBfYXNrV2ViU2VydmljZSAoKSB7XG4gICAgICBsZXQgdXJsID0gdGhpcy5fcGF0aFxuICAgICAgICArICdHZXRQZW5kaW5nTW9kaWZpY2F0aW9uc0Zyb21SZXZpc2lvbj9JZD0nICsgdGhpcy5tb2RpZi5yZXZpc2lvbmlkO1xuXG4gICAgICBsZXQgdGhpc01vZGlmID0gdGhpcztcbiAgICAgIHB1bHNlU2VydmljZS5ydW5BamF4U2ltcGxlKHVybCxcbiAgICAgICAgdGhpcy5fZ2V0UGVuZGluZ01vZGlmaWNhdGlvblN1Y2Nlc3MuYmluZCh0aGlzTW9kaWYpLFxuICAgICAgICB0aGlzLl9nZXRQZW5kaW5nTW9kaWZpY2F0aW9uRXJyb3IuYmluZCh0aGlzTW9kaWYpLFxuICAgICAgICB0aGlzLl9nZXRQZW5kaW5nTW9kaWZpY2F0aW9uRmFpbC5iaW5kKHRoaXNNb2RpZikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlYiBzZXJ2aWNlIC0gc3VjY2Vzc1xuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gZGF0YSBcbiAgICAgKi9cbiAgICBfZ2V0UGVuZGluZ01vZGlmaWNhdGlvblN1Y2Nlc3MgKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLm1vZGlmLmluaXRNb2RpZmljYXRpb25zID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1vZGlmLmluaXRNb2RpZmljYXRpb25zID0gZGF0YS5OdW1iZXI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tb2RpZi5wZW5kaW5nTW9kaWZpY2F0aW9ucyAhPSBkYXRhLk51bWJlcikge1xuICAgICAgICAvLyBsb2cgOiBtb2RpZmljYXRpb24gY2hhbmdlXG4gICAgICAgIGNvbnNvbGUubG9nKCdtb2RpZmljYXRpb25tYW5hZ2VyIDogQ0hBTkdFIHBlbmRpbmc9J1xuICAgICAgICAgICsgdGhpcy5tb2RpZi5wZW5kaW5nTW9kaWZpY2F0aW9ucyArICctPicgKyBkYXRhLk51bWJlclxuICAgICAgICAgICsgJyAvdG90YWw9JyArIHRoaXMubW9kaWYuaW5pdE1vZGlmaWNhdGlvbnNcbiAgICAgICAgICArICcgKG1hY2g9JyArIHRoaXMubW9kaWYubWFjaGluZWlkXG4gICAgICAgICAgKyAnLCBraW5kPScgKyB0aGlzLm1vZGlmLmtpbmQgKyAnLCByZXY9JyArIHRoaXMubW9kaWYucmV2aXNpb25pZCk7XG4gICAgICAgIC8vKyAnLHJhbmdlPScgKyB0aGlzLm1vZGlmLnJhbmdlc1swXTsgLT4gTk8gYmVjYXVzc2UgcmFuZ2UudG9TdHJpbmcgaXMgYmFkbHkgZGVmaW5lZFxuICAgICAgICB0aGlzLm1vZGlmLnBlbmRpbmdNb2RpZmljYXRpb25zID0gZGF0YS5OdW1iZXI7XG4gICAgICB9XG5cbiAgICAgIC8vICBBTFdBWVMgU2VuZCBNZXNzYWdlXG4gICAgICBldmVudEJ1cy5FdmVudEJ1cy5kaXNwYXRjaFRvQWxsKCdtb2RpZmljYXRpb25FdmVudCcsIHRoaXMubW9kaWYpO1xuXG4gICAgICAvLyBSZS1zdGFydCB0aW1lclxuICAgICAgaWYgKGRhdGEuTnVtYmVyID09IDApIHsgLy8gTm8gbW9yZSBtb2RpZlxuICAgICAgICAvLyBLaWxsIG1lXG4gICAgICAgIHRoaXMuX21vZGlmaWNhdGlvbk1hbmFnZXIucmVtb3ZlTW9kaWZpY2F0aW9uKHRoaXMubW9kaWYucmV2aXNpb25pZCk7XG4gICAgICAgIC8vIGxvZyA6IGVuZCBvZiBtb2RpZmljYXRpb25cbiAgICAgICAgY29uc29sZS5sb2coJ21vZGlmaWNhdGlvbm1hbmFnZXIgOiBFTkQgKG1hY2g9JyArIHRoaXMubW9kaWYubWFjaGluZWlkXG4gICAgICAgICAgKyAnLGtpbmQ9JyArIHRoaXMubW9kaWYua2luZCArICcscmV2PScgKyB0aGlzLm1vZGlmLnJldmlzaW9uaWQpO1xuICAgICAgICAvLysgJyxyYW5nZT0nICsgdGhpcy5tb2RpZi5yYW5nZXNbMF07IC0+IE5PIGJlY2F1c3NlIHJhbmdlLnRvU3RyaW5nIGlzIGJhZGx5IGRlZmluZWRcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAvLyBDb250aW51ZSBtb2RpZlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLl9hc2tXZWJTZXJ2aWNlKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSwgdGhpcy5fcmVmcmVzaFJhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFxuICAgIF9nZXRQZW5kaW5nTW9kaWZpY2F0aW9uRXJyb3IgKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9wb3NzaWJsZU5iRmFpbHMgPD0gMCkge1xuICAgICAgICAvLyBLaWxsIG1lXG4gICAgICAgIHRoaXMuX21vZGlmaWNhdGlvbk1hbmFnZXIucmVtb3ZlTW9kaWZpY2F0aW9uKHRoaXMubW9kaWYucmV2aXNpb25pZCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcG9zc2libGVOYkZhaWxzLS07XG4gICAgICAgIC8vIFJlc3RhcnQgdGltZXJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fYXNrV2ViU2VydmljZSgpO1xuICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMuX3JlZnJlc2hSYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2ViIHNlcnZpY2UgLSBlcnJvciBPUiBmYWlsXG4gICAgICogQHBhcmFtIHshU3RyaW5nfSB1cmwgXG4gICAgICogQHBhcmFtIHshQm9vbGVhbn0gaXNUaW1lb3V0LCBcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IHhoclN0YXR1cyBcbiAgICAgKi9cbiAgICBfZ2V0UGVuZGluZ01vZGlmaWNhdGlvbkZhaWwgKHVybCwgaXNUaW1lb3V0LCB4aHJTdGF0dXMpIHtcbiAgICAgIGlmICh0aGlzLl9wb3NzaWJsZU5iRmFpbHMgPD0gMCkge1xuICAgICAgICAvLyBLaWxsIG1lXG4gICAgICAgIHRoaXMuX21vZGlmaWNhdGlvbk1hbmFnZXIucmVtb3ZlTW9kaWZpY2F0aW9uKHRoaXMubW9kaWYucmV2aXNpb25pZCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fcG9zc2libGVOYkZhaWxzLS07XG4gICAgICAgIC8vIFJlc3RhcnQgdGltZXJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5fYXNrV2ViU2VydmljZSgpO1xuICAgICAgICB9LmJpbmQodGhpcyksIHRoaXMuX3JlZnJlc2hSYXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSAvLyBlbmQgY2xhc3MgU2luZ2xlTW9kaWZpY2F0aW9uXG5cblxuICBjbGFzcyBNb2RpZmljYXRpb25NYW5hZ2VyQ29tcG9uZW50IGV4dGVuZHMgcHVsc2VDb21wb25lbnQuUHVsc2VQYXJhbUluaXRpYWxpemVkQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBjb25zdCBzZWxmID0gc3VwZXIoLi4uYXJncyk7XG5cbiAgICAgIHNlbGYubWV0aG9kcyA9IHtcbiAgICAgICAgYWRkTW9kaWZpY2F0aW9uOiBzZWxmLmFkZE1vZGlmaWNhdGlvbixcbiAgICAgICAgZ2V0TW9kaWZpY2F0aW9uczogc2VsZi5nZXRNb2RpZmljYXRpb25zXG4gICAgICB9O1xuXG4gICAgICAvLyBNYXAgW3JldmlzaW9uaWRdID0gU2luZ2xlTW9kaWZpY2F0aW9uXG4gICAgICAvLyBIb3cgdG8gdXNlIG1hcCA6IGh0dHBzOi8vd3d3LnplbmRldnMueHl6L2xlcy1ub3V2ZWF1eC1vYmpldHMtc2V0LWV0LW1hcC1lbi1qYXZhc2NyaXB0LWVzNi9cbiAgICAgIHNlbGYuX21hcE9mTW9kaWZpY2F0aW9ucyA9IG5ldyBNYXAoKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZFdoZW5Db25uZWN0ZWRPbmNlIChhdHRyLCBvbGRWYWwsIG5ld1ZhbCkge1xuICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZFdoZW5Db25uZWN0ZWRPbmNlKGF0dHIsIG9sZFZhbCwgbmV3VmFsKTtcbiAgICB9XG5cbiAgICBpbml0aWFsaXplICgpIHtcbiAgICAgIC8vIEF0dHJpYnV0ZXNcbiAgICAgIC8vIExpc3RlbmVyIGFuZCBkaXNwYXRjaGVyc1xuXG4gICAgICAvLyBJbiBjYXNlIG9mIGNsb25lLCBuZWVkIHRvIGJlIGVtcHR5IDpcbiAgICAgICQodGhpcy5lbGVtZW50KS5lbXB0eSgpO1xuXG4gICAgICAvLyBDcmVhdGUgTk8gRE9NIC0+IHJldmlzaW9ucHJvZ3Jlc3MuLi4gd2lsbCBkaXNwbGF5IGlmIG5lZWRlZFxuXG4gICAgICAvLyBJbml0aWFsaXphdGlvbiBPSyA9PiBzd2l0Y2ggdG8gdGhlIG5leHQgY29udGV4dFxuICAgICAgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJJbml0aWFsaXphdGlvbiAoKSB7XG4gICAgICBzdXBlci5jbGVhckluaXRpYWxpemF0aW9uKCk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQYXJhbWV0ZXJzICgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgY2hlY2tzIHdpdGggYXR0cmlidXRlIHBhcmFtXG5cbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgIH1cblxuICAgIGRpc3BsYXlFcnJvciAobWVzc2FnZSkge1xuICAgICAgLy8gTm90aGluZ1xuICAgIH1cblxuICAgIHJlbW92ZUVycm9yICgpIHtcbiAgICAgIC8vIE5vdGhpbmdcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEFkZCBhIG1vZGlmaWNhdGlvbiB0byBjaGVjayAtIHByaXZhdGUgbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFpbnRlZ2VyfSByZXZpc2lvbmlkIC0gSWQgb2YgdGhlIHJldmlzaW9uIChhY2Nlc3MgdG8gbW9kaWZpY2F0aW9ucyBpbiBkYXRhYmFzZSlcbiAgICAgKiBAcGFyYW0geyFpbnRlZ2VyfSBraW5kIC0gY2FuIGJlICdyZWFzb24nLCAnTVNUJywgJ3NlcmlhbG51bWJlcicuLi5cbiAgICAgKiBAcGFyYW0geyFpbnRlZ2VyfSBtYWNoaW5laWRcbiAgICAgKiBAcGFyYW0geyFbcHVsc2VSYW5nZTpSYW5nZV19IGFycmF5b2ZwdWxzZVJhbmdlIC0gUmFuZ2Ugb2YgdGhlIG1vZGlmaWNhdGlvblxuICAgICAqIEByZXR1cm5zIHshQm9vbGVhbn0gdHJ1ZSA9IHN1Y2Nlc3NcbiAgICAgKi9cbiAgICBhZGRNb2RpZmljYXRpb24gKHJldmlzaW9uaWQsIGtpbmQsIG1hY2hpbmVpZCwgYXJyYXlPZlB1bHNlUmFuZ2VzKSB7XG4gICAgICBsZXQgbW9kaWYgPSB7XG4gICAgICAgIHJldmlzaW9uaWQ6IHJldmlzaW9uaWQsXG4gICAgICAgIG1hY2hpbmVpZDogbWFjaGluZWlkLFxuICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICByYW5nZXM6IGFycmF5T2ZQdWxzZVJhbmdlcyxcbiAgICAgICAgaW5pdE1vZGlmaWNhdGlvbnM6IHVuZGVmaW5lZCwgLy8gcGVuZGluZyBtb2RpZmljYXRpb25zIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgIHBlbmRpbmdNb2RpZmljYXRpb25zOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBsZXQgc2luZ2xlTW9kaWYgPSBuZXcgU2luZ2xlTW9kaWZpY2F0aW9uKG1vZGlmLCB0aGlzLCB0aGlzLmdldENvbmZpZ09yQXR0cmlidXRlKCdwYXRoJywgJycpKTtcbiAgICAgIHRoaXMuX21hcE9mTW9kaWZpY2F0aW9ucy5zZXQocmV2aXNpb25pZCwgc2luZ2xlTW9kaWYpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbW9kaWZpY2F0aW9uIFxuICAgICAqXG4gICAgICogQHBhcmFtIHshaW50ZWdlcn0gcmV2aXNpb25pZCAtIElkIG9mIHRoZSByZXZpc2lvbiAoYWNjZXNzIHRvIG1vZGlmaWNhdGlvbnMgaW4gZGF0YWJhc2UpXG4gICAgICogQHJldHVybnMgeyFCb29sZWFufSB0cnVlID0gc3VjY2Vzc1xuICAgICAqL1xuICAgIHJlbW92ZU1vZGlmaWNhdGlvbiAocmV2aXNpb25pZCkge1xuICAgICAgdGhpcy5fbWFwT2ZNb2RpZmljYXRpb25zLmRlbGV0ZShyZXZpc2lvbmlkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBleGlzdGluZyBtb2RpZmljYXRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFpbnRlZ2VyfSBraW5kIC0gY2FuIGJlICdyZWFzb24nLCAnbW9zJywgJ3NlcmlhbG51bWJlcicuLi5cbiAgICAgKiBAcGFyYW0geyFpbnRlZ2VyfSBtYWNoaW5laWRcbiAgICAgKiBAcGFyYW0geyFwdWxzZVJhbmdlOlJhbmdlfSByYW5nZSAtIG9wdGlvbmFsIHJhbmdlIChtb2RpZi5yYW5nZXNbaV0gc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoaXMgcmFuZ2UpXG4gICAgICogQHJldHVybnMgeyFPYmplY3R9IGxpc3Qgb2YgbW9kaWZpY2F0aW9uc1xuICAgICAqL1xuICAgIGdldE1vZGlmaWNhdGlvbnMgKGtpbmQsIG1hY2hpbmVpZCwgcmFuZ2UpIHtcbiAgICAgIGxldCByZXR1cm5lZE1hcCA9IG5ldyBNYXAoKTtcblxuICAgICAgZm9yIChsZXQgbW9kaWYgb2YgdGhpcy5fbWFwT2ZNb2RpZmljYXRpb25zKSB7XG4gICAgICAgIGlmICgobW9kaWZbMV0ubW9kaWYua2luZCA9PSBraW5kKVxuICAgICAgICAgICYmIChtb2RpZlsxXS5tb2RpZi5tYWNoaW5laWQgPT0gbWFjaGluZWlkKSkge1xuICAgICAgICAgIGxldCBhZGRNb2RpZiA9IGZhbHNlO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kaWZbMV0ubW9kaWYucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKHB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQocmFuZ2UpXG4gICAgICAgICAgICAgIHx8ICEocHVsc2VSYW5nZS5pbnRlcnNlY3RzKG1vZGlmWzFdLm1vZGlmLnJhbmdlc1tpXSwgcmFuZ2UpKS5pc0VtcHR5KCkpKSB7XG4gICAgICAgICAgICAgIGFkZE1vZGlmID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFkZE1vZGlmKVxuICAgICAgICAgICAgcmV0dXJuZWRNYXAuc2V0KG1vZGlmWzBdLCBtb2RpZlsxXS5tb2RpZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXR1cm5lZE1hcDtcbiAgICB9XG5cbiAgICAvLyBDYWxsYmFjayBldmVudHNcbiAgICAvKipcbiAgICAgKiBFdmVudCBjYWxsYmFjayBpbiBjYXNlIGEgY29uZmlnIGlzIHVwZGF0ZWQ6IChyZS0pc3RhcnQgdGhlIGNvbXBvbmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBldmVudFxuICAgICAqL1xuICAgIG9uQ29uZmlnQ2hhbmdlIChldmVudCkge1xuICAgICAgLy8gRGVmYXVsdCA9IGRvIG5vdGhpbmdcbiAgICB9XG4gIH1cblxuICBwdWxzZUNvbXBvbmVudC5yZWdpc3RlckVsZW1lbnQoJ3gtbW9kaWZpY2F0aW9ubWFuYWdlcicsIE1vZGlmaWNhdGlvbk1hbmFnZXJDb21wb25lbnQpO1xufSkoKTtcbiIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4vKipcbiAqIEBtb2R1bGUgeC1yZXBvcnRkYXRldGltZVxuICogQHJlcXVpcmVzIG1vZHVsZTpwdWxzZUNvbXBvbmVudFxuICogXG4gKi9cbnZhciBwdWxzZUNvbXBvbmVudCA9IHJlcXVpcmUoJ3B1bHNlY29tcG9uZW50Jyk7XG52YXIgcHVsc2VSYW5nZSA9IHJlcXVpcmUoJ3B1bHNlUmFuZ2UnKTtcbnZhciBwdWxzZVV0aWxpdHkgPSByZXF1aXJlKCdwdWxzZVV0aWxpdHknKTtcblxucmVxdWlyZSgneC1kYXRlcGlja2VyL3gtZGF0ZXBpY2tlcicpO1xucmVxdWlyZSgneC1kYXRldGltZXBpY2tlci94LWRhdGV0aW1lcGlja2VyJyk7XG5cbi8qKlxuICogQnVpbGQgYSBjdXN0b20gdGFnIDx4LXJlcG9ydGRhdGV0aW1lPlxuICogVXNlZCBieSByZXBvcnQgd2ViIGFwcFxuICogXG4gKiBQYXJhbWV0ZXJzIDpcbiAqIGdyb3VwRGlzcGxheUZvcm0gPSBEQVRFUkFOR0VcbiAqIGdyb3VwTmFtZS4gZXggPSBcbiAqIGRhdGFUeXBlID0gREFURSBvciBEQVRFVElNRVxuICogd2ViYXBwLiBFeCA6IExhc3RfMV9kYXkgSU5cbiAqIHdlYmFwcG5hbWUgSU5cbiAqIG1pbmRhdGUgSU5cbiAqIG1pbmRhdGVuYW1lIElOXG4gKiBtYXhkYXRlIElOXG4gKiBtYXhkYXRlbmFtZSBJTlxuICovXG5cbihmdW5jdGlvbiAoKSB7XG5cbiAgY2xhc3MgUmVwb3J0RGF0ZVRpbWVDb21wb25lbnQgZXh0ZW5kcyBwdWxzZUNvbXBvbmVudC5QdWxzZVBhcmFtQXV0b1BhdGhTaW5nbGVSZXF1ZXN0Q29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIFxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJncyBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBjb25zdCBzZWxmID0gc3VwZXIoLi4uYXJncyk7XG5cbiAgICAgIHNlbGYuX2NvbnRlbnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHNlbGYubWV0aG9kcyA9IHtcbiAgICAgICAgaXNWYWxpZDogc2VsZi5pc1ZhbGlkLFxuICAgICAgICBnZXRWYWx1ZUFzSXM6IHNlbGYuZ2V0VmFsdWVBc0lzLFxuICAgICAgICBnZXRNaW5WYWx1ZUFzSXM6IHNlbGYuZ2V0TWluVmFsdWVBc0lzLFxuICAgICAgICBnZXRNYXhWYWx1ZUFzSXM6IHNlbGYuZ2V0TWF4VmFsdWVBc0lzLFxuICAgICAgICBnZXRXZWJBcHBSYW5nZTogc2VsZi5nZXRXZWJBcHBSYW5nZVxuICAgICAgICAvLyxnZXRXZWJBcHBSYW5nZUZyb21NaW5NYXg6IHNlbGYuZ2V0V2ViQXBwUmFuZ2VGcm9tTWluTWF4IC8vIHN0YXRpY1xuICAgICAgfTtcblxuICAgICAgLy8gRE9NOiBuZXZlciBpbiBjb25zdHJ1Y3RvciwgdXNlIHRoZSBpbml0aWFsaXplIG1ldGhvZCBpbnN0ZWFkXG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIC8vZ2V0IGNvbnRlbnQgKCkgeyByZXR1cm4gdGhpcy5fY29udGVudDsgfSAvLyBPcHRpb25hbFxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZFdoZW5Db25uZWN0ZWRPbmNlIChhdHRyLCBvbGRWYWwsIG5ld1ZhbCkge1xuICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZFdoZW5Db25uZWN0ZWRPbmNlKGF0dHIsIG9sZFZhbCwgbmV3VmFsKTtcbiAgICAgIHN3aXRjaCAoYXR0cikge1xuICAgICAgICBjYXNlICdncm91cERpc3BsYXlGb3JtJzpcbiAgICAgICAgICB0aGlzLnN0YXJ0KCk7IC8vIHJlc3RhcnQgdGhlIGNvbXBvbmVudC4gPT0gdmFsaWRhdGUgKyBzZW5kIGFqYXggcmVxdWVzdFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdncm91cE5hbWUnOlxuICAgICAgICAgIHRoaXMuc3RhcnQoKTsgLy8gcmVzdGFydCB0aGUgY29tcG9uZW50LiA9PSB2YWxpZGF0ZSArIHNlbmQgYWpheCByZXF1ZXN0XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RhdGFUeXBlJzpcbiAgICAgICAgICB0aGlzLnJlc2V0KCk7IC8vIENhbGwgaW5pdGlhbGl6ZSBhZ2FpblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd3ZWJhcHAnOlxuICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbkZyb21XZWJBcHAobmV3VmFsKTtcbiAgICAgICAgICAvLyBzaG93IC8gaGlkZSBpcyBkb25lIGJ5IGNoYW5nZSBzZWxlY3Rpb24gLSBub3QgbmVlZGVkIGhlcmVcbiAgICAgICAgICAvL3RoaXMuc3RhcnQoKTsgLy8gdmFsaWRhdGUgKyBzZW5kIGFqYXggcmVxdWVzdCB3aGVuIG5lZWRlZCAtIGRvbmUgYnkgY2hhbmdlIHNlbGVjdGlvblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtaW5kYXRlJzoge1xuICAgICAgICAgIGxldCBpc0RhdGVUaW1lID0gKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGFUeXBlJykgPT0gJ0RBVEVUSU1FJyk7XG4gICAgICAgICAgJCh0aGlzLl9taW5EVFApLmF0dHIoaXNEYXRlVGltZSA/ICdkZWZhdWx0ZGF0ZXRpbWUnIDogJ2RlZmF1bHRkYXRlJywgbmV3VmFsKTtcbiAgICAgICAgfSBicmVhaztcbiAgICAgICAgY2FzZSAnbWF4ZGF0ZSc6IHtcbiAgICAgICAgICBsZXQgaXNEYXRlVGltZSA9ICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhVHlwZScpID09ICdEQVRFVElNRScpO1xuICAgICAgICAgICQodGhpcy5fbWF4RFRQKS5hdHRyKGlzRGF0ZVRpbWUgPyAnZGVmYXVsdGRhdGV0aW1lJyA6ICdkZWZhdWx0ZGF0ZScsIG5ld1ZhbCk7XG4gICAgICAgIH0gYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3NldFNlbGVjdGlvbkZyb21XZWJBcHAgKHZhbCkge1xuICAgICAgLy8gc2hvdyAvIGhpZGUgaXMgZG9uZSBieSBjaGFuZ2Ugc2VsZWN0aW9uIC0gbm90IG5lZWRlZCBoZXJlXG5cbiAgICAgIGxldCBpc0RhdGVUaW1lID0gKHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGFUeXBlJykgPT0gJ0RBVEVUSU1FJyk7XG4gICAgICBsZXQgcGFydHMgPSB2YWwuc3BsaXQoXCJfXCIpO1xuICAgICAgdGhpcy5fc2VsZWN0VHlwZUNCKHBhcnRzWzBdKTtcbiAgICAgIHN3aXRjaCAocGFydHNbMF0pIHtcbiAgICAgICAgY2FzZSAoJ3NpbmNlJyk6IHtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICQodGhpcy5fbWluRFRQKS5hdHRyKGlzRGF0ZVRpbWUgPyAnZGVmYXVsdGRhdGV0aW1lJyA6ICdkZWZhdWx0ZGF0ZScsIHBhcnRzWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gYnJlYWs7XG4gICAgICAgIGNhc2UgKCdwYXN0Jyk6IHtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICQodGhpcy5fcGFzdE5iKVswXS52YWx1ZSA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0UGFzdENCKHBhcnRzWzJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gYnJlYWs7XG4gICAgICAgIGNhc2UgKCdjdXJyZW50Jyk6IHtcbiAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdEN1cnJlbnRDQihwYXJ0c1sxXSArICdfJyArIHBhcnRzWzJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gYnJlYWs7XG4gICAgICAgIGNhc2UgKCdleHBsaWNpdCcpOiB7XG4gICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICAgICAgICAkKHRoaXMuX21pbkRUUCkuYXR0cihpc0RhdGVUaW1lID8gJ2RlZmF1bHRkYXRldGltZScgOiAnZGVmYXVsdGRhdGUnLCBwYXJ0c1sxXSk7XG4gICAgICAgICAgICAkKHRoaXMuX21heERUUCkuYXR0cihpc0RhdGVUaW1lID8gJ2RlZmF1bHRkYXRldGltZScgOiAnZGVmYXVsdGRhdGUnLCBwYXJ0c1syXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgeyAvLyBFeGVtcGxlIDogaW4gcmVwb3J0IG1hZGUgZnJvbSBhbm90aGVyIHJlcG9ydFxuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ21pbmRhdGUnKSkge1xuICAgICAgICAgICAgICAkKHRoaXMuX21pbkRUUCkuYXR0cihpc0RhdGVUaW1lID8gJ2RlZmF1bHRkYXRldGltZScgOiAnZGVmYXVsdGRhdGUnLFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21pbmRhdGUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbWF4ZGF0ZScpKSB7XG4gICAgICAgICAgICAgICQodGhpcy5fbWF4RFRQKS5hdHRyKGlzRGF0ZVRpbWUgPyAnZGVmYXVsdGRhdGV0aW1lJyA6ICdkZWZhdWx0ZGF0ZScsXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWF4ZGF0ZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gYnJlYWs7XG4gICAgICAgIC8vIE5ldmVyIGRlZmF1bHQgPyBOTyAhISEgQ2FuIGhhcHBlbiB3aGVuIG1pbiBhbmQgbWF4IGFyZSBnaXZlbiArIGNoYW5nZSBwYXJhbWV0ZXJzXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbWluZGF0ZScpKSB7XG4gICAgICAgICAgICAkKHRoaXMuX21pbkRUUCkuYXR0cihpc0RhdGVUaW1lID8gJ2RlZmF1bHRkYXRldGltZScgOiAnZGVmYXVsdGRhdGUnLFxuICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtaW5kYXRlJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbWF4ZGF0ZScpKSB7XG4gICAgICAgICAgICAkKHRoaXMuX21heERUUCkuYXR0cihpc0RhdGVUaW1lID8gJ2RlZmF1bHRkYXRldGltZScgOiAnZGVmYXVsdGRhdGUnLFxuICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtYXhkYXRlJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRDaGFuZ2VTZWwgKCkge1xuICAgICAgdGhpcy5fdHlwZVNlbGVjdENCWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25DaGFuZ2VTZWwuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgdGhpcy5fcGFzdE5iWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25DaGFuZ2VTZWwuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgdGhpcy5fcGFzdFVuaXRDQlswXS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlU2VsLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDQlswXS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlU2VsLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICB9XG5cbiAgICBfc2VsZWN0SXRlbUJ5VmFsdWUgKGVsbW50LCB2YWx1ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbG1udC5vcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlbG1udC5vcHRpb25zW2ldLnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgIGVsbW50LnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9zZWxlY3RUeXBlQ0IgKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZWxlY3RJdGVtQnlWYWx1ZSh0aGlzLl90eXBlU2VsZWN0Q0JbMF0sIHZhbHVlKTtcbiAgICB9XG4gICAgX3NlbGVjdFBhc3RDQiAodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NlbGVjdEl0ZW1CeVZhbHVlKHRoaXMuX3Bhc3RVbml0Q0JbMF0sIHZhbHVlKTtcbiAgICB9XG4gICAgX3NlbGVjdEN1cnJlbnRDQiAodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NlbGVjdEl0ZW1CeVZhbHVlKHRoaXMuX2N1cnJlbnRDQlswXSwgdmFsdWUpO1xuICAgIH1cblxuXG4gICAgX2ZpbGxUeXBlQ0IgKCkge1xuICAgICAgLy8gQ29tYm9ib3hcbiAgICAgICQodGhpcy5fdHlwZVNlbGVjdENCKS5lbXB0eSgpO1xuXG4gICAgICBsZXQgb3B0aW9uQ0IgPSAkKCc8b3B0aW9uIHZhbHVlPWV4cGxpY2l0Pjwvb3B0aW9uPicpLmh0bWwoXCJGcm9tLi4uIHRvLi4uXCIpO1xuICAgICAgdGhpcy5fdHlwZVNlbGVjdENCLmFwcGVuZChvcHRpb25DQik7XG4gICAgICBvcHRpb25DQiA9ICQoJzxvcHRpb24gdmFsdWU9c2luY2U+PC9vcHRpb24+JykuaHRtbChcIlNpbmNlLi4uXCIpO1xuICAgICAgdGhpcy5fdHlwZVNlbGVjdENCLmFwcGVuZChvcHRpb25DQik7XG4gICAgICBvcHRpb25DQiA9ICQoJzxvcHRpb24gdmFsdWU9cGFzdD48L29wdGlvbj4nKS5odG1sKFwiUGFzdFwiKTtcbiAgICAgIHRoaXMuX3R5cGVTZWxlY3RDQi5hcHBlbmQob3B0aW9uQ0IpO1xuICAgICAgb3B0aW9uQ0IgPSAkKCc8b3B0aW9uIHZhbHVlPWN1cnJlbnQ+PC9vcHRpb24+JykuaHRtbChcIkN1cnJlbnRcIik7XG4gICAgICB0aGlzLl90eXBlU2VsZWN0Q0IuYXBwZW5kKG9wdGlvbkNCKTtcbiAgICB9XG5cbiAgICBfZmlsbFBhc3RDQiAoKSB7XG4gICAgICAvLyBDb21ib2JveFxuICAgICAgJCh0aGlzLl9wYXN0VW5pdENCKS5lbXB0eSgpO1xuXG4gICAgICBsZXQgb3B0aW9uQ0IgPSAkKCc8b3B0aW9uIHZhbHVlPWhvdXI+PC9vcHRpb24+JykuaHRtbChcImhvdXIocylcIilcbiAgICAgICAgLmFkZENsYXNzKCdoaWRlLWZvci1mdWxsLWRheScpO1xuICAgICAgdGhpcy5fcGFzdFVuaXRDQi5hcHBlbmQob3B0aW9uQ0IpO1xuICAgICAgb3B0aW9uQ0IgPSAkKCc8b3B0aW9uIHZhbHVlPXNoaWZ0Pjwvb3B0aW9uPicpLmh0bWwoXCJzaGlmdChzKVwiKVxuICAgICAgICAuYWRkQ2xhc3MoJ2hpZGUtZm9yLWZ1bGwtZGF5Jyk7XG4gICAgICB0aGlzLl9wYXN0VW5pdENCLmFwcGVuZChvcHRpb25DQik7XG4gICAgICBvcHRpb25DQiA9ICQoJzxvcHRpb24gdmFsdWU9ZGF5IHNlbGVjdGVkPjwvb3B0aW9uPicpLmh0bWwoXCJkYXkocylcIik7XG4gICAgICB0aGlzLl9wYXN0VW5pdENCLmFwcGVuZChvcHRpb25DQik7XG4gICAgICBvcHRpb25DQiA9ICQoJzxvcHRpb24gdmFsdWU9d2Vlaz48L29wdGlvbj4nKS5odG1sKFwid2VlayhzKVwiKTtcbiAgICAgIHRoaXMuX3Bhc3RVbml0Q0IuYXBwZW5kKG9wdGlvbkNCKTtcbiAgICAgIG9wdGlvbkNCID0gJCgnPG9wdGlvbiB2YWx1ZT1tb250aD48L29wdGlvbj4nKS5odG1sKFwibW9udGgocylcIik7XG4gICAgICB0aGlzLl9wYXN0VW5pdENCLmFwcGVuZChvcHRpb25DQik7XG4gICAgICBvcHRpb25DQiA9ICQoJzxvcHRpb24gdmFsdWU9cXVhcnRlcj48L29wdGlvbj4nKS5odG1sKFwicXVhcnRlcihzKVwiKTtcbiAgICAgIHRoaXMuX3Bhc3RVbml0Q0IuYXBwZW5kKG9wdGlvbkNCKTtcbiAgICAgIG9wdGlvbkNCID0gJCgnPG9wdGlvbiB2YWx1ZT15ZWFyPjwvb3B0aW9uPicpLmh0bWwoXCJ5ZWFyKHMpXCIpO1xuICAgICAgdGhpcy5fcGFzdFVuaXRDQi5hcHBlbmQob3B0aW9uQ0IpO1xuXG4gICAgICAvLyBSZW1vdmUgaG91cnMgYW5kIHNoaWZ0cyBpZiBkYXRlcyBhcmUgcmVxdWlyZWQgLT4gZG9uZSB1c2luZyBDU1MgIVxuICAgICAgLyppZiAoaXNEYXRlKSB7XG4gICAgICAgICQoXCIjV2ViQXBwUGFyYW1zRGF0ZVRpbWVfdW5pdCBvcHRpb25bdmFsdWU9J2hvdXInXVwiKS5yZW1vdmUoKTtcbiAgICAgICAgJChcIiNXZWJBcHBQYXJhbXNEYXRlVGltZV9kdXJhdGlvbiBvcHRpb25bdmFsdWU9JzFfaG91ciddXCIpLnJlbW92ZSgpO1xuICAgICAgICAkKFwiI1dlYkFwcFBhcmFtc0RhdGVUaW1lX3VuaXQgb3B0aW9uW3ZhbHVlPSdzaGlmdCddXCIpLnJlbW92ZSgpO1xuICAgICAgICAkKFwiI1dlYkFwcFBhcmFtc0RhdGVUaW1lX2R1cmF0aW9uIG9wdGlvblt2YWx1ZT0nMV9zaGlmdCddXCIpLnJlbW92ZSgpO1xuICAgICAgfSovXG4gICAgfVxuXG4gICAgX2ZpbGxDdXJyZW50Q0IgKCkge1xuICAgICAgLy8gQ29tYm9ib3hcbiAgICAgICQodGhpcy5fY3VycmVudENCKS5lbXB0eSgpO1xuXG4gICAgICBsZXQgb3B0aW9uQ0IgPSAkKCc8b3B0aW9uIHZhbHVlPTFfaG91cj48L29wdGlvbj4nKS5odG1sKFwiMSBob3VyXCIpXG4gICAgICAgIC5hZGRDbGFzcygnaGlkZS1mb3ItZnVsbC1kYXknKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDQi5hcHBlbmQob3B0aW9uQ0IpO1xuICAgICAgb3B0aW9uQ0IgPSAkKCc8b3B0aW9uIHZhbHVlPTFfc2hpZnQ+PC9vcHRpb24+JykuaHRtbChcIjEgc2hpZnRcIilcbiAgICAgICAgLmFkZENsYXNzKCdoaWRlLWZvci1mdWxsLWRheScpO1xuICAgICAgdGhpcy5fY3VycmVudENCLmFwcGVuZChvcHRpb25DQik7XG4gICAgICBvcHRpb25DQiA9ICQoJzxvcHRpb24gdmFsdWU9MV9kYXkgc2VsZWN0ZWQ+PC9vcHRpb24+JykuaHRtbChcInRvZGF5XCIpO1xuICAgICAgdGhpcy5fY3VycmVudENCLmFwcGVuZChvcHRpb25DQik7XG4gICAgICBvcHRpb25DQiA9ICQoJzxvcHRpb24gdmFsdWU9Ml9kYXk+PC9vcHRpb24+JykuaHRtbChcInRvZGF5ICsgeWVzdGVyZGF5XCIpO1xuICAgICAgdGhpcy5fY3VycmVudENCLmFwcGVuZChvcHRpb25DQik7XG4gICAgICBvcHRpb25DQiA9ICQoJzxvcHRpb24gdmFsdWU9MV93ZWVrPjwvb3B0aW9uPicpLmh0bWwoXCIxIHdlZWtcIik7XG4gICAgICB0aGlzLl9jdXJyZW50Q0IuYXBwZW5kKG9wdGlvbkNCKTtcbiAgICAgIG9wdGlvbkNCID0gJCgnPG9wdGlvbiB2YWx1ZT0yX3dlZWs+PC9vcHRpb24+JykuaHRtbChcIjEgd2Vla3NcIik7XG4gICAgICB0aGlzLl9jdXJyZW50Q0IuYXBwZW5kKG9wdGlvbkNCKTtcbiAgICAgIG9wdGlvbkNCID0gJCgnPG9wdGlvbiB2YWx1ZT0xX21vbnRoPjwvb3B0aW9uPicpLmh0bWwoXCIxIG1vbnRoXCIpO1xuICAgICAgdGhpcy5fY3VycmVudENCLmFwcGVuZChvcHRpb25DQik7XG4gICAgICBvcHRpb25DQiA9ICQoJzxvcHRpb24gdmFsdWU9MV9xdWFydGVyPjwvb3B0aW9uPicpLmh0bWwoXCIxIHF1YXJ0ZXJcIik7XG4gICAgICB0aGlzLl9jdXJyZW50Q0IuYXBwZW5kKG9wdGlvbkNCKTtcbiAgICAgIG9wdGlvbkNCID0gJCgnPG9wdGlvbiB2YWx1ZT0xX3llYXI+PC9vcHRpb24+JykuaHRtbChcIjEgeWVhclwiKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDQi5hcHBlbmQob3B0aW9uQ0IpO1xuXG4gICAgfVxuXG4gICAgLy8gcmV0dXJuIHZhbHVlIGlucHV0XG4gICAgaW5pdFBhcmFtRm9yUmVwb3J0IChkaXZUb0ZpbGwsIG5hbWUsIHBhcmFtZXRlcmtleSwgZGF0YVR5cGUsIHBhcmFtZXRlclR5cGUsXG4gICAgICBkZWZhdWx0VmFsdWUsIHZhbHVlLCByZXF1aXJlZCwgaGlkZGVuLCBoZWxwdGV4dCkge1xuICAgICAgJChkaXZUb0ZpbGwpLmFkZENsYXNzKCdwYXJhbWV0ZXInKTtcbiAgICAgICQoZGl2VG9GaWxsKS5hcHBlbmQoXCI8aW5wdXQgdHlwZT0naGlkZGVuJyBpZD0nbmFtZScgdmFsdWU9J1wiICsgbmFtZSArIFwiJyAvPlwiKTtcbiAgICAgICQoZGl2VG9GaWxsKS5hcHBlbmQoXCI8aW5wdXQgdHlwZT0naGlkZGVuJyBpZD0ncGFyYW1ldGVya2V5JyB2YWx1ZT0nXCIgKyBwYXJhbWV0ZXJrZXkgKyBcIicgLz5cIik7XG4gICAgICAkKGRpdlRvRmlsbCkuYXBwZW5kKFwiPGlucHV0IHR5cGU9J2hpZGRlbicgaWQ9J2RlZmF1bHR2YWx1ZScgdmFsdWU9J1wiICsgZGVmYXVsdFZhbHVlICsgXCInIC8+XCIpO1xuICAgICAgbGV0IHJldElucHV0ID0gJChcIjxpbnB1dCB0eXBlPSdoaWRkZW4nIGlkPSd2YWx1ZScgdmFsdWU9J1wiICsgdmFsdWUgKyBcIicgLz5cIik7XG4gICAgICAkKGRpdlRvRmlsbCkuYXBwZW5kKHJldElucHV0KTtcbiAgICAgICQoZGl2VG9GaWxsKS5hcHBlbmQoXCI8aW5wdXQgdHlwZT0naGlkZGVuJyBpZD0nZGF0YXR5cGUnIHZhbHVlPSdcIiArIGRhdGFUeXBlICsgXCInIC8+XCIpO1xuICAgICAgJChkaXZUb0ZpbGwpLmFwcGVuZChcIjxpbnB1dCB0eXBlPSdoaWRkZW4nIGlkPSdwYXJhbWV0ZXJ0eXBlJyB2YWx1ZT0nXCIgKyBwYXJhbWV0ZXJUeXBlICsgXCInIC8+XCIpO1xuICAgICAgJChkaXZUb0ZpbGwpLmFwcGVuZChcIjxpbnB1dCB0eXBlPSdoaWRkZW4nIGlkPSdyZXF1aXJlZCcgdmFsdWU9J1wiICsgcmVxdWlyZWQgKyBcIicgLz5cIik7XG4gICAgICAkKGRpdlRvRmlsbCkuYXBwZW5kKFwiPGlucHV0IHR5cGU9J2hpZGRlbicgaWQ9J2hlbHB0ZXh0JyB2YWx1ZT0nXCIgKyBoZWxwdGV4dCArIFwiJyAvPlwiKTtcbiAgICAgICQoZGl2VG9GaWxsKS5hcHBlbmQoXCI8aW5wdXQgdHlwZT0naGlkZGVuJyBpZD0naGlkZGVuJyB2YWx1ZT0nXCIgKyBoaWRkZW4gKyBcIicgLz5cIik7XG4gICAgICBpZiAocGFyYW1ldGVya2V5ID09ICdXRUJBUFAnKSB7XG4gICAgICAgICQoZGl2VG9GaWxsKS5hcHBlbmQoXCI8aW5wdXQgdHlwZT0naGlkZGVuJyBpZD0nd2lkZ2V0JyB2YWx1ZT0nVEVYVEJPWCcgLz5cIik7XG4gICAgICAgIHJldElucHV0ID0gJChcIjxpbnB1dCB0eXBlPSdoaWRkZW4nIGlkPSdcIiArIG5hbWUgKyBcIl92YWx1ZScgdmFsdWU9IC8+XCIpO1xuICAgICAgICAkKGRpdlRvRmlsbCkuYXBwZW5kKHJldElucHV0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRJbnB1dDtcbiAgICAgIC8qXG4gICAgICAgIDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgaWQ9XCJ3aWRnZXRcIiB2YWx1ZT1cIkRBVEVCT1hcIiAvPlxuICA8aW5wdXQgdHlwZT1cImhpZGRlblwiIGlkPVwibmFtZVwiIHZhbHVlPVwiJHtzY2FsYXJQYXJhbWV0ZXIubmFtZX1cIiAvPlxuICBcbiAgPHgtZGF0ZXBpY2tlciBpZD0nJHtzY2FsYXJQYXJhbWV0ZXIubmFtZX1fdmFsdWUnPjwveC1kYXRlcGlja2VyPlxuICAgICAgKi9cbiAgICB9XG5cbiAgICBpbml0aWFsaXplICgpIHtcbiAgICAgIHRoaXMuYWRkQ2xhc3MoJ3B1bHNlLXRleHQnKTsgLy8gTWFuZGF0b3J5IGZvciBsb2FkZXJcbiAgICAgIC8vcHVsc2UtdGV4dCAvIHB1bHNlLWljb24gLyBwdWxzZS1sYXN0YmFyIC8gcHVsc2Utc2xvdGJhciAvIHB1bHNlLXBpZWdhdWdlIC8gcHVsc2UtYmlnZGlzcGxheVxuXG4gICAgICAvLyBMaXN0ZW5lciBhbmQgZGlzcGF0Y2hlcnNcblxuICAgICAgLy8gSW4gY2FzZSBvZiBjbG9uZSwgbmVlZCB0byBiZSBlbXB0eSA6XG4gICAgICAkKHRoaXMuZWxlbWVudCkuZW1wdHkoKTtcblxuICAgICAgLy8gQ3JlYXRlIERPTSAtIENvbnRlbnQgLSBhZGRlZCBpbiBwYXJhbWV0ZXJHcm91cENvbnRlbnQgbm8tbGVmdC1ib3JkZXJcbiAgICAgIHRoaXMuX2NvbnRlbnQgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdwdWxzZS1yZXBvcnQtY29udGVudCcpO1xuICAgICAgJCh0aGlzLmVsZW1lbnQpXG4gICAgICAgIC5hZGRDbGFzcygncHVsc2UtcmVwb3J0LWRhdGV0aW1lJylcbiAgICAgICAgLmFwcGVuZCh0aGlzLl9jb250ZW50KTtcblxuICAgICAgbGV0IGlzRGF0ZVRpbWUgPSAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YVR5cGUnKSA9PSAnREFURVRJTUUnKTtcbiAgICAgIGlmIChpc0RhdGVUaW1lKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQuYWRkQ2xhc3MoJ3B1bHNlLXJlcG9ydC1pc2RhdGV0aW1lJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jb250ZW50LmFkZENsYXNzKCdwdWxzZS1yZXBvcnQtaXNkYXRlJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0IHJvdyAncHVsc2UtcmVwb3J0LWRhdGV0aW1lLW1haW4tc2VsLWRpdidcblxuICAgICAgLy8gZXhwbGljaXQgLyBzaW5jZSAvIHBhc3QgLyBjdXJyZW50XG4gICAgICB0aGlzLl90eXBlU2VsZWN0Q0IgPSAkKCc8c2VsZWN0IGNsYXNzPVwicHVsc2UtcmVwb3J0LWRhdGV0aW1lLXR5cGUtQ0JcIiA+PC9zZWxlY3Q+Jyk7XG4gICAgICB0aGlzLl9maWxsVHlwZUNCKCk7XG5cbiAgICAgIC8vIHBhc3QgZGV0YWlscyAtIGV4IDogMSArIGRheVxuICAgICAgdGhpcy5fcGFzdE5iID0gJCgnPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT1cIjFcIiBtaW49XCIxXCIgbWF4PVwiMzY1XCI+PC9pbnB1dD4nKVxuICAgICAgICAuYWRkQ2xhc3MoJ3B1bHNlLXJlcG9ydC1kYXRldGltZS1wYXN0LW51bWJlcicpO1xuICAgICAgdGhpcy5fcGFzdFVuaXRDQiA9ICQoJzxzZWxlY3Q+PC9zZWxlY3Q+JykuYWRkQ2xhc3MoJ3B1bHNlLXJlcG9ydC1kYXRldGltZS1wYXN0LXVuaXQtQ0InKTtcbiAgICAgIHRoaXMuX2ZpbGxQYXN0Q0IoKTtcblxuICAgICAgLy8gY3VycmVudCBkZXRhaWxzXG4gICAgICB0aGlzLl9jdXJyZW50Q0IgPSAkKCc8c2VsZWN0Pjwvc2VsZWN0PicpLmFkZENsYXNzKCdwdWxzZS1yZXBvcnQtZGF0ZXRpbWUtY3VycmVudC1DQicpO1xuICAgICAgdGhpcy5fZmlsbEN1cnJlbnRDQigpO1xuXG4gICAgICAvLyBXZWJBcHBQYXJhbXNEYXRlVGltZV9yb3cxXG4gICAgICBsZXQgdHlwZU1haW5TZWxEaXYgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdwdWxzZS1yZXBvcnQtZGF0ZXRpbWUtbWFpbi1zZWwtZGl2JylcbiAgICAgICAgLmFwcGVuZCh0aGlzLl90eXBlU2VsZWN0Q0IpLmFwcGVuZCh0aGlzLl9wYXN0TmIpLmFwcGVuZCh0aGlzLl9wYXN0VW5pdENCKS5hcHBlbmQodGhpcy5fY3VycmVudENCKTtcblxuICAgICAgJCh0aGlzLl9jb250ZW50KS5hcHBlbmQodHlwZU1haW5TZWxEaXYpO1xuXG4gICAgICAvLyBESVYgZm9yIG1pbiAvIG1heCAvIGxvYWRlciAvIGVycm9yIFxuICAgICAgbGV0IG1pbk1heERpdiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3B1bHNlLXJlcG9ydC1kYXRldGltZS1taW4tbWF4LWRpdicpO1xuXG4gICAgICAvLyBDcmVhdGUgRE9NIC0gTG9hZGVyXG4gICAgICBsZXQgbG9hZGVyID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygncHVsc2UtbG9hZGVyJykuaHRtbCgnTG9hZGluZy4uLicpLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICBsZXQgbG9hZGVyRGl2ID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygncHVsc2UtbG9hZGVyLWRpdicpLmFwcGVuZChsb2FkZXIpO1xuICAgICAgJChtaW5NYXhEaXYpLmFwcGVuZChsb2FkZXJEaXYpO1xuXG4gICAgICAvLyBDcmVhdGUgRE9NIC0gbWVzc2FnZSBmb3IgZXJyb3JcbiAgICAgIHRoaXMuX21lc3NhZ2VTcGFuID0gJCgnPHNwYW4+PC9zcGFuPicpLmFkZENsYXNzKCdwdWxzZS1tZXNzYWdlJykuaHRtbCgnJyk7XG4gICAgICBsZXQgbWVzc2FnZURpdiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3B1bHNlLW1lc3NhZ2UtZGl2JylcbiAgICAgICAgLmFwcGVuZCh0aGlzLl9tZXNzYWdlU3Bhbik7XG4gICAgICAkKG1pbk1heERpdikuYXBwZW5kKG1lc3NhZ2VEaXYpO1xuXG4gICAgICAvLyBNSU4gLyBNQVggLSBzYW1lIHBvc2l0aW9uIGFzIGxvYWRlciBBTkQgZXJyb3IgbWVzc2FnZSAtIFdlYkFwcFBhcmFtc0RhdGVUaW1lX3JvdzNcbiAgICAgIHRoaXMuX21pbkRUUCA9IHB1bHNlVXRpbGl0eS5jcmVhdGVqUXVlcnlFbGVtZW50V2l0aEF0dHJpYnV0ZShcbiAgICAgICAgaXNEYXRlVGltZSA/ICd4LWRhdGV0aW1lcGlja2VyJyA6ICd4LWRhdGVwaWNrZXInLCB7XG4gICAgICAgICdzaG93c2Vjb25kcyc6IFwidHJ1ZVwiXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fbWluRFRQLmFkZENsYXNzKCdwdWxzZS1yZXBvcnQtZGF0ZXRpbWUtbWluLURUUCcpO1xuICAgICAgLy8uYWRkQ2xhc3MoJ3BhcmFtZXRlcicpOyAvLyBVc2VkIGJ5IHJlcG9ydGluZyB0byByZXRyaWV2ZSBzY2FsYXJwYXJhbWV0ZXJcbiAgICAgIGxldCBtaW5EaXYgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdwdWxzZS1yZXBvcnQtZGF0ZXRpbWUtbWluLWRpdicpXG4gICAgICAgIC5hcHBlbmQodGhpcy5fbWluRFRQKTtcblxuICAgICAgdGhpcy5fbWF4RFRQID0gcHVsc2VVdGlsaXR5LmNyZWF0ZWpRdWVyeUVsZW1lbnRXaXRoQXR0cmlidXRlKFxuICAgICAgICBpc0RhdGVUaW1lID8gJ3gtZGF0ZXRpbWVwaWNrZXInIDogJ3gtZGF0ZXBpY2tlcicsIHtcbiAgICAgICAgJ3Nob3dzZWNvbmRzJzogXCJ0cnVlXCJcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fbWF4RFRQLmFkZENsYXNzKCdwdWxzZS1yZXBvcnQtZGF0ZXRpbWUtbWF4LURUUCcpO1xuICAgICAgLy8uYWRkQ2xhc3MoJ3BhcmFtZXRlcicpOyAvLyBVc2VkIGJ5IHJlcG9ydGluZyB0byByZXRyaWV2ZSBzY2FsYXJwYXJhbWV0ZXJcbiAgICAgIGxldCBtYXhEaXYgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdwdWxzZS1yZXBvcnQtZGF0ZXRpbWUtbWF4LWRpdicpXG4gICAgICAgIC5hcHBlbmQodGhpcy5fbWF4RFRQKTtcblxuICAgICAgbWluTWF4RGl2LmFwcGVuZChtaW5EaXYpLmFwcGVuZChtYXhEaXYpO1xuICAgICAgJCh0aGlzLl9jb250ZW50KS5hcHBlbmQobWluTWF4RGl2KTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSBsZWZ0IGJvcmRlciBvZiB0aGUgZ3JvdXBcbiAgICAgICQodGhpcy5lbGVtZW50KS5wYXJlbnQoKS5hZGRDbGFzcygnbm8tbGVmdC1ib3JkZXInKTtcblxuICAgICAgLy8gU2hvdyAvIEhpZGUgZm9yIGNvbnNpc3RhbmN5XG4gICAgICBsZXQgcmFuZ2VUeXBlID0gdGhpcy5fdHlwZVNlbGVjdENCWzBdLm9wdGlvbnNbdGhpcy5fdHlwZVNlbGVjdENCWzBdLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgdGhpcy5fc2hvd0hpZGUocmFuZ2VUeXBlKTtcblxuICAgICAgLy8gT24gY2hhbmdlIHNlbGVjdGlvbiA9PiBjaGFuZ2UgZGlzcGxheVxuICAgICAgdGhpcy5fc2V0Q2hhbmdlU2VsKCk7XG5cbiAgICAgIC8vIEdldCBBdHRyaWJ1dGVzID0+IGNoYW5nZSBzZWxlY3Rpb25cbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCd3ZWJhcHAnKSkge1xuICAgICAgICBsZXQgd2ViQXBwVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd3ZWJhcHAnKTtcbiAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uRnJvbVdlYkFwcCh3ZWJBcHBWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEhpZGRlbiBkaXYgZm9yIHJlcG9ydFxuICAgICAgbGV0IG1pblJlcG9ydERpdiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3B1bHNlLXJlcG9ydC1oaWRkZW4nKTtcbiAgICAgIHRoaXMuaW5pdFBhcmFtRm9yUmVwb3J0KG1pblJlcG9ydERpdixcbiAgICAgICAgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWluZGF0ZW5hbWUnKSwgJ01JTkRBVEUnLCAvLyBuYW1lLCBwYXJhbWV0ZXJrZXlcbiAgICAgICAgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YVR5cGUnKSwgLy8gZGF0YVR5cGUgPSAnREFURSc6J0RBVEVUSU1FJ1xuICAgICAgICAnU0lNUExFJywgJycsICcnLCAvLyAsIHBhcmFtZXRlclR5cGUsIGRlZmF1bHRWYWx1ZSwgdmFsdWUsIFxuICAgICAgICAnZmFsc2UnLCAnZmFsc2UnLCAnJyk7IC8vIHJlcXVpcmVkLCBoaWRkZW4sIGhlbHB0ZXh0XG4gICAgICBtaW5NYXhEaXYuYXBwZW5kKG1pblJlcG9ydERpdik7XG5cbiAgICAgIGxldCBtYXhSZXBvcnREaXYgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdwdWxzZS1yZXBvcnQtaGlkZGVuJyk7XG4gICAgICB0aGlzLmluaXRQYXJhbUZvclJlcG9ydChtYXhSZXBvcnREaXYsXG4gICAgICAgIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21heGRhdGVuYW1lJyksICdNQVhEQVRFJywgLy8gbmFtZSwgcGFyYW1ldGVya2V5XG4gICAgICAgIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGFUeXBlJyksIC8vIGRhdGFUeXBlID0gJ0RBVEUnOidEQVRFVElNRSdcbiAgICAgICAgJ1NJTVBMRScsICcnLCAnJywgLy8gcGFyYW1ldGVyVHlwZSwgZGVmYXVsdFZhbHVlLCB2YWx1ZSwgXG4gICAgICAgICdmYWxzZScsICdmYWxzZScsICcnKTsgLy8gcmVxdWlyZWQsIGhpZGRlbiwgaGVscHRleHRcbiAgICAgIG1pbk1heERpdi5hcHBlbmQobWF4UmVwb3J0RGl2KTtcblxuICAgICAgbGV0IHdlYmFwcFJlcG9ydERpdiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3B1bHNlLXJlcG9ydC1oaWRkZW4nKTtcbiAgICAgIHRoaXMuX3dlYkFwcFZhbHVlID0gdGhpcy5pbml0UGFyYW1Gb3JSZXBvcnQod2ViYXBwUmVwb3J0RGl2LFxuICAgICAgICB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd3ZWJhcHBuYW1lJyksICdXRUJBUFAnLCAvLyBuYW1lLCBwYXJhbWV0ZXJrZXlcbiAgICAgICAgJ1NUUklORycsIC8vIGRhdGFUeXBlXG4gICAgICAgICdTSU1QTEUnLCAnJywgJycsIC8vIHBhcmFtZXRlclR5cGUsIGRlZmF1bHRWYWx1ZSwgdmFsdWUsIFxuICAgICAgICAnZmFsc2UnLCAndHJ1ZScsICcnKTsgLy8gcmVxdWlyZWQsIGhpZGRlbiwgaGVscHRleHRcbiAgICAgIG1pbk1heERpdi5hcHBlbmQod2ViYXBwUmVwb3J0RGl2KTtcblxuICAgICAgLy8gSW5pdGlhbGl6YXRpb24gT0sgPT4gc3dpdGNoIHRvIHRoZSBuZXh0IGNvbnRleHRcbiAgICAgIHRoaXMuc3dpdGNoVG9OZXh0Q29udGV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgKiBDbGVhciBhbnl0aGluZyB0aGF0IHdhcyBkb25lIGR1cmluZyBpbnRpYWxpemF0aW9uLCBzbyB0aGF0IGluaXRpYWxpemUgY2FuIGJlIGNhbGxlZCBvbmNlIGFnYWluLlxuICAgICAgKiBSZW1vdmUgYWxsIHRoZSBkaXNwYXRjaGVycyBhbmQgbGlzdGVuZXJzLlxuICAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IG5vIHN0YXRlIHN3aXRjaCBpcyBkb25lIGhlcmVcbiAgICAqL1xuICAgIGNsZWFySW5pdGlhbGl6YXRpb24gKCkge1xuICAgICAgLy8gUGFyYW1ldGVyc1xuXG4gICAgICAvLyBET01cbiAgICAgICQodGhpcy5lbGVtZW50KS5lbXB0eSgpO1xuICAgICAgdGhpcy5fY29udGVudCA9IHVuZGVmaW5lZDtcblxuICAgICAgc3VwZXIuY2xlYXJJbml0aWFsaXphdGlvbigpO1xuICAgIH1cblxuICAgIHJlc2V0ICgpIHsgLy8gT3B0aW9uYWwgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIENvZGUgaGVyZSB0byBjbGVhbiB0aGUgY29tcG9uZW50IHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBpbml0aWFsaXplZCBmb3IgZXhhbXBsZSBhZnRlciBhIHBhcmFtZXRlciBjaGFuZ2VcbiAgICAgIHRoaXMucmVtb3ZlRXJyb3IoKTtcbiAgICAgIC8vIEVtcHR5IHRoaXMuX2NvbnRlbnRcblxuICAgICAgdGhpcy5zd2l0Y2hUb05leHRDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQYXJhbWV0ZXJzICgpIHtcbiAgICAgIGlmICghdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZ3JvdXBEaXNwbGF5Rm9ybScpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ21pc3NpbmcgYXR0cmlidXRlIGdyb3VwRGlzcGxheUZvcm0gaW4gcmVwb3J0ZGF0ZXRpbWUuZWxlbWVudCcpO1xuICAgICAgICAvLyBEZWxheWVkIGRpc3BsYXkgOlxuICAgICAgICAvL3RoaXMuc2V0RXJyb3IoJ21pc3NpbmcgZGlzcGxheSBmb3JtJyk7XG4gICAgICAgIC8vIG9yXG4gICAgICAgIC8vIEltbWVkaWF0IGRpc3BsYXkgOlxuICAgICAgICB0aGlzLnN3aXRjaFRvS2V5KCdFcnJvcicsICgpID0+IHRoaXMuZGlzcGxheUVycm9yKCdpbnZhbGlkIGdyb3VwRGlzcGxheUZvcm0nKSwgKCkgPT4gdGhpcy5yZW1vdmVFcnJvcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKCdncm91cE5hbWUnKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdtaXNzaW5nIGF0dHJpYnV0ZSBncm91cE5hbWUgaW4gcmVwb3J0ZGF0ZXRpbWUuZWxlbWVudCcpO1xuICAgICAgICAvLyBEZWxheWVkIGRpc3BsYXkgOlxuICAgICAgICAvL3RoaXMuc2V0RXJyb3IoJ21pc3NpbmcgZ3JvdXBOYW1lJyk7XG4gICAgICAgIC8vIG9yXG4gICAgICAgIC8vIEltbWVkaWF0IGRpc3BsYXkgOlxuICAgICAgICB0aGlzLnN3aXRjaFRvS2V5KCdFcnJvcicsICgpID0+IHRoaXMuZGlzcGxheUVycm9yKCdpbnZhbGlkIGdyb3VwTmFtZScpLCAoKSA9PiB0aGlzLnJlbW92ZUVycm9yKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGFUeXBlJykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignbWlzc2luZyBhdHRyaWJ1dGUgZGF0YVR5cGUgaW4gcmVwb3J0ZGF0ZXRpbWUuZWxlbWVudCcpO1xuICAgICAgICAvLyBEZWxheWVkIGRpc3BsYXkgOlxuICAgICAgICAvL3RoaXMuc2V0RXJyb3IoJ21pc3NpbmcgZGF0YVR5cGUnKTtcbiAgICAgICAgLy8gb3JcbiAgICAgICAgLy8gSW1tZWRpYXQgZGlzcGxheSA6XG4gICAgICAgIHRoaXMuc3dpdGNoVG9LZXkoJ0Vycm9yJywgKCkgPT4gdGhpcy5kaXNwbGF5RXJyb3IoJ2ludmFsaWQgZGF0YVR5cGUnKSwgKCkgPT4gdGhpcy5yZW1vdmVFcnJvcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN3aXRjaFRvTmV4dENvbnRleHQoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIG1hbmFnZUVycm9yIChkYXRhKSB7XG4gICAgICBzdXBlci5tYW5hZ2VFcnJvcihkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBtYW5hZ2VGYWlsdXJlIChpc1RpbWVvdXQsIHhoclN0YXR1cykge1xuICAgICAgc3VwZXIubWFuYWdlRmFpbHVyZShpc1RpbWVvdXQsIHhoclN0YXR1cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgZGlzcGxheUVycm9yICh0ZXh0KSB7XG4gICAgICBpZiAodHlwZW9mIHRleHQgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBObyBtZXNzYWdlIHRvIGRpc3BsYXksIGRvIG5vdCBkaXNwbGF5IGFueSBlcnJvclxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9tZXNzYWdlU3BhbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgJCh0aGlzLl9tZXNzYWdlU3BhbikuaHRtbCh0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVFcnJvciAoKSB7XG4gICAgICAvLyBDb2RlIGhlcmUgdG8gcmVtb3ZlIHRoZSBlcnJvciBtZXNzYWdlLiBPbmx5IHJlcXVpcmVkIGlmIGRpc3BsYXlFcnJvciBpcyBpbXBsZW1lbnRlZFxuICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICB0aGlzLmRpc3BsYXlFcnJvcignJyk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcmxvYWQgdG8gYWx3YXlzIHJlZnJlc2ggdmFsdWVcbiAgICBnZXQgaXNWaXNpYmxlICgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9zaG93SGlkZSAocmFuZ2VUeXBlKSB7XG5cbiAgICAgIGlmIChyYW5nZVR5cGUgPT0gJ3Bhc3QnKSB7XG4gICAgICAgIHRoaXMuX3Bhc3ROYi5zaG93KCk7XG4gICAgICAgIHRoaXMuX3Bhc3RVbml0Q0Iuc2hvdygpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3Bhc3ROYi5oaWRlKCk7XG4gICAgICAgIHRoaXMuX3Bhc3RVbml0Q0IuaGlkZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmFuZ2VUeXBlID09ICdjdXJyZW50Jykge1xuICAgICAgICB0aGlzLl9jdXJyZW50Q0Iuc2hvdygpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDQi5oaWRlKCk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAocmFuZ2VUeXBlKSB7XG4gICAgICAgIGNhc2UgKCdzaW5jZScpOiB7XG4gICAgICAgICAgLy8gb25seSBmcm9tIHZpc2libGUgKyBlbmFibGVkXG4gICAgICAgICAgLy8kKHRoaXMuX21pbkRUUCkuc2hvdygpO1xuICAgICAgICAgIC8vJCh0aGlzLl9taW5EVFApLmVuYWJsZSgpO1xuICAgICAgICAgIHRoaXMuX21pbkRUUC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcblxuICAgICAgICAgICQodGhpcy5fbWF4RFRQKS5oaWRlKCk7XG4gICAgICAgIH0gYnJlYWs7XG4gICAgICAgIGNhc2UgKCdleHBsaWNpdCcpOiB7XG4gICAgICAgICAgLy8gdmlzaWJsZSArIGVuYWJsZWRcbiAgICAgICAgICAkKHRoaXMuX21heERUUCkuc2hvdygpO1xuXG4gICAgICAgICAgLy8kKHRoaXMuX21pbkRUUCkuZW5hYmxlKCk7XG4gICAgICAgICAgdGhpcy5fbWluRFRQLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgICAgICAgIHRoaXMuX21heERUUC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcbiAgICAgICAgICAvLyQodGhpcy5fbWF4RFRQKS5lbmFibGUoKTtcbiAgICAgICAgfSBicmVhaztcbiAgICAgICAgY2FzZSAoJ2N1cnJlbnQnKTpcbiAgICAgICAgY2FzZSAoJ3Bhc3QnKTpcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIHZpc2libGUgKyBkaXNhYmxlZFxuICAgICAgICAgICAgJCh0aGlzLl9tYXhEVFApLnNob3coKTtcblxuICAgICAgICAgICAgdGhpcy5fbWluRFRQLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl9tYXhEVFAucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIC8vJCh0aGlzLl9taW5EVFApLmRpc2FibGUoKTtcbiAgICAgICAgICAgIC8vJCh0aGlzLl9tYXhEVFApLmRpc2FibGUoKTtcbiAgICAgICAgICB9IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3N0b3JlV2ViQXBwVmFsdWUgKCkge1xuICAgICAgbGV0IHdlYmFwcHJhbmdlID0gdGhpcy5nZXRXZWJBcHBSYW5nZSgpO1xuICAgICAgJCh0aGlzLl93ZWJBcHBWYWx1ZSkuYXR0cigndmFsdWUnLCB3ZWJhcHByYW5nZSk7XG4gICAgfVxuXG4gICAgLyoqIFJlcGxhY2UgX3J1bkFqYXhXaGVuSXNWaXNpYmxlIHdoZW4gTk8gdXJsIHNob3VsZCBiZSBjYWxsZWRcbiAgICAgKiAgcmV0dXJuIHRydWUgaWYgc29tZXRoaW5nIGlzIGRvbmUsIGZhbHNlIGlmIF9ydW5BamF4V2hlbklzVmlzaWJsZSBzaG91bGQgYmUgY2FsbGVkXG4gICAgICovXG4gICAgX3J1bkFsdGVybmF0ZUdldERhdGEgKCkge1xuICAgICAgbGV0IHJhbmdlVHlwZSA9IHRoaXMuX3R5cGVTZWxlY3RDQlswXS5vcHRpb25zW3RoaXMuX3R5cGVTZWxlY3RDQlswXS5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgIHRoaXMuX3Nob3dIaWRlKHJhbmdlVHlwZSk7IC8vIEFsd2F5cyBoZXJlXG5cbiAgICAgIGlmIChyYW5nZVR5cGUgPT0gJ2V4cGxpY2l0JyB8fCByYW5nZVR5cGUgPT0gJ3NpbmNlJykge1xuICAgICAgICB0aGlzLl9zdG9yZVdlYkFwcFZhbHVlKCk7XG4gICAgICAgIC8vIChfbWluRGF0ZU1vbWVudCwgX21heERhdGVNb21lbnQpOyAtPiBuZWVkIHRvIGJlIHJlYWRcbiAgICAgICAgdGhpcy5zd2l0Y2hUb0NvbnRleHQoJ0xvYWRlZCcpOyAvLyB0byBTVE9QIGNhbGxpbmcgQWpheCByZXF1ZXN0XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIENhbGwgd2ViIHNlcnZpY2VcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdldFNob3J0VXJsICgpIHtcbiAgICAgIGxldCByYW5nZVR5cGUgPSB0aGlzLl90eXBlU2VsZWN0Q0JbMF0ub3B0aW9uc1t0aGlzLl90eXBlU2VsZWN0Q0JbMF0uc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICBpZiAocmFuZ2VUeXBlID09ICdwYXN0Jykge1xuICAgICAgICBsZXQgbnVtYmVyID0gJCh0aGlzLl9wYXN0TmIpWzBdLnZhbHVlO1xuICAgICAgICBsZXQgdW5pdCA9IHRoaXMuX3Bhc3RVbml0Q0JbMF0ub3B0aW9uc1t0aGlzLl9wYXN0VW5pdENCWzBdLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgICByZXR1cm4gJ1RpbWUvUGFzdFJhbmdlLycgKyBudW1iZXIgKyAnXycgKyB1bml0O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBjcnQgPSB0aGlzLl9jdXJyZW50Q0JbMF0ub3B0aW9uc1t0aGlzLl9jdXJyZW50Q0JbMF0uc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICAgIHJldHVybiAnVGltZS9DdXJyZW50UmFuZ2UvJyArIGNydDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWZyZXNoIChkYXRhKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIGNvbXBvbmVudCB3aXRoIGRhdGEgcmV0dXJuZWQgYnkgdGhlIHdlYiBzZXJ2aWNlIGluIGNhc2Ugb2Ygc3VjY2Vzc1xuICAgICAgbGV0IGlzRGF0ZVRpbWUgPSAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YVR5cGUnKSA9PSAnREFURVRJTUUnKTtcbiAgICAgIGlmIChpc0RhdGVUaW1lKSB7XG4gICAgICAgIC8vIFwiWVlZWS1NTS1ERFRISDptbTpzc1wiXG4gICAgICAgIGxldCByID0gcHVsc2VSYW5nZS5jcmVhdGVTdHJpbmdSYW5nZUZyb21TdHJpbmcoZGF0YS5VdGNEYXRlVGltZVJhbmdlKTtcbiAgICAgICAgJCh0aGlzLl9taW5EVFApLmF0dHIoJ2RlZmF1bHRkYXRldGltZScsIHIubG93ZXIpO1xuICAgICAgICAkKHRoaXMuX21heERUUCkuYXR0cignZGVmYXVsdGRhdGV0aW1lJywgci51cHBlcik7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gWVlZWS1NTS1ERFxuICAgICAgICBsZXQgciA9IHB1bHNlUmFuZ2UuY3JlYXRlU3RyaW5nUmFuZ2VGcm9tU3RyaW5nKGRhdGEuRGF5UmFuZ2UpO1xuICAgICAgICAkKHRoaXMuX21pbkRUUCkuYXR0cignZGVmYXVsdGRhdGUnLCByLmxvd2VyKTtcbiAgICAgICAgJCh0aGlzLl9tYXhEVFApLmF0dHIoJ2RlZmF1bHRkYXRlJywgci51cHBlcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0b3JlV2ViQXBwVmFsdWUoKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsYmFjayBldmVudHNcblxuICAgIG9uQ2hhbmdlU2VsICgpIHtcbiAgICAgIC8vIFNob3cgLyBIaWRlXG4gICAgICBsZXQgcmFuZ2VUeXBlID0gdGhpcy5fdHlwZVNlbGVjdENCWzBdLm9wdGlvbnNbdGhpcy5fdHlwZVNlbGVjdENCWzBdLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgdGhpcy5fc2hvd0hpZGUocmFuZ2VUeXBlKTtcblxuICAgICAgLy8gUmVsb2FkIGlmIG5lY2Vzc2FyeVxuICAgICAgc3dpdGNoIChyYW5nZVR5cGUpIHtcbiAgICAgICAgY2FzZSAoJ2N1cnJlbnQnKTpcbiAgICAgICAgY2FzZSAoJ3Bhc3QnKToge1xuICAgICAgICAgIC8vIEZvcmNlIHJlLWxvYWRcbiAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH0gYnJlYWs7XG4gICAgICAgIGNhc2UgKCdzaW5jZScpOlxuICAgICAgICBjYXNlICgnZXhwbGljaXQnKTpcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIHRoaXMuX3N0b3JlV2ViQXBwVmFsdWUoKTtcbiAgICAgICAgICAvLyBEbyBub3RoaW5nIG1vcmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEV4dGVybmFsIG1ldGhvZHNcbiAgICBpc1ZhbGlkICgpIHsgLy8gY2YgX2NhbGxiYWNrX3ZhbGlkYXRlX3NldHRpbmdzICgpIHtcbiAgICAgIGlmICghdGhpcy5fYmVnaW5EVFBbMF0uaXNWYWxpZCgpKSB7XG4gICAgICAgIC8vcHVsc2VDdXN0b21EaWFsb2cub3BlbkVycm9yKCdTdGFydCBkYXRlL3RpbWUgaXMgbm90IHZhbGlkLicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2VuZERUUFswXS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgLy9wdWxzZUN1c3RvbURpYWxvZy5vcGVuRXJyb3IoJ0VuZCBkYXRlL3RpbWUgaXMgbm90IHZhbGlkLicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCA9PSB0aGlzLl9lbmREVFBbMF0uZ2V0SVNPVmFsdWUoKSkge1xuICAgICAgICAvL3B1bHNlQ3VzdG9tRGlhbG9nLm9wZW5FcnJvcignRW5kIGRhdGUvdGltZSBpcyBub3QgdmFsaWQuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGV0IGJlZ2luRGF0ZVRpbWUgPSBuZXcgRGF0ZSh0aGlzLl9iZWdpbkRUUFswXS5nZXRJU09WYWx1ZSgpKTtcbiAgICAgIGxldCBlbmREYXRlVGltZSA9IG5ldyBEYXRlKHRoaXMuX2VuZERUUFswXS5nZXRJU09WYWx1ZSgpKTtcblxuICAgICAgLy8gQ2hlY2sgdGhlIHJhbmdlXG4gICAgICBpZiAoZW5kRGF0ZVRpbWUpIHtcbiAgICAgICAgaWYgKGVuZERhdGVUaW1lIDwgYmVnaW5EYXRlVGltZSkge1xuICAgICAgICAgIC8vcHVsc2VDdXN0b21EaWFsb2cub3BlbkVycm9yKCdFbmQgZGF0ZS90aW1lIGlzIGJlZm9yZSBzdGFydCBkYXRlL3RpbWUuJyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChiZWdpbkRhdGVUaW1lIDwgZW5kRGF0ZVRpbWUpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgPSBpdCBpcyBPS1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vcHVsc2VDdXN0b21EaWFsb2cub3BlbkVycm9yKCdFbXB0eSBwZXJpb2QuJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIGVuZCBpc1ZhbGlkXG5cbiAgICBnZXRWYWx1ZUFzSXMgKG5hbWUpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtaW5kYXRlbmFtZScpID09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWluVmFsdWVBc0lzKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnbWF4ZGF0ZW5hbWUnKSA9PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1heFZhbHVlQXNJcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGdldE1pblZhbHVlQXNJcyAoKSB7IC8vJ1lZWVktTU0tREQgSEg6bW06c3MgXG4gICAgICByZXR1cm4gdGhpcy5fbWluRFRQWzBdLmdldFZhbHVlQXNJcygpO1xuICAgIH1cblxuICAgIGdldE1heFZhbHVlQXNJcyAoKSB7IC8vJ1lZWVktTU0tREQgSEg6bW06c3MgXG4gICAgICByZXR1cm4gdGhpcy5fbWF4RFRQWzBdLmdldFZhbHVlQXNJcygpO1xuICAgIH1cblxuICAgIGdldFdlYkFwcFJhbmdlICgpIHtcbiAgICAgIGxldCByYW5nZVR5cGUgPSB0aGlzLl90eXBlU2VsZWN0Q0JbMF0ub3B0aW9uc1t0aGlzLl90eXBlU2VsZWN0Q0JbMF0uc2VsZWN0ZWRJbmRleF0udmFsdWU7XG5cbiAgICAgIGxldCByZXRWYWwgPSByYW5nZVR5cGUgKyAnXyc7XG4gICAgICBzd2l0Y2ggKHJhbmdlVHlwZSkge1xuICAgICAgICBjYXNlICgnc2luY2UnKToge1xuICAgICAgICAgIHJldFZhbCArPSB0aGlzLmdldE1pblZhbHVlQXNJcygpO1xuICAgICAgICB9IGJyZWFrO1xuICAgICAgICBjYXNlICgnZXhwbGljaXQnKToge1xuICAgICAgICAgIHJldFZhbCArPSB0aGlzLmdldE1pblZhbHVlQXNJcygpICsgJ18nICsgdGhpcy5nZXRNYXhWYWx1ZUFzSXMoKTtcbiAgICAgICAgfSBicmVhaztcbiAgICAgICAgY2FzZSAoJ2N1cnJlbnQnKToge1xuICAgICAgICAgIHJldFZhbCArPSB0aGlzLl9jdXJyZW50Q0JbMF0ub3B0aW9uc1t0aGlzLl9jdXJyZW50Q0JbMF0uc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICAgIH0gYnJlYWs7XG4gICAgICAgIGNhc2UgKCdwYXN0Jyk6IHtcbiAgICAgICAgICBsZXQgbnVtYmVyID0gdGhpcy5fcGFzdE5iWzBdLnZhbHVlO1xuICAgICAgICAgIGxldCB1bml0ID0gdGhpcy5fcGFzdFVuaXRDQlswXS5vcHRpb25zW3RoaXMuX3Bhc3RVbml0Q0JbMF0uc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICAgICAgcmV0VmFsICs9IG51bWJlciArICdfJyArIHVuaXQ7XG4gICAgICAgIH0gYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAvLyBOZXZlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0VmFsO1xuICAgIH1cbiAgICAvL19zdG9yZVdlYkFwcFZhbHVlXG4gICAgLy8gR2V0IFwiV2ViQXBwUGFyYW1zRGF0ZVwiIGZyb20gXCJQdWxzZU1pbkRhdGVcIiwgXCJQdWxzZU1heERhdGVcIlxuICAgIC8qXG4gICAgc3RhdGljIGdldFdlYkFwcFJhbmdlRnJvbU1pbk1heChtaW4sIG1heCkgeyAgICAgIFxuICAgICAgbGV0IHJldFZhbCA9ICdleHBsaWNpdF8nICsgbWluICsgJ18nICsgbWF4O1xuICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9XG4gICAgKi9cblxuICB9XG5cbiAgcHVsc2VDb21wb25lbnQucmVnaXN0ZXJFbGVtZW50KCd4LXJlcG9ydGRhdGV0aW1lJywgUmVwb3J0RGF0ZVRpbWVDb21wb25lbnQsXG4gICAgWydncm91cERpc3BsYXlGb3JtJywgJ2dyb3VwTmFtZScsICdkYXRhVHlwZScsICd3ZWJhcHAnLCAnbWluZGF0ZScsICdtYXhkYXRlJyxcbiAgICAgICdtaW5kYXRlbmFtZScsICdtYXhkYXRlbmFtZScsICd3ZWJhcHBuYW1lJ10pO1xuICAvLyBtaW5kYXRlbmFtZScsJ21heGRhdGVuYW1lJyA9PSBQdWxzZU1pbkRhdGUgLyBQdWxzZU1heERhdGVcbn0pKCk7XG4iLCIvLyBDb3B5cmlnaHQgKEMpIDIwMDktMjAyMyBMZW1vaW5lIEF1dG9tYXRpb24gVGVjaG5vbG9naWVzXG4vL1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuLyogU2luZ2xldG9uIGNsYXNzIHRvIG1hbmFnZSBldmVudHMgc2VudCBiZXR3ZWVuIHB1bHNlIGNvbXBvbmVudHMgKi9cblxudmFyIEV2ZW50QnVzQ2xhc3MgPSB7fTtcbkV2ZW50QnVzQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGlzdGVuZXJzID0ge307XG4gIHRoaXMuZ2xvYmFsTGlzdGVuZXJzID0ge307XG59O1xuRXZlbnRCdXNDbGFzcy5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgICogQWRkIGEgc2lnbmFsIGxpc3RlbmVyIGZvciBhIGdpdmVuIGNvbnRleHQgb24gZXZlbnQgYnVzIGZvciAxIGNvbXBvbmVudD1zY29wZVxuICAgICpcbiAgICAqIEBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgbGlzdGVuZXIgc2NvcGUgKD0gdGhpcyBpbiBjYWxsYmFjayA9IHh0YWcgY2xhc3MpXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gc2lnbmFsIGdlbmVyaWMgbmFtZSBvZiBzaWduYWwgdG8gbGlzdGVuIG9uIGV2ZW50IGJ1c1xuICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRleHQgY29udGV4dCBjb25jZXJuIGJ5IHNpZ25hbCBzZW50IChleDpwZXJpb2QtY29udGV4dClcbiAgICAqIEBwYXJhbSB7TWV0aG9kfSBjYWxsYmFjayBjYWxsYmFjayB0byBjYWxsXG4gICovXG4gIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChzY29wZSwgc2lnbmFsLCBjb250ZXh0LCBjYWxsYmFjaykge1xuICAgIC8vIGhvcGUgKGNvbnRleHQgIT0gJ3VuZGVmaW5lZCcgJiYgY29udGV4dCAhPSAnJykge1xuICAgIGlmICh0eXBlb2YgdGhpcy5saXN0ZW5lcnNbc2lnbmFsXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5saXN0ZW5lcnNbc2lnbmFsXSA9IHt9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMubGlzdGVuZXJzW3NpZ25hbF1bY29udGV4dF0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzW3NpZ25hbF1bY29udGV4dF0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnNbc2lnbmFsXVtjb250ZXh0XS5wdXNoKHsgc2NvcGU6IHNjb3BlLCBjYWxsYmFjazogY2FsbGJhY2sgfSk7XG4gICAgY29uc29sZS5sb2coYCR7c2NvcGUuZ2V0SW5mbyA/IHNjb3BlLmdldEluZm8oKSA6ICcnfTogYWRkIGxpc3RlbmVyIGV2ZW50PSR7c2lnbmFsfV8ke2NvbnRleHR9YCk7XG4gIH0sXG4gIC8qKlxuICAgICogQWRkIGEgc2lnbmFsIGxpc3RlbmVyIGZvciBhbGwgY29udGV4dHMgb24gZXZlbnQgYnVzIGZvciAxIGNvbXBvbmVudD1zY29wZVxuICAgICpcbiAgICAqIEBmdW5jdGlvbiBhZGRHbG9iYWxFdmVudExpc3RlbmVyXG4gICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgbGlzdGVuZXIgc2NvcGUgKD0gdGhpcyBpbiBjYWxsYmFjaylcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaWduYWwgZ2VuZXJpYyBuYW1lIG9mIHNpZ25hbCB0byBsaXN0ZW4gb24gZXZlbnQgYnVzXG4gICAgKiBAcGFyYW0ge01ldGhvZH0gY2FsbGJhY2sgY2FsbGJhY2sgdG8gY2FsbFxuICAqL1xuICBhZGRHbG9iYWxFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoc2NvcGUsIHNpZ25hbCwgY2FsbGJhY2spIHtcbiAgICAvLyBnbG9iYWwgbGlzdGVuZXIgPSBmb3IgYWxsIGNvbnRleHRzXG4gICAgaWYgKHR5cGVvZiB0aGlzLmdsb2JhbExpc3RlbmVyc1tzaWduYWxdID09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmdsb2JhbExpc3RlbmVyc1tzaWduYWxdID0gW107XG4gICAgfVxuICAgIHRoaXMuZ2xvYmFsTGlzdGVuZXJzW3NpZ25hbF0ucHVzaCh7IHNjb3BlOiBzY29wZSwgY2FsbGJhY2s6IGNhbGxiYWNrIH0pO1xuICAgIGNvbnNvbGUubG9nKGAke3Njb3BlLmdldEluZm8gPyBzY29wZS5nZXRJbmZvKCkgOiAnJ306IGFkZCBnbG9iYWwgbGlzdGVuZXIgc2lnbmFsPSR7c2lnbmFsfSBET05FYCk7XG4gIH0sXG4gIC8qKlxuICAgICogUmVtb3ZlIGFsbCBzaWduYWwgbGlzdGVuZXJzIGZvciBhbGwgY29udGV4dHMgb24gZXZlbnQgYnVzIGZvciAxIGNvbXBvbmVudD1zY29wZVxuICAgICpcbiAgICAqIEBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyQnlTaWduYWxcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBsaXN0ZW5lciBzY29wZSAoPSB0aGlzIGluIGNhbGxiYWNrKVxuICAgICogQHBhcmFtIHtTdHJpbmd9IHNpZ25hbCBnZW5lcmljIG5hbWUgb2Ygc2lnbmFsIHRvIGxpc3RlbiBvbiBldmVudCBidXNcbiAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lckJ5U2lnbmFsOiBmdW5jdGlvbiAoc2NvcGUsIHNpZ25hbCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5saXN0ZW5lcnNbc2lnbmFsXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgZm9yIChsZXQgY29udGV4dCBpbiB0aGlzLmxpc3RlbmVyc1tzaWduYWxdKSB7XG4gICAgICAgIC8vIEZvciBBTEwgZm91bmRlZCBjb250ZXh0cyA6IHJlbW92ZSBsaXN0ZW5lcnNcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxpc3RlbmVyc1tzaWduYWxdW2NvbnRleHRdICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbGV0IG5ld0FycmF5ID0gW107XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxpc3RlbmVyc1tzaWduYWxdW2NvbnRleHRdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGlzdGVuZXIgPSB0aGlzLmxpc3RlbmVyc1tzaWduYWxdW2NvbnRleHRdW2ldO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLnNjb3BlICE9IHNjb3BlKSB7XG4gICAgICAgICAgICAgIG5ld0FycmF5LnB1c2gobGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke3Njb3BlLmdldEluZm8gPyBzY29wZS5nZXRJbmZvKCkgOiAnJ306IHJlbW92ZSBsaXN0ZW5lciBzaWduYWw9JHtzaWduYWx9IGNvbnRleHQ9JHtjb250ZXh0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxpc3RlbmVyc1tzaWduYWxdW2NvbnRleHRdID0gbmV3QXJyYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gR2xvYmFsIGxpc3RlbmVyc1xuICAgIGlmICh0eXBlb2YgdGhpcy5nbG9iYWxMaXN0ZW5lcnNbc2lnbmFsXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgbGV0IG5ld0FycmF5ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZ2xvYmFsTGlzdGVuZXJzW3NpZ25hbF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gdGhpcy5nbG9iYWxMaXN0ZW5lcnNbc2lnbmFsXVtpXTtcbiAgICAgICAgaWYgKGxpc3RlbmVyLnNjb3BlICE9IHNjb3BlKSB7XG4gICAgICAgICAgbmV3QXJyYXkucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYCR7c2NvcGUuZ2V0SW5mbyA/IHNjb3BlLmdldEluZm8oKSA6ICcnfTogcmVtb3ZlIGdsb2JhbCBsaXN0ZW5lciBzaWduYWw9JHtzaWduYWx9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZ2xvYmFsTGlzdGVuZXJzW3NpZ25hbF0gPSBuZXdBcnJheTtcbiAgICB9XG4gICAgLy9jb25zb2xlLmxvZyhgJHtzY29wZS5nZXRJbmZvID8gc2NvcGUuZ2V0SW5mbygpIDogJyd9OiByZW1vdmUgbGlzdGVuZXJzIGJ5IHNpZ25hbD0ke3NpZ25hbH0gRE9ORWApO1xuICB9LFxuXG4gIC8qKlxuICAqIFJlbW92ZSBhbGwgc2lnbmFsIGxpc3RlbmVycyBmb3IgYWxsIGNvbnRleHRzIG9uIGV2ZW50IGJ1cyBmb3IgMSBjb21wb25lbnQ9c2NvcGVcbiAgKlxuICAqIEBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyQnlTY29wZVxuICAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSBsaXN0ZW5lciBzY29wZSAoPSB0aGlzIGluIGNhbGxiYWNrKVxuICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyQnlTY29wZTogZnVuY3Rpb24gKHNjb3BlKSB7XG4gICAgZm9yIChsZXQgc2lnbmFsIGluIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICBmb3IgKGxldCBjb250ZXh0IGluIHRoaXMubGlzdGVuZXJzW3NpZ25hbF0pIHtcbiAgICAgICAgLy8gRm9yIEFMTCBmb3VuZGVkIHNpZ25hbCArIGNvbnRleHRzIDogcmVtb3ZlIGxpc3RlbmVyc1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubGlzdGVuZXJzW3NpZ25hbF1bY29udGV4dF0gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsZXQgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGlzdGVuZXJzW3NpZ25hbF1bY29udGV4dF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsaXN0ZW5lciA9IHRoaXMubGlzdGVuZXJzW3NpZ25hbF1bY29udGV4dF1baV07XG4gICAgICAgICAgICBpZiAobGlzdGVuZXIuc2NvcGUgIT0gc2NvcGUpIHtcbiAgICAgICAgICAgICAgbmV3QXJyYXkucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYCR7c2NvcGUuZ2V0SW5mbyA/IHNjb3BlLmdldEluZm8oKSA6ICcnfTogcmVtb3ZlIGxpc3RlbmVyIHNpZ25hbD0ke3NpZ25hbH0gY29udGV4dD0ke2NvbnRleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3NpZ25hbF1bY29udGV4dF0gPSBuZXdBcnJheTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBHbG9iYWwgbGlzdGVuZXJzXG4gICAgZm9yIChsZXQgc2lnbmFsIGluIHRoaXMuZ2xvYmFsTGlzdGVuZXJzKSB7XG4gICAgICBsZXQgbmV3QXJyYXkgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5nbG9iYWxMaXN0ZW5lcnNbc2lnbmFsXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbGlzdGVuZXIgPSB0aGlzLmdsb2JhbExpc3RlbmVyc1tzaWduYWxdW2ldO1xuICAgICAgICBpZiAobGlzdGVuZXIuc2NvcGUgIT0gc2NvcGUpIHtcbiAgICAgICAgICBuZXdBcnJheS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgJHtzY29wZS5nZXRJbmZvID8gc2NvcGUuZ2V0SW5mbygpIDogJyd9OiByZW1vdmUgZ2xvYmFsIGxpc3RlbmVyIHNpZ25hbD0ke3NpZ25hbH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5nbG9iYWxMaXN0ZW5lcnNbc2lnbmFsXSA9IG5ld0FycmF5O1xuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKGAke3Njb3BlLmdldEluZm8gPyBzY29wZS5nZXRJbmZvKCkgOiAnJ306IHJlbW92ZSAoYWxsKSBsaXN0ZW5lcnMgRE9ORWApO1xuICB9LFxuICAvKipcbiAgICAqIERpc3BhdGNoIGEgc2lnbmFsIGZvciBhIGdpdmVuIGNvbnRleHQgb24gZXZlbnQgYnVzXG4gICAgKlxuICAgICogQGZ1bmN0aW9uIGRpc3BhdGNoVG9Db250ZXh0XG4gICAgKiBAcGFyYW0ge1N0cmluZ30gc2lnbmFsIGdlbmVyaWMgbmFtZSBvZiBzaWduYWwgdG8gZGlzcGF0Y2ggdG8gb24gZXZlbnQgYnVzXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gY29udGV4dCBjb250ZXh0IGNvbmNlcm4gYnkgc2lnbmFsIHNlbnQgKGV4OnBlcmlvZC1jb250ZXh0KVxuICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBtYWluIGluZm9ybWF0aW9uIHRvIGdpdmUgdG8gbGlzdGVuZXJzXG4gICovXG4gIGRpc3BhdGNoVG9Db250ZXh0OiBmdW5jdGlvbiAoc2lnbmFsLCBjb250ZXh0LCB0YXJnZXQpIHtcbiAgICBjb25zb2xlLmxvZyhgZGlzcGF0Y2ggdG8gbGlzdGVuZXJzIHNpZ25hbD0ke3NpZ25hbH0gY29udGV4dD0ke2NvbnRleHR9YCk7XG4gICAgbGV0IGV2ZW50ID0ge1xuICAgICAgLypzaWduYWw6IHNpZ25hbCxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICB0eXBlOiBzaWduYWwgKyAnXycgKyBjb250ZXh0LCovXG4gICAgICB0YXJnZXQ6IHRhcmdldFxuICAgIH07XG4gICAgbGV0IGFyZ3MgPSBbXTtcbiAgICB2YXIgbnVtT2ZBcmdzID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU9mQXJnczsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncyA9IGFyZ3MubGVuZ3RoID4gMyA/IGFyZ3Muc3BsaWNlKDMsIGFyZ3MubGVuZ3RoIC0gMSkgOiBbXTtcbiAgICBhcmdzID0gW2V2ZW50XS5jb25jYXQoYXJncyk7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmxpc3RlbmVyc1tzaWduYWxdICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMubGlzdGVuZXJzW3NpZ25hbF1bY29udGV4dF0gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbGV0IG51bU9mQ2FsbGJhY2tzID0gdGhpcy5saXN0ZW5lcnNbc2lnbmFsXVtjb250ZXh0XS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT2ZDYWxsYmFja3M7IGkrKykge1xuICAgICAgICAgIGxldCBsaXN0ZW5lciA9IHRoaXMubGlzdGVuZXJzW3NpZ25hbF1bY29udGV4dF1baV07XG4gICAgICAgICAgaWYgKGxpc3RlbmVyICYmIGxpc3RlbmVyLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5hcHBseShsaXN0ZW5lci5zY29wZSwgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdBUk5JTkcgOlxuICAgIC8vIEdsb2JhbCBsaXN0ZW5lcnMgRE8gTk9UIHJlY2VpdmUgdGhpcyBldmVudCB3aXRoIGNvbnRleHQgdG8gYWxsb3cgXCJsb2NhbFwiIGNvbW11bmljYXRpb24uXG4gICAgLy8gRm9yIGV4YW1wbGUgOiBwYWdlIFJ1bm5pbmcgKG5vIGNvbnRleHQpICsgRGV0YWlsc1xuICB9LFxuICAvKipcbiAgICAqIERpc3BhdGNoIGEgc2lnbmFsIHRvIEdMT0JBTCBjb250ZXh0IG9uIGV2ZW50IGJ1c1xuICAgICpcbiAgICAqIEBmdW5jdGlvbiBkaXNwYXRjaFRvR2xvYmFsT25seVxuICAgICogQHBhcmFtIHtTdHJpbmd9IHNpZ25hbCBnZW5lcmljIG5hbWUgb2Ygc2lnbmFsIHRvIGRpc3BhdGNoIHRvIG9uIGV2ZW50IGJ1c1xuICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBtYWluIGluZm9ybWF0aW9uIHRvIGdpdmUgdG8gbGlzdGVuZXJzXG4gICovXG4gIGRpc3BhdGNoVG9HbG9iYWxPbmx5OiBmdW5jdGlvbiAoc2lnbmFsLCB0YXJnZXQpIHtcbiAgICBsZXQgZXZlbnQgPSB7XG4gICAgICAvKnNpZ25hbDogc2lnbmFsLFxuICAgICAgY29udGV4dDogJycsXG4gICAgICB0eXBlOiBzaWduYWwsKi9cbiAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgfTtcbiAgICBsZXQgYXJncyA9IFtdO1xuICAgIHZhciBudW1PZkFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtT2ZBcmdzOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzID0gYXJncy5sZW5ndGggPiAyID8gYXJncy5zcGxpY2UoMiwgYXJncy5sZW5ndGggLSAxKSA6IFtdO1xuICAgIGFyZ3MgPSBbZXZlbnRdLmNvbmNhdChhcmdzKTtcbiAgICAvLyArIGdsb2JhbFxuICAgIGlmICh0eXBlb2YgdGhpcy5nbG9iYWxMaXN0ZW5lcnNbc2lnbmFsXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgbGV0IG51bU9mQ2FsbGJhY2tzID0gdGhpcy5nbG9iYWxMaXN0ZW5lcnNbc2lnbmFsXS5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU9mQ2FsbGJhY2tzOyBpKyspIHtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gdGhpcy5nbG9iYWxMaXN0ZW5lcnNbc2lnbmFsXVtpXTtcbiAgICAgICAgaWYgKGxpc3RlbmVyICYmIGxpc3RlbmVyLmNhbGxiYWNrKSB7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2suYXBwbHkobGlzdGVuZXIuc2NvcGUsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICAqIERpc3BhdGNoIGEgc2lnbmFsIHRvIEFMTCBjb250ZXh0cyBvbiBldmVudCBidXNcbiAgICAqXG4gICAgKiBAZnVuY3Rpb24gZGlzcGF0Y2hUb0FsbFxuICAgICogQHBhcmFtIHtTdHJpbmd9IHNpZ25hbCBnZW5lcmljIG5hbWUgb2Ygc2lnbmFsIHRvIGRpc3BhdGNoIHRvIG9uIGV2ZW50IGJ1c1xuICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBtYWluIGluZm9ybWF0aW9uIHRvIGdpdmUgdG8gbGlzdGVuZXJzXG4gICovXG4gIGRpc3BhdGNoVG9BbGw6IGZ1bmN0aW9uIChzaWduYWwsIHRhcmdldCkge1xuICAgIGxldCBldmVudCA9IHtcbiAgICAgIC8qc2lnbmFsOiBzaWduYWwsXG4gICAgICBjb250ZXh0OiAnJyxcbiAgICAgIHR5cGU6IHNpZ25hbCwqL1xuICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICB9O1xuICAgIGxldCBhcmdzID0gW107XG4gICAgdmFyIG51bU9mQXJncyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1PZkFyZ3M7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MgPSBhcmdzLmxlbmd0aCA+IDIgPyBhcmdzLnNwbGljZSgyLCBhcmdzLmxlbmd0aCAtIDEpIDogW107XG4gICAgYXJncyA9IFtldmVudF0uY29uY2F0KGFyZ3MpO1xuICAgIGlmICh0eXBlb2YgdGhpcy5saXN0ZW5lcnNbc2lnbmFsXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgZm9yIChsZXQgY29udGV4dCBpbiB0aGlzLmxpc3RlbmVyc1tzaWduYWxdKSB7XG4gICAgICAgIC8vIEZvciBBTEwgZm91bmRlZCBjb250ZXh0cyA6IGRpc3BhdGNoXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5saXN0ZW5lcnNbc2lnbmFsXVtjb250ZXh0XSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGxldCBudW1PZkNhbGxiYWNrcyA9IHRoaXMubGlzdGVuZXJzW3NpZ25hbF1bY29udGV4dF0ubGVuZ3RoO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT2ZDYWxsYmFja3M7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpc3RlbmVyID0gdGhpcy5saXN0ZW5lcnNbc2lnbmFsXVtjb250ZXh0XVtpXTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lciAmJiBsaXN0ZW5lci5jYWxsYmFjaykge1xuICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5hcHBseShsaXN0ZW5lci5zY29wZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vICsgZ2xvYmFsXG4gICAgaWYgKHR5cGVvZiB0aGlzLmdsb2JhbExpc3RlbmVyc1tzaWduYWxdICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZXQgbnVtT2ZDYWxsYmFja3MgPSB0aGlzLmdsb2JhbExpc3RlbmVyc1tzaWduYWxdLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT2ZDYWxsYmFja3M7IGkrKykge1xuICAgICAgICBsZXQgbGlzdGVuZXIgPSB0aGlzLmdsb2JhbExpc3RlbmVyc1tzaWduYWxdW2ldO1xuICAgICAgICBpZiAobGlzdGVuZXIgJiYgbGlzdGVuZXIuY2FsbGJhY2spIHtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjay5hcHBseShsaXN0ZW5lci5zY29wZSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG59O1xuXG5leHBvcnRzLkV2ZW50QnVzID0gbmV3IEV2ZW50QnVzQ2xhc3MoKTtcbiIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4vKipcbiAqIEBmaWxlIGFjY2VzcyBjb25maWd1cmF0aW9uLlxuICovXG5cbi8qKlxuKiBAbW9kdWxlIHB1bHNlQ29uZmlnXG4qIEByZXF1aXJlcyBwdWxzZVV0aWxpdHlcbiogQHJlcXVpcmVzIHB1bHNlTG9naW5cbiovXG52YXIgcHVsc2VVdGlsaXR5ID0gcmVxdWlyZSgncHVsc2VVdGlsaXR5Jyk7XG52YXIgcHVsc2VMb2dpbiA9IHJlcXVpcmUoJ3B1bHNlTG9naW4nKTtcblxuXG4vLy8vLy8vLy8vIC8vLy8vLy8vLy8gLy8vLy8vLy8vL1xuLy8gVFJBTlNMQVRJT04gICAgICAgICAgICAgICAgLy9cbi8vLy8vLy8vLy8gLy8vLy8vLy8vLyAvLy8vLy8vLy8vXG5cbi8qKlxuICogZnVuY3Rpb24gY2FsbGVkIHRvIGZpbmQgYSB0cmFuc2xhdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgbGlua2VkIHRvIGEgdHJhbnNsYXRpb24gXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdFRyYW5zbGF0aW9uIFRyYW5zbGF0aW9uIHJldHVybmVkIGlmIHRoZSBrZXkgaXMgbm90IGZvdW5kXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHN0cmluZyB0byBkaXNwbGF5XG4gKi9cbmV4cG9ydHMucHVsc2VUcmFuc2xhdGUgPSBmdW5jdGlvbiAoa2V5LCBkZWZhdWx0VHJhbnNsYXRpb24pIHtcbiAgbGV0IHJlc3VsdCA9IGRlZmF1bHRUcmFuc2xhdGlvbjtcblxuICAvLyBUcmFuc2xhdGlvbnMgYWNjZXNzaWJsZT9cbiAgaWYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKFBVTFNFX1RSQU5TTEFUSU9OKSkge1xuICAgIGxldCB0cmFuc2xhdGlvbiA9IFBVTFNFX1RSQU5TTEFUSU9OO1xuICAgIGxldCBsaXN0T2ZLZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0T2ZLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cmFuc2xhdGlvbiA9IHRyYW5zbGF0aW9uW2xpc3RPZktleXNbaV1dO1xuICAgICAgaWYgKChwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKHRyYW5zbGF0aW9uKSkgfHwgKCcnID09PSB0cmFuc2xhdGlvbikpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKGkgPT0gKGxpc3RPZktleXMubGVuZ3RoIC0gMSkpXG4gICAgICAgIHJlc3VsdCA9IHRyYW5zbGF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLy8vLy8vLy8vIC8vLy8vLy8vLy8gLy8vLy8vLy8vL1xuLy8gTG9jYWwgRnVuY3Rpb25zICAgICAgICAgICAgLy9cbi8vLy8vLy8vLy8gLy8vLy8vLy8vLyAvLy8vLy8vLy8vXG5cbnZhciBnZXRBcHBOYW1lID0gZnVuY3Rpb24gKCkge1xuICAvKiBUaGlzIGNvdWxkIGJlIGZvdW5kIGluIFVSTCAtIEJVVCBjYW4gbm90LCBiZWNhdXNlIG9mIGhhcmRjb2RlZCBzY3JpcHQgaW4gdGVtcGxhdGUuaHRtbCAoY2FzZSBzZW5zaXRpdmUsIG90aGVyIGFwcC4uLikgXG4gIE1vcmUgOiBpbiB3ZSByZWFkIGFwcCBuYW1lIGluIFVSTCwgaXQgd2lsbCBiZSBtb3JlIGRpZmZpY3VsdCB0byBzaGFyZSBkYXRhIGJldHdlZW4gYXBwLCBmb3IgZXhlbXBsZSBtYWNoaW5lcyBcbiAgKi9cbiAgcmV0dXJuIExFTV9DT05GSUdfREVGQVVMVC5hcHBOYW1lO1xufVxuXG52YXIgZ2V0UGFnZU5hbWUgPSBleHBvcnRzLmdldFBhZ2VOYW1lID0gZnVuY3Rpb24gKCkge1xuICBsZXQgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmOyAvLyBcIi4uLi9wYWdlbmFtZS5odG1sXCJcbiAgdmFyIHBvc1JlcSA9IGhyZWYubGFzdEluZGV4T2YoJz8nKTtcbiAgaWYgKHBvc1JlcSAhPSAtMSkge1xuICAgIGhyZWYgPSBocmVmLnNsaWNlKDAsIHBvc1JlcSk7IC8vIFRvIGlnbm9yZSBhbGwgYWZ0ZXIgP1xuICB9XG4gIHZhciBwb3NQdCA9IGhyZWYubGFzdEluZGV4T2YoJy4nKTtcbiAgdmFyIHBvc1NsYXNoID0gaHJlZi5sYXN0SW5kZXhPZignLycpO1xuICBsZXQgcGFnZU5hbWUgPSAnJztcbiAgaWYgKChwb3NQdCAhPSAtMSkgJiYgKHBvc1NsYXNoICE9IC0xKSkgeyAvLyBGb3VuZCBib3RoXG4gICAgcGFnZU5hbWUgPSBocmVmLnNsaWNlKHBvc1NsYXNoICsgMSwgcG9zUHQpO1xuICB9XG5cbiAgcmV0dXJuIHBhZ2VOYW1lO1xufTtcblxuXG4vL3ZhciBpc0N1cnJlbnRBcHAgPSBcbmV4cG9ydHMuaXNDdXJyZW50QXBwID0gZnVuY3Rpb24gKGFwcE5hbWUpIHtcbiAgLy8gRmluZCBhcHAgbmFtZVxuICBsZXQgYXBwID0gZ2V0QXBwTmFtZSgpO1xuICBpZiAoYXBwID09IGFwcE5hbWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgZ2V0QXBwQ29udGV4dE9ubHkgPSBleHBvcnRzLmdldEFwcENvbnRleHRPbmx5ID0gZnVuY3Rpb24gKCkge1xuICAvLyBnZXQgQXBwQ29udGV4dCBpbiBVUkxcbiAgbGV0IGFwcEN0eENvbmZpZyA9IGdldFVSTENvbmZpZygnQXBwQ29udGV4dCcpO1xuICBpZiAoYXBwQ3R4Q29uZmlnLmZvdW5kKSB7XG4gICAgcmV0dXJuIGFwcEN0eENvbmZpZy52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxudmFyIGdldEFwcENvbnRleHRPclJvbGUgPSBleHBvcnRzLmdldEFwcENvbnRleHRPclJvbGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGdldCBBcHBDb250ZXh0IGluIFVSTFxuICBsZXQgYXBwQ3R4Q29uZmlnID0gZ2V0VVJMQ29uZmlnKCdBcHBDb250ZXh0Jyk7XG4gIGlmIChhcHBDdHhDb25maWcuZm91bmQpIHtcbiAgICByZXR1cm4gYXBwQ3R4Q29uZmlnLnZhbHVlO1xuICB9XG5cbiAgLy8gSWYgbm90IGZvdW5kLCBnZXQgcm9sZVxuICByZXR1cm4gcHVsc2VMb2dpbi5nZXRSb2xlKCk7XG59XG5cbnZhciBnZXRMb2dpbkFwcENvbnRleHRPclJvbGUgPSBleHBvcnRzLmdldExvZ2luQXBwQ29udGV4dE9yUm9sZSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGxvZ2luID0gcHVsc2VMb2dpbi5nZXRMb2dpbigpO1xuICBpZiAobG9naW4gIT0gJycpIHtcbiAgICByZXR1cm4gbG9naW47XG4gIH1cblxuICAvLyBnZXQgQXBwQ29udGV4dCBpbiBVUkxcbiAgbGV0IGFwcEN0eENvbmZpZyA9IGdldFVSTENvbmZpZygnQXBwQ29udGV4dCcpO1xuICBpZiAoYXBwQ3R4Q29uZmlnLmZvdW5kKSB7XG4gICAgcmV0dXJuIGFwcEN0eENvbmZpZy52YWx1ZTtcbiAgfVxuXG4gIC8vIElmIG5vdCBmb3VuZCwgZ2V0IHJvbGVcbiAgcmV0dXJuIHB1bHNlTG9naW4uZ2V0Um9sZSgpO1xufVxuXG4vLy8vLy8vLy8vIC8vLy8vLy8vLy8gLy8vLy8vLy8vL1xuLy8gXCJTRUFSQ0ggSU4gQ09ORklHXCIgTUVUSE9EUyAvL1xuLy8vLy8vLy8vLyAvLy8vLy8vLy8vIC8vLy8vLy8vLy9cblxudmFyIGdldFVSTENvbmZpZyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgbGV0IHJldFZhbCA9IHsgZm91bmQ6IGZhbHNlLCB2YWx1ZTogJycgfTtcbiAgbGV0IGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgLy8gVG8gZmluZCBjb25maWcgTElLRSBwcm9kdWN0aW9uLnRocmVzaG9sZE5iT2ZQaWVjZXMsIFNQTElUXG4gIGxldCBsaXN0T2ZLZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGlmIChsaXN0T2ZLZXlzLmxlbmd0aCA+PSAxKSB7XG4gICAgbGV0IGxhc3RLZXkgPSBsaXN0T2ZLZXlzW2xpc3RPZktleXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGFsbFZhbHVlcztcbiAgICBpZiAoJ21hY2hpbmUnID09IGxhc3RLZXkpIHtcbiAgICAgIGFsbFZhbHVlcyA9IHB1bHNlVXRpbGl0eS5nZXRBTExNYWNoaW5lSWRQYXJhbWV0ZXJWYWx1ZShocmVmKTsgLy8gRm9yIENvbXBhdGliaWxpdHlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBhbGxWYWx1ZXMgPSBwdWxzZVV0aWxpdHkuZ2V0VVJMUGFyYW1ldGVyVmFsdWVzKGhyZWYsIGxhc3RLZXkpO1xuICAgIH1cbiAgICBpZiAoYWxsVmFsdWVzICE9IG51bGwgJiYgYWxsVmFsdWVzLmxlbmd0aCAhPSAwKSB7XG4gICAgICBpZiAoYWxsVmFsdWVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldFZhbC52YWx1ZSA9IGFsbFZhbHVlc1swXTtcbiAgICAgICAgcmV0VmFsLmZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXRWYWwudmFsdWUgPSBhbGxWYWx1ZXM7XG4gICAgICAgIHJldFZhbC5mb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXRWYWw7XG59O1xuXG52YXIgZ2V0TG9jYWxDb25maWcgPSBmdW5jdGlvbiAoa2V5LCBsb2dpbiwgcGFnZU5hbWUpIHtcbiAgbGV0IHJldFZhbCA9IHsgZm91bmQ6IGZhbHNlLCB2YWx1ZTogJycgfTtcbiAgaWYgKGtleSA9PSAncGF0aCcpIHtcbiAgICBpZiAodHlwZW9mIHNlc3Npb25TdG9yYWdlICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICBsZXQgaXRlbSA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIGlmIChpdGVtICE9IG51bGwpIHtcbiAgICAgICAgcmV0VmFsLnZhbHVlID0gSlNPTi5wYXJzZShpdGVtKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmV0VmFsLnZhbHVlKSkge1xuICAgICAgICAgIC8vIHJlc2V0XG4gICAgICAgICAgcmV0VmFsLnZhbHVlID0gJyc7XG4gICAgICAgICAgLy8gUmVtb3ZlIGZyb20gbG9jYWwgc3RvcmFnZSBlcnJvclxuICAgICAgICAgIGNvbnNvbGUud2FybignQ29uZmlnIFN0cmFuZ2UgYXJyYXkgZm9yIGtleT0nICsga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXRWYWwuZm91bmQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiByZXRWYWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLndhcm4oJ0NvbmZpZyBjYW4gbm90IHJlYWQgbG9jYWwgc3RvcmFnZSAnKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBGaW5kIGFwcCBuYW1lXG4gICAgbGV0IGFwcCA9IGdldEFwcE5hbWUoKTtcblxuICAgIC8vIEdldCBHTE9CQUxcbiAgICBsZXQga2V5U3RyaW5nID0gJ1BVTFNFLicgKyBhcHAgKyAnLicgKyBrZXk7XG4gICAgbGV0IGl0ZW0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXlTdHJpbmcpO1xuICAgIGlmIChpdGVtICE9IG51bGwpIHtcbiAgICAgIHJldFZhbC52YWx1ZSA9IEpTT04ucGFyc2UoaXRlbSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXRWYWwudmFsdWUpKSB7XG4gICAgICAgIC8vIHJlc2V0XG4gICAgICAgIHJldFZhbC52YWx1ZSA9ICcnO1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSBsb2NhbCBzdG9yYWdlIGVycm9yXG4gICAgICAgIGNvbnNvbGUud2FybignQ29uZmlnIHJlbW92ZSBhcnJheSAnICsga2V5U3RyaW5nKTtcbiAgICAgICAgLy9yZXNldChrZXlTdHJpbmcpO1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXlTdHJpbmcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldFZhbC5mb3VuZCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXRWYWw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEdldCBieSBsb2dpbiArIHBhZ2VcbiAgICBrZXlTdHJpbmcgPSAnUFVMU0UuJyArIGFwcCArICcuJyArIGxvZ2luICsgJy4nICsgcGFnZU5hbWUgKyAnLicgKyBrZXk7XG4gICAgaXRlbSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleVN0cmluZyk7XG4gICAgaWYgKGl0ZW0gIT0gbnVsbCkge1xuICAgICAgcmV0VmFsLnZhbHVlID0gSlNPTi5wYXJzZShpdGVtKTsgLy8gUGFyc2UgaXMgbm90IG1hbmRhdG9yeS4gQnV0IGNhbiBiZSBkb25lXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXRWYWwudmFsdWUpKSB7XG4gICAgICAgIC8vIHJlc2V0XG4gICAgICAgIHJldFZhbC52YWx1ZSA9ICcnO1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSBsb2NhbCBzdG9yYWdlIGVycm9yXG4gICAgICAgIGNvbnNvbGUud2FybignQ29uZmlnIHJlbW92ZSBhcnJheSAnICsga2V5U3RyaW5nKTtcbiAgICAgICAgLy9yZXNldChrZXlTdHJpbmcpO1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXlTdHJpbmcpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldFZhbC5mb3VuZCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXRWYWw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEdldCBieSBsb2dpbiBvbmx5ICh3YXMgcm9sZSlcbiAgICBrZXlTdHJpbmcgPSAnUFVMU0UuJyArIGFwcCArICcuJyArIGxvZ2luICsgJy4nICsga2V5O1xuICAgIGl0ZW0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXlTdHJpbmcpO1xuICAgIGlmIChpdGVtICE9IG51bGwpIHtcbiAgICAgIHJldFZhbC52YWx1ZSA9IEpTT04ucGFyc2UoaXRlbSk7IC8vIFBhcnNlIGlzIG5vdCBtYW5kYXRvcnkuIEJ1dCBjYW4gYmUgZG9uZVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmV0VmFsLnZhbHVlKSkge1xuICAgICAgICAvLyByZXNldFxuICAgICAgICByZXRWYWwudmFsdWUgPSAnJztcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gbG9jYWwgc3RvcmFnZSBlcnJvclxuICAgICAgICBjb25zb2xlLndhcm4oJ0NvbmZpZyByZW1vdmUgYXJyYXkgJyArIGtleVN0cmluZyk7XG4gICAgICAgIC8vcmVzZXQoa2V5U3RyaW5nKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5U3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXRWYWwuZm91bmQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmV0VmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0VmFsO1xufTtcblxudmFyIGdldFJvbGVQYWdlQ29uZmlnID0gZnVuY3Rpb24gKGtleSwgcm9sZSwgcGFnZU5hbWUpIHtcbiAgbGV0IHJldFZhbCA9IHsgZm91bmQ6IGZhbHNlLCB2YWx1ZTogJycgfTtcbiAgaWYgKCghcHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChyb2xlKSkgJiYgKHJvbGUgIT0gJycpXG4gICAgJiYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKHBhZ2VOYW1lKSkgJiYgKHBhZ2VOYW1lICE9ICcnKSkge1xuICAgIC8vIEdldCBOZXcgY29uZmlnIChvbGQgaXMgcmVtb3ZlZCAyMDE4LTExKVxuICAgIGlmICh0eXBlb2YgUFVMU0VfREVGQVVMVF9DT05GSUcgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybignUFVMU0VfREVGQVVMVF9DT05GSUcgaXMgdW5kZWZpbmVkJyk7XG4gICAgICByZXR1cm4gcmV0VmFsO1xuICAgIH1cbiAgICAvLyBTRUFSQ0ggaW4gTkVXIHJvbGUgQ09ORklHXG4gICAgaWYgKCh0eXBlb2YgUFVMU0VfREVGQVVMVF9DT05GSUcucm9sZXNwYWdlcyAhPSAndW5kZWZpbmVkJylcbiAgICAgICYmIChQVUxTRV9ERUZBVUxUX0NPTkZJRy5yb2xlc3BhZ2VzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICBpZiAoKHR5cGVvZiBQVUxTRV9ERUZBVUxUX0NPTkZJRy5yb2xlc3BhZ2VzW3JvbGVdICE9ICd1bmRlZmluZWQnKVxuICAgICAgICAmJiAoUFVMU0VfREVGQVVMVF9DT05GSUcucm9sZXNwYWdlc1tyb2xlXSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBsZXQgY2ZnID0gUFVMU0VfREVGQVVMVF9DT05GSUcucm9sZXNwYWdlc1tyb2xlXVtwYWdlTmFtZV07XG4gICAgICAgIGlmICghcHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChjZmcpKSB7XG4gICAgICAgICAgbGV0IGxpc3RPZktleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RPZktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNmZyA9IGNmZ1tsaXN0T2ZLZXlzW2ldXTtcbiAgICAgICAgICAgIGlmICgocHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChjZmcpKSB8fCAoJycgPT09IGNmZykpIHtcbiAgICAgICAgICAgICAgYnJlYWs7IC8vIFRvIGV4aXQgZm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSAobGlzdE9mS2V5cy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICByZXRWYWwuZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICByZXRWYWwudmFsdWUgPSBjZmc7XG4gICAgICAgICAgICAgIHJldHVybiByZXRWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldFZhbDtcbn07XG5cbnZhciBnZXRSb2xlQ29uZmlnID0gZnVuY3Rpb24gKGtleSwgcm9sZSwgcGFnZU5hbWUpIHtcbiAgbGV0IHJldFZhbCA9IHsgZm91bmQ6IGZhbHNlLCB2YWx1ZTogJycgfTtcbiAgaWYgKHR5cGVvZiBQVUxTRV9ERUZBVUxUX0NPTkZJRyA9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUud2FybignUFVMU0VfREVGQVVMVF9DT05GSUcgaXMgdW5kZWZpbmVkIC0gbm9ybWFsIGZvciBkb2NzJyk7XG4gICAgcmV0dXJuIHJldFZhbDtcbiAgfVxuXG4gIGlmICgoIXB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQocm9sZSkpICYmIChyb2xlICE9ICcnKSkge1xuICAgIC8vIFNFQVJDSCBpbiBORVcgcm9sZSBDT05GSUdcbiAgICBpZiAoKHR5cGVvZiBQVUxTRV9ERUZBVUxUX0NPTkZJRy5yb2xlcyAhPSAndW5kZWZpbmVkJylcbiAgICAgICYmIChQVUxTRV9ERUZBVUxUX0NPTkZJRy5yb2xlcyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgbGV0IGNmZyA9IFBVTFNFX0RFRkFVTFRfQ09ORklHLnJvbGVzW3JvbGVdO1xuICAgICAgaWYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKGNmZykpIHtcbiAgICAgICAgbGV0IGxpc3RPZktleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0T2ZLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2ZnID0gY2ZnW2xpc3RPZktleXNbaV1dO1xuICAgICAgICAgIGlmICgocHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChjZmcpKSB8fCAoJycgPT09IGNmZykpIHtcbiAgICAgICAgICAgIGJyZWFrOyAvLyBUbyBleGl0IGZvclxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PSAobGlzdE9mS2V5cy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgcmV0VmFsLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldFZhbC52YWx1ZSA9IGNmZztcbiAgICAgICAgICAgIHJldHVybiByZXRWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXRWYWw7XG59XG5cbnZhciBnZXRQYWdlQ29uZmlnID0gZnVuY3Rpb24gKGtleSwgcm9sZSwgcGFnZU5hbWUpIHtcbiAgbGV0IHJldFZhbCA9IHsgZm91bmQ6IGZhbHNlLCB2YWx1ZTogJycgfTtcbiAgaWYgKHR5cGVvZiBQVUxTRV9ERUZBVUxUX0NPTkZJRyA9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUud2FybignUFVMU0VfREVGQVVMVF9DT05GSUcgaXMgdW5kZWZpbmVkJyk7XG4gICAgcmV0dXJuIHJldFZhbDtcbiAgfVxuXG4gIGlmICgoIXB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQocGFnZU5hbWUpKSAmJiAocGFnZU5hbWUgIT0gJycpKSB7XG4gICAgLy8gU2VhcmNoIHRoZSBrZXkgZm9yIHRoZSBjdXJyZW50IHBhZ2VzXG4gICAgaWYgKCh0eXBlb2YgUFVMU0VfREVGQVVMVF9DT05GSUcucGFnZXMgIT0gJ3VuZGVmaW5lZCcpXG4gICAgICAmJiAoUFVMU0VfREVGQVVMVF9DT05GSUcucGFnZXMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgIGxldCBjZmcgPSBQVUxTRV9ERUZBVUxUX0NPTkZJRy5wYWdlc1twYWdlTmFtZV07XG4gICAgICBpZiAoIXB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQoY2ZnKSkge1xuICAgICAgICBsZXQgbGlzdE9mS2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RPZktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjZmcgPSBjZmdbbGlzdE9mS2V5c1tpXV07XG4gICAgICAgICAgaWYgKChwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKGNmZykpIHx8ICgnJyA9PT0gY2ZnKSkge1xuICAgICAgICAgICAgYnJlYWs7IC8vIFRvIGV4aXQgZm9yXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpID09IChsaXN0T2ZLZXlzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICByZXRWYWwuZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0VmFsLnZhbHVlID0gY2ZnO1xuICAgICAgICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldFZhbDtcbn07XG5cbnZhciBnZXRBcHBDb25maWcgPSBmdW5jdGlvbiAoa2V5LCByb2xlLCBwYWdlTmFtZSkge1xuICBsZXQgcmV0VmFsID0geyBmb3VuZDogZmFsc2UsIHZhbHVlOiAnJyB9O1xuICBpZiAodHlwZW9mIFBVTFNFX0RFRkFVTFRfQ09ORklHID09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS53YXJuKCdQVUxTRV9ERUZBVUxUX0NPTkZJRyBpcyB1bmRlZmluZWQnKTtcbiAgICByZXR1cm4gcmV0VmFsO1xuICB9XG5cbiAgLy8gU2VhcmNoIHRoZSBrZXkgaW4gdGhlIGdsb2JhbCBzZWN0aW9uXG4gIGlmICgodHlwZW9mIFBVTFNFX0RFRkFVTFRfQ09ORklHICE9ICd1bmRlZmluZWQnKVxuICAgICYmIChQVUxTRV9ERUZBVUxUX0NPTkZJRyAhPT0gdW5kZWZpbmVkKSkge1xuICAgIGxldCBjZmcgPSBQVUxTRV9ERUZBVUxUX0NPTkZJRy5nZW5lcmFsO1xuICAgIGlmICghcHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChjZmcpKSB7XG4gICAgICBsZXQgbGlzdE9mS2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0T2ZLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNmZyA9IGNmZ1tsaXN0T2ZLZXlzW2ldXTtcbiAgICAgICAgaWYgKHB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQoY2ZnKSkge1xuICAgICAgICAgIHJldHVybiByZXRWYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCcnID09PSBjZmcpIHtcbiAgICAgICAgICByZXR1cm4gcmV0VmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID09IChsaXN0T2ZLZXlzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgcmV0VmFsLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICByZXRWYWwudmFsdWUgPSBjZmc7XG4gICAgICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0VmFsO1xufVxuXG4vKiogR2V0IGNvbmZpZ3VyYXRpb24gdXNpbmcgYWxsIHBhcmFtYXRlcnNcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZUNvbmZpZ1xuICogQGZ1bmN0aW9uIGdldENvbXBvbmVudERlZmF1bHRDb25maWdcbiAqIEBwYXJhbSBrZXkga2V5IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGNvbmZpZ3VyYXRpb24gdG8gdXNlXG4gKi9cbnZhciBnZXRDb21wb25lbnREZWZhdWx0Q29uZmlnID0gZnVuY3Rpb24gKGtleSkge1xuICBsZXQgcmV0VmFsID0geyBmb3VuZDogZmFsc2UsIHZhbHVlOiAnJyB9O1xuICBpZiAoKHB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQoa2V5KSkgfHwgKGtleSA9PT0gJycpKSB7XG4gICAgLy8gTE9HIEVSUk9SIGhlcmVcbiAgICByZXR1cm4gcmV0VmFsO1xuICB9XG4gIGxldCBjZmcgPSB0YWdDb25maWc7XG4gIGlmICghcHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChjZmcpKSB7XG4gICAgbGV0IGxpc3RPZktleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RPZktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNmZyA9IGNmZ1tsaXN0T2ZLZXlzW2ldXTtcbiAgICAgIGlmICgocHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChjZmcpKSB8fCAoY2ZnID09PSAnJykpIHtcbiAgICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0VmFsLmZvdW5kID0gdHJ1ZTtcbiAgICByZXRWYWwudmFsdWUgPSBjZmc7XG4gICAgcmV0dXJuIHJldFZhbDtcbiAgfVxuICByZXR1cm4gcmV0VmFsO1xufTtcbi8vLy8vLy8vLy8gLy8vLy8vLy8vLyAvLy8vLy8vLy8vXG4vLyBFTkQgb2YgTG9jYWwgRnVuY3Rpb25zICAgICAvL1xuLy8vLy8vLy8vLyAvLy8vLy8vLy8vIC8vLy8vLy8vLy9cblxuXG4vKiogR2V0IGNvbmZpZ3VyYXRpb24gdXNpbmcgYWxsIHBhcmFtYXRlcnNcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZUNvbmZpZ1xuICogQGZ1bmN0aW9uIGdldEZ1bGxDb25maWdcbiAqIEBwYXJhbSBrZXkga2V5IHRvIGNoZWNrXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIGRlZmF1bHQgVmFsdWVcbiAqIEBwYXJhbSBvbmx5RGVmYXVsdCAtIGlmIHRydWUsIGRvbid0IHRha2UgaW50byBhY2NvdW50IHRoZSBvdmVycmlkZXMgKHVybCBvciBsb2NhbHN0b3JhZ2UpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZU5hbWUgLSBzcGVjaWZpYyBwYWdlLCBpZiBuZWVkZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSByb2xlIC0gaGlkZGVuIHBhcmFtLCByb2xlIGlmIHNob3VsZCBiZSB1c2VkXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGNvbmZpZ3VyYXRpb24gdG8gdXNlXG4gKi9cbnZhciBnZXRGdWxsQ29uZmlnID0gZnVuY3Rpb24gKGtleSwgZGVmYXVsdFZhbHVlLCBvbmx5RGVmYXVsdCwgcGFnZU5hbWUsIHJvbGUpIHtcbiAgLy8gRmluZCByb2xlXG4gIGlmIChyb2xlID09IG51bGwpXG4gICAgcm9sZSA9IGdldEFwcENvbnRleHRPclJvbGUoKTsgLy8gV0FTIGdldFJvbGUoKTsgLy9MQVRFUiA6IG1heWJlIHVzZSBsb2dpbiBpZiBleGlzdCA/XG5cbiAgbGV0IGxvZ2luID0gZ2V0TG9naW5BcHBDb250ZXh0T3JSb2xlKCk7XG5cbiAgbGV0IGNvbmZpZyA9IHsgZm91bmQ6IGZhbHNlLCB2YWx1ZTogZGVmYXVsdFZhbHVlIH07XG5cbiAgLy8gRmluZCBwYWdlIG5hbWVcbiAgaWYgKHBhZ2VOYW1lID09IG51bGwpXG4gICAgcGFnZU5hbWUgPSBnZXRQYWdlTmFtZSgpO1xuXG4gIC8vIEFyZSB0aGUgb3ZlcnJpZGVzIHRha2VuIGludG8gYWNjb3VudD9cbiAgaWYgKG9ubHlEZWZhdWx0ID09IG51bGwgfHwgb25seURlZmF1bHQgPT0gZmFsc2UpIHtcbiAgICB0cnkge1xuICAgICAgLy8gU2VhcmNoIHRoZSB2YWx1ZSBpbiB0aGUgY3VycmVudCBVUkxcbiAgICAgIGNvbmZpZyA9IGdldFVSTENvbmZpZyhrZXkpO1xuICAgICAgaWYgKGNvbmZpZy5mb3VuZCkgeyByZXR1cm4gY29uZmlnOyB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignZ2V0RnVsbENvbmZpZyAtIGdldFVSTENvbmZpZyBlcnJvciBmb3Iga2V5PScgKyBrZXkgKyAnIERlZmF1bHQ9JyArIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFNlYXJjaCB0aGUgdmFsdWUgaW4gdGhlIGxvY2Fsc3RvcmFnZSwgcmVsYXRlZCB0byB0aGUgY3VycmVudCBhcHBcbiAgICAgIGNvbmZpZyA9IGdldExvY2FsQ29uZmlnKGtleSwgbG9naW4sIHBhZ2VOYW1lKTtcbiAgICAgIGlmIChjb25maWcuZm91bmQpIHsgcmV0dXJuIGNvbmZpZzsgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2dldEZ1bGxDb25maWcgLSBnZXRMb2NhbENvbmZpZyBlcnJvciBmb3Iga2V5PScgKyBrZXkgKyAnIERlZmF1bHQ9JyArIGRlZmF1bHRWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBTZWFyY2ggcm9sZS9wYWdlIGNvbmZpZ1xuICAgIGNvbmZpZyA9IGdldFJvbGVQYWdlQ29uZmlnKGtleSwgcm9sZSwgcGFnZU5hbWUpO1xuICAgIGlmIChjb25maWcuZm91bmQpIHsgcmV0dXJuIGNvbmZpZzsgfVxuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2dldEZ1bGxDb25maWcgLSBnZXRSb2xlUGFnZUNvbmZpZyBlcnJvciBmb3Iga2V5PScgKyBrZXkgKyAnIERlZmF1bHQ9JyArIGRlZmF1bHRWYWx1ZSk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFNlYXJjaCByb2xlIGNvbmZpZ1xuICAgIGNvbmZpZyA9IGdldFJvbGVDb25maWcoa2V5LCByb2xlLCBwYWdlTmFtZSk7XG4gICAgaWYgKGNvbmZpZy5mb3VuZCkgeyByZXR1cm4gY29uZmlnOyB9XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignZ2V0RnVsbENvbmZpZyAtIGdldFJvbGVDb25maWcgZXJyb3IgZm9yIGtleT0nICsga2V5ICsgJyBEZWZhdWx0PScgKyBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBTZWFyY2ggcGFnZSBjb25maWdcbiAgICBjb25maWcgPSBnZXRQYWdlQ29uZmlnKGtleSwgcm9sZSwgcGFnZU5hbWUpO1xuICAgIGlmIChjb25maWcuZm91bmQpIHsgcmV0dXJuIGNvbmZpZzsgfVxuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2dldEZ1bGxDb25maWcgLSBnZXRQYWdlQ29uZmlnIGVycm9yIGZvciBrZXk9JyArIGtleSArICcgRGVmYXVsdD0nICsgZGVmYXVsdFZhbHVlKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gU2VhcmNoIEFwcCBjb25maWcgKGdlbmVyYWwpXG4gICAgY29uZmlnID0gZ2V0QXBwQ29uZmlnKGtleSwgcm9sZSwgcGFnZU5hbWUpO1xuICAgIGlmIChjb25maWcuZm91bmQpIHsgcmV0dXJuIGNvbmZpZzsgfVxuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2dldEZ1bGxDb25maWcgLSBnZXRBcHBDb25maWcgZXJyb3IgZm9yIGtleT0nICsga2V5ICsgJyBEZWZhdWx0PScgKyBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBSZXR1cm4gZGVmYXVsdCAodGFnQ29uZmlnID0gUFdDIGNvbmZpZylcbiAgICBjb25maWcgPSBnZXRDb21wb25lbnREZWZhdWx0Q29uZmlnKGtleSk7XG4gICAgaWYgKGNvbmZpZy5mb3VuZCkgeyByZXR1cm4gY29uZmlnOyB9XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignZ2V0RnVsbENvbmZpZyAtIGdldENvbXBvbmVudERlZmF1bHRDb25maWcgZXJyb3IgZm9yIGtleT0nICsga2V5ICsgJyBEZWZhdWx0PScgKyBkZWZhdWx0VmFsdWUpO1xuICB9XG5cbiAgLy9pZiBOT1QgZm91bmQgKHByb2JhYmx5IGZvciBBcHBDb250ZXh0KSwgc2VhcmNoIGluIHJvbGVcbiAgbGV0IHJlYWxSb2xlID0gcHVsc2VMb2dpbi5nZXRSb2xlKCk7XG4gIGlmIChyb2xlICE9IHJlYWxSb2xlKVxuICAgIHJldHVybiBnZXRGdWxsQ29uZmlnKGtleSwgZGVmYXVsdFZhbHVlLCBvbmx5RGVmYXVsdCwgcGFnZU5hbWUsIHJlYWxSb2xlKTtcblxuICAvLyBEZWZhdWx0ID0gbm90IGZvdW5kXG4gIHJldHVybiBjb25maWc7XG59O1xuXG4vKiogR2V0IGEgY29uZmlndXJhdGlvbiB3aXRoIG5vIHNwZWNpZmljIHR5cGUsIHJlYWQgaW4gdGhpcyBvcmRlcjpcbiAqIC0gaW4gdGhlIHVybFxuICogLSBpbiBsb2NhbFN0b3JhZ2Ugb2YgdGhlIHdlYiBwYWdlXG4gKiAtIGluIHJvbGUrcGFnZSBjb25maWd1cmF0aW9uXG4gKiAtIGluIHJvbGUgY29uZmlndXJhdGlvblxuICogLSBpbiBwYWdlIGNvbmZpZ3VyYXRpb25cbiAqIC0gZ2xvYmFsIGRlZmF1bHQgdmFsdWUgLSB0YWdDb25maWdcbiAqIC0gdmFsdWUgc3BlY2lmaWVkIGluIHRoZSBhcmd1bWVudCBcImRlZmF1bHRWYWx1ZVwiXG4gKiBcbiAqICAvIVxcIFVzZSBpdCBvbmx5IGZvciBjb21wbGV4IG9iamVjdHMgLyFcXFxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlQ29uZmlnXG4gKiBAZnVuY3Rpb24gZ2V0XG4gKiBAcGFyYW0geyFTdHJpbmd9IGtleSAtIGtleSB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRWYWx1ZSAtIGRlZmF1bHQgVmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlIC0gc3BlY2lmaWMgcGFnZSwgaWYgbmVlZGVkXG4gKi9cbnZhciBnZXQgPSBleHBvcnRzLmdldCA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSwgcGFnZSkge1xuICAvLyBHZXQgY29uZmlnXG4gIGxldCBsaXN0T2ZLZXlzID0ga2V5LnNwbGl0KCcuJyk7IC8vIEV4OiAnQU5ZX3RhZ05hbWUucmVhbEtleSdcbiAgaWYgKGxpc3RPZktleXMubGVuZ3RoID4gMSkgeyAvLyBGaW5kIG92ZXJsb2FkIGZpcnN0XG4gICAgbGV0IGxhc3RLZXkgPSBsaXN0T2ZLZXlzW2xpc3RPZktleXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGNvbmZpZyA9IGdldEZ1bGxDb25maWcobGFzdEtleSwgZGVmYXVsdFZhbHVlLCBmYWxzZSwgcGFnZSk7XG4gICAgaWYgKGNvbmZpZy5mb3VuZClcbiAgICAgIHJldHVybiBjb25maWcudmFsdWU7XG4gIH1cblxuICAvLyBGVUxMIHRhZy5rZXkgdG8gZmluZCBkZWZhdWx0IGNvbXBvbmVudCBjb25maWdcbiAgbGV0IGNvbmZpZyA9IGdldEZ1bGxDb25maWcoa2V5LCBkZWZhdWx0VmFsdWUsIGZhbHNlLCBwYWdlKTtcbiAgaWYgKGNvbmZpZy5mb3VuZClcbiAgICByZXR1cm4gY29uZmlnLnZhbHVlO1xuXG4gIHJldHVybiBkZWZhdWx0VmFsdWU7XG59O1xuXG4vKiogR2V0IGEgY29uZmlndXJhdGlvbiByZXR1cm5lZCBhcyBhIEJPT0xFQU5cbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZUNvbmZpZ1xuICogQGZ1bmN0aW9uIGdldEJvb2xcbiAqIEBwYXJhbSB7IVN0cmluZ30ga2V5IC0ga2V5IHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdFZhbHVlIC0gZGVmYXVsdCBWYWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2UgLSBzcGVjaWZpYyBwYWdlLCBpZiBuZWVkZWRcbiAqL1xuZXhwb3J0cy5nZXRCb29sID0gZnVuY3Rpb24gKGtleSwgZGVmYXVsdFZhbHVlLCBwYWdlKSB7XG4gIGxldCB0bXAgPSBnZXQoa2V5LCBkZWZhdWx0VmFsdWUsIHBhZ2UpO1xuICByZXR1cm4gKHRtcCA9PSB0cnVlIHx8IHRtcCA9PSAndHJ1ZScgfHwgdG1wID09ICcxJyB8fCB0bXAgPT0gMSk7XG59O1xuXG4vKiogR2V0IGEgY29uZmlndXJhdGlvbiByZXR1cm5lZCBhcyBhbiBJTlRFR0VSXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VDb25maWdcbiAqIEBmdW5jdGlvbiBnZXRJbnRcbiAqIEBwYXJhbSB7IVN0cmluZ30ga2V5IC0ga2V5IHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdFZhbHVlIC0gZGVmYXVsdCBWYWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2UgLSBzcGVjaWZpYyBwYWdlLCBpZiBuZWVkZWRcbiAqL1xuZXhwb3J0cy5nZXRJbnQgPSBmdW5jdGlvbiAoa2V5LCBkZWZhdWx0VmFsdWUsIHBhZ2UpIHtcbiAgbGV0IHRtcCA9IGdldChrZXksIGRlZmF1bHRWYWx1ZSwgcGFnZSk7XG4gIHJldHVybiBwYXJzZUludCh0bXAsIDEwKTtcbn1cblxuLyoqIEdldCBhIGNvbmZpZ3VyYXRpb24gcmV0dXJuZWQgYXMgYW4gRkxPQVRcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZUNvbmZpZ1xuICogQGZ1bmN0aW9uIGdldEZsb2F0XG4gKiBAcGFyYW0geyFTdHJpbmd9IGtleSAtIGtleSB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRWYWx1ZSAtIGRlZmF1bHQgVmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlIC0gc3BlY2lmaWMgcGFnZSwgaWYgbmVlZGVkXG4gKi9cbmV4cG9ydHMuZ2V0RmxvYXQgPSBmdW5jdGlvbiAoa2V5LCBkZWZhdWx0VmFsdWUsIHBhZ2UpIHtcbiAgbGV0IHRtcCA9IGdldChrZXksIGRlZmF1bHRWYWx1ZSwgcGFnZSk7XG4gIHJldHVybiBwYXJzZUZsb2F0KHRtcCk7XG59XG5cbi8qKiBHZXQgYSBjb25maWd1cmF0aW9uIHJldHVybmVkIGFzIGEgU1RSSU5HXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VDb25maWdcbiAqIEBmdW5jdGlvbiBnZXRTdHJpbmdcbiAqIEBwYXJhbSB7IVN0cmluZ30ga2V5IC0ga2V5IHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdFZhbHVlIC0gZGVmYXVsdCBWYWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2UgLSBzcGVjaWZpYyBwYWdlLCBpZiBuZWVkZWRcbiAqL1xudmFyIGdldFN0cmluZyA9IGV4cG9ydHMuZ2V0U3RyaW5nID0gZnVuY3Rpb24gKGtleSwgZGVmYXVsdFZhbHVlLCBwYWdlKSB7XG4gIGxldCB0bXAgPSBnZXQoa2V5LCBkZWZhdWx0VmFsdWUsIHBhZ2UpO1xuICBpZiAodG1wID09IHVuZGVmaW5lZCB8fCB0bXAgPT0gbnVsbClcbiAgICB0bXAgPSAnJztcbiAgcmV0dXJuIFN0cmluZyh0bXApO1xufVxuXG4vKiogR2V0IGEgY29uZmlndXJhdGlvbiByZXR1cm5lZCBhcyBhbiBBUlJBWVxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlQ29uZmlnXG4gKiBAZnVuY3Rpb24gZ2V0QXJyYXlcbiAqIEBwYXJhbSB7IVN0cmluZ30ga2V5IC0ga2V5IHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdFZhbHVlIC0gZGVmYXVsdCBWYWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2UgLSBzcGVjaWZpYyBwYWdlLCBpZiBuZWVkZWRcbiAqL1xudmFyIGdldEFycmF5ID1cbiAgZXhwb3J0cy5nZXRBcnJheSA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSwgcGFnZSkge1xuICAgIGxldCB0bXAgPSBnZXQoa2V5LCBkZWZhdWx0VmFsdWUsIHBhZ2UpO1xuICAgIGlmICh0bXAgPT0gbnVsbClcbiAgICAgIHJldHVybiBbXTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0bXApKSB7XG4gICAgICBpZiAodHlwZW9mIHRtcCA9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHRtcC5zcGxpdCgnLCcpO1xuXG4gICAgICByZXR1cm4gW3RtcF07XG4gICAgfVxuICAgIC8vIE9LIGZvciByb2xlcyBpbiBjb25maWcgZmlsZSAvIEtPIGZvciBsb2NhbHN0b3JhZ2VcbiAgICBjb25zb2xlLmxvZygncHVsc2VDb25maWcuZ2V0IGZvdW5kIEFSUkFZIGZvciBrZXk9JyArIGtleSk7XG4gICAgcmV0dXJuIHRtcDtcbiAgfVxuXG4vKiogR2V0IHRoZSBkZWZ1YWx0IHZhbHVlIHdpdGggbm8gc3BlY2lmaWMgdHlwZSwgcmVhZCBpbiB0aGlzIG9yZGVyXG4gKiAtIGluIGN1c3RvbSBsb2NhbCBkZWZpbml0aW9uIChkZXBlbmRpbmcgb24gdGhlIHJvbGUgZmlyc3QpXG4gKiAtIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjdXJyZW50IHBhZ2VcbiAqIC0gZ2xvYmFsIGRlZmF1bHQgdmFsdWVcbiAqIC0gdmFsdWUgc3BlY2lmaWVkIGluIHRoZSBhcmd1bWVudCBcImRlZmF1bHRWYWx1ZVwiXG4gKiBcbiAqICAvIVxcIFVzZSBpdCBvbmx5IGZvciBjb21wbGV4IG9iamVjdHMgLyFcXFxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlQ29uZmlnXG4gKiBAZnVuY3Rpb24gZ2V0RGVmYXVsdFxuICogQHBhcmFtIHshU3RyaW5nfSBrZXkgLSBrZXkgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZWZhdWx0VmFsdWUgLSBkZWZhdWx0IFZhbHVlXG4gKi9cbnZhciBnZXREZWZhdWx0ID0gZXhwb3J0cy5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIC8vIEdldCBjb25maWdcbiAgbGV0IGxpc3RPZktleXMgPSBrZXkuc3BsaXQoJy4nKTsgLy8gRXg6ICdBTllfdGFnTmFtZS5yZWFsS2V5J1xuICBpZiAobGlzdE9mS2V5cy5sZW5ndGggPiAxKSB7IC8vIEZpbmQgb3ZlcmxvYWQgZmlyc3RcbiAgICBsZXQgbGFzdEtleSA9IGxpc3RPZktleXNbbGlzdE9mS2V5cy5sZW5ndGggLSAxXTtcbiAgICBsZXQgY29uZmlnID0gZ2V0RnVsbENvbmZpZyhsYXN0S2V5LCBkZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIGlmIChjb25maWcuZm91bmQpIHtcbiAgICAgIHJldHVybiBjb25maWcudmFsdWU7XG4gICAgfVxuICB9XG4gIC8vIEZVTEwgdGFnLmtleSB0byBmaW5kIGRlZmF1bHQgY29tcG9uZW50IGNvbmZpZ1xuICBsZXQgY29uZmlnID0gZ2V0RnVsbENvbmZpZyhrZXksIGRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gIGlmIChjb25maWcuZm91bmQpIHtcbiAgICByZXR1cm4gY29uZmlnLnZhbHVlO1xuICB9XG4gIHJldHVybiBkZWZhdWx0VmFsdWU7XG59O1xuXG4vKiogR2V0IGEgZGVmYXVsdCBjb25maWd1cmF0aW9uIHJldHVybmVkIGFzIGEgQk9PTEVBTlxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlQ29uZmlnXG4gKiBAZnVuY3Rpb24gZ2V0RGVmYXVsdEJvb2xcbiAqIEBwYXJhbSB7IVN0cmluZ30ga2V5IC0ga2V5IHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdFZhbHVlIC0gZGVmYXVsdCBWYWx1ZVxuICovXG5leHBvcnRzLmdldERlZmF1bHRCb29sID0gZnVuY3Rpb24gKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGxldCB0bXAgPSBnZXREZWZhdWx0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgcmV0dXJuICh0bXAgPT0gdHJ1ZSB8fCB0bXAgPT0gJ3RydWUnIHx8IHRtcCA9PSAnMScgfHwgdG1wID09IDEpO1xufTtcblxuLyoqIEdldCBhIGRlZmF1bHQgY29uZmlndXJhdGlvbiByZXR1cm5lZCBhcyBhbiBJTlRFR0VSXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VDb25maWdcbiAqIEBmdW5jdGlvbiBnZXREZWZhdWx0SW50XG4gKiBAcGFyYW0geyFTdHJpbmd9IGtleSAtIGtleSB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRWYWx1ZSAtIGRlZmF1bHQgVmFsdWVcbiAqL1xuZXhwb3J0cy5nZXREZWZhdWx0SW50ID0gZnVuY3Rpb24gKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGxldCB0bXAgPSBnZXREZWZhdWx0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgcmV0dXJuIHBhcnNlSW50KHRtcCwgMTApO1xufVxuXG4vKiogR2V0IGEgZGVmYXVsdCBjb25maWd1cmF0aW9uIHJldHVybmVkIGFzIGFuIEZMT0FUXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VDb25maWdcbiAqIEBmdW5jdGlvbiBnZXREZWZhdWx0RmxvYXRcbiAqIEBwYXJhbSB7IVN0cmluZ30ga2V5IC0ga2V5IHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdFZhbHVlIC0gZGVmYXVsdCBWYWx1ZVxuICovXG5leHBvcnRzLmdldERlZmF1bHRGbG9hdCA9IGZ1bmN0aW9uIGdldERlZmF1bHRGbG9hdCAoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgbGV0IHRtcCA9IGdldERlZmF1bHQoa2V5LCBkZWZhdWx0VmFsdWUpO1xuICByZXR1cm4gcGFyc2VGbG9hdCh0bXApO1xufVxuXG4vKiogR2V0IGEgZGVmYXVsdCBjb25maWd1cmF0aW9uIHJldHVybmVkIGFzIGEgU1RSSU5HXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VDb25maWdcbiAqIEBmdW5jdGlvbiBnZXREZWZhdWx0U3RyaW5nXG4gKiBAcGFyYW0geyFTdHJpbmd9IGtleSAtIGtleSB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRWYWx1ZSAtIGRlZmF1bHQgVmFsdWVcbiAqL1xuZXhwb3J0cy5nZXREZWZhdWx0U3RyaW5nID0gZnVuY3Rpb24gKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGxldCB0bXAgPSBnZXREZWZhdWx0KGtleSwgZGVmYXVsdFZhbHVlKTtcbiAgaWYgKHRtcCA9PSB1bmRlZmluZWQgfHwgdG1wID09IG51bGwpXG4gICAgdG1wID0gJyc7XG4gIHJldHVybiBTdHJpbmcodG1wKTtcbn1cblxuLyoqIEdldCBhIGRlZmF1bHQgY29uZmlndXJhdGlvbiByZXR1cm5lZCBhcyBhbiBBUlJBWVxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlQ29uZmlnXG4gKiBAZnVuY3Rpb24gZ2V0RGVmYXVsdEFycmF5XG4gKiBAcGFyYW0geyFTdHJpbmd9IGtleSAtIGtleSB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IGRlZmF1bHRWYWx1ZSAtIGRlZmF1bHQgVmFsdWVcbiAqL1xuZXhwb3J0cy5nZXREZWZhdWx0QXJyYXkgPSBmdW5jdGlvbiAoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgbGV0IHRtcCA9IGdldERlZmF1bHQoa2V5LCBkZWZhdWx0VmFsdWUpO1xuICBpZiAodG1wID09IG51bGwpXG4gICAgcmV0dXJuIFtdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodG1wKSlcbiAgICByZXR1cm4gW3RtcF07XG4gIHJldHVybiB0bXA7XG59XG5cblxuLyoqIFNldCBHTE9CQUwgY29uZmlndXJhdGlvbiBmb3IgdGhlIFdIT0xFIGFwcFxuICogRm9yIGV4YW1wbGUgOiByb2xlLCB0aGVtZSwgbWFjaGluZS4uLlxuICogU3BlY2lhbCBzZXNzaW9uIHN0b3JhZ2UgZm9yIHBhdGhcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZUNvbmZpZ1xuICogQGZ1bmN0aW9uIHNldEdsb2JhbCAobm8gcm9sZSwgbm8gcGFnZSlcbiAqIEBwYXJhbSBrZXkgLSBrZXkgdG8gZmlsbFxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgYXNzb2NpYXRlZCB0byB0aGUga2V5XG4gKi9cbnZhciBzZXRHbG9iYWwgPSBleHBvcnRzLnNldEdsb2JhbCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIC8vIEZpbmQgYXBwIG5hbWVcbiAgbGV0IGFwcCA9IGdldEFwcE5hbWUoKTtcblxuICAvLyBTVE9SRVxuICBpZiAoa2V5ID09ICdwYXRoJykge1xuICAgIC8vIFNUT1JFXG4gICAgaWYgKHR5cGVvZiBzZXNzaW9uU3RvcmFnZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHZhbHVlID09PSAnJykgeyAvLyBLZWVwICc9PT0nIGJlY2F1c2UgJz09JyBmYWlscyB3aGVuIGZhbHNlXG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQga2V5U3RyaW5nID0gJ1BVTFNFLicgKyBhcHAgKyAnLicgKyBrZXk7XG4gICAgaWYgKHZhbHVlID09PSAnJykgeyAvLyBLZWVwICc9PT0nIGJlY2F1c2UgJz09JyBmYWlscyB3aGVuIGZhbHNlXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXlTdHJpbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgeyAvLyBBdm9pZCBhcnJheSBpbiBsb2NhbCBzdG9yYWdlIHRvIGtlZXAgY29tcGF0aWJpbGl0eSB3aXRoIHVybCAvIGF0dHJpYnV0ZXMgPT0gc3RyaW5nXG4gICAgICAgIGxldCBzdHIgPSB2YWx1ZS5qb2luKCk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleVN0cmluZywgSlNPTi5zdHJpbmdpZnkoc3RyKSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5U3RyaW5nLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBjb25zb2xlLndhcm4oJ0NvbmZpZyBjYW4gbm90IHNldCBsb2NhbCBzdG9yYWdlICgnICsga2V5ICsgJyknKTtcbiAgfVxufVxuXG4vKiogU2V0IGNvbmZpZ3VyYXRpb24gKGluIGxvY2FsIHN0b3JhZ2UpXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VDb25maWdcbiAqIEBmdW5jdGlvbiBzZXRcbiAqIEBwYXJhbSBrZXkgLSBrZXkgdG8gZmlsbFxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgYXNzb2NpYXRlZCB0byB0aGUga2V5XG4gKiBAcGFyYW0gaWdub3JlUGFnZU5hbWUgLSBpZiB0cnVlLCB3ZSBzaG91bGQgc3RvcmUgYnkgcm9sZSBvbmx5IChkZWZhdWx0IGZhbHNlKVxuICogQHBhcmFtIGdsb2JhbCAtIGlmIHRydWUsIHRoZSBjb25maWd1cmF0aW9uIHdpbGwgYmUgZ2xvYmFsIGZvciBhbGwgcGFnZXNcbiAqL1xudmFyIHNldCA9IGV4cG9ydHMuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGlnbm9yZVBhZ2VOYW1lKSB7XG4gIC8qIFRPRE8gOiBwcm9iYWJseSBhZGQgYW4gZXJyb3IgZm9yIHJvbGUsIHRoZW1lLCBwYXRoICovXG4gIGlmIChrZXkgPT0gJ3JvbGUnIHx8IGtleSA9PSAndGhlbWUnIHx8IGtleSA9PSAncGF0aCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGBDb25maWcuc2V0IHNob3VsZCBub3QgYmUgY2FsbCB3aXRoIGtleSA9ICR7a2V5fWApO1xuICAgIHNldEdsb2JhbChrZXksIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBTVE9SRVxuICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZpbmQgYXBwIG5hbWUgLyByb2xlIC8gcGFnZVxuICAgIGxldCBhcHAgPSBnZXRBcHBOYW1lKCk7XG4gICAgLy9sZXQgcm9sZSA9IGdldEFwcENvbnRleHRPclJvbGUoKTsgLy8gV0FTIGdldFJvbGUoKTtcbiAgICBsZXQgbG9naW4gPSBnZXRMb2dpbkFwcENvbnRleHRPclJvbGUoKTtcblxuICAgIGxldCBrZXlTdHJpbmc7XG4gICAgaWYgKGlnbm9yZVBhZ2VOYW1lKSB7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIHByZWZpeFxuICAgICAga2V5U3RyaW5nID0gJ1BVTFNFLicgKyBhcHAgKyAnLicgKyBsb2dpbiArICcuJyArIGtleTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsZXQgcGFnZU5hbWUgPSBnZXRQYWdlTmFtZSgpO1xuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBwcmVmaXhcbiAgICAgIGtleVN0cmluZyA9ICdQVUxTRS4nICsgYXBwICsgJy4nICsgbG9naW4gKyAnLicgKyBwYWdlTmFtZSArICcuJyArIGtleTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICcnKSB7IC8vIEtlZXAgJz09PScgYmVjYXVzZSAnPT0nIGZhaWxzIHdoZW4gZmFsc2VcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleVN0cmluZyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7IC8vIEF2b2lkIGFycmF5IGluIGxvY2FsIHN0b3JhZ2UgdG8ga2VlcCBjb21wYXRpYmlsaXR5IHdpdGggdXJsIC8gYXR0cmlidXRlcyA9PSBzdHJpbmdcbiAgICAgICAgbGV0IHN0ciA9IHZhbHVlLmpvaW4oKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5U3RyaW5nLCBKU09OLnN0cmluZ2lmeShzdHIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXlTdHJpbmcsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGNvbnNvbGUud2FybignQ29uZmlnIGNhbiBub3Qgc2V0IHZhbHVlIGluIGxvY2FsIHN0b3JhZ2UgICgnICsga2V5ICsgJyknKTtcbiAgfVxufVxuXG4vKiogQ2xlYXIgbG9jYWwgY29uZmlndXJhdGlvblxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlQ29uZmlnXG4gKiBAZnVuY3Rpb24gcmVzZXRcbiAqIEBwYXJhbSBrZXkgLSBrZXkgdG8gY2xlYXJcbiAqL1xuZXhwb3J0cy5yZXNldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgLy8gTG9jYWxcbiAgc2V0KGtleSwgJycpO1xuICAvLyBieSByb2xlXG4gIHNldEdsb2JhbChrZXksICcnLCB0cnVlKTtcbiAgLy8gR2xvYmFsXG4gIHNldEdsb2JhbChrZXksICcnKTtcbn1cblxuLy8vLy8vLy8vLyAvLy8vLy8vLy8vIC8vLy8vLy8vLy9cbi8vIGlzIGxvZ2luIHBhZ2UgICAgICAgICAgICAgIC8vXG4vLy8vLy8vLy8vIC8vLy8vLy8vLy8gLy8vLy8vLy8vL1xuXG5leHBvcnRzLmlzTG9naW5QYWdlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2xvZ2luJyA9PSBnZXRQYWdlTmFtZSgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCd2YWxpZGF0ZScgPT0gZ2V0UGFnZU5hbWUoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqIENsZWFyIGxvY2FsIGNvbmZpZ3VyYXRpb25cbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZUNvbmZpZ1xuICogQGZ1bmN0aW9uIGdvVG9QYWdlTG9naW5cbiAqL1xuZXhwb3J0cy5nb1RvUGFnZUxvZ2luID0gZnVuY3Rpb24gKCkge1xuICBsZXQgcHdhX3BhdGggPSBnZXRTdHJpbmcoJ3B1bHNld2ViYXBwcGF0aCcsICcnKTtcbiAgbGV0IG5ld2Z1bGxVUkwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgaWYgKCcnID09IHB3YV9wYXRoKSB7XG4gICAgbmV3ZnVsbFVSTCA9IHB1bHNlVXRpbGl0eS5jaGFuZ2VQYWdlTmFtZSh3aW5kb3cubG9jYXRpb24uaHJlZiwgJ2xvZ2luJyk7XG4gIH1cbiAgZWxzZSB7XG4gICAgbmV3ZnVsbFVSTCA9IHB3YV9wYXRoICsgJy9sb2dpbi5odG1sJztcblxuICAgIC8vIEFkZCAncGF0aCcgaWYgZXhpc3RzIGluIHVybCA6XG4gICAgbGV0IHRtcFBhdGggPSBwdWxzZVV0aWxpdHkuZ2V0VVJMUGFyYW1ldGVyVmFsdWVzKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCAncGF0aCcpO1xuICAgIGlmICh0bXBQYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgIG5ld2Z1bGxVUkwgPSBwdWxzZVV0aWxpdHkuY2hhbmdlVVJMUGFyYW1ldGVyKG5ld2Z1bGxVUkwsICdwYXRoJywgdG1wUGF0aFswXSk7XG4gICAgfVxuICAgIGxldCB0bXBNYWluUGF0aCA9IHB1bHNlVXRpbGl0eS5nZXRVUkxQYXJhbWV0ZXJWYWx1ZXMod2luZG93LmxvY2F0aW9uLmhyZWYsICdtYWlucGF0aCcpO1xuICAgIGlmICh0bXBNYWluUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICBuZXdmdWxsVVJMID0gcHVsc2VVdGlsaXR5LmNoYW5nZVVSTFBhcmFtZXRlcihuZXdmdWxsVVJMLCAnbWFpbnBhdGgnLCB0bXBNYWluUGF0aFswXSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBDb2RlIGlmIGV4aXN0cyAodmFsaWRhdGUgcGFnZSlcbiAgICBsZXQgdG1wQ29kZSA9IHB1bHNlVXRpbGl0eS5nZXRVUkxQYXJhbWV0ZXJWYWx1ZXMod2luZG93LmxvY2F0aW9uLmhyZWYsICdjb2RlJyk7XG4gICAgaWYgKHRtcENvZGUubGVuZ3RoID4gMCkge1xuICAgICAgbmV3ZnVsbFVSTCA9IHB1bHNlVXRpbGl0eS5yZW1vdmVVUkxQYXJhbWV0ZXIobmV3ZnVsbFVSTCwgJ2NvZGUnKTtcbiAgICB9XG4gIH1cblxuICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IG5ld2Z1bGxVUkw7XG59XG5cbi8qKiBDbGVhciBsb2NhbCBjb25maWd1cmF0aW9uXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VDb25maWdcbiAqIEBmdW5jdGlvbiBnb1RvUGFnZUxvZ2luXG4gKi9cbmV4cG9ydHMuZ29Ub0ZpcnN0UGFnZSA9IGZ1bmN0aW9uIChyb2xlKSB7XG4gIC8vIEdvIHRvIGZpcnN0UGFnZSAoaWYgZGVmaW5lZClcbiAgbGV0IHJvbGVzID0gZ2V0QXJyYXkoJ3JvbGVzJyk7XG5cbiAgLy8gQnJvd3NlIGFsbCByb2xlc1xuICBmb3IgKGxldCBpUm9sZSA9IDA7IGlSb2xlIDwgcm9sZXMubGVuZ3RoOyBpUm9sZSsrKSB7XG4gICAgbGV0IGFSb2xlID0gcm9sZXNbaVJvbGVdO1xuICAgIGlmIChyb2xlID09IGFSb2xlLnJvbGUpIHtcbiAgICAgIC8vIHJvbGUgZm91bmQgPT0gYVJvbGUuZGlzcGxheTtcbiAgICAgIGlmIChwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKGFSb2xlLmZpcnN0UGFnZSkpIHsgLy8gTWF5YmUgYWRkIHNvb25cbiAgICAgICAgLy8gZ28gdG8gaG9tZVxuICAgICAgICBsZXQgZnVsbFVSTCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgbGV0IG5ld2Z1bGxVUkwgPSBmdWxsVVJMLnN1YnN0cmluZygwLCBmdWxsVVJMLmxhc3RJbmRleE9mKCcvJykgKyAxKSArICdob21lLmh0bWwnO1xuXG4gICAgICAgIC8vIEFkZCAncGF0aCcgaWYgZXhpc3RzIGluIHVybCA6XG4gICAgICAgIGxldCB0bXBQYXRoID0gcHVsc2VVdGlsaXR5LmdldFVSTFBhcmFtZXRlclZhbHVlcyh3aW5kb3cubG9jYXRpb24uaHJlZiwgJ3BhdGgnKTtcbiAgICAgICAgaWYgKHRtcFBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG5ld2Z1bGxVUkwgPSBwdWxzZVV0aWxpdHkuY2hhbmdlVVJMUGFyYW1ldGVyKG5ld2Z1bGxVUkwsICdwYXRoJywgdG1wUGF0aFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRtcE1haW5QYXRoID0gcHVsc2VVdGlsaXR5LmdldFVSTFBhcmFtZXRlclZhbHVlcyh3aW5kb3cubG9jYXRpb24uaHJlZiwgJ21haW5wYXRoJyk7XG4gICAgICAgIGlmICh0bXBNYWluUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbmV3ZnVsbFVSTCA9IHB1bHNlVXRpbGl0eS5jaGFuZ2VVUkxQYXJhbWV0ZXIobmV3ZnVsbFVSTCwgJ21haW5wYXRoJywgdG1wTWFpblBhdGhbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBuZXdmdWxsVVJMO1xuICAgICAgfVxuICAgICAgZWxzZSB7IC8vIGdvIHRvIGZpcnN0UGFnZVxuICAgICAgICBsZXQgZmlyc3RQYWdlID0gYVJvbGUuZmlyc3RQYWdlO1xuICAgICAgICAvL2xldCBmdWxsVVJMID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgICAvL2xldCBuZXdmdWxsVVJMID0gZnVsbFVSTC5zdWJzdHJpbmcoMCwgZnVsbFVSTC5sYXN0SW5kZXhPZignLycpICsgMSkgKyBmaXJzdFBhZ2UgKyAnLmh0bWwnO1xuICAgICAgICBsZXQgbmV3ZnVsbFVSTCA9IHB1bHNlVXRpbGl0eS5jaGFuZ2VQYWdlTmFtZSh3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsIGZpcnN0UGFnZSk7XG5cbiAgICAgICAgLy8gQWRkICdwYXRoJyBpZiBleGlzdHMgaW4gdXJsIDpcbiAgICAgICAgbGV0IHRtcFBhdGggPSBwdWxzZVV0aWxpdHkuZ2V0VVJMUGFyYW1ldGVyVmFsdWVzKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCAncGF0aCcpO1xuICAgICAgICBpZiAodG1wUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbmV3ZnVsbFVSTCA9IHB1bHNlVXRpbGl0eS5jaGFuZ2VVUkxQYXJhbWV0ZXIobmV3ZnVsbFVSTCwgJ3BhdGgnLCB0bXBQYXRoWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG1wTWFpblBhdGggPSBwdWxzZVV0aWxpdHkuZ2V0VVJMUGFyYW1ldGVyVmFsdWVzKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCAnbWFpbnBhdGgnKTtcbiAgICAgICAgaWYgKHRtcE1haW5QYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBuZXdmdWxsVVJMID0gcHVsc2VVdGlsaXR5LmNoYW5nZVVSTFBhcmFtZXRlcihuZXdmdWxsVVJMLCAnbWFpbnBhdGgnLCB0bXBNYWluUGF0aFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IG5ld2Z1bGxVUkw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuLy8vLy8vLy8vLyAvLy8vLy8vLy8vIC8vLy8vLy8vLy9cbi8vIGxvZ2luIC8gdXNlciAvIGNvbnRleHQgICAgIC8vXG4vLy8vLy8vLy8vIC8vLy8vLy8vLy8gLy8vLy8vLy8vL1xuXG4vL3ZhciBjdXJyZW50Um9sZU9yQXBwQ29udGV4dElzRGVmaW5lZCA9IFxuZXhwb3J0cy5jdXJyZW50Um9sZU9yQXBwQ29udGV4dElzRGVmaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHJvbGVzID0gZ2V0QXJyYXkoJ3JvbGVzJyk7XG4gIGxldCBjdXJyZW50Um9sZSA9IGdldEFwcENvbnRleHRPclJvbGUoKTsgLy8gV0FTIGdldFJvbGUoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb2xlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyb2xlc1tpXS5yb2xlID09IGN1cnJlbnRSb2xlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBnZXQgbG9naW4gLyByb2xlIG9yIGFwcENvbnRleHQgZGlzcGxheSBhY2NvcmRpbmcgdG8gd2hhdCBpcyBhdmFpbGFibGVcbi8vdmFyIGdldEN1cnJlbnRVc2VyRGlzcGxheSA9IFxuZXhwb3J0cy5nZXRDdXJyZW50VXNlckRpc3BsYXkgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCByb2xlcyA9IGdldEFycmF5KCdyb2xlcycpO1xuXG4gIC8vIEFwcCBDb250ZXh0XG4gIGxldCBhcHBDb250ZXh0ID0gZ2V0QXBwQ29udGV4dE9ubHkoKTtcbiAgaWYgKGFwcENvbnRleHQgIT0gJycpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocm9sZXNbaV0ucm9sZSA9PSBhcHBDb250ZXh0KSB7XG4gICAgICAgIGlmIChyb2xlc1tpXS5kaXNwbGF5ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcm9sZXNbaV0uZGlzcGxheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE9yIGxvZ2luXG4gIGxldCBsb2dpbiA9IHB1bHNlTG9naW4uZ2V0TG9naW5EaXNwbGF5KCk7XG4gIGlmIChsb2dpbiAhPSAnJykge1xuICAgIHJldHVybiBsb2dpbjtcbiAgfVxuXG4gIC8vIE9yIHJvbGVcbiAgbGV0IGN1cnJlbnRSb2xlID0gcHVsc2VMb2dpbi5nZXRSb2xlKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocm9sZXNbaV0ucm9sZSA9PSBjdXJyZW50Um9sZSkge1xuICAgICAgaWYgKHJvbGVzW2ldLmRpc3BsYXkgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcm9sZXNbaV0uZGlzcGxheTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8vLy8vLy8vLy8gLy8vLy8vLy8vLyAvLy8vLy8vLy8vXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuLy8vLy8vLy8vLyAvLy8vLy8vLy8vIC8vLy8vLy8vLy8iLCIvLyBDb3B5cmlnaHQgKEMpIDIwMDktMjAyMyBMZW1vaW5lIEF1dG9tYXRpb24gVGVjaG5vbG9naWVzXG4vL1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuLyoqXG4qIEBtb2R1bGUgcHVsc2VDdXN0b21EaWFsb2dcbiogQHJlcXVpcmVzIHB1bHNlVXRpbGl0eVxuKiBAcmVxdWlyZXMgcHVsc2VTdmdcbiovXG5cbnZhciBwdWxzZVV0aWxpdHkgPSByZXF1aXJlKCdwdWxzZVV0aWxpdHknKTtcbnZhciBwdWxzZVN2ZyA9IHJlcXVpcmUoJ3B1bHNlU3ZnJyk7XG5cbnZhciBwdWxzZUN1c3RvbURpYWxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gQ29udmVuaWVudCBvYmplY3QgdG8gc3RvcmUgYW5kIGdldCBkYXRhIGF0dGFjaGVkIHRvIGEgZGlhbG9nXG4gIHZhciBfZGF0YU1hbmFnZXIgPSBwdWxzZVV0aWxpdHkuY3JlYXRlRGF0YU1hbmFnZXIoJ2N1c3RvbURpYWxvZ0lkJyk7XG5cbiAgLy8gTGlzdCBvZiBvcGVuIGRpYWxvZ3NcbiAgdmFyIF9vcGVuSWRzID0gW107XG5cbiAgdmFyIF9kaXNwbGF5TmF2aWdhdGlvbiA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBpZCA9IF9kYXRhTWFuYWdlci5nZXRJZChzZWxlY3Rvcik7XG4gICAgdmFyIGRpYWxvZ0lkID0gJ2N1c3RvbURpYWxvZycgKyBpZDtcbiAgICB2YXIgZGF0YSA9IF9kYXRhTWFuYWdlci5nZXQoaWQpO1xuXG4gICAgLy8gRXh0cmFjdCBwYXJhbWV0ZXJzIGRlZmluaW5nIHRoZSBlbGVtZW50IHZpc2liaWxpdHlcbiAgICB2YXIgY3VycmVudFBhZ2UgPSBkYXRhWydjdXJyZW50UGFnZSddO1xuICAgIHZhciBwYWdlQ291bnQgPSBkYXRhWydwYWdlQ291bnQnXTtcbiAgICB2YXIgY2FuY2VsQnV0dG9uID0gZGF0YVsnYXR0cmlidXRlcyddWydjYW5jZWxCdXR0b24nXTsgLy8gY2FuIGJlIG51bGwsIFwiaGlkZGVuXCJcbiAgICB2YXIgcHJldmlvdXNCdXR0b24gPSBkYXRhWydhdHRyaWJ1dGVzJ11bJ3ByZXZpb3VzQnV0dG9uJ107IC8vIGNhbiBiZSBudWxsLCBcImhpZGRlblwiXG4gICAgdmFyIG5leHRCdXR0b24gPSBkYXRhWydhdHRyaWJ1dGVzJ11bJ25leHRCdXR0b24nXTsgLy8gY2FuIGJlIG51bGwsIFwiaGlkZGVuXCJcbiAgICB2YXIgb2tCdXR0b24gPSBkYXRhWydhdHRyaWJ1dGVzJ11bJ29rQnV0dG9uJ107IC8vIGNhbiBiZSBudWxsLCBcImhpZGRlblwiXG4gICAgdmFyIG11bHRpUGFnZSA9IGRhdGFbJ2F0dHJpYnV0ZXMnXVsnbXVsdGlQYWdlJ107IC8vIGNhbiBiZSBcImF1dG9cIiAvIG51bGwsIFwib25cIiwgXCJvZmZcIlxuXG4gICAgLy8gRmlyc3QgYW5kL29yIGxhc3QgcGFnZT9cbiAgICAkKCcjJyArIGRpYWxvZ0lkKS50b2dnbGVDbGFzcygnY3VzdG9tRGlhbG9nRmlyc3RQYWdlJywgY3VycmVudFBhZ2UgPT0gMCk7XG4gICAgJCgnIycgKyBkaWFsb2dJZCkudG9nZ2xlQ2xhc3MoJ2N1c3RvbURpYWxvZ0xhc3RQYWdlJywgY3VycmVudFBhZ2UgPT0gcGFnZUNvdW50IC0gMSk7XG5cbiAgICAvLyBIaWRkZW4gYnV0dG9ucz9cbiAgICAkKCcjJyArIGRpYWxvZ0lkKS50b2dnbGVDbGFzcygnY3VzdG9tRGlhbG9nTm9DYW5jZWwnLCBjYW5jZWxCdXR0b24gPT0gJ2hpZGRlbicpO1xuICAgICQoJyMnICsgZGlhbG9nSWQpLnRvZ2dsZUNsYXNzKCdjdXN0b21EaWFsb2dOb1ByZXZpb3VzJywgcHJldmlvdXNCdXR0b24gPT0gJ2hpZGRlbicpO1xuICAgICQoJyMnICsgZGlhbG9nSWQpLnRvZ2dsZUNsYXNzKCdjdXN0b21EaWFsb2dOb05leHQnLCBuZXh0QnV0dG9uID09ICdoaWRkZW4nKTtcbiAgICAkKCcjJyArIGRpYWxvZ0lkKS50b2dnbGVDbGFzcygnY3VzdG9tRGlhbG9nTm9PaycsIG9rQnV0dG9uID09ICdoaWRkZW4nKTtcblxuICAgIC8vIE11bHRpcGFnZSBzdGF0ZVxuICAgICQoJyMnICsgZGlhbG9nSWQpLnRvZ2dsZUNsYXNzKCdjdXN0b21EaWFsb2dNdWx0aVBhZ2VPbicsIG11bHRpUGFnZSA9PSAnb24nKTtcbiAgICAkKCcjJyArIGRpYWxvZ0lkKS50b2dnbGVDbGFzcygnY3VzdG9tRGlhbG9nTXVsdGlQYWdlT2ZmJywgbXVsdGlQYWdlID09ICdvZmYnKTtcblxuICAgIC8vIFNldCBjdXJyZW50IHBhZ2VcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZ2VDb3VudDsgaSsrKVxuICAgICAgJCgnIycgKyBkaWFsb2dJZCArICcgLmN1c3RvbURpYWxvZ1BhZ2UnICsgaSkudG9nZ2xlQ2xhc3MoJ2N1c3RvbURpYWxvZ0N1cnJlbnRQYWdlJywgaSA9PSBjdXJyZW50UGFnZSk7XG4gIH07XG5cbiAgLypcbiAgKiBDbG9zZSBhIHByZXBhcmVkIGRpYWxvZ1xuICAqIHNlbGVjdG9yOiB0aGUgZGl2IGNvbnRhaW5pbmcgdGhlIGRpYWxvZ1xuICAqL1xuICB2YXIgY2xvc2UgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgaWQgPSBfZGF0YU1hbmFnZXIuZ2V0SWQoc2VsZWN0b3IpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gX2RhdGFNYW5hZ2VyLmdldChpZClbJ2F0dHJpYnV0ZXMnXTtcblxuICAgIHZhciBkaWFsb2dJZCA9ICdjdXN0b21EaWFsb2cnICsgaWQ7XG5cbiAgICAvLyBvbkNsb3NlP1xuICAgIGlmIChhdHRyaWJ1dGVzWydvbkNsb3NlJ10gIT0gbnVsbClcbiAgICAgIGF0dHJpYnV0ZXNbJ29uQ2xvc2UnXSgpO1xuXG4gICAgJCgnIycgKyBkaWFsb2dJZCkucmVtb3ZlQ2xhc3MoJ2N1c3RvbURpYWxvZ0VuYWJsZWQnKTtcblxuICAgIC8vIGF1dG9EZWxldGU/XG4gICAgaWYgKGF0dHJpYnV0ZXNbJ2F1dG9EZWxldGUnXSAhPSBudWxsICYmIGF0dHJpYnV0ZXNbJ2F1dG9EZWxldGUnXSA9PSB0cnVlKSB7XG4gICAgICAkKCcjJyArIGRpYWxvZ0lkKS5yZW1vdmUoKTtcbiAgICAgIF9kYXRhTWFuYWdlci5yZXNldChpZCk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gX29wZW5JZHMuaW5kZXhPZihpZCk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIF9vcGVuSWRzLnNwbGljZShpbmRleCwgMSlcblxuICAgICAgaWYgKF9vcGVuSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gVW5ibHVyIHRoZSBwcmV2aW91cyBkaWFsb2dcbiAgICAgICAgJCgnI2N1c3RvbURpYWxvZycgKyBfb3Blbklkc1tfb3Blbklkcy5sZW5ndGggLSAxXSkuY3NzKCdmaWx0ZXInLCAnYmx1cigwKScpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIFVuYmx1ciBiZWhpbmQgdGhlIGZpcnN0IGRpYWxvZ1xuICAgICAgICAkKCcucHVsc2UtaGVhZGVyJykuY3NzKCdmaWx0ZXInLCAnYmx1cigwKScpO1xuICAgICAgICAkKCcjcHVsc2UtaW5uZXInKS5jc3MoJ2ZpbHRlcicsICdibHVyKDApJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICogQ2FsbCBcImNhbmNlbFwiIG9mIGEgZGlhbG9nXG4gICovXG4gIHZhciBjYW5jZWwgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgaWQgPSBfZGF0YU1hbmFnZXIuZ2V0SWQoc2VsZWN0b3IpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gX2RhdGFNYW5hZ2VyLmdldChpZClbJ2F0dHJpYnV0ZXMnXTtcblxuICAgIC8vIG9uQ2FuY2VsP1xuICAgIGlmIChhdHRyaWJ1dGVzWydvbkNhbmNlbCddICE9IG51bGwpXG4gICAgICBhdHRyaWJ1dGVzWydvbkNhbmNlbCddKCk7XG5cbiAgICAvLyBhdXRvQ2xvc2U/XG4gICAgaWYgKChhdHRyaWJ1dGVzWydhdXRvQ2xvc2UnXSAhPSBudWxsICYmIGF0dHJpYnV0ZXNbJ2F1dG9DbG9zZSddID09IHRydWUpIHx8IChhdHRyaWJ1dGVzWydvbkNhbmNlbCddID09IG51bGwpKSAvLyBJZiBubyBhdXRvQ2xvc2UgQU5EIG5vIG1ldGhvZCBDYW5jZWwgOiBYIHNob3VsZCBjbG9zZSBkaWFsb2dcbiAgICAgIGNsb3NlKHNlbGVjdG9yKTtcbiAgfTtcblxuICAvKlxuICAqIENhbGwgXCJva1wiIG9mIGEgZGlhbG9nXG4gICovXG4gIHZhciBvayA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBpZCA9IF9kYXRhTWFuYWdlci5nZXRJZChzZWxlY3Rvcik7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBfZGF0YU1hbmFnZXIuZ2V0KGlkKVsnYXR0cmlidXRlcyddO1xuXG4gICAgLy8gb25Paz9cbiAgICBpZiAoYXR0cmlidXRlc1snb25PayddICE9IG51bGwpXG4gICAgICBhdHRyaWJ1dGVzWydvbk9rJ10oKTtcblxuICAgIC8vIGF1dG9DbG9zZT9cbiAgICBpZiAoYXR0cmlidXRlc1snYXV0b0Nsb3NlJ10gIT0gbnVsbCAmJiBhdHRyaWJ1dGVzWydhdXRvQ2xvc2UnXSA9PSB0cnVlKVxuICAgICAgY2xvc2Uoc2VsZWN0b3IpO1xuICB9O1xuXG4gIC8qXG4gICogQ2FsbCBcInByZXZpb3VzXCIgb2YgYSBkaWFsb2dcbiAgKi9cbiAgdmFyIHByZXZpb3VzID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGlkID0gX2RhdGFNYW5hZ2VyLmdldElkKHNlbGVjdG9yKTtcbiAgICB2YXIgY3VycmVudFBhZ2UgPSBfZGF0YU1hbmFnZXIuZ2V0KGlkKVsnY3VycmVudFBhZ2UnXTtcbiAgICBpZiAoY3VycmVudFBhZ2UgPiAwKVxuICAgICAgX2RhdGFNYW5hZ2VyLnNldChpZCwgJ2N1cnJlbnRQYWdlJywgY3VycmVudFBhZ2UgLSAxKTtcbiAgICBfZGlzcGxheU5hdmlnYXRpb24oc2VsZWN0b3IpO1xuICB9O1xuXG4gIC8qXG4gICogQ2FsbCBcIm5leHRcIiBvZiBhIGRpYWxvZ1xuICAqL1xuICB2YXIgbmV4dCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBpZCA9IF9kYXRhTWFuYWdlci5nZXRJZChzZWxlY3Rvcik7XG4gICAgdmFyIHBhZ2VDb3VudCA9IF9kYXRhTWFuYWdlci5nZXQoaWQpWydwYWdlQ291bnQnXTtcbiAgICB2YXIgY3VycmVudFBhZ2UgPSBfZGF0YU1hbmFnZXIuZ2V0KGlkKVsnY3VycmVudFBhZ2UnXTtcbiAgICBpZiAoY3VycmVudFBhZ2UgPCBwYWdlQ291bnQgLSAxKVxuICAgICAgX2RhdGFNYW5hZ2VyLnNldChpZCwgJ2N1cnJlbnRQYWdlJywgY3VycmVudFBhZ2UgKyAxKTtcbiAgICBfZGlzcGxheU5hdmlnYXRpb24oc2VsZWN0b3IpO1xuICB9O1xuXG4gIC8qXG4gICogRGlzcGxheSBhIGRlZmluZWQgcGFnZSBvZiBhIGRpYWxvZ1xuICAqL1xuICB2YXIgZ29Ub1BhZ2UgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIG5iKSB7XG4gICAgdmFyIGlkID0gX2RhdGFNYW5hZ2VyLmdldElkKHNlbGVjdG9yKTtcbiAgICB2YXIgcGFnZUNvdW50ID0gX2RhdGFNYW5hZ2VyLmdldChpZClbJ3BhZ2VDb3VudCddO1xuICAgIGlmIChuYiA8IHBhZ2VDb3VudCAmJiBuYiA+PSAwKVxuICAgICAgX2RhdGFNYW5hZ2VyLnNldChpZCwgJ2N1cnJlbnRQYWdlJywgbmIpO1xuICAgIF9kaXNwbGF5TmF2aWdhdGlvbihzZWxlY3Rvcik7XG4gIH07XG5cbiAgdmFyIF9jcmVhdGVEaWFsb2cgPSBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuICAgIC8vIENyZWF0ZSBhbiBpZFxuICAgIHZhciBpZCA9IF9kYXRhTWFuYWdlci5jcmVhdGVOZXdJZCgpO1xuICAgIHZhciBkaWFsb2dJZCA9ICdjdXN0b21EaWFsb2cnICsgaWQ7XG5cbiAgICAvLyBPcHRpb25zXG4gICAgdmFyIGNsb3NlQnV0dG9uID0gKGF0dHJpYnV0ZXNbJ2Nsb3NlQnV0dG9uJ10gIT0gJ2hpZGRlbicpO1xuICAgIHZhciBmdWxsU2NyZWVuT25TbWFydHBob25lID0gKGF0dHJpYnV0ZXNbJ2Z1bGxTY3JlZW5PblNtYXJ0cGhvbmUnXSA9PSB0cnVlKTtcbiAgICB2YXIgYmlnU2l6ZSA9IChhdHRyaWJ1dGVzWydiaWdTaXplJ10gPT0gdHJ1ZSk7XG4gICAgdmFyIGZ1bGxTaXplID0gKGF0dHJpYnV0ZXNbJ2Z1bGxTaXplJ10gPT0gdHJ1ZSk7XG4gICAgdmFyIHNtYWxsU2l6ZSA9IChhdHRyaWJ1dGVzWydzbWFsbFNpemUnXSA9PSB0cnVlKTtcbiAgICB2YXIgaGVscE5hbWUgPSBhdHRyaWJ1dGVzWydoZWxwTmFtZSddO1xuXG4gICAgLy8gQ3JlYXRlIGEgZGlhbG9nXG4gICAgJCgnYm9keScpLmFwcGVuZChcbiAgICAgIFwiPGRpdiBpZD0nXCIgKyBkaWFsb2dJZCArIFwiJyBjbGFzcz0nY3VzdG9tRGlhbG9nJz5cIiArXG4gICAgICBcIjxkaXYgY2xhc3M9J2N1c3RvbURpYWxvZ1NoYWRvdyc+PC9kaXY+XCIgK1xuICAgICAgXCI8ZGl2IGNsYXNzPSdjdXN0b21EaWFsb2dXaW5kb3dcIiArIChmdWxsU2NyZWVuT25TbWFydHBob25lID8gJyBjdXN0b21EaWFsb2dXaW5kb3dGdWxsU2NyZWVuT25TbWFydHBob25lJyA6ICcnKSArXG4gICAgICAoZnVsbFNpemUgPyAnIGZ1bGxTaXplJyA6IChiaWdTaXplID8gJyBiaWdTaXplJyA6IChzbWFsbFNpemUgPyAnIHNtYWxsU2l6ZScgOiAnJykpKSArIFwiJz5cIiArXG4gICAgICBcIjxkaXYgY2xhc3M9J2N1c3RvbURpYWxvZ0hlYWRlcic+XCIgK1xuICAgICAgKGNsb3NlQnV0dG9uID8gXCI8ZGl2IGNsYXNzPSdjdXN0b21EaWFsb2dDbG9zZUJveCcgdGl0bGU9J0Nsb3NlIGRpYWxvZyc+PC9kaXY+XCIgOiAnJykgK1xuICAgICAgKGhlbHBOYW1lID8gXCI8ZGl2IGNsYXNzPSdjdXN0b21EaWFsb2dIZWxwQm94JyB0aXRsZT0nSGVscCBmaWxlJyBoZWxwbmFtZT0nXCIgKyBoZWxwTmFtZSArIFwiJz48L2Rpdj5cIiA6ICcnKSArXG4gICAgICBcIjxkaXYgY2xhc3M9J2N1c3RvbURpYWxvZ1RpdGxlJz5cIiArIGF0dHJpYnV0ZXNbJ3RpdGxlJ10gKyAnPC9kaXY+JyArXG4gICAgICAnPC9kaXY+JyArXG4gICAgICBcIjxkaXYgY2xhc3M9J2N1c3RvbURpYWxvZ0NvbnRlbnQnPjwvZGl2PlwiICtcbiAgICAgIFwiPGRpdiBjbGFzcz0nY3VzdG9tRGlhbG9nQnV0dG9ucyc+XCIgK1xuICAgICAgXCI8YnV0dG9uIGNsYXNzPSdjdXN0b21EaWFsb2dDYW5jZWwgYnV0dG9uRGlhbG9nJyB0aXRsZT0nQ2FuY2VsJyByb2xlPSdidXR0b24nPjwvYnV0dG9uPlwiICtcbiAgICAgIFwiPGJ1dHRvbiBjbGFzcz0nY3VzdG9tRGlhbG9nUHJldmlvdXMgYnV0dG9uRGlhbG9nJyB0aXRsZT0nUHJldmlvdXMnIHJvbGU9J2J1dHRvbic+PC9idXR0b24+XCIgK1xuICAgICAgXCI8YnV0dG9uIGNsYXNzPSdjdXN0b21EaWFsb2dOZXh0IGJ1dHRvbkRpYWxvZycgdGl0bGU9J05leHQnIHJvbGU9J2J1dHRvbic+PC9idXR0b24+XCIgK1xuICAgICAgXCI8YnV0dG9uIGNsYXNzPSdjdXN0b21EaWFsb2dPayBidXR0b25EaWFsb2cnIHRpdGxlPSdPaycgcm9sZT0nYnV0dG9uJz48L2J1dHRvbj5cIiArXG4gICAgICAnPC9kaXY+JyArXG4gICAgICAnPC9kaXY+JyArXG4gICAgICAnPC9kaXY+Jyk7XG4gICAgX2RhdGFNYW5hZ2VyLmluaXRpYWxpemVJZEF0dHJpYnV0ZSgnIycgKyBkaWFsb2dJZCwgaWQpO1xuXG4gICAgcHVsc2VTdmcuaW5saW5lQmFja2dyb3VuZFN2ZygnIycgKyBkaWFsb2dJZCArICcgLmN1c3RvbURpYWxvZ0NhbmNlbCcpO1xuICAgIHB1bHNlU3ZnLmlubGluZUJhY2tncm91bmRTdmcoJyMnICsgZGlhbG9nSWQgKyAnIC5jdXN0b21EaWFsb2dQcmV2aW91cycpO1xuICAgIHB1bHNlU3ZnLmlubGluZUJhY2tncm91bmRTdmcoJyMnICsgZGlhbG9nSWQgKyAnIC5jdXN0b21EaWFsb2dOZXh0Jyk7XG4gICAgcHVsc2VTdmcuaW5saW5lQmFja2dyb3VuZFN2ZygnIycgKyBkaWFsb2dJZCArICcgLmN1c3RvbURpYWxvZ09rJyk7XG4gICAgcHVsc2VTdmcuaW5saW5lQmFja2dyb3VuZFN2ZygnIycgKyBkaWFsb2dJZCArICcgLmN1c3RvbURpYWxvZ0Nsb3NlQm94Jyk7XG4gICAgcHVsc2VTdmcuaW5saW5lQmFja2dyb3VuZFN2ZygnIycgKyBkaWFsb2dJZCArICcgLmN1c3RvbURpYWxvZ0hlbHBCb3gnKTtcblxuICAgIC8vIE51bWJlciBvZiBwYWdlc1xuICAgIF9kYXRhTWFuYWdlci5zZXQoaWQsICdhdHRyaWJ1dGVzJywgYXR0cmlidXRlcyk7XG4gICAgX2RhdGFNYW5hZ2VyLnNldChpZCwgJ2N1cnJlbnRQYWdlJywgMCk7XG4gICAgX2RhdGFNYW5hZ2VyLnNldChpZCwgJ3BhZ2VDb3VudCcsIDApO1xuXG4gICAgLy8gQWRkIGNhbGxiYWNrc1xuICAgICQoJyMnICsgZGlhbG9nSWQgKyAnIC5jdXN0b21EaWFsb2dDbG9zZUJveCcpLmNsaWNrKGZ1bmN0aW9uICgpIHsgY2FuY2VsKCcjJyArIGRpYWxvZ0lkKTsgfSk7XG4gICAgJCgnIycgKyBkaWFsb2dJZCArICcgLmN1c3RvbURpYWxvZ0NhbmNlbCcpLmNsaWNrKGZ1bmN0aW9uICgpIHsgY2FuY2VsKCcjJyArIGRpYWxvZ0lkKTsgfSk7XG4gICAgJCgnIycgKyBkaWFsb2dJZCArICcgLmN1c3RvbURpYWxvZ1ByZXZpb3VzJykuY2xpY2soZnVuY3Rpb24gKCkgeyBwcmV2aW91cygnIycgKyBkaWFsb2dJZCk7IH0pO1xuICAgICQoJyMnICsgZGlhbG9nSWQgKyAnIC5jdXN0b21EaWFsb2dOZXh0JykuY2xpY2soZnVuY3Rpb24gKCkgeyBuZXh0KCcjJyArIGRpYWxvZ0lkKTsgfSk7XG4gICAgJCgnIycgKyBkaWFsb2dJZCArICcgLmN1c3RvbURpYWxvZ09rJykuY2xpY2soZnVuY3Rpb24gKCkgeyBvaygnIycgKyBkaWFsb2dJZCk7IH0pO1xuXG4gICAgJCgnLmN1c3RvbURpYWxvZ0hlbHBCb3gnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAvL2xldCBoZWxwTmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdoZWxwbmFtZScpO1xuICAgICAgbGV0IHBhdGhuYW1lID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgICAgbGV0IHBkZlBhdGggPSBwYXRobmFtZS5zdWJzdHJpbmcoMCwgcGF0aG5hbWUubGFzdEluZGV4T2YoJy8nKSArIDEpICsgJ2hlbHAvJyArIGhlbHBOYW1lICsgJy5wZGYnO1xuICAgICAgLy8gT3BlbiBoZWxwIGZpbGUgKGlmIGV4aXN0cylcbiAgICAgIGZ1bmN0aW9uIF9maWxlRXhpc3RzICh1cmwpIHtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICByZXEub3BlbignSEVBRCcsIHVybCwgZmFsc2UpOyAvLyBoZWFkIGlzIGZhc3RlciB0aGFuIEdFVFxuICAgICAgICAgIHJlcS5zZW5kKCk7XG4gICAgICAgICAgcmV0dXJuIHJlcS5zdGF0dXMgPT0gMjAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9maWxlRXhpc3RzKHBkZlBhdGgpKSB7XG4gICAgICAgIHdpbmRvdy5vcGVuKHBkZlBhdGgsICdyZXNpemFibGUsc2Nyb2xsYmFycycpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vcHVsc2VDdXN0b21EaWFsb2cub3BlbkluZm8oJ0ZpbGUgbm90IGZvdW5kICEnKTsgLy8gaW1wb3NzaWJsZSBpbiBkaWFsb2cgOihcbiAgICAgICAgd2luZG93LmFsZXJ0KCdGaWxlIG5vdCBmb3VuZCAhJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBNYXggaGVpZ2h0IG9yIGhlaWdodCBvZiB0aGUgZGlhbG9nXG4gICAgaWYgKGF0dHJpYnV0ZXNbJ2ZpeGVkSGVpZ2h0J10gPT0gdHJ1ZSkge1xuICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICQoJyMnICsgZGlhbG9nSWQgKyAnIC5jdXN0b21EaWFsb2dDb250ZW50ID4gZGl2JykuY3NzKCdoZWlnaHQnLCAoKCQodGhpcykuaGVpZ2h0KCkgLSA3MCkgKiAoZnVsbFNpemUgPyAwLjk5IDogKGJpZ1NpemUgPyAwLjc1IDogMC42KSkpICsgJ3B4Jyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJCgnIycgKyBkaWFsb2dJZCArICcgLmN1c3RvbURpYWxvZ0NvbnRlbnQgPiBkaXYnKS5jc3MoJ21heC1oZWlnaHQnLCAoKCQodGhpcykuaGVpZ2h0KCkgLSA3MCkgKiAoZnVsbFNpemUgPyAwLjk5IDogKGJpZ1NpemUgPyAwLjc1IDogMC42KSkpICsgJ3B4Jyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgZGlhbG9nXG4gICAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAkKCcjJyArIGRpYWxvZ0lkICsgJyAuY3VzdG9tRGlhbG9nV2luZG93JykuY3NzKCd0b3AnLCAoKCQodGhpcykuaGVpZ2h0KCkgLSAkKCcjJyArIGRpYWxvZ0lkICsgJyAuY3VzdG9tRGlhbG9nV2luZG93JykuaGVpZ2h0KCkpICogMC4zKSArICdweCcpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlkO1xuICB9O1xuXG4gIC8qXG4gICAqIEFkZCBhIHBhZ2UgdG8gYSBwcmVwYXJlZCBkaWFsb2dcbiAgICogc2VsZWN0b3I6IHRoZSBkaXYgY29udGFpbmluZyB0aGUgZGlhbG9nXG4gICAqIHBhZ2VTZWxlY3RvcjogdGhlIGRpdiB0aGF0IHdpbGwgYmUgdGhlIG5ldyBwYWdlXG4gICAqL1xuICB2YXIgYWRkUGFnZSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgcGFnZVNlbGVjdG9yKSB7XG4gICAgLy8gSWQgb2YgdGhlIGRpYWxvZ1xuICAgIHZhciBpZCA9IF9kYXRhTWFuYWdlci5nZXRJZChzZWxlY3Rvcik7XG5cbiAgICAvLyBOdW1iZXIgb2YgcGFnZXNcbiAgICB2YXIgcGFnZUNvdW50ID0gX2RhdGFNYW5hZ2VyLmdldChpZClbJ3BhZ2VDb3VudCddO1xuICAgIHZhciBibG9ja1RvSW5zZXJ0ID0gJChwYWdlU2VsZWN0b3IpLmRldGFjaCgpLmFkZENsYXNzKCdjdXN0b21EaWFsb2dQYWdlJyArIHBhZ2VDb3VudCk7XG4gICAgYmxvY2tUb0luc2VydC5hcHBlbmRUbygnI2N1c3RvbURpYWxvZycgKyBpZCArICcgLmN1c3RvbURpYWxvZ0NvbnRlbnQnKTtcbiAgICBfZGF0YU1hbmFnZXIuaW5pdGlhbGl6ZUlkQXR0cmlidXRlKHBhZ2VTZWxlY3RvciwgaWQpO1xuXG4gICAgLy8gVXBkYXRlIGRhdGFcbiAgICBfZGF0YU1hbmFnZXIuc2V0KGlkLCAncGFnZUNvdW50JywgcGFnZUNvdW50ICsgMSk7XG5cbiAgICAvLyBEaW1lbnNpb25zIG9mIGEgcGFnZVxuICAgICQoJyNjdXN0b21EaWFsb2cnICsgaWQgKyAnIC5jdXN0b21EaWFsb2dDb250ZW50ID4gZGl2JykuY3NzKCd3aWR0aCcsICgxMDAgLyAocGFnZUNvdW50ICsgMSkpICsgJyUnKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IF9kYXRhTWFuYWdlci5nZXQoaWQpWydhdHRyaWJ1dGVzJ107XG4gICAgdmFyIGJpZ1NpemUgPSAoYXR0cmlidXRlc1snYmlnU2l6ZSddID09IHRydWUpO1xuICAgIHZhciBmdWxsU2l6ZSA9IChhdHRyaWJ1dGVzWydmdWxsU2l6ZSddID09IHRydWUpO1xuICAgIGlmIChhdHRyaWJ1dGVzWydmaXhlZEhlaWdodCddID09IHRydWUpXG4gICAgICAkKCcjY3VzdG9tRGlhbG9nJyArIGlkICsgJyAuY3VzdG9tRGlhbG9nQ29udGVudCA+IGRpdicpXG4gICAgICAgIC5jc3MoJ2hlaWdodCcsICgoJCh3aW5kb3cpLmhlaWdodCgpIC0gNzApICogKGZ1bGxTaXplID8gMC45OSA6IChiaWdTaXplID8gMC43NSA6IDAuNikpKSArICdweCcpO1xuICAgIGVsc2VcbiAgICAgICQoJyNjdXN0b21EaWFsb2cnICsgaWQgKyAnIC5jdXN0b21EaWFsb2dDb250ZW50ID4gZGl2JylcbiAgICAgICAgLmNzcygnbWF4LWhlaWdodCcsICgoJCh3aW5kb3cpLmhlaWdodCgpIC0gNzApICogKGZ1bGxTaXplID8gMC45OSA6IChiaWdTaXplID8gMC43NSA6IDAuNikpKSArICdweCcpO1xuXG4gICAgLy8gQWRhcHRlIHRoZSBuYXZpZ2F0aW9uIGJ1dHRvbnNcbiAgICBfZGlzcGxheU5hdmlnYXRpb24oc2VsZWN0b3IpO1xuICB9O1xuXG4gIC8qIENyZWF0ZSBhIGRpYWxvZyB3aXRoIGluaXRpYWxpemUgYW5kIGFkZHBhZ2VcbiAgICogQXR0cmlidXRlczpcbiAgICogLSB0aXRsZVxuICAgKiAtIGNhbmNlbEJ1dHRvbiAvIHByZXZpb3VzQnV0dG9uIC8gbmV4dEJ1dHRvbiAvIG9rQnV0dG9uOiBjYW4gYmUgc2V0IHRvIFwiaGlkZGVuXCJcbiAgICogLSBtdWx0aXBhZ2U6IGNhbiBiZSBzZXQgdG8gXCJhdXRvXCIgKGRlZmF1bHQpLCBcIm9uXCIsIFwib2ZmXCJcbiAgICogLSBvbk9wZW4sIG9uT2ssIG9uQ2FuY2VsLCBvbkNsb3NlOiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdHJpZ2dlcmVkXG4gICAqIC0gYXV0b0Nsb3NlOiB0cnVlIC8gZmFsc2UgKGRlZmF1bHQpLCBjbG9zZSBhdXRvbWF0aWNhbGx5IHRoZSBkaWFsb2dcbiAgICogLSBhdXRvRGVsZXRlOiB0cnVlIC8gZmFsc2UgKGRlZmF1bHQpLCByZW1vdmUgYXV0b21hdGljYWxseSB0aGUgaHRtbCBhc3NvY2lhdGVkIHRvIHRoZSBkaWFsb2dcbiAgICogLSBmaXhlZEhlaWdodDogdHJ1ZSAvIGZhbHNlIChkZWZhdWx0KSwgZm9yY2UgXCJmdWxsXCIgaGVpZ2h0IG90aGVyd2lzZSBjYW4gYmUgc21hbGxlclxuICAgKiAtIGJpZ1NpemU6IHRydWUgLyBmYWxzZSAoZGVmYXVsdCksIHdpZHRoIDkwJSBvbiBiaWcgc2NyZWVuXG4gICAqIC0gZnVsbFNpemU6IHRydWUgLyBmYWxzZSAoZGVmYXVsdCksIHdpZHRoIDk5JSBvbiBiaWcgc2NyZWVuXG4gICAqIC0gZnVsbFNjcmVlbk9uU21hcnRwaG9uZTogdHJ1ZSAvIGZhbHNlIChkZWZhdWx0KSwgYWN0aXZhdGUgdGhlIGZ1bGwgc2NyZWVuIG9uIHNtYXJ0cGhvbmVcbiAgICpcbiAgICogUmV0dXJuIHRoZSBkaXYgbmFtZSBvZiB0aGUgZGlhbG9nXG4gICAqL1xuICB2YXIgaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChzZWxlY3RvciwgYXR0cmlidXRlcykge1xuICAgIGlmIChhdHRyaWJ1dGVzID09IG51bGwpXG4gICAgICBhdHRyaWJ1dGVzID0ge307XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgZGlhbG9nXG4gICAgdmFyIGlkID0gX2NyZWF0ZURpYWxvZyhhdHRyaWJ1dGVzKTtcblxuICAgIC8vIEFkZCBhIHBhZ2VcbiAgICBhZGRQYWdlKCcjY3VzdG9tRGlhbG9nJyArIGlkLCBzZWxlY3Rvcik7XG5cbiAgICByZXR1cm4gJ2N1c3RvbURpYWxvZycgKyBpZDtcbiAgfTtcblxuICB2YXIgc2V0QXR0cmlidXRlID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBrZXksIHZhbHVlKSB7XG4gICAgLy8gSWQgb2YgdGhlIGRpYWxvZ1xuICAgIHZhciBpZCA9IF9kYXRhTWFuYWdlci5nZXRJZChzZWxlY3Rvcik7XG5cbiAgICAvLyBVcGRhdGUgZGF0YVxuICAgIHZhciBhdHRyaWJ1dGVzID0gX2RhdGFNYW5hZ2VyLmdldChpZClbJ2F0dHJpYnV0ZXMnXTtcbiAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICBfZGF0YU1hbmFnZXIuc2V0KGlkLCAnYXR0cmlidXRlcycsIGF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gUG9zc2libHkgdXBkYXRlIHRoZSB0aXRsZVxuICAgIGlmIChrZXkgPT0gJ3RpdGxlJykge1xuICAgICAgJCgnI2N1c3RvbURpYWxvZycgKyBpZCArICcgLmN1c3RvbURpYWxvZ1RpdGxlJykuaHRtbCh2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIE9wZW4gY29tbW9uIGRpYWxvZ3MgKGluZm8sIHdhcm5pbmcsIGVycm9yLCBxdWVzdGlvbilcbiAgdmFyIF9hZGRDb21tb25QYWdlID0gZnVuY3Rpb24gKGlkLCBtZXNzYWdlLCBpY29uKSB7XG4gICAgdmFyIGRpYWxvZ0lkID0gJ2N1c3RvbURpYWxvZycgKyBpZDtcbiAgICB2YXIgcGFnZUlkID0gZGlhbG9nSWQgKyAnY29udGVudCc7XG4gICAgJCgnYm9keScpLmFwcGVuZChcbiAgICAgIFwiPGRpdiBpZD0nXCIgKyBwYWdlSWQgKyBcIic+XCIgK1xuICAgICAgXCI8ZGl2IGNsYXNzPSdjdXN0b21EaWFsb2dJY29uIGN1c3RvbURpYWxvZ0ljb25cIiArIGljb24gKyBcIic+PC9kaXY+XCIgK1xuICAgICAgXCI8ZGl2IGNsYXNzPSdjdXN0b21EaWFsb2dNZXNzYWdlJz5cIiArIG1lc3NhZ2UgKyAnPC9kaXY+JyArXG4gICAgICAnPC9kaXY+Jyk7XG4gICAgYWRkUGFnZSgnIycgKyBkaWFsb2dJZCwgJyMnICsgcGFnZUlkKTtcblxuICAgIC8vIEtlZXAgYWZ0ZXIgYWRkUGFnZSB0byBra2VwIGNvbG9yXG4gICAgcHVsc2VTdmcuaW5saW5lQmFja2dyb3VuZFN2ZygnIycgKyBwYWdlSWQgKyAnIC5jdXN0b21EaWFsb2dJY29uJyk7XG4gIH07XG5cbiAgLypcbiAgKiBPcGVuIGEgcHJlcGFyZWQgZGlhbG9nXG4gICogc2VsZWN0b3I6IHRoZSBkaXYgY29udGFpbmluZyB0aGUgZGlhbG9nXG4gICoga25vd25EaWFsb2dJZCA6IGRpYWxvZyBpZCBpZiBrbm93biAtIGVsc2UgYnVnOiBvcGVuIG1hY2hpbmUgc2VsZWN0aW9uIHBhZ2UgdHdpY2UgPT4gYmx1clxuICAqL1xuICB2YXIgb3BlbiA9IGZ1bmN0aW9uIChzZWxlY3Rvciwga25vd25EaWFsb2dJZCkge1xuICAgIF9kaXNwbGF5TmF2aWdhdGlvbihzZWxlY3Rvcik7XG4gICAgdmFyIGlkID0gX2RhdGFNYW5hZ2VyLmdldElkKHNlbGVjdG9yKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IF9kYXRhTWFuYWdlci5nZXQoaWQpWydhdHRyaWJ1dGVzJ107XG5cbiAgICAvLyBCYWNrIHRvIGZpcnN0IHBhZ2VcbiAgICBpZiAoX2RhdGFNYW5hZ2VyLmdldChpZClbJ2N1cnJlbnRQYWdlJ10gPiAwKVxuICAgICAgX2RhdGFNYW5hZ2VyLnNldChpZCwgJ2N1cnJlbnRQYWdlJywgMCk7XG4gICAgX2Rpc3BsYXlOYXZpZ2F0aW9uKHNlbGVjdG9yKTtcblxuICAgIGlmIChhdHRyaWJ1dGVzWydvbk9wZW4nXSAhPSBudWxsKVxuICAgICAgYXR0cmlidXRlc1snb25PcGVuJ10oKTtcbiAgICAkKCcjY3VzdG9tRGlhbG9nJyArIGlkKS5hZGRDbGFzcygnY3VzdG9tRGlhbG9nRW5hYmxlZCcpO1xuXG4gICAgLy8gQWRhcHQgdGhlIHBvc2l0aW9uXG4gICAgJCgnI2N1c3RvbURpYWxvZycgKyBpZCArICcgLmN1c3RvbURpYWxvZ1dpbmRvdycpLmNzcygndG9wJywgKCgkKCcjY3VzdG9tRGlhbG9nJyArIGlkICsgJyAuY3VzdG9tRGlhbG9nU2hhZG93JykuaGVpZ2h0KCkgLSAkKCcjY3VzdG9tRGlhbG9nJyArIGlkICsgJyAuY3VzdG9tRGlhbG9nV2luZG93JykuaGVpZ2h0KCkpICogMC4zKSArICdweCcpO1xuXG4gICAgLy8gQmx1ciB0aGUgcHJldmlvdXMgZGlhbG9nIGlmIG5vdCBhbHJlYWR5IGRvbmUgICAgXG4gICAgaWYgKCdjdXN0b21EaWFsb2cnICsgaWQgIT0ga25vd25EaWFsb2dJZCkge1xuICAgICAgaWYgKF9vcGVuSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgJCgnI2N1c3RvbURpYWxvZycgKyBfb3Blbklkc1tfb3Blbklkcy5sZW5ndGggLSAxXSkuY3NzKCdmaWx0ZXInLCAnYmx1cigzcHgpJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gQmx1ciBiZWhpbmQgdGhlIGZpcnN0IGRpYWxvZ1xuICAgICAgICAkKCcucHVsc2UtaGVhZGVyJykuY3NzKCdmaWx0ZXInLCAnYmx1cigycHgpJyk7XG4gICAgICAgICQoJyNwdWxzZS1pbm5lcicpLmNzcygnZmlsdGVyJywgJ2JsdXIoMnB4KScpO1xuICAgICAgfVxuICAgICAgX29wZW5JZHNbX29wZW5JZHMubGVuZ3RoXSA9IGlkO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICAqIE9wZW4gYW4gaW5mbyBkaWFsb2cuXG4gICogSXQgY291bGQgYmUgJC5wcm9tcHQgQlVUIHRoaXMgb25lIHVzZSBQb21hbW8gZGVzaWduLlxuICAqIG1lc3NhZ2U6IG1lc3NhZ2UgaW5zaWRlIHRoZSB3aW5kb3dcbiAgKiB0aXRsZTogdGl0bGUgb2YgdGhlIHdpbmRvd1xuICAqIG9uQ2xvc2U6IGNhbGxiYWNrIHdoZW4gdGhlIHdpbmRvdyBpcyBjbG9zZWQgKG9rIG9yIGNhbmNlbClcbiAgKi9cbiAgdmFyIG9wZW5JbmZvID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHRpdGxlLCBvbkNsb3NlKSB7XG4gICAgdmFyIGlkID0gX2NyZWF0ZURpYWxvZyh7XG4gICAgICB0aXRsZTogKHRpdGxlID09IG51bGwgPyAnSW5mb3JtYXRpb24nIDogdGl0bGUpLFxuICAgICAgY2FuY2VsQnV0dG9uOiAnaGlkZGVuJyxcbiAgICAgIHByZXZpb3VzQnV0dG9uOiAnaGlkZGVuJyxcbiAgICAgIGF1dG9DbG9zZTogdHJ1ZSxcbiAgICAgIGF1dG9EZWxldGU6IHRydWUsXG4gICAgICBvbkNsb3NlOiBvbkNsb3NlXG4gICAgfSk7XG4gICAgX2FkZENvbW1vblBhZ2UoaWQsIG1lc3NhZ2UsICdJbmZvcm1hdGlvbicpO1xuICAgIG9wZW4oJyNjdXN0b21EaWFsb2cnICsgaWQpO1xuXG4gICAgcmV0dXJuICdjdXN0b21EaWFsb2cnICsgaWQ7XG4gIH07XG5cbiAgLypcbiAgKiBPcGVuIGEgd2FybmluZyBkaWFsb2dcbiAgKiBtZXNzYWdlOiBtZXNzYWdlIGluc2lkZSB0aGUgd2luZG93XG4gICogdGl0bGU6IHRpdGxlIG9mIHRoZSB3aW5kb3dcbiAgKiBvbkNsb3NlOiBjYWxsYmFjayB3aGVuIHRoZSB3aW5kb3cgaXMgY2xvc2VkIChvayBvciBjYW5jZWwpXG4gICovXG4gIHZhciBvcGVuV2FybmluZyA9IGZ1bmN0aW9uIChtZXNzYWdlLCB0aXRsZSwgb25DbG9zZSkge1xuICAgIHZhciBpZCA9IF9jcmVhdGVEaWFsb2coe1xuICAgICAgdGl0bGU6ICh0aXRsZSA9PSBudWxsID8gJ1dhcm5pbmcnIDogdGl0bGUpLFxuICAgICAgY2FuY2VsQnV0dG9uOiAnaGlkZGVuJyxcbiAgICAgIHByZXZpb3VzQnV0dG9uOiAnaGlkZGVuJyxcbiAgICAgIGF1dG9DbG9zZTogdHJ1ZSxcbiAgICAgIGF1dG9EZWxldGU6IHRydWUsXG4gICAgICBvbkNsb3NlOiBvbkNsb3NlXG4gICAgfSk7XG4gICAgX2FkZENvbW1vblBhZ2UoaWQsIG1lc3NhZ2UsICdXYXJuaW5nJyk7XG4gICAgb3BlbignI2N1c3RvbURpYWxvZycgKyBpZCk7XG4gIH07XG5cbiAgLypcbiAgKiBPcGVuIGFuIGVycm9yIGRpYWxvZ1xuICAqIG1lc3NhZ2U6IG1lc3NhZ2UgaW5zaWRlIHRoZSB3aW5kb3dcbiAgKiB0aXRsZTogdGl0bGUgb2YgdGhlIHdpbmRvd1xuICAqIG9uQ2xvc2U6IGNhbGxiYWNrIHdoZW4gdGhlIHdpbmRvdyBpcyBjbG9zZWQgKG9rIG9yIGNhbmNlbClcbiAgKi9cbiAgdmFyIG9wZW5FcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCB0aXRsZSwgb25DbG9zZSkge1xuICAgIHZhciBpZCA9IF9jcmVhdGVEaWFsb2coe1xuICAgICAgdGl0bGU6ICh0aXRsZSA9PSBudWxsID8gJ0Vycm9yJyA6IHRpdGxlKSxcbiAgICAgIGNhbmNlbEJ1dHRvbjogJ2hpZGRlbicsXG4gICAgICBwcmV2aW91c0J1dHRvbjogJ2hpZGRlbicsXG4gICAgICBhdXRvQ2xvc2U6IHRydWUsXG4gICAgICBhdXRvRGVsZXRlOiB0cnVlLFxuICAgICAgb25DbG9zZTogb25DbG9zZVxuICAgIH0pO1xuICAgIF9hZGRDb21tb25QYWdlKGlkLCBtZXNzYWdlLCAnRXJyb3InKTtcbiAgICBvcGVuKCcjY3VzdG9tRGlhbG9nJyArIGlkKTtcbiAgfTtcblxuICAvKlxuICAqIE9wZW4gYSBjb25maXJtIGRpYWxvZ1xuICAqIG1lc3NhZ2U6IG1lc3NhZ2UgaW5zaWRlIHRoZSB3aW5kb3dcbiAgKiB0aXRsZTogdGl0bGUgb2YgdGhlIHdpbmRvd1xuICAqIG9uT2s6IGNhbGxiYWNrIHdoZW4gXCJva1wiIGlzIGNsaWNrZWRcbiAgKiBvbkNhbmNlbDogY2FsbGJhY2sgd2hlbiBcImNhbmNlbFwiIGlzIGNsaWNrZWRcbiAgKi9cbiAgdmFyIG9wZW5Db25maXJtID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHRpdGxlLCBvbk9rLCBvbkNhbmNlbCkge1xuICAgIHZhciBpZCA9IF9jcmVhdGVEaWFsb2coe1xuICAgICAgdGl0bGU6ICh0aXRsZSA9PSBudWxsID8gJ0NvbmZpcm1hdGlvbicgOiB0aXRsZSksXG4gICAgICBhdXRvQ2xvc2U6IHRydWUsXG4gICAgICBhdXRvRGVsZXRlOiB0cnVlLFxuICAgICAgb25Pazogb25PayxcbiAgICAgIG9uQ2FuY2VsOiBvbkNhbmNlbFxuICAgIH0pO1xuICAgIF9hZGRDb21tb25QYWdlKGlkLCBtZXNzYWdlLCAnUXVlc3Rpb24nKTtcbiAgICBvcGVuKCcjY3VzdG9tRGlhbG9nJyArIGlkKTtcbiAgfTtcblxuICAvKlxuICAqIE9wZW4gYSBsb2FkZXJcbiAgKiBhYm9ydEZ1bmN0aW9uOiBpZiBzZXQsIHRoZSB1c2VyIGNhbiBhYm9ydCBhbmQgdGhpcyBmdW5jdGlvbiBpcyBleGVjdXRlZFxuICAqL1xuICB2YXIgb3BlbkxvYWRlciA9IGZ1bmN0aW9uIChhYm9ydEZ1bmN0aW9uKSB7XG4gICAgLy8gTG9hZGVyIGFscmVhZHkgb3Blbj9cbiAgICB2YXIgaWQ7IC8vIFRvIGRlZmluZSBpZCBvbmx5IG9uY2VcbiAgICB0cnkge1xuICAgICAgaWQgPSBfZGF0YU1hbmFnZXIuZ2V0SWQoJyNjdXN0b21EaWFsb2dMb2FkZXInKTtcbiAgICAgIHZhciBkaWFsb2dJZCA9ICdjdXN0b21EaWFsb2cnICsgaWQ7XG5cbiAgICAgIC8vIEFscmVhZHkgb3BlbiwganVzdCBjaGFuZ2UgdGhlIGFib3J0IGZ1bmN0aW9uXG4gICAgICB2YXIgYXR0cmlidXRlcyA9IF9kYXRhTWFuYWdlci5nZXQoaWQpWydhdHRyaWJ1dGVzJ107XG4gICAgICBhdHRyaWJ1dGVzWydvbkNhbmNlbCddID0gYWJvcnRGdW5jdGlvbjtcbiAgICAgIGF0dHJpYnV0ZXNbJ2NhbmNlbEJ1dHRvbiddID0gKGFib3J0RnVuY3Rpb24gPT0gbnVsbCA/ICdoaWRkZW4nIDogJycpO1xuICAgICAgX2RhdGFNYW5hZ2VyLnNldChpZCwgJ2F0dHJpYnV0ZXMnLCBhdHRyaWJ1dGVzKTtcbiAgICAgIF9kaXNwbGF5TmF2aWdhdGlvbignIycgKyBkaWFsb2dJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAvL1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBkaWFsb2cgd2l0aCBwb3NzaWJseSBhIGNhbmNlbCBidXR0b25cbiAgICBpZCA9IChhYm9ydEZ1bmN0aW9uID09IG51bGwpID9cbiAgICAgIF9jcmVhdGVEaWFsb2coe1xuICAgICAgICB0aXRsZTogJ1BsZWFzZSB3YWl0Li4uJyxcbiAgICAgICAgY2FuY2VsQnV0dG9uOiAnaGlkZGVuJyxcbiAgICAgICAgcHJldmlvdXNCdXR0b246ICdoaWRkZW4nLFxuICAgICAgICBva0J1dHRvbjogJ2hpZGRlbicsXG4gICAgICAgIG5leHRCdXR0b246ICdoaWRkZW4nLFxuICAgICAgICBjbG9zZUJ1dHRvbjogJ2hpZGRlbicsXG4gICAgICAgIGF1dG9DbG9zZTogdHJ1ZSxcbiAgICAgICAgYXV0b0RlbGV0ZTogdHJ1ZVxuICAgICAgfSkgOiBfY3JlYXRlRGlhbG9nKHtcbiAgICAgICAgdGl0bGU6ICdQbGVhc2Ugd2FpdC4uLicsXG4gICAgICAgIHByZXZpb3VzQnV0dG9uOiAnaGlkZGVuJyxcbiAgICAgICAgb2tCdXR0b246ICdoaWRkZW4nLFxuICAgICAgICBuZXh0QnV0dG9uOiAnaGlkZGVuJyxcbiAgICAgICAgY2xvc2VCdXR0b246ICdoaWRkZW4nLFxuICAgICAgICBvbkNhbmNlbDogYWJvcnRGdW5jdGlvbixcbiAgICAgICAgYXV0b0Nsb3NlOiB0cnVlLFxuICAgICAgICBhdXRvRGVsZXRlOiB0cnVlXG4gICAgICB9KTtcblxuICAgIC8vIEFkZCBhIHNwZWNpYWwgY2xhc3MgdG8gdGhpcyBkaWFsb2dcbiAgICAkKCcjY3VzdG9tRGlhbG9nJyArIGlkKS5hZGRDbGFzcygnY3VzdG9tRGlhbG9nQnV0dG9uUmlnaHQnKTtcblxuICAgIC8vIEFkZCBjb250ZW50XG4gICAgJCgnYm9keScpLmFwcGVuZChcbiAgICAgIFwiPGRpdiBpZD0nY3VzdG9tRGlhbG9nTG9hZGVyJz5cIiArXG4gICAgICBcIjxkaXYgY2xhc3M9J2N1c3RvbVByb2dyZXNzJyBzdHlsZT0nbWFyZ2luOiAyMHB4IDEwcHgnPlwiICtcbiAgICAgIFwiPGRpdiBkYXRhLWVmZmVjdD0nc2xpZGUtbGVmdCcgY2xhc3M9J2N1c3RvbVByb2dyZXNzQmFyJyByb2xlPSdwcm9ncmVzc2JhcicgYXJpYS12YWx1ZW5vdz0nMTAwJyBhcmlhLXZhbHVlbWluPScwJyBhcmlhLXZhbHVlbWF4PScxMDAnIHN0eWxlPSd3aWR0aDogMTAwJTsgdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZS1pbi1vdXQgMHM7Jz48L2Rpdj5cIiArXG4gICAgICAnPC9kaXY+JyArXG4gICAgICAnPC9kaXY+Jyk7XG4gICAgYWRkUGFnZSgnI2N1c3RvbURpYWxvZycgKyBpZCwgJyNjdXN0b21EaWFsb2dMb2FkZXInKTtcblxuICAgIC8vIE9wZW4gaXRcbiAgICBvcGVuKCcjY3VzdG9tRGlhbG9nJyArIGlkKTtcbiAgfTtcblxuICAvKlxuICAqIENsb3NlIHRoZSBsb2FkZXJcbiAgKi9cbiAgdmFyIGNsb3NlTG9hZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICgkKCcjY3VzdG9tRGlhbG9nTG9hZGVyJykubGVuZ3RoKVxuICAgICAgY2xvc2UoJyNjdXN0b21EaWFsb2dMb2FkZXInKTtcbiAgfTtcblxuICAvKlxuICAqIENsb3NlIGFsbCBkaWFsb2dzXG4gICovXG4gIHZhciBjbG9zZUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkKCcuY3VzdG9tRGlhbG9nJykuZWFjaChmdW5jdGlvbiAoKSB7IGNsb3NlKCcjJyArIHRoaXMuaWQpOyB9KTtcbiAgfTtcblxuICAvKlxuICAqIENsb3NlIHRoZSBsYXN0IGRpYWxvZ1xuICAqL1xuICB2YXIgY2xvc2VMYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChfb3Blbklkcy5sZW5ndGggPiAwKVxuICAgICAgY2FuY2VsKCcjY3VzdG9tRGlhbG9nJyArIF9vcGVuSWRzW19vcGVuSWRzLmxlbmd0aCAtIDFdKTtcbiAgfTtcblxuICAvLyBDb25uZWN0IHRoZSBrZXkgXCJlc2NhcGVcIlxuICAkKGRvY3VtZW50KS5rZXl1cChmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT0gMjcpXG4gICAgICBjbG9zZUxhc3QoKTtcbiAgfSk7XG5cbiAgLy8gTGlzdCBvZiBleHBvcnRlZCBmdW5jdGlvbnNcbiAgcmV0dXJuIHtcbiAgICBjYW5jZWw6IGNhbmNlbCxcbiAgICBjbG9zZTogY2xvc2UsXG4gICAgb2s6IG9rLFxuICAgIHByZXZpb3VzOiBwcmV2aW91cyxcbiAgICBuZXh0OiBuZXh0LFxuICAgIGdvVG9QYWdlOiBnb1RvUGFnZSxcbiAgICBhZGRQYWdlOiBhZGRQYWdlLFxuICAgIGluaXRpYWxpemU6IGluaXRpYWxpemUsXG4gICAgc2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGUsXG4gICAgb3Blbjogb3BlbixcbiAgICBvcGVuSW5mbzogb3BlbkluZm8sXG4gICAgb3Blbldhcm5pbmc6IG9wZW5XYXJuaW5nLFxuICAgIG9wZW5FcnJvcjogb3BlbkVycm9yLFxuICAgIG9wZW5Db25maXJtOiBvcGVuQ29uZmlybSxcbiAgICBvcGVuTG9hZGVyOiBvcGVuTG9hZGVyLFxuICAgIGNsb3NlTG9hZGVyOiBjbG9zZUxvYWRlcixcbiAgICBjbG9zZUFsbDogY2xvc2VBbGwsXG4gICAgY2xvc2VMYXN0OiBjbG9zZUxhc3RcbiAgfVxufTtcblxuLy8gU2luZ2xldG9uOiBkZWZpbmUgZ2xvYmFsLnNpbmdsZXRvblB1bHNlQ3VzdG9tRGlhbG9nIGlmIG5vdCBzZXQgYW5kIHJldHVybiBpdCBpbiB0aGUgZXhwb3J0c1xuZ2xvYmFsLnNpbmdsZXRvblB1bHNlQ3VzdG9tRGlhbG9nID0gZ2xvYmFsLnNpbmdsZXRvblB1bHNlQ3VzdG9tRGlhbG9nIHx8IHB1bHNlQ3VzdG9tRGlhbG9nKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5zaW5nbGV0b25QdWxzZUN1c3RvbURpYWxvZzsiLCIvLyBDb3B5cmlnaHQgKEMpIDIwMDktMjAyMyBMZW1vaW5lIEF1dG9tYXRpb24gVGVjaG5vbG9naWVzXG4vL1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuLyoqXG4gKiBAZmlsZSBhY2Nlc3MgbG9naW4gZmVhdHVyZXMuXG4gKi9cblxuLyoqXG4qIEBtb2R1bGUgcHVsc2VMb2dpblxuKiBAcmVxdWlyZXMgcHVsc2VVdGlsaXR5XG4qIE5FVkVSIEFERCA6IHB1bHNlQ29uZmlnIGhlcmUuIHB1bHNlQ29uZmlnIGNhbiB1c2UgcHVsc2VMb2dpbi5cbiovXG52YXIgcHVsc2VVdGlsaXR5ID0gcmVxdWlyZSgncHVsc2VVdGlsaXR5Jyk7XG52YXIgZXZlbnRCdXMgPSByZXF1aXJlKCdldmVudEJ1cycpO1xuXG4vLy8vLy8vLy8vIC8vLy8vLy8vLy8gLy8vLy8vLy8vLyAvLy8vLy8vLy8vXG4vLyBpcyBsb2dpbiBwYWdlID0gc2VlIGluIHB1bHNlQ29uZmlnICAgIC8vXG4vLy8vLy8vLy8vIC8vLy8vLy8vLy8gLy8vLy8vLy8vLyAvLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8gLy8vLy8vLy8vLyAvLy8vLy8vLy8vXG4vLyBBY2Nlc3MgPSBnZXQgICAgICAgICAgICAgICAvL1xuLy8vLy8vLy8vLyAvLy8vLy8vLy8vIC8vLy8vLy8vLy9cblxuLy92YXIgZ2V0TG9naW4gPSBcbmV4cG9ydHMuZ2V0TG9naW4gPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBsb2dpbiA9IHB1bHNlVXRpbGl0eS5yZWFkQ29va2llKCdQdWxzZUxvZ2luJyk7XG4gIC8vIE5vcm1hbFxuICAvKmxldCBuYW1lID0gJ1B1bHNlTG9naW49JztcbiAgbGV0IGRlY29kZWRDb29raWUgPSBkZWNvZGVVUklDb21wb25lbnQoZG9jdW1lbnQuY29va2llKTtcbiAgbGV0IGNhID0gZGVjb2RlZENvb2tpZS5zcGxpdCgnOycpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNhLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGMgPSBjYVtpXTtcbiAgICB3aGlsZSAoYy5jaGFyQXQoMCkgPT0gJyAnKSB7XG4gICAgICBjID0gYy5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmIChjLmluZGV4T2YobmFtZSkgPT0gMCkge1xuICAgICAgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWUubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgfVxuICB9Ki9cbiAgaWYgKGxvZ2luID09IG51bGwpXG4gICAgcmV0dXJuICcnO1xuICBlbHNlXG4gICAgcmV0dXJuIGxvZ2luO1xufVxuXG5leHBvcnRzLmdldExvZ2luRGlzcGxheSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGxvZ2luID0gcHVsc2VVdGlsaXR5LnJlYWRDb29raWUoJ1B1bHNlVXNlckRpc3BsYXknKTtcbiAgaWYgKGxvZ2luID09IG51bGwpXG4gICAgcmV0dXJuICcnO1xuICBlbHNlXG4gICAgcmV0dXJuIGxvZ2luO1xufVxuXG5leHBvcnRzLmdldExvZ2luRm9yV2ViU2VydmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGxvZ2luID0gcHVsc2VVdGlsaXR5LnJlYWRDb29raWUoJ1B1bHNlTG9naW4nKTtcbiAgaWYgKChsb2dpbiA9PSBudWxsKVxuICAgIHx8IChsb2dpbiA9PSAnZGV2JykgfHwgKGxvZ2luID09ICdzdXBwb3J0JylcbiAgICB8fCAobG9naW4gPT0gJ0RldicpIHx8IChsb2dpbiA9PSAnU3VwcG9ydCcpKVxuICAgIHJldHVybiAnJztcbiAgZWxzZVxuICAgIHJldHVybiBsb2dpbjtcbn1cblxuLy92YXIgZ2V0Um9sZSA9IFxuZXhwb3J0cy5nZXRSb2xlID0gZnVuY3Rpb24gKCkge1xuICAvLyBGaW5kIHJvbGUgaW4gVVJMLT4gUkVNT1ZFRCAhISFcbiAgbGV0IHJvbGUgPSBwdWxzZVV0aWxpdHkucmVhZENvb2tpZSgnUHVsc2VSb2xlJyk7XG4gIGlmIChyb2xlID09IG51bGwpXG4gICAgcmV0dXJuICcnO1xuICBlbHNlXG4gICAgcmV0dXJuIHJvbGU7XG59XG5cbmV4cG9ydHMuZ2V0QWNjZXNzVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGxldCB0b2tlbiA9IHB1bHNlVXRpbGl0eS5yZWFkQ29va2llKCdQdWxzZUFjY2Vzc1Rva2VuJyk7XG4gIGlmICh0b2tlbiA9PSBudWxsKVxuICAgIHJldHVybiAnJztcbiAgZWxzZVxuICAgIHJldHVybiB0b2tlbjtcbn1cbmV4cG9ydHMuZ2V0QWNjZXNzVG9rZW5FeHBpcmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICBsZXQgdG9rZW4gPSBwdWxzZVV0aWxpdHkucmVhZENvb2tpZSgnUHVsc2VBY2Nlc3NUb2tlbkV4cGlyZWRBdCcpO1xuICBpZiAodG9rZW4gPT0gbnVsbClcbiAgICByZXR1cm4gJyc7XG4gIGVsc2VcbiAgICByZXR1cm4gdG9rZW47XG59XG5leHBvcnRzLmdldFJlZnJlc2hUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHRva2VuID0gcHVsc2VVdGlsaXR5LnJlYWRDb29raWUoJ1B1bHNlUmVmcmVzaFRva2VuJyk7XG4gIGlmICh0b2tlbiA9PSBudWxsKVxuICAgIHJldHVybiAnJztcbiAgZWxzZVxuICAgIHJldHVybiB0b2tlbjtcbn1cbmV4cG9ydHMuZ2V0UmVmcmVzaFRva2VuRXhwaXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHRva2VuID0gcHVsc2VVdGlsaXR5LnJlYWRDb29raWUoJ1B1bHNlUmVmcmVzaFRva2VuRXhwaXJlZEF0Jyk7XG4gIGlmICh0b2tlbiA9PSBudWxsKVxuICAgIHJldHVybiAnJztcbiAgZWxzZVxuICAgIHJldHVybiB0b2tlbjtcbn1cblxuLy8vLy8vLy8vLyAvLy8vLy8vLy8vIC8vLy8vLy8vLy9cbi8vIFN0b3JhZ2UgICAgICAgICAgICAgICAgICAgIC8vXG4vLy8vLy8vLy8vIC8vLy8vLy8vLy8gLy8vLy8vLy8vL1xuXG52YXIgc2V0QWNjZXNzVG9rZW4gPSBleHBvcnRzLnNldEFjY2Vzc1Rva2VuID0gZnVuY3Rpb24gKGFjY2Vzc190b2tlbiwgZXhwaXJlZGF0KSB7XG4gIGlmIChhY2Nlc3NfdG9rZW4gIT0gbnVsbCAmJiBhY2Nlc3NfdG9rZW4gIT0gJycpIHtcbiAgICBwdWxzZVV0aWxpdHkuY3JlYXRlQ29va2llKCdQdWxzZUFjY2Vzc1Rva2VuJywgYWNjZXNzX3Rva2VuLCAxKTtcbiAgICBwdWxzZVV0aWxpdHkuY3JlYXRlQ29va2llKCdQdWxzZUFjY2Vzc1Rva2VuRXhwaXJlZEF0JywgZXhwaXJlZGF0LCAxKTtcblxuICAgIGxldCB0YXJnZXQgPSB7XG4gICAgICAvL3VybDogdXJsLFxuICAgICAgLy9zb3VyY2U6IHRoaXMuZWxlbWVudC50YWdOYW1lLFxuICAgICAga2luZDogJ0FjY2Vzc1Rva2VuJ1xuICAgIH07XG4gICAgZXZlbnRCdXMuRXZlbnRCdXMuZGlzcGF0Y2hUb0FsbCgnVG9rZW5IYXNDaGFuZ2VkRXZlbnQnLCB0YXJnZXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHB1bHNlVXRpbGl0eS5lcmFzZUNvb2tpZSgnUHVsc2VBY2Nlc3NUb2tlbicpO1xuICAgIHB1bHNlVXRpbGl0eS5lcmFzZUNvb2tpZSgnUHVsc2VBY2Nlc3NUb2tlbkV4cGlyZWRBdCcpO1xuXG4gICAgLy8gTm8gZGlzcGF0Y2ggaGVyZSwgYmVjYXVzZSBnb1RvUGFnZUxvZ2luIGlzIGFsd2F5cyBjYWxsZWQganVzdCBhZnRlclxuICB9XG59XG5cbnZhciBzZXRSZWZyZXNoVG9rZW4gPSBleHBvcnRzLnNldFJlZnJlc2hUb2tlbiA9IGZ1bmN0aW9uIChyZWZyZXNoX3Rva2VuLCBleHBpcmVkYXQpIHtcbiAgaWYgKHJlZnJlc2hfdG9rZW4gIT0gbnVsbCAmJiByZWZyZXNoX3Rva2VuICE9ICcnKSB7XG4gICAgcHVsc2VVdGlsaXR5LmNyZWF0ZUNvb2tpZSgnUHVsc2VSZWZyZXNoVG9rZW4nLCByZWZyZXNoX3Rva2VuLCAxKTtcbiAgICBwdWxzZVV0aWxpdHkuY3JlYXRlQ29va2llKCdQdWxzZVJlZnJlc2hUb2tlbkV4cGlyZWRBdCcsIGV4cGlyZWRhdCwgMSk7XG5cbiAgICBsZXQgdGFyZ2V0ID0ge1xuICAgICAgLy91cmw6IHVybCxcbiAgICAgIC8vc291cmNlOiB0aGlzLmVsZW1lbnQudGFnTmFtZSxcbiAgICAgIGtpbmQ6ICdSZWZyZXNoVG9rZW4nXG4gICAgfTtcbiAgICBldmVudEJ1cy5FdmVudEJ1cy5kaXNwYXRjaFRvQWxsKCdUb2tlbkhhc0NoYW5nZWRFdmVudCcsIHRhcmdldCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcHVsc2VVdGlsaXR5LmVyYXNlQ29va2llKCdQdWxzZVJlZnJlc2hUb2tlbicpO1xuICAgIHB1bHNlVXRpbGl0eS5lcmFzZUNvb2tpZSgnUHVsc2VSZWZyZXNoVG9rZW5FeHBpcmVkQXQnKTtcblxuICAgIC8vIE5vIGRpc3BhdGNoIGhlcmUsIGJlY2F1c2UgZ29Ub1BhZ2VMb2dpbiBpcyBhbHdheXMgY2FsbGVkIGp1c3QgYWZ0ZXJcbiAgfVxufVxuXG5leHBvcnRzLnN0b3JlUm9sZSA9IGZ1bmN0aW9uIChyb2xlKSB7XG4gIHB1bHNlVXRpbGl0eS5jcmVhdGVDb29raWUoJ1B1bHNlUm9sZScsIHJvbGUsIDkwKTtcbiAgLy9kb2N1bWVudC5jb29raWUgPSAnUHVsc2VSb2xlPScgKyByb2xlICsgJztwYXRoPS8nO1xufVxuXG52YXIgc3RvcmVMb2dpblJvbGUgPVxuICBleHBvcnRzLnN0b3JlTG9naW5Sb2xlID0gZnVuY3Rpb24gKGxvZ2luLCByb2xlLCBkaXNwbGF5LCBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4sXG4gICAgYWNjZXNzX3Rva2VuX2V4cGlyZWRhdCwgcmVmcmVzaF90b2tlbl9leHBpcmVkYXQsIHNlc3Npb25Pbmx5KSB7XG4gICAgcHVsc2VVdGlsaXR5LmNyZWF0ZUNvb2tpZSgnUHVsc2VMb2dpbicsIGxvZ2luLCBzZXNzaW9uT25seT8wOjEpO1xuICAgIHB1bHNlVXRpbGl0eS5jcmVhdGVDb29raWUoJ1B1bHNlUm9sZScsIHJvbGUsIHNlc3Npb25Pbmx5PzA6MSk7XG4gICAgLy9kb2N1bWVudC5jb29raWUgPSAnUHVsc2VMb2dpbj0nICsgbG9naW4gKyAnO3BhdGg9Lyc7XG4gICAgLy9kb2N1bWVudC5jb29raWUgPSAnUHVsc2VSb2xlPScgKyByb2xlICsgJztwYXRoPS8nOyAvLyA9PSBzdG9yZVJvbGUocm9sZSk7XG4gICAgcHVsc2VVdGlsaXR5LmNyZWF0ZUNvb2tpZSgnUHVsc2VVc2VyRGlzcGxheScsIGRpc3BsYXksIHNlc3Npb25Pbmx5PzA6MSk7XG5cbiAgICBzZXRBY2Nlc3NUb2tlbihhY2Nlc3NfdG9rZW4sIGFjY2Vzc190b2tlbl9leHBpcmVkYXQpO1xuICAgIHNldFJlZnJlc2hUb2tlbihyZWZyZXNoX3Rva2VuLCByZWZyZXNoX3Rva2VuX2V4cGlyZWRhdCk7XG4gIH1cblxuZXhwb3J0cy5zdG9yZUxvZ2luUm9sZUZyb21SZWZyZXNoRFRPID0gZnVuY3Rpb24gKGRhdGEsIHNlc3Npb25Pbmx5KSB7XG4gIGxldCBsb2dpbiA9IGRhdGEuTG9naW47XG4gIGxldCByb2xlID0gZGF0YS5Sb2xlO1xuICByb2xlID0gcm9sZS50b0xvd2VyQ2FzZSgpO1xuICBsZXQgZGlzcGxheSA9IGRhdGEuVXNlckRpc3BsYXk7IC8vIGZyb20gdiAxMlxuICBpZiAoIHB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQoZGlzcGxheSkgKSB7XG4gICAgZGlzcGxheSA9IGRhdGEuVXNlck5hbWU7XG4gIH1cbiAgbGV0IGFjY2Vzc190b2tlbiA9IGRhdGEuQWNjZXNzVG9rZW47XG4gIC8vIGRhdGEuQ29tcGFueUlkXG4gIGxldCBhY2Nlc3NfdG9rZW5fZXhwaXJlZGF0ID0gZGF0YS5FeHBpcmVzQXQ7XG4gIGxldCByZWZyZXNoX3Rva2VuID0gZGF0YS5SZWZyZXNoVG9rZW47XG4gIGxldCByZWZyZXNoX3Rva2VuX2V4cGlyZWRhdCA9IGRhdGEuUmVmcmVzaFRva2VuRXhwaXJlc0F0O1xuXG4gIHN0b3JlTG9naW5Sb2xlKGxvZ2luLCByb2xlLCBkaXNwbGF5LCBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4sXG4gICAgYWNjZXNzX3Rva2VuX2V4cGlyZWRhdCwgcmVmcmVzaF90b2tlbl9leHBpcmVkYXQsIHNlc3Npb25Pbmx5KTtcbn1cblxuLy8vLy8vLy8vLyAvLy8vLy8vLy8vIC8vLy8vLy8vLy9cbi8vIENsZWFuIHN0b3JhZ2UgICAgICAgICAgICAgIC8vXG4vLy8vLy8vLy8vIC8vLy8vLy8vLy8gLy8vLy8vLy8vL1xuXG4vLyBnb1RvUGFnZUxvZ2luIGlzIGFsd2F5cyBjYWxsZWQganVzdCBhZnRlclxuZXhwb3J0cy5jbGVhbkxvZ2luUm9sZSA9IGZ1bmN0aW9uICgpIHtcbiAgcHVsc2VVdGlsaXR5LmVyYXNlQ29va2llKCdQdWxzZUxvZ2luJyk7XG4gIHB1bHNlVXRpbGl0eS5lcmFzZUNvb2tpZSgnUHVsc2VSb2xlJyk7XG4gIC8vZG9jdW1lbnQuY29va2llID0gJ1B1bHNlTG9naW49JyArICc7cGF0aD0vJztcbiAgLy9kb2N1bWVudC5jb29raWUgPSAnUHVsc2VSb2xlPScgKyAnO3BhdGg9Lyc7XG4gIHB1bHNlVXRpbGl0eS5lcmFzZUNvb2tpZSgnUHVsc2VVc2VyRGlzcGxheScpO1xuICBzZXRBY2Nlc3NUb2tlbignJyk7XG4gIHNldFJlZnJlc2hUb2tlbignJyk7XG59XG5cbi8vLy8vLy8vLy8gLy8vLy8vLy8vLyAvLy8vLy8vLy8vXG4vLyBFeHBpcmF0aW9uICAgICAgICAgICAgICAgICAvL1xuLy8vLy8vLy8vLyAvLy8vLy8vLy8vIC8vLy8vLy8vLy9cblxuZXhwb3J0cy5pc1Rva2VuRXhwaXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHJlZnJlc2hfdG9rZW5fZXhwaXJhdGlvbiA9IHB1bHNlVXRpbGl0eS5yZWFkQ29va2llKCdQdWxzZUFjY2Vzc1Rva2VuRXhwaXJlZEF0Jyk7XG4gIGlmIChyZWZyZXNoX3Rva2VuX2V4cGlyYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsc2Uge1xuICAgIGxldCBtX2V4cGlyID0gbW9tZW50KHJlZnJlc2hfdG9rZW5fZXhwaXJhdGlvbik7XG4gICAgbGV0IG5vdyA9IG1vbWVudCgpO1xuICAgIGlmIChub3cuaXNBZnRlcihtX2V4cGlyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG4vKiBOZWFybHkgZXhwaXJlZCAqL1xudmFyIHRva2VuTmVlZFJlZnJlc2ggPSBleHBvcnRzLnRva2VuTmVlZFJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gIGxldCByZWZyZXNoX3Rva2VuX2V4cGlyYXRpb24gPSBwdWxzZVV0aWxpdHkucmVhZENvb2tpZSgnUHVsc2VBY2Nlc3NUb2tlbkV4cGlyZWRBdCcpO1xuICBpZiAocmVmcmVzaF90b2tlbl9leHBpcmF0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZWxzZSB7XG4gICAgbGV0IG1fZXhwaXIgPSBtb21lbnQocmVmcmVzaF90b2tlbl9leHBpcmF0aW9uKTtcbiAgICBsZXQgaW5YbWluID0gbW9tZW50KCkuYWRkKDUsICdtaW51dGVzJyk7XG5cbiAgICBpZiAoaW5YbWluLmlzQWZ0ZXIobV9leHBpcikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuLy8vLy8vLy8vLyAvLy8vLy8vLy8vIC8vLy8vLy8vLy9cbi8vIFJlbmV3IHRva2VuID0gcmVmcmVzaCAgICAgIC8vXG4vLy8vLy8vLy8vIC8vLy8vLy8vLy8gLy8vLy8vLy8vL1xuXG52YXIgcmVmcmVzaFRva2VuID0gZXhwb3J0cy5yZWZyZXNoVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGxldCB0YXJnZXQgPSB7XG4gICAgLy91cmw6IHVybCxcbiAgICAvL3NvdXJjZTogdGhpcy5lbGVtZW50LnRhZ05hbWUsXG4gICAgbWVzc2FnZTogJ0F1dGhlbnRpY2F0aW9uIEVycm9yLiBQbGVhc2UgcmV0cnknXG4gIH07XG4gIGV2ZW50QnVzLkV2ZW50QnVzLmRpc3BhdGNoVG9BbGwoJ0F1dGhvcml6YXRpb25FcnJvckV2ZW50JywgdGFyZ2V0KTtcbn1cblxuZXhwb3J0cy5yZWZyZXNoVG9rZW5JZk5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRva2VuTmVlZFJlZnJlc2goKSkge1xuICAgIHJlZnJlc2hUb2tlbigpO1xuICB9XG59XG5cbi8vLy8vLy8vLy8gLy8vLy8vLy8vLyAvLy8vLy8vLy8vXG4vLyBBdXRoZW50aWNhdGlvbiAvIFZhbGlkYXRlICAvL1xuLy8vLy8vLy8vLyAvLy8vLy8vLy8vIC8vLy8vLy8vLy9cblxuZXhwb3J0cy5jbGVhbkF1dGhlbnRpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICBwdWxzZVV0aWxpdHkuZXJhc2VDb29raWUoJ0F1dGhlbnRpY2F0aW9uS2luZCcpO1xuICBwdWxzZVV0aWxpdHkuZXJhc2VDb29raWUoJ0F1dGhlbnRpY2F0aW9uTmFtZScpO1xuICBwdWxzZVV0aWxpdHkuZXJhc2VDb29raWUoJ0F1dGhlbnRpY2F0aW9uTG9naW4nKTtcbiAgcHVsc2VVdGlsaXR5LmVyYXNlQ29va2llKCdBdXRoZW50aWNhdGlvblN0YXRlJyk7XG59XG5cbmV4cG9ydHMuc3RvcmVBdXRoZW50aWNhdGlvbiA9IGZ1bmN0aW9uIChBdXRoZW50aWNhdGlvbktpbmQsXG4gIEF1dGhlbnRpY2F0aW9uTmFtZSwgU3RhdGVSZXF1aXJlZCwgbG9naW4pIHtcbiAgcHVsc2VVdGlsaXR5LmNyZWF0ZUNvb2tpZSgnQXV0aGVudGljYXRpb25LaW5kJywgQXV0aGVudGljYXRpb25LaW5kLCAxKTtcbiAgcHVsc2VVdGlsaXR5LmNyZWF0ZUNvb2tpZSgnQXV0aGVudGljYXRpb25OYW1lJywgQXV0aGVudGljYXRpb25OYW1lLCAxKTtcbiAgcHVsc2VVdGlsaXR5LmNyZWF0ZUNvb2tpZSgnQXV0aGVudGljYXRpb25Mb2dpbicsIGxvZ2luLCAxKTtcbiAgaWYgKFwidHJ1ZVwiID09IFN0YXRlUmVxdWlyZWQpIHtcbiAgICBsZXQgbWF4ID0gNDAwMDAwMDAwMDsgLy8gbWF4IGludGVnZXJcbiAgICBsZXQgc3RhdGUgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpO1xuICAgIHB1bHNlVXRpbGl0eS5jcmVhdGVDb29raWUoJ0F1dGhlbnRpY2F0aW9uU3RhdGUnLCBzdGF0ZSwgMSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcHVsc2VVdGlsaXR5LmNyZWF0ZUNvb2tpZSgnQXV0aGVudGljYXRpb25TdGF0ZScsICcnLCAxKTtcbiAgfVxufVxuXG5leHBvcnRzLmdldEF1dGhlbnRpY2F0aW9uS2luZCA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGF1dGggPSBwdWxzZVV0aWxpdHkucmVhZENvb2tpZSgnQXV0aGVudGljYXRpb25LaW5kJyk7XG4gIGlmIChhdXRoID09IG51bGwpXG4gICAgcmV0dXJuICcnO1xuICBlbHNlXG4gICAgcmV0dXJuIGF1dGg7XG59XG5cbmV4cG9ydHMuZ2V0QXV0aGVudGljYXRpb25OYW1lID0gZnVuY3Rpb24gKCkge1xuICBsZXQgYXV0aCA9IHB1bHNlVXRpbGl0eS5yZWFkQ29va2llKCdBdXRoZW50aWNhdGlvbk5hbWUnKTtcbiAgaWYgKGF1dGggPT0gbnVsbClcbiAgICByZXR1cm4gJyc7XG4gIGVsc2VcbiAgICByZXR1cm4gYXV0aDtcbn1cblxuZXhwb3J0cy5nZXRBdXRoZW50aWNhdGlvbkxvZ2luID0gZnVuY3Rpb24gKCkge1xuICBsZXQgYXV0aCA9IHB1bHNlVXRpbGl0eS5yZWFkQ29va2llKCdBdXRoZW50aWNhdGlvbkxvZ2luJyk7XG4gIGlmIChhdXRoID09IG51bGwpXG4gICAgcmV0dXJuICcnO1xuICBlbHNlXG4gICAgcmV0dXJuIGF1dGg7XG59XG5cbmV4cG9ydHMuZ2V0QXV0aGVudGljYXRpb25TdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGF1dGggPSBwdWxzZVV0aWxpdHkucmVhZENvb2tpZSgnQXV0aGVudGljYXRpb25TdGF0ZScpO1xuICBpZiAoYXV0aCA9PSBudWxsKVxuICAgIHJldHVybiAnJztcbiAgZWxzZVxuICAgIHJldHVybiBhdXRoO1xufVxuXG4vLy8vLy8vLy8vIC8vLy8vLy8vLy8gLy8vLy8vLy8vL1xuLy8gRU5EICAgICAgICAgICAgICAgICAgICAgICAgLy9cbi8vLy8vLy8vLy8gLy8vLy8vLy8vLyAvLy8vLy8vLy8vXG5cbiIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4vKipcbiAqIEBmaWxlIE1vZHVsZSB0byBtYW5pcHVsYXRlIHJhbmdlc1xuICogQG1vZHVsZSBwdWxzZVJhbmdlXG4gKiovXG5cbi8qIEZPUiBiZXR0ZXIgdW5kZXJzdGFuZGluZyA6IFNlcGFyYXRlIGNvbW1lbnQgLSBob3BlIGl0IGlzIG5vdCBwYXJzZWRcbiAqIFxuICogLy8gQmV0d2VlbiB4LXRhZyA9PSBhdHRyaWJ1dGUgKyBldmVudCArIHNlbnQgdG8gd2ViIHNlcnZpY2VzXG4gKiByYW5nZVN0cmluZyA9ICdbaXNvc3RyaW5nLCBpc29zdHJpbmcpJ1xuICogXG4gKiAvLyBUbXAgZm9yIGNvbXBhdGliaWxpdHlcbiAqIHN0cmluZ1JhbmdlLmxvd2VyID0gaXNvc3RyaW5nIFxuICogc3RyaW5nUmFuZ2UudXBwZXIgPSBpc29zdHJpbmcgXG4gKiBcbiAqIC8vIEludGVybiB1c2Ugb25seVxuICogZGF0ZVJhbmdlLmxvd2VyID0gRGF0ZSgpXG4gKiBkYXRlUmFuZ2UudXBwZXIgPSBEYXRlKClcbiAqIFxuICogLy8gQ29udmVyc2lvbiAvIENyZWF0aW9uXG4gKiBwdWxzZVJhbmdlLmNyZWF0ZURhdGVSYW5nZUZyb21TdHJpbmdcbiAqIHB1bHNlUmFuZ2UuY3JlYXRlU3RyaW5nUmFuZ2VGcm9tU3RyaW5nXG4gKiBwdWxzZVV0aWxpdHkuY3JlYXRlU2luZ2xlUmFuZ2VGb3JXZWJTZXJ2aWNlXG4gKiBcbiAqIC8vIFVzZSA6XG4gKiBwdWxzZVV0aWxpdHkuY29udmVydERhdGVSYW5nZUZvcldlYlNlcnZpY2VcbiAqIFxuICovXG5cbi8qKlxuICogR2VuZXJpYyBjbGFzcyByYW5nZVxuICpcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBSYW5nZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvcjogY3JlYXRlIGFuIGVtcHR5IHJhbmdlXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9sb3dlciA9IG51bGw7XG4gICAgdGhpcy5fbG93ZXJJbmNsdXNpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl91cHBlciA9IG51bGw7XG4gICAgdGhpcy5fdXBwZXJJbmNsdXNpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9lbXB0eSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogTG93ZXIgdmFsdWUgb2YgdGhlIHJhbmdlXG4gICAqIFxuICAgKiBJZiB0aGUgcmFuZ2UgaXMgZW1wdHksIGFuIGV4Y2VwdGlvbiAnZW1wdHkgcmFuZ2UnIGlzIHJhaXNlZFxuICAgKi9cbiAgZ2V0IGxvd2VyICgpIHtcbiAgICBpZiAodGhpcy5fZW1wdHkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1JhbmdlLmxvd2VyOiBlbXB0eSByYW5nZScpO1xuICAgICAgdGhyb3cgJ2VtcHR5IHJhbmdlJztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xvd2VyO1xuICB9XG4gIHNldCBsb3dlciAobCkge1xuICAgIHRoaXMuX2xvd2VyID0gbDtcbiAgICBpZiAodGhpcy5fbG93ZXIgPT0gbnVsbCkge1xuICAgICAgdGhpcy5fbG93ZXJJbmNsdXNpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fZW1wdHkgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKiBcbiAgICogSXMgdGhlIGxvd2VyIHZhbHVlIGluY2x1c2l2ZSA/XG4gICAqIFxuICAgKiBJZiB0aGUgcmFuZ2UgaXMgZW1wdHksIGZhbHNlIGlzIHJldHVybmVkXG4gICAqL1xuICBnZXQgbG93ZXJJbmNsdXNpdmUgKCkge1xuICAgIHJldHVybiAhdGhpcy5fZW1wdHkgJiYgKHRoaXMuX2xvd2VyICE9IG51bGwpICYmIHRoaXMuX2xvd2VySW5jbHVzaXZlO1xuICB9XG4gIHNldCBsb3dlckluY2x1c2l2ZSAobGkpIHtcbiAgICB0aGlzLl9sb3dlckluY2x1c2l2ZSA9IGxpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwcGVyIHZhbHVlIG9mIHRoZSByYW5nZVxuICAgKiBcbiAgICogSWYgdGhlIHJhbmdlIGlzIGVtcHR5LCBhbiBleGNlcHRpb24gJ2VtcHR5IHJhbmdlJyBpcyByYWlzZWRcbiAgICovXG4gIGdldCB1cHBlciAoKSB7XG4gICAgaWYgKHRoaXMuX2VtcHR5KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdSYW5nZS51cHBlcjogZW1wdHkgcmFuZ2UnKTtcbiAgICAgIHRocm93ICdlbXB0eSByYW5nZSc7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91cHBlcjtcbiAgfVxuICBzZXQgdXBwZXIgKHUpIHtcbiAgICB0aGlzLl91cHBlciA9IHU7XG4gICAgaWYgKHRoaXMuX3VwcGVyID09IG51bGwpIHtcbiAgICAgIHRoaXMuX3VwcGVySW5jbHVzaXZlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2VtcHR5ID0gZmFsc2U7XG4gIH1cblxuICAvKiogXG4gICAqIElzIHRoZSB1cHBlciB2YWx1ZSBpbmNsdXNpdmUgP1xuICAgKiBcbiAgICogSWYgdGhlIHJhbmdlIGlzIGVtcHR5LCBmYWxzZSBpcyByZXR1cm5lZFxuICAgKi9cbiAgZ2V0IHVwcGVySW5jbHVzaXZlICgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2VtcHR5ICYmICh0aGlzLl91cHBlciAhPSBudWxsKSAmJiB0aGlzLl91cHBlckluY2x1c2l2ZTtcbiAgfVxuICBzZXQgdXBwZXJJbmNsdXNpdmUgKHVpKSB7XG4gICAgdGhpcy5fdXBwZXJJbmNsdXNpdmUgPSB1aTtcbiAgfVxuXG4gIC8qKiBJbmNsdXNpdml0eTogW10gb3IgKCkgb3IgWykgb3IgKF1cbiAgICogXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldCBpbmNsdXNpdml0eSAoKSB7XG4gICAgbGV0IHM7XG4gICAgaWYgKHRoaXMubG93ZXJJbmNsdXNpdmUpIHtcbiAgICAgIHMgPSAnWyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcyA9ICcoJztcbiAgICB9XG4gICAgaWYgKHRoaXMudXBwZXJJbmNsdXNpdmUpIHtcbiAgICAgIHMgKz0gJ10nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMgKz0gJyknO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIC8qKiBTZXQgdGhlIGluY2x1c2l2aXR5IHBhcnNpbmcgYSBzdHJpbmc6ICcoJyBhbmQgJyknIGlzIGZvciBleGNsdXNpdmUsICdbJyBhbmQgJ10nIGlzIGZvciBpbmNsdXNpdmVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluY2x1c2l2aXR5IC0gSW5jbHVzaXZpdHkgc3RyaW5nIHRvIHBhcnNlOiBbXSBvciBbKSBvciAoXSBvciAoKVxuICAgKi9cbiAgcGFyc2VJbmNsdXNpdml0eSAoaW5jbHVzaXZpdHkpIHtcbiAgICBpZiAoaW5jbHVzaXZpdHkubGVuZ3RoICE9IDIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYHBhcnNlSW5jbHVzaXZpdHk6IGludmFsaWQgaW5jbHVzaXZpdHkgJHtpbmNsdXNpdml0eX1gKTtcbiAgICAgIHRocm93ICdJbnZhbGlkIGluY2x1c2l2aXR5J1xuICAgIH1cbiAgICBzd2l0Y2ggKGluY2x1c2l2aXR5LmNoYXJBdCgwKSkge1xuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIHRoaXMuX2xvd2VySW5jbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcoJzpcbiAgICAgICAgdGhpcy5fbG93ZXJJbmNsdXNpdmUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLmVycm9yKGBwYXJzZUluY2x1c2l2aXR5OiBpbnZhbGlkIGxvd2VyIGluY2x1c2l2aXR5IGluICR7aW5jbHVzaXZpdHl9YCk7XG4gICAgICAgIHRocm93ICdJbnZhbGlkIGluY2x1c2l2aXR5JztcbiAgICB9XG4gICAgc3dpdGNoIChpbmNsdXNpdml0eS5jaGFyQXQoMSkpIHtcbiAgICAgIGNhc2UgJ10nOlxuICAgICAgICB0aGlzLl91cHBlckluY2x1c2l2ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnKSc6XG4gICAgICAgIHRoaXMuX3VwcGVySW5jbHVzaXZlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5lcnJvcihgcGFyc2VJbmNsdXNpdml0eTogaW52YWxpZCB1cHBlciBpbmNsdXNpdml0eSBpbiAke2luY2x1c2l2aXR5fWApO1xuICAgICAgICB0aHJvdyAnSW52YWxpZCBpbmNsdXNpdml0eSc7XG4gICAgfVxuICB9XG5cbiAgLyoqIElzIHRoZSByYW5nZSBlbXB0eVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcmFuZ2UgaXMgZW1wdHlcbiAgICovXG4gIGlzRW1wdHkgKCkge1xuICAgIGlmICh0aGlzLl9lbXB0eSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX3VwcGVyICE9IG51bGwgJiYgdGhpcy5fbG93ZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuX3VwcGVyIDwgdGhpcy5fbG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0aGlzLl91cHBlciA9PSB0aGlzLl9sb3dlciAmJiAoIXRoaXMuX3VwcGVySW5jbHVzaXZlIHx8ICF0aGlzLl9sb3dlckluY2x1c2l2ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byBjb252ZXJ0IGFuIG9iamVjdCB0byBhIHN0cmluZ1xuICAgKiBcbiAgICogQGNhbGxiYWNrIHRvU3RyaW5nQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtPYmplY3R9IC0gT2JqZWN0IHRvIGNvbnZlcnRcbiAgICogQHJldHVybiB7c3RyaW5nfSBSZXN1bHRcbiAgICovXG5cbiAgLyoqIFRvIHN0cmluZyBjb252ZXJzaW9uXG4gICAqIEBwYXJhbSB7dG9TdHJpbmdDYWxsYmFja30gYm91bmRUb1N0cmluZyAtIG1ldGhvZCB0byBjYWxsIHRvIGNvbnZlcnQgdGhlIGxvd2VyIG9yIHVwcGVyIHZhbHVlIHRvIGEgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nIChib3VuZFRvU3RyaW5nKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gJ2VtcHR5JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5sb3dlckluY2x1c2l2ZSA/ICdbJyA6ICcoJ30keyh0aGlzLmxvd2VyICE9IG51bGwpID8gYm91bmRUb1N0cmluZyh0aGlzLmxvd2VyKSA6ICcnfSwkeyh0aGlzLnVwcGVyICE9IG51bGwpID8gYm91bmRUb1N0cmluZyh0aGlzLnVwcGVyKSA6ICcnfSR7IXRoaXMudXBwZXJJbmNsdXNpdmUgPyAnKScgOiAnXSd9YDtcbiAgICB9XG4gIH1cbn1cblxuLyoqIENyZWF0ZSBhbiBlbXB0eSByYW5nZVxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlUmFuZ2VcbiAqIEBmdW5jdGlvbiBjcmVhdGVFbXB0eVxuICogXG4gKiBAcmV0dXJuIHtSYW5nZX0gZW1wdHkgcmFuZ2VcbiAqL1xudmFyIGNyZWF0ZUVtcHR5ID0gZXhwb3J0cy5jcmVhdGVFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBSYW5nZSgpO1xufVxuXG4vKiogQ3JlYXRlIGEgcmFuZ2Ugd2l0aCB0aGUgZGVmYXVsdCBpbmNsdXNpdml0eSBbKVxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlUmFuZ2VcbiAqIEBmdW5jdGlvbiBjcmVhdGVEZWZhdWx0SW5jbHVzaXZpdHlcbiAqIFxuICogQHBhcmFtIHsqfSBsb3dlciAtIExvd2VyIHZhbHVlXG4gKiBAcGFyYW0geyp9IHVwcGVyIC0gVXBwZXIgdmFsdWVcbiAqIEByZXR1cm4ge1JhbmdlfSBSYW5nZVxuICovXG52YXIgY3JlYXRlRGVmYXVsdEluY2x1c2l2aXR5ID0gZXhwb3J0cy5jcmVhdGVEZWZhdWx0SW5jbHVzaXZpdHkgPSBmdW5jdGlvbiAobG93ZXIsIHVwcGVyKSB7XG4gIGxldCByID0gbmV3IFJhbmdlKCk7XG4gIHIubG93ZXIgPSBsb3dlcjtcbiAgci51cHBlciA9IHVwcGVyO1xuICByLmxvd2VySW5jbHVzaXZlID0gdHJ1ZTtcbiAgci51cHBlckluY2x1c2l2ZSA9IGZhbHNlO1xuICByZXR1cm4gcjtcbn1cblxuLyoqIENyZWF0ZSBhIHJhbmdlXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VSYW5nZVxuICogQGZ1bmN0aW9uIGNyZWF0ZVxuICogXG4gKiBAcGFyYW0geyp9IGxvd2VyIC0gTG93ZXIgdmFsdWVcbiAqIEBwYXJhbSB7Kn0gdXBwZXIgLSBVcHBlciB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGluY2x1c2l2aXR5IC0gSW5jbHVzaXZpdHk6ICgpIG9yIFtdIG9yIFspIG9yIChdXG4gKiBAcmV0dXJuIHtSYW5nZX0gUmFuZ2VcbiAqL1xudmFyIGNyZWF0ZSA9IGV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlciwgaW5jbHVzaXZpdHkpIHtcbiAgbGV0IHIgPSBuZXcgUmFuZ2UoKTtcbiAgci5sb3dlciA9IGxvd2VyO1xuICByLnVwcGVyID0gdXBwZXI7XG4gIHIucGFyc2VJbmNsdXNpdml0eShpbmNsdXNpdml0eSk7XG4gIHJldHVybiByO1xufVxuXG4vKiogQ2FsbGJhY2sgdG8gcGFyc2UgYSBzdHJpbmdcbiAqIFxuICogQGNhbGxiYWNrIHBhcnNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSAtIHN0cmluZyB0byBwYXJzZVxuICogQHJldHVybiB7T2JqZWN0fSBuZXcgb2JqZWN0XG4gKi9cblxuLyoqIEV4dGVuZGVkIG1ldGhvZCB0byBwYXJzZSBhIGJvdW5kLCBjb25zaWRlcmluZyBudWxsIHZhbHVlc1xuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJnIC0gc3RyaW5nIHRvIHBhcnNlXG4gKiBAcGFyYW0ge3BhcnNlQ2FsbGJhY2t9IHBhcnNlQm91bmQgLSBGdW5jdGlvbiB0byBjYWxsIHRvIHBhcnNlIG5vdCBlbXB0eSBsb3dlciBhbmQgdXBwZXIgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IG9iamVjdCByZXR1cm5lZCBieSBwYXJzZUJvdW5kXG4gKi9cbnZhciBwYXJzZUJvdW5kRXh0ID0gZnVuY3Rpb24gKGFyZywgcGFyc2VCb3VuZCkge1xuICBsZXQgcyA9IGFyZy50cmltKCk7XG4gIGlmICgocy5sZW5ndGggPT0gMCkgfHwgKHMgPT0gJy1vbycpIHx8IChzID09ICcrb28nKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBwYXJzZUJvdW5kKHMpO1xuICB9XG59XG5cbi8qKiBDcmVhdGUgYSByYW5nZSBmcm9tIGEgc3RyaW5nIChwYXJzZSBpdClcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVJhbmdlXG4gKiBAZnVuY3Rpb24gX2NyZWF0ZUZyb21TdHJpbmdcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZyAtIHN0cmluZyB0byBwYXJzZVxuICogQHBhcmFtIHtwYXJzZUNhbGxiYWNrfSBwYXJzZUJvdW5kIC0gRnVuY3Rpb24gdG8gY2FsbCB0byBwYXJzZSB0aGUgbG93ZXIgYW5kIHRoZSB1cHBlciB2YWx1ZXNcbiAqIEByZXR1cm4ge1JhbmdlfSBSYW5nZVxuICovXG52YXIgX2NyZWF0ZUZyb21TdHJpbmcgPVxuICAvL2V4cG9ydHMuY3JlYXRlRnJvbVN0cmluZyA9IFxuICBmdW5jdGlvbiAoYXJnLCBwYXJzZUJvdW5kKSB7XG4gICAgbGV0IHMgPSBhcmcudHJpbSgpO1xuXG4gICAgaWYgKHMgPT0gJycgfHwgcyA9PSAnZW1wdHknKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRW1wdHkoKTtcbiAgICB9XG5cbiAgICBpZiAocy5sZW5ndGggPCAzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBjcmVhdGVGcm9tU3RyaW5nOiAke3N9IGlzIHRvbyBzaG9ydGApO1xuICAgICAgdGhyb3cgJ0ludmFsaWQgc3RyaW5nIGxlbmd0aCc7XG4gICAgfVxuXG4gICAgbGV0IHBvcyA9IHMuaW5kZXhPZignLCcpO1xuICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgIHBvcyA9IHMuaW5kZXhPZignOycpO1xuICAgIH1cbiAgICBpZiAocG9zID09IC0xKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdubyBzZXBhcmF0b3InKTtcbiAgICAgIHRocm93ICdJbnZhbGlkIHJhbmdlLCBubyBzZXBhcmF0b3InO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gcG9zICE9IC0xXG4gICAgICBsZXQgciA9IG5ldyBSYW5nZSgpO1xuICAgICAgbGV0IGxvd2VyTGltaXRDaGFycyA9IFsnWycsICcoJ107XG4gICAgICBsZXQgZmlyc3RDaGFyID0gcy5jaGFyQXQoMCk7XG4gICAgICBpZiAobG93ZXJMaW1pdENoYXJzLmluZGV4T2YoZmlyc3RDaGFyKSAhPSAtMSkgeyAvLyBjaGFyIGZvdW5kXG4gICAgICAgIHIubG93ZXJJbmNsdXNpdmUgPSAoZmlyc3RDaGFyID09ICdbJyk7XG4gICAgICAgIGxldCBsb3dlciA9IHMuc3Vic3RyKDEsIHBvcyAtIDEpO1xuICAgICAgICByLmxvd2VyID0gcGFyc2VCb3VuZEV4dChsb3dlciwgcGFyc2VCb3VuZCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGxvd2VyIGxpbWl0IGluICcgKyBhcmcpO1xuICAgICAgICByLmxvd2VySW5jbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGxvd2VyID0gcy5zdWJzdHIoMCwgcG9zKS50cmltKCk7XG4gICAgICAgIHIubG93ZXIgPSBwYXJzZUJvdW5kRXh0KGxvd2VyLCBwYXJzZUJvdW5kKTtcbiAgICAgIH1cbiAgICAgIGxldCB1cHBlckxpbWl0Q2hhcnMgPSBbJ10nLCAnKSddO1xuICAgICAgbGV0IGxhc3RDaGFyID0gcy5jaGFyQXQocy5sZW5ndGggLSAxKTtcbiAgICAgIGlmICh1cHBlckxpbWl0Q2hhcnMuaW5kZXhPZihsYXN0Q2hhcikgIT0gLTEpIHsgLy8gY2hhciBmb3VuZFxuICAgICAgICByLnVwcGVySW5jbHVzaXZlID0gKGxhc3RDaGFyID09ICddJyk7XG4gICAgICAgIGxldCB1cHBlciA9IHMuc3Vic3RyKHBvcyArIDEsIHMubGVuZ3RoIC0gMSAtIChwb3MgKyAxKSk7XG4gICAgICAgIHIudXBwZXIgPSBwYXJzZUJvdW5kRXh0KHVwcGVyLCBwYXJzZUJvdW5kKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgdXBwZXIgbGltaXQgaW4gJyArIGFyZyk7XG4gICAgICAgIHIudXBwZXJJbmNsdXNpdmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IHVwcGVyID0gcy5zdWJzdHIocG9zICsgMSwgcy5sZW5ndGggLSAocG9zICsgMSkpO1xuICAgICAgICByLnVwcGVyID0gcGFyc2VCb3VuZEV4dCh1cHBlciwgcGFyc2VCb3VuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gIH1cblxuLyoqIFJhbmdlIHdoZXJlIHRoZSBib3VuZHMgYXJlIG5hdGl2ZSBKYXZhc2NyaXB0IGRhdGVzXG4gKiBcbiAqIEBleHRlbmRzIFJhbmdlXG4gKi9cbmNsYXNzIERhdGVSYW5nZSBleHRlbmRzIFJhbmdlIHtcbiAgLyoqIENvbnN0cnVjdG9yOiBjcmVhdGUgYSBEYXRlUmFuZ2UgZnJvbSBhIHN0cmluZyBSYW5nZSBvciBhIERhdGUgcmFuZ2VcbiAgICogXG4gICAqIEBvdmVycmlkZVxuICAgKiBcbiAgICogQHBhcmFtIHtSYW5nZX0gciAtIFJhbmdlIHRvIGNvbnZlcnQgdG8gYSBEYXRlUmFuZ2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHIpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmICghci5pc0VtcHR5KCkpIHtcbiAgICAgIGxldCBsO1xuICAgICAgaWYgKHR5cGVvZiByLmxvd2VyID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGwgPSBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHIubG93ZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IHRyaW1tZWQgPSByLmxvd2VyLnRyaW0oKTtcbiAgICAgICAgaWYgKCh0cmltbWVkID09ICcnKSB8fCAodHJpbW1lZCA9PSAnLW9vJykpIHtcbiAgICAgICAgICBsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsID0gbmV3IERhdGUoci5sb3dlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsID0gci5sb3dlcjtcbiAgICAgIH1cbiAgICAgIGxldCB1O1xuICAgICAgaWYgKHR5cGVvZiByLnVwcGVyID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHUgPSBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHIudXBwZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IHRyaW1tZWQgPSByLnVwcGVyLnRyaW0oKTtcbiAgICAgICAgaWYgKCh0cmltbWVkID09ICcnKSB8fCAodHJpbW1lZCA9PSAnK29vJykpIHtcbiAgICAgICAgICB1ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB1ID0gbmV3IERhdGUoci51cHBlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB1ID0gci51cHBlcjtcbiAgICAgIH1cbiAgICAgIHN1cGVyLmxvd2VyID0gbDtcbiAgICAgIHN1cGVyLnVwcGVyID0gdTtcbiAgICAgIHN1cGVyLmxvd2VySW5jbHVzaXZlID0gci5sb3dlckluY2x1c2l2ZTtcbiAgICAgIHN1cGVyLnVwcGVySW5jbHVzaXZlID0gci51cHBlckluY2x1c2l2ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqIENyZWF0ZSBhIG5hdGl2ZSBKYXZhc2NyaXB0IERhdGUgcmFuZ2UgZnJvbSBhIHN0cmluZyAoY2FsbGluZyBuZXcgRGF0ZSAoKSlcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVJhbmdlXG4gKiBAZnVuY3Rpb24gY3JlYXRlRGF0ZVJhbmdlRnJvbVN0cmluZ1xuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJnIC0gU3RyaW5nIHRvIHBhcnNlXG4gKiBAcmV0dXJuIHtEYXRlUmFuZ2V9IFJhbmdlXG4gKi9cbnZhciBjcmVhdGVEYXRlUmFuZ2VGcm9tU3RyaW5nID0gZXhwb3J0cy5jcmVhdGVEYXRlUmFuZ2VGcm9tU3RyaW5nID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gbmV3IERhdGVSYW5nZShfY3JlYXRlRnJvbVN0cmluZyhhcmcsIHMgPT4gbmV3IERhdGUocykpKTtcbn1cblxuLyoqIENyZWF0ZSBhIG5hdGl2ZSBKYXZhc2NyaXB0IERhdGUgcmFuZ2Ugd2l0aCB0aGUgZGVmYXVsdCBpbmNsdXNpdml0eVxuICogWykgaW4gY2FzZSBsb3dlciBhbmQgdXBwZXIgYXJlIGRpZmZlcmVudCBhbmQgW10gaW4gY2FzZSBsb3dlciBhbmQgdXBwZXIgYXJlIHRoZSBzYW1lXG4gKiBcbiAqIEluIGNhc2UgbG93ZXIgb3IgdXBwZXIgaXMgYSBzdHJpbmcsIHRoZXkgYXJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGEgRGF0ZVxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlUmFuZ2VcbiAqIEBmdW5jdGlvbiBjcmVhdGVEYXRlUmFuZ2VEZWZhdWx0SW5jbHVzaXZpdHlcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd8RGF0ZX0gbG93ZXIgLSBMb3dlciB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd8RGF0ZX0gdXBwZXIgLSBVcHBlciB2YWx1ZVxuICogQHJldHVybiB7RGF0ZVJhbmdlfSBSYW5nZVxuICovXG5leHBvcnRzLmNyZWF0ZURhdGVSYW5nZURlZmF1bHRJbmNsdXNpdml0eSA9IGZ1bmN0aW9uIChsb3dlciwgdXBwZXIpIHtcbiAgbGV0IGw7XG4gIGlmICgodHlwZW9mIGxvd2VyID09ICd1bmRlZmluZWQnKSB8fCAobG93ZXIgPT0gJ251bGwnKSkge1xuICAgIGwgPSBudWxsO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSAnc3RyaW5nJykge1xuICAgIGxldCB0cmltbWVkID0gbG93ZXIudHJpbSgpO1xuICAgIGlmICgodHJpbW1lZCA9PSAnJykgfHwgKHRyaW1tZWQgPT0gJy1vbycpKSB7XG4gICAgICBsID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBsID0gbmV3IERhdGUobG93ZXIpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBsID0gbG93ZXI7XG4gIH1cbiAgbGV0IHU7XG4gIGlmICgodHlwZW9mIHVwcGVyID09ICd1bmRlZmluZWQnKSB8fCAodXBwZXIgPT0gJ251bGwnKSkge1xuICAgIHUgPSBudWxsO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiB1cHBlciA9PSAnc3RyaW5nJykge1xuICAgIGxldCB0cmltbWVkID0gdXBwZXIudHJpbSgpO1xuICAgIGlmICgodHJpbW1lZCA9PSAnJykgfHwgKHRyaW1tZWQgPT0gJytvbycpKSB7XG4gICAgICB1ID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB1ID0gbmV3IERhdGUodXBwZXIpO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB1ID0gdXBwZXI7XG4gIH1cbiAgaWYgKChsID49IHUpICYmIChsIDw9IHUpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlUmFuZ2UoY3JlYXRlKGwsIHUsICdbXScpKTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gbmV3IERhdGVSYW5nZShjcmVhdGUobCwgdSwgJ1spJykpO1xuICB9XG59XG5cbi8qKiBDcmVhdGUgYSBuYXRpdmUgSmF2YXNjcmlwdCBEYXRlIHJhbmdlXG4gKiBcbiAqIEluIGNhc2UgbG93ZXIgb3IgdXBwZXIgaXMgYSBzdHJpbmcsIHRoZXkgYXJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGEgRGF0ZVxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlUmFuZ2VcbiAqIEBmdW5jdGlvbiBjcmVhdGVEYXRlUmFuZ2VcbiAqIFxuICogQHBhcmFtIHtzdHJpbmd8RGF0ZX0gbG93ZXIgLSBMb3dlciB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd8RGF0ZX0gdXBwZXIgLSBVcHBlciB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGluY2x1c2l2aXR5IC0gSW5jbHVzaXZpdHk6IFtdIG9yICgpIG9yIFspIG9yIChdXG4gKiBAcmV0dXJuIHtEYXRlUmFuZ2V9IFJhbmdlXG4gKi9cbmV4cG9ydHMuY3JlYXRlRGF0ZVJhbmdlID0gZnVuY3Rpb24gKGxvd2VyLCB1cHBlciwgaW5jbHVzaXZpdHkpIHtcbiAgcmV0dXJuIG5ldyBEYXRlUmFuZ2UoY3JlYXRlKGxvd2VyLCB1cHBlciwgaW5jbHVzaXZpdHkpKTtcbn1cblxuLyoqIENvbnZlcnQgYSBzdHJpbmcgb3IgRGF0ZSByYW5nZSB0byBhIERhdGUgcmFuZ2VcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVJhbmdlXG4gKiBAZnVuY3Rpb24gY29udmVydFRvRGF0ZVJhbmdlXG4gKiBcbiAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlIC0gc3RyaW5nIG9yIERhdGUgcmFuZ2VcbiAqIEByZXR1cm4ge0RhdGVSYW5nZX0gRGF0ZSByYW5nZVxuICovXG5leHBvcnRzLmNvbnZlcnRUb0RhdGVSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICBpZiAodHlwZW9mIHJhbmdlID09ICdzdHJpbmcnKVxuICAgIHJldHVybiBjcmVhdGVEYXRlUmFuZ2VGcm9tU3RyaW5nKHJhbmdlKTtcbiAgcmV0dXJuIG5ldyBEYXRlUmFuZ2UocmFuZ2UpO1xufVxuXG4vKiogUmFuZ2Ugd2hlcmUgdGhlIGJvdW5kcyBhcmUgc3RyaW5nc1xuICogXG4gKiBAZXh0ZW5kcyBSYW5nZVxuICovXG5jbGFzcyBTdHJpbmdSYW5nZSBleHRlbmRzIFJhbmdlIHtcbiAgLyoqIENvbnN0cnVjdG9yOiBjcmVhdGUgYSBTdHJpbmdSYW5nZSBmcm9tIGEgUmFuZ2VcbiAgICogXG4gICAqIEBvdmVycmlkZVxuICAgKiBcbiAgICogQHBhcmFtIHtSYW5nZX0gciAtIFJhbmdlIHRvIGNvbnZlcnQgdG8gYSBTdHJpbmdSYW5nZVxuICAgKi9cbiAgY29uc3RydWN0b3Iocikge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKCFyLmlzRW1wdHkoKSkge1xuICAgICAgbGV0IGw7XG4gICAgICBpZiAodHlwZW9mIHIubG93ZXIgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbCA9IG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh0eXBlb2Ygci5sb3dlciA9PSAnc3RyaW5nJykge1xuICAgICAgICBsZXQgdHJpbW1lZCA9IHIubG93ZXIudHJpbSgpO1xuICAgICAgICBpZiAoKHRyaW1tZWQgPT0gJycpIHx8ICh0cmltbWVkID09ICctb28nKSkge1xuICAgICAgICAgIGwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGwgPSByLmxvd2VyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChyLmxvd2VyID09IG51bGwpIHtcbiAgICAgICAgbCA9IG51bGw7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbCA9IHIubG93ZXIudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGxldCB1O1xuICAgICAgaWYgKHR5cGVvZiByLnVwcGVyID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHIgPSBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHIudXBwZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IHRyaW1tZWQgPSByLnVwcGVyLnRyaW0oKTtcbiAgICAgICAgaWYgKCh0cmltbWVkID09ICcnKSB8fCAodHJpbW1lZCA9PSAnK29vJykpIHtcbiAgICAgICAgICB1ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB1ID0gci51cHBlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoci51cHBlciA9PSBudWxsKSB7XG4gICAgICAgIHUgPSBudWxsO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHUgPSByLnVwcGVyLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBzdXBlci5sb3dlciA9IGw7XG4gICAgICBzdXBlci51cHBlciA9IHU7XG4gICAgICBzdXBlci5sb3dlckluY2x1c2l2ZSA9IHIubG93ZXJJbmNsdXNpdmU7XG4gICAgICBzdXBlci51cHBlckluY2x1c2l2ZSA9IHIudXBwZXJJbmNsdXNpdmU7XG4gICAgfVxuICB9XG59XG5cbi8qKiBDcmVhdGUgYSBzdHJpbmcgcmFuZ2UgKG5vIGNvbnZlcnNpb24gb2YgdGhlIGxvd2VyIGFuZCB1cHBlciB2YWx1ZXMpXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VSYW5nZVxuICogQGZ1bmN0aW9uIGNyZWF0ZVN0cmluZ1JhbmdlRnJvbVN0cmluZ1xuICogXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJnIC0gU3RyaW5nIHRvIHBhcnNlXG4gKiBAcmV0dXJuIHtTdHJpbmdSYW5nZX0gcmFuZ2VcbiAqL1xuZXhwb3J0cy5jcmVhdGVTdHJpbmdSYW5nZUZyb21TdHJpbmcgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBuZXcgU3RyaW5nUmFuZ2UoX2NyZWF0ZUZyb21TdHJpbmcoYXJnLCBzID0+IHMpKTtcbn1cblxuLyoqIENhbGxiYWNrIHRvIGNvbXBhcmUgdHdvIG9iamVjdHNcbiAqIFxuICogQGNhbGxiYWNrIGVxQ2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSAtIGZpcnN0IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IC0gc2Vjb25kIG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gRXF1YWxpdHkgY29tcGFyaXNvbiBiZXR3ZWVuIHRoZSB0d28gb2JqZWN0c1xuICovXG5cbi8qKiBDaGVjayB0aGUgZXF1YWxpdHkgYmV0d2VlbiB0d28gYm91bmQgb2JqZWN0c1xuICAqIFxuICAqIE5vdGUgdGhhdCB0aGUgYm91bmRzIG11c3QgYmUgYm90aCBsb3dlciBvciBib3RoIHVwcGVyXG4gICogXG4gICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVJhbmdlXG4gICogQGZ1bmN0aW9uIGJvdW5kRXF1YWxzXG4gICogXG4gKiBAcGFyYW0ge09iamVjdH0gYSAtIEZpcnN0IGJvdW5kIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIC0gU2Vjb25kIGJvdW5kIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7ZXFDYWxsYmFja30gZXEgLSBNZXRob2QgdG8gdXNlIHRvIGNvbXBhcmUgdGhlIGJvdW5kcyBpbiBjYXNlIHRoZXkgYXJlIG5vdCBudWxsXG4gKiBAcmV0dXJuIHtib29sZWFufSBFcXVhbGl0eVxuICAqL1xudmFyIGJvdW5kRXF1YWxzID0gZXhwb3J0cy5ib3VuZEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiLCBlcSkge1xuICBpZiAobnVsbCA9PSBhKSB7XG4gICAgcmV0dXJuIChudWxsID09IGIpO1xuICB9XG4gIGVsc2UgaWYgKG51bGwgPT0gYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBlbHNlIHsgLy8geCBhbmQgeSBub3QgbnVsbFxuICAgIHJldHVybiBlcShhLCBiKTtcbiAgfVxufVxuXG4vKiogQ2hlY2sgdGhlIGVxdWFsaXR5IG9mIHRoZSByYW5nZVxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlUmFuZ2VcbiAqIEBmdW5jdGlvbiBlcXVhbHNcbiAqIFxuICogQHBhcmFtIHtSYW5nZX0gYSAtIEZpcnN0IHJhbmdlIHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7UmFuZ2V9IGIgLSBTZWNvbmQgcmFuZ2UgdG8gY29tcGFyZVxuICogQHBhcmFtIHtlcUNhbGxiYWNrfSBlcSAtIE1ldGhvZCB0byB1c2UgdG8gY29tcGFyZSB0aGUgbG93ZXIgYW5kIHVwcGVyIHZhbHVlcyAod2hlbiBub3QgbnVsbClcbiAqIEByZXR1cm4ge2Jvb2xlYW59IEVxdWFsaXR5XG4gKi9cbnZhciBlcXVhbHMgPSBleHBvcnRzLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiLCBlcSkge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgobnVsbCA9PSBhKSAmJiAobnVsbCA9PSBiKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgobnVsbCA9PSBhKSB8fCAobnVsbCA9PSBiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYS5pc0VtcHR5KCkgJiYgYi5pc0VtcHR5KCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIGlmIChhLmlzRW1wdHkoKSB8fCBiLmlzRW1wdHkoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gYm91bmRFcXVhbHMoYS5sb3dlciwgYi5sb3dlciwgZXEpICYmIGJvdW5kRXF1YWxzKGEudXBwZXIsIGIudXBwZXIsIGVxKVxuICAgICYmIChhLmxvd2VySW5jbHVzaXZlID09IGIubG93ZXJJbmNsdXNpdmUpXG4gICAgJiYgKGEudXBwZXJJbmNsdXNpdmUgPT0gYi51cHBlckluY2x1c2l2ZSk7XG59XG5cbi8qKiBDaGVjayB0aGUgZXF1YWxpdHkgb2YgdGhlIHJhbmdlIHdpdGggYSBkZWZhdWx0IHZhbHVlIGVxdWFsaXR5IGNvbXBhcmlzb24gKD49ICYmIDw9KVxuICogXG4gKiBAcGFyYW0ge1JhbmdlfSBhIC0gRmlyc3QgcmFuZ2UgdG8gY29tcGFyZVxuICogQHBhcmFtIHtSYW5nZX0gYiAtIFNlY29uZCByYW5nZSB0byBjb21wYXJlXG4gKiBAcmV0dXJuIHtib29sZWFufSBFcXVhbGl0eVxuICovXG5leHBvcnRzLmVxdWFsc0RlZmF1bHQgPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gZXF1YWxzKGEsIGIsIChhLCBiKSA9PiAoYSA+PSBiKSAmJiAoYiA8PSBhKSk7IC8vIEJlY2F1c2UgZm9yIG5hdGl2ZSBqYXZhc2NyaXB0IERhdGUsIGE9PWIgZG9lcyBub3Qgd29ya1xufVxuXG4vKiogT3ZlcmxhcCBvcGVyYXRvclxuICogXG4gKiBJZiB0aGUgb3BlcmF0b3IgY2FuJ3QgYmUgYXBwbGllZCwgZmFsc2UgaXMgcmV0dXJuZWRcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVJhbmdlXG4gKiBAZnVuY3Rpb24gb3ZlcmxhcHNcbiAqIFxuICogQHBhcmFtIHtSYW5nZX0gYSAtIGZpcnN0IHJhbmdlXG4gKiBAcGFyYW0ge1JhbmdlfSBiIC0gc2Vjb25kIHJhbmdlXG4gKiBAcmV0dXJuIHRydWUgaWYgYSBhbmQgYiBvdmVybGFwXG4gKi9cbnZhciBvdmVybGFwcyA9IGV4cG9ydHMub3ZlcmxhcHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICBpZiAoYS5pc0VtcHR5KCkgfHwgYi5pc0VtcHR5KCkpIHtcbiAgICBjb25zb2xlLndhcm4oJ292ZXJsYXBzOiBlbXB0eSwgcmV0dXJuIGZhbHNlJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVsc2UgaWYgKChudWxsID09IGEubG93ZXIpICYmIChudWxsID09IGEudXBwZXIpKSB7IC8vICgsKSA9PiB0cnVlXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZWxzZSBpZiAobnVsbCA9PSBhLmxvd2VyKSB7IC8vICgsLi4uID0+IGNvbXBhcmUgdXBwZXIgb25seVxuICAgIGlmIChudWxsID09IGIubG93ZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICgoYS51cHBlciA+PSBiLmxvd2VyKSAmJiAoYS51cHBlciA8PSBiLmxvd2VyKSkgeyAvLyBDb25zaWRlciBpbmNsdXNpdml0eS4gLy8gTm90ZTogPT0gZG9lcyBub3Qgd29yayB3aXRoIERhdGVcbiAgICAgIHJldHVybiBiLmxvd2VySW5jbHVzaXZlICYmIGEudXBwZXJJbmNsdXNpdmU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGIubG93ZXIgPCBhLnVwcGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKG51bGwgPT0gYS51cHBlcikgeyAvLyAuLi4sKSA9PiBjb21wYXJlIGxvd2VyIG9ubHlcbiAgICBpZiAobnVsbCA9PSBiLnVwcGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGEubG93ZXIgPCBiLnVwcGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGEubG93ZXIgPj0gYi51cHBlcikgJiYgKGEubG93ZXIgPD0gYi51cHBlcikpIHsgLy8gQ29uc2lkZXIgaW5jbHVzaXZpdHkuIC8vIE5vdGU6ID09IGRvZXMgbm90IHdvcmsgd2l0aCBEYXRlXG4gICAgICByZXR1cm4gYi51cHBlckluY2x1c2l2ZSAmJiBhLmxvd2VySW5jbHVzaXZlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7IC8vIFsoLi4uLC4uLildXG4gICAgaWYgKChudWxsICE9IGIudXBwZXIpICYmIChudWxsICE9IGIubG93ZXIpKSB7XG4gICAgICBpZiAoKGIubG93ZXIgPj0gYS51cHBlcikgJiYgKGIubG93ZXIgPD0gYS51cHBlcikpIHsgLy8gTm90ZTogPT0gZG9lcyBub3Qgd29yayB3aXRoIERhdGVcbiAgICAgICAgcmV0dXJuIGIubG93ZXJJbmNsdXNpdmUgJiYgYS51cHBlckluY2x1c2l2ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChiLnVwcGVyID49IGEubG93ZXIpICYmIChiLnVwcGVyIDw9IGEubG93ZXIpKSB7IC8vIE5vdGU6ID09IGRvZXMgbm90IHdvcmsgd2l0aCBEYXRlXG4gICAgICAgIHJldHVybiBiLnVwcGVySW5jbHVzaXZlICYmIGEubG93ZXJJbmNsdXNpdmU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChiLmxvd2VyIDwgYS51cHBlcikgJiYgKGEubG93ZXIgPCBiLnVwcGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7IC8vIFJldmVyc2UgaXQgISBJbiBiLCB0aGVyZSBpcyAtb28gb3IgK29vXG4gICAgICByZXR1cm4gb3ZlcmxhcHMoYiwgYSk7XG4gICAgfVxuICB9XG59XG5cbi8qKiBJbnRlcnNlY3RzIHR3byByYW5nZXNcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVJhbmdlXG4gKiBAZnVuY3Rpb24gaW50ZXJzZWN0c1xuICogXG4gKiBAcGFyYW0ge1JhbmdlfSBhIC0gZmlyc3QgcmFuZ2VcbiAqIEBwYXJhbSB7UmFuZ2V9IGIgLSBzZWNvbmQgcmFuZ2VcbiAqIEByZXR1cm4ge1JhbmdlfSBJbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByYW5nZXNcbiAqL1xuZXhwb3J0cy5pbnRlcnNlY3RzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKCFvdmVybGFwcyhhLCBiKSkge1xuICAgIC8vIHRvU3RyaW5nKG5vIHBhcmFtKSA9PSB1bmRlZmluZWQgLT4gaWdub3JlIGxvZ1xuICAgIHJldHVybiBjcmVhdGVFbXB0eSgpO1xuICB9XG4gIGVsc2UgeyAvLyBPdmVybGFwIG9rXG4gICAgbGV0IGxvd2VyO1xuICAgIGxldCBsb3dlckluY2x1c2l2ZTtcbiAgICBpZiAobnVsbCA9PSBhLmxvd2VyKSB7XG4gICAgICBsb3dlciA9IGIubG93ZXI7XG4gICAgICBsb3dlckluY2x1c2l2ZSA9IGIubG93ZXJJbmNsdXNpdmU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG51bGwgPT0gYi5sb3dlcikge1xuICAgICAgbG93ZXIgPSBhLmxvd2VyO1xuICAgICAgbG93ZXJJbmNsdXNpdmUgPSBhLmxvd2VySW5jbHVzaXZlO1xuICAgIH1cbiAgICBlbHNlIGlmICgoYS5sb3dlciA+PSBiLmxvd2VyKSAmJiAoYS5sb3dlciA8PSBiLmxvd2VyKSkgeyAvLyBOb3RlOiA9PSBkb2VzIG5vdCB3b3JrIHdpdGggRGF0ZVxuICAgICAgbG93ZXIgPSBhLmxvd2VyO1xuICAgICAgbG93ZXJJbmNsdXNpdmUgPSBhLmxvd2VySW5jbHVzaXZlICYmIGIubG93ZXJJbmNsdXNpdmU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEubG93ZXIgPCBiLmxvd2VyKSB7XG4gICAgICBsb3dlciA9IGIubG93ZXI7XG4gICAgICBsb3dlckluY2x1c2l2ZSA9IGIubG93ZXJJbmNsdXNpdmU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbG93ZXIgPSBhLmxvd2VyO1xuICAgICAgbG93ZXJJbmNsdXNpdmUgPSBhLmxvd2VySW5jbHVzaXZlXG4gICAgfVxuXG4gICAgbGV0IHVwcGVyO1xuICAgIGxldCB1cHBlckluY2x1c2l2ZTtcbiAgICBpZiAobnVsbCA9PSBhLnVwcGVyKSB7XG4gICAgICB1cHBlciA9IGIudXBwZXI7XG4gICAgICB1cHBlckluY2x1c2l2ZSA9IGIudXBwZXJJbmNsdXNpdmU7XG4gICAgfVxuICAgIGVsc2UgaWYgKG51bGwgPT0gYi51cHBlcikge1xuICAgICAgdXBwZXIgPSBhLnVwcGVyO1xuICAgICAgdXBwZXJJbmNsdXNpdmUgPSBhLnVwcGVySW5jbHVzaXZlO1xuICAgIH1cbiAgICBlbHNlIGlmICgoYS51cHBlciA+PSBiLnVwcGVyKSAmJiAoYS51cHBlciA8PSBiLnVwcGVyKSkgeyAvLyBOb3RlOiA9PSBkb2VzIG5vdCB3b3JrIHdpdGggRGF0ZVxuICAgICAgdXBwZXIgPSBhLnVwcGVyO1xuICAgICAgdXBwZXJJbmNsdXNpdmUgPSBhLnVwcGVySW5jbHVzaXZlICYmIGIudXBwZXJJbmNsdXNpdmU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEudXBwZXIgPCBiLnVwcGVyKSB7XG4gICAgICB1cHBlciA9IGEudXBwZXI7XG4gICAgICB1cHBlckluY2x1c2l2ZSA9IGEudXBwZXJJbmNsdXNpdmU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdXBwZXIgPSBiLnVwcGVyO1xuICAgICAgdXBwZXJJbmNsdXNpdmUgPSBiLnVwcGVySW5jbHVzaXZlO1xuICAgIH1cblxuICAgIGxldCByID0gY3JlYXRlRGVmYXVsdEluY2x1c2l2aXR5KGxvd2VyLCB1cHBlcik7XG4gICAgci5sb3dlckluY2x1c2l2ZSA9IGxvd2VySW5jbHVzaXZlO1xuICAgIHIudXBwZXJJbmNsdXNpdmUgPSB1cHBlckluY2x1c2l2ZTtcbiAgICByZXR1cm4gcjtcbiAgfVxufSIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG4vKipcbiAqIEBmaWxlIEFjY2VzcyB3ZWIvYXNwIHNlcnZpY2VzXG4gKi9cblxuLyoqXG4qIEBtb2R1bGUgcHVsc2VTZXJ2aWNlXG4qIEByZXF1aXJlcyBwdWxzZVV0aWxpdHlcbiogQHJlcXVpcmVzIHB1bHNlTG9naW5cbiovXG5cbnZhciBwdWxzZUxvZ2luID0gcmVxdWlyZSgncHVsc2VMb2dpbicpO1xuXG4vKipcbiAqIE1ldGhvZCB0byBjYWxsIGFuIEFqYXggcmVxdWVzdCAod2l0aG91dCB0b2tlbilcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlU2VydmljZVxuICpcbiAqIEBmdW5jdGlvbiBydW5BamF4U2ltcGxlXG4gKiBcbiAqID09IHdpdGhvdXQgdG9rZW5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIHVybCB1c2VkIGJ5IGFqYXggcmVxdWVzdFxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VjY2VzcyBjYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bCBhbmQgcmV0dXJucyBhIHZhbGlkIGRhdGFcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGVycm9yIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCBpZiB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZWQgYnV0IGFuIGVycm9yIGRhdGEgaXMgcmV0dXJuZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZhaWwgY2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIGluIGNhc2Ugb2YgcmVxdWVzdCBmYWlsdXJlLiBGaXJzdCBhcmd1bWVudCBpcyB0aGUgVVJMLCBzZWNvbmQgYXJndW1lbnQgaXMgaWYgaXQgaXMgYmVjYXVzZSBvZiBhIHRpbWVvdXQsIHRoaXJkIGFyZ3VtZW50IGlzIHRoZSBzdGF0dXNcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IFRpbWVvdXQgaW4gbXNcbiAqL1xuZXhwb3J0cy5ydW5BamF4U2ltcGxlID0gZnVuY3Rpb24gKHVybCwgc3VjY2VzcywgZXJyb3IsIGZhaWwsIHRpbWVvdXQpIHtcbiAgaWYgKHR5cGVvZiB1cmwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcigncnVuQWpheFNpbXBsZTogbm8gdmFsaWQgdXJsJyk7XG4gICAgaWYgKGZhaWwpIHtcbiAgICAgIGZhaWwodXJsLCBmYWxzZSwgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICAkLnN1cHBvcnQuY29ycyA9IHRydWU7XG4gIGlmIChcIlwiICE9IHB1bHNlTG9naW4uZ2V0QWNjZXNzVG9rZW4oKSkge1xuICAgICQuYWpheChcbiAgICAgIHtcbiAgICAgICAgY3Jvc3NEb21haW46IHRydWUsXG4gICAgICAgIGNhY2hlOiBmYWxzZSwgLyogZm9yIElFICovXG4gICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgdGltZW91dDogKCh0aW1lb3V0ID09IHVuZGVmaW5lZCkgfHwgKHRpbWVvdXQgPT0gbnVsbCkgfHwgKCFpc0ludGVnZXIodGltZW91dCkpKSA/IDQgKiA2MCAqIDEwMDAgOiB0aW1lb3V0LCAvLyBkZWZhdWx0IHRpbWVvdXQgPSA0IG1pblxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyICcgKyBwdWxzZUxvZ2luLmdldEFjY2Vzc1Rva2VuKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcbiAgICAgIC5kb25lKGZ1bmN0aW9uIChkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikge1xuICAgICAgICBpZiAoZGF0YS5FcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBydW5BamF4OiBlcnJvciwgdXJsPSR7dXJsfSBtZXNzYWdlPSR7ZGF0YS5FcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvcihkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYHJ1bkFqYXg6IHN1Y2Nlc3MsIHVybD0ke3VybH1gKTtcbiAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgc3VjY2VzcyhkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuZmFpbChmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYHJ1bkFqYXg6IGZhaWx1cmUsIHVybD0ke3VybH0gdGV4dFN0YXR1cz0ke3RleHRTdGF0dXN9YCk7XG4gICAgICAgIGlmIChmYWlsKSB7XG4gICAgICAgICAgaWYgKHRleHRTdGF0dXMgPT0gJ3RpbWVvdXQnKSB7XG4gICAgICAgICAgICBmYWlsKHVybCwgdHJ1ZSwganFYSFIuc3RhdHVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmYWlsKHVybCwgZmFsc2UsIGpxWEhSLnN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuICBlbHNlIHtcbiAgICAkLmFqYXgoXG4gICAgICB7XG4gICAgICAgIGNyb3NzRG9tYWluOiB0cnVlLFxuICAgICAgICBjYWNoZTogZmFsc2UsIC8qIGZvciBJRSAqL1xuICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHRpbWVvdXQ6ICgodGltZW91dCA9PSB1bmRlZmluZWQpIHx8ICh0aW1lb3V0ID09IG51bGwpIHx8ICghaXNJbnRlZ2VyKHRpbWVvdXQpKSkgPyA0ICogNjAgKiAxMDAwIDogdGltZW91dCwgLy8gZGVmYXVsdCB0aW1lb3V0ID0gNCBtaW5cbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgfVxuICAgIClcbiAgICAgIC5kb25lKGZ1bmN0aW9uIChkYXRhLCB0ZXh0U3RhdHVzLCBqcVhIUikge1xuICAgICAgICBpZiAoZGF0YS5FcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBydW5BamF4OiBlcnJvciwgdXJsPSR7dXJsfSBtZXNzYWdlPSR7ZGF0YS5FcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvcihkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYHJ1bkFqYXg6IHN1Y2Nlc3MsIHVybD0ke3VybH1gKTtcbiAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgc3VjY2VzcyhkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuZmFpbChmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYHJ1bkFqYXg6IGZhaWx1cmUsIHVybD0ke3VybH0gdGV4dFN0YXR1cz0ke3RleHRTdGF0dXN9YCk7XG4gICAgICAgIGlmIChmYWlsKSB7XG4gICAgICAgICAgaWYgKHRleHRTdGF0dXMgPT0gJ3RpbWVvdXQnKSB7XG4gICAgICAgICAgICBmYWlsKHVybCwgdHJ1ZSwganFYSFIuc3RhdHVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmYWlsKHVybCwgZmFsc2UsIGpxWEhSLnN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxufSAvLyBydW5BamF4U2ltcGxlXG5cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjYWxsIGFuIEFqYXggcmVxdWVzdFxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VTZXJ2aWNlXG4gKlxuICogQGZ1bmN0aW9uIHJ1bkFqYXhcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdG9rZW4gVG9rZW4gdG8gY2hlY2sgYSBjYWxsYmFjayBjb3JyZXNwb25kcyB0byB0aGUgcmVxdWVzdFxuICogQHBhcmFtIHtzdHJpbmd9IHVybCB1cmwgdXNlZCBieSBhamF4IHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0IFRpbWVvdXQgaW4gbXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1Y2Nlc3MgY2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwgYW5kIHJldHVybnMgYSB2YWxpZCBkYXRhXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBlcnJvciBjYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgaWYgdGhlIHJlcXVlc3QgaXMgY29tcGxldGVkIGJ1dCBhbiBlcnJvciBkYXRhIGlzIHJldHVybmVkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmYWlsIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCBpbiBjYXNlIG9mIHJlcXVlc3QgZmFpbHVyZS4gRmlyc3QgYXJndW1lbnQgaXMgdGhlIFVSTCwgc2Vjb25kIGFyZ3VtZW50IGlzIGlmIGl0IGlzIGJlY2F1c2Ugb2YgYSB0aW1lb3V0LCB0aGlyZCBhcmd1bWVudCBpcyB0aGUgc3RhdHVzXG4gKi9cbmV4cG9ydHMucnVuQWpheCA9IGZ1bmN0aW9uICh0b2tlbiwgdXJsLCB0aW1lb3V0LCBzdWNjZXNzLCBlcnJvciwgZmFpbCkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGBydW5BamF4KCR7dG9rZW59KTogbm8gdmFsaWQgdXJsYCk7XG4gICAgaWYgKGZhaWwpIHtcbiAgICAgIGZhaWwodG9rZW4sIHVybCwgZmFsc2UsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgJC5zdXBwb3J0LmNvcnMgPSB0cnVlO1xuICBpZiAoXCJcIiAhPSBwdWxzZUxvZ2luLmdldEFjY2Vzc1Rva2VuKCkpIHtcbiAgICAkLmFqYXgoXG4gICAgICB7XG4gICAgICAgIGNyb3NzRG9tYWluOiB0cnVlLFxuICAgICAgICBjYWNoZTogZmFsc2UsIC8qIGZvciBJRSAqL1xuICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIHRpbWVvdXQ6ICgodGltZW91dCA9PSB1bmRlZmluZWQpIHx8ICh0aW1lb3V0ID09IG51bGwpIHx8ICghaXNJbnRlZ2VyKHRpbWVvdXQpKSkgPyA0ICogNjAgKiAxMDAwIDogdGltZW91dCwgLy8gZGVmYXVsdCB0aW1lb3V0ID0gNCBtaW5cbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciAnICsgcHVsc2VMb2dpbi5nZXRBY2Nlc3NUb2tlbigpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG4gICAgICAuZG9uZShmdW5jdGlvbiAoZGF0YSwgdGV4dFN0YXR1cywganFYSFIpIHtcbiAgICAgICAgaWYgKGRhdGEuRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgcnVuQWpheCgke3Rva2VufSk6IGVycm9yLCB1cmw9JHt1cmx9IG1lc3NhZ2U9JHtkYXRhLkVycm9yTWVzc2FnZX1gKTtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yKHRva2VuLCBkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYHJ1bkFqYXgoJHt0b2tlbn0pOiBzdWNjZXNzLCB1cmw9JHt1cmx9YCk7XG4gICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHN1Y2Nlc3ModG9rZW4sIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5mYWlsKGZ1bmN0aW9uIChqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgcnVuQWpheCgke3Rva2VufSk6IGZhaWx1cmUsIHVybD0ke3VybH0gdGV4dFN0YXR1cz0ke3RleHRTdGF0dXN9YCk7XG4gICAgICAgIGlmIChmYWlsKSB7XG4gICAgICAgICAgaWYgKHRleHRTdGF0dXMgPT0gJ3RpbWVvdXQnKSB7XG4gICAgICAgICAgICBmYWlsKHRva2VuLCB1cmwsIHRydWUsIGpxWEhSLnN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmFpbCh0b2tlbiwgdXJsLCBmYWxzZSwganFYSFIuc3RhdHVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgICQuYWpheChcbiAgICAgIHtcbiAgICAgICAgY3Jvc3NEb21haW46IHRydWUsXG4gICAgICAgIGNhY2hlOiBmYWxzZSwgLyogZm9yIElFICovXG4gICAgICAgIHR5cGU6ICdHRVQnLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgdGltZW91dDogKCh0aW1lb3V0ID09IHVuZGVmaW5lZCkgfHwgKHRpbWVvdXQgPT0gbnVsbCkgfHwgKCFpc0ludGVnZXIodGltZW91dCkpKSA/IDQgKiA2MCAqIDEwMDAgOiB0aW1lb3V0LCAvLyBkZWZhdWx0IHRpbWVvdXQgPSA0IG1pblxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICB9XG4gICAgKVxuICAgICAgLmRvbmUoZnVuY3Rpb24gKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSB7XG4gICAgICAgIGlmIChkYXRhLkVycm9yTWVzc2FnZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYHJ1bkFqYXgoJHt0b2tlbn0pOiBlcnJvciwgdXJsPSR7dXJsfSBtZXNzYWdlPSR7ZGF0YS5FcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvcih0b2tlbiwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBydW5BamF4KCR7dG9rZW59KTogc3VjY2VzcywgdXJsPSR7dXJsfWApO1xuICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICBzdWNjZXNzKHRva2VuLCBkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuZmFpbChmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYHJ1bkFqYXgoJHt0b2tlbn0pOiBmYWlsdXJlLCB1cmw9JHt1cmx9IHRleHRTdGF0dXM9JHt0ZXh0U3RhdHVzfWApO1xuICAgICAgICBpZiAoZmFpbCkge1xuICAgICAgICAgIGlmICh0ZXh0U3RhdHVzID09ICd0aW1lb3V0Jykge1xuICAgICAgICAgICAgZmFpbCh0b2tlbiwgdXJsLCB0cnVlLCBqcVhIUi5zdGF0dXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZhaWwodG9rZW4sIHVybCwgZmFsc2UsIGpxWEhSLnN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIGdldCBBamF4IG1lc3NhZ2UgZm9yIHVzZXIgZGlzcGxheVxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VTZXJ2aWNlXG4gKlxuICogQGZ1bmN0aW9uIGdldEFqYXhFcnJvck1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geGhyU3RhdHVzIHhoclN0YXR1cyAoY2YgcnVuIG9yIHBvc3QgQWpheCBmb3IgZGV0YWlscylcbiAqIEByZXR1cm4ge1N0cmluZ30gbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWRcbiAqL1xuZXhwb3J0cy5nZXRBamF4RXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gKHhoclN0YXR1cykge1xuICBpZiAodHlwZW9mIHhoclN0YXR1cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gJ0VtcHR5IFhIUiBzdGF0dXMnO1xuICB9XG4gIGVsc2Uge1xuICAgIGxldCBzdGF0dXNNZXNzYWdlTWFwID0ge1xuICAgICAgJzAnOiAnTm90IGNvbm5lY3RlZCwgY2hlY2sgdGhlIG5ldHdvcmsnLFxuICAgICAgJzQwMCc6ICdCYWQgcmVxdWVzdCcsXG4gICAgICAnNDAxJzogJ1VuYXV0aG9yaXNlZCBhY2Nlc3MnLFxuICAgICAgJzQwMyc6ICdGb3JiaWRkZW4gcmVzb3VyY2UsIGNhbm5vdCBiZSBhY2Nlc3NlZCcsXG4gICAgICAnNDA0JzogJ1JlcXVlc3RlZCBwYWdlIG5vdCBmb3VuZCcsXG4gICAgICAnNTAwJzogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgICAnNTAxJzogJ05vdCBpbXBsZW1lbnRlZCcsXG4gICAgICAnNTAyJzogJ0JhZCBHYXRld2F5IG9yIFByb3h5IEVycm9yJyxcbiAgICAgICc1MDMnOiAnU2VydmljZSBVbmF2YWlsYWJsZScsXG4gICAgICAnNTA0JzogJ0dhdGV3YXkgVGltZW91dCcsXG4gICAgICAnNTIwJzogJ1Vua25vd24gRXJyb3InXG4gICAgfTtcbiAgICBsZXQgbWVzc2FnZSA9IHN0YXR1c01lc3NhZ2VNYXBbeGhyU3RhdHVzXTtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBtZXNzYWdlID0gYHVua25vd24gc3RhdHVzICR7eGhyU3RhdHVzfWA7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG59XG5cbi8qKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY2FsbCBhbiBBamF4IHJlcXVlc3RcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlU2VydmljZVxuICpcbiAqIEBmdW5jdGlvbiBwb3N0QWpheFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b2tlbiBUb2tlbiB0byBjaGVjayBhIGNhbGxiYWNrIGNvcnJlc3BvbmRzIHRvIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIHVybCB1c2VkIGJ5IGFqYXggcmVxdWVzdFxuICogQHBhcmFtIHtqc29ufSBqc29uRGF0YSBqc29uRGF0YSB0byBwb3N0XG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCBUaW1lb3V0IGluIG1zXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdWNjZXNzIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCBpZiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsIGFuZCByZXR1cm5zIGEgdmFsaWQgZGF0YVxuICogQHBhcmFtIHtmdW5jdGlvbn0gZXJyb3IgY2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIGlmIHRoZSByZXF1ZXN0IGlzIGNvbXBsZXRlZCBidXQgYW4gZXJyb3IgZGF0YSBpcyByZXR1cm5lZFxuICogQHBhcmFtIHtmdW5jdGlvbn0gZmFpbCBjYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgaW4gY2FzZSBvZiByZXF1ZXN0IGZhaWx1cmUuIEZpcnN0IGFyZ3VtZW50IGlzIHRoZSBVUkwsIHNlY29uZCBhcmd1bWVudCBpcyBpZiBpdCBpcyBiZWNhdXNlIG9mIGEgdGltZW91dCwgdGhpcmQgYXJndW1lbnQgaXMgdGhlIHN0YXR1c1xuICovXG5leHBvcnRzLnBvc3RBamF4ID0gZnVuY3Rpb24gKHRva2VuLCB1cmwsIGpzb25EYXRhLCB0aW1lb3V0LCBzdWNjZXNzLCBlcnJvciwgZmFpbCkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGBwb3N0QWpheCgke3Rva2VufSk6IG5vIHZhbGlkIHVybGApO1xuICAgIGlmIChmYWlsKSB7XG4gICAgICBmYWlsKHRva2VuLCB1cmwsIGZhbHNlLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gICQuc3VwcG9ydC5jb3JzID0gdHJ1ZTtcbiAgaWYgKFwiXCIgIT0gcHVsc2VMb2dpbi5nZXRBY2Nlc3NUb2tlbigpKSB7XG4gICAgJC5hamF4KHtcbiAgICAgIGNyb3NzRG9tYWluOiB0cnVlLFxuICAgICAgY2FjaGU6IGZhbHNlLCAvKiBmb3IgSUUgKi9cbiAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgIHVybDogdXJsLFxuICAgICAgdGltZW91dDogKCh0aW1lb3V0ID09IHVuZGVmaW5lZCkgfHwgKHRpbWVvdXQgPT0gbnVsbCkgfHwgKCFpc0ludGVnZXIodGltZW91dCkpKSA/IDQgKiA2MCAqIDEwMDAgOiB0aW1lb3V0LCAvLyBkZWZhdWx0IHRpbWVvdXQgPSA0IG1pblxuICAgICAgY29udGVudFR5cGU6ICd0ZXh0L3BsYWluJywgLy8gc2hvdWxkIGJlICdhcHBsaWNhdGlvbi9qc29uJyBidXQgZG8gbm90IHdvcmsgYXQgYWxsXG4gICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoanNvbkRhdGEpLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgJyArIHB1bHNlTG9naW4uZ2V0QWNjZXNzVG9rZW4oKVxuICAgICAgfVxuICAgIH0pXG4gICAgICAuZG9uZShmdW5jdGlvbiAoZGF0YSwgdGV4dFN0YXR1cywganFYSFIpIHtcbiAgICAgICAgaWYgKGRhdGEuRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgcG9zdEFqYXgoJHt0b2tlbn0pOiBlcnJvciwgdXJsPSR7dXJsfSBtZXNzYWdlPSR7ZGF0YS5FcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvcih0b2tlbiwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBwb3N0QWpheCgke3Rva2VufSk6IHN1Y2Nlc3MsIHVybD0ke3VybH1gKTtcbiAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgc3VjY2Vzcyh0b2tlbiwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmZhaWwoZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBwb3N0QWpheCgke3Rva2VufSk6IGZhaWx1cmUsIHVybD0ke3VybH0gdGV4dFN0YXR1cz0ke3RleHRTdGF0dXN9YCk7XG4gICAgICAgIGlmIChmYWlsKSB7XG4gICAgICAgICAgaWYgKHRleHRTdGF0dXMgPT0gJ3RpbWVvdXQnKSB7XG4gICAgICAgICAgICBmYWlsKHRva2VuLCB1cmwsIHRydWUsIGpxWEhSLnN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmFpbCh0b2tlbiwgdXJsLCBmYWxzZSwganFYSFIuc3RhdHVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG4gIGVsc2Uge1xuICAgICQuYWpheCh7XG4gICAgICBjcm9zc0RvbWFpbjogdHJ1ZSxcbiAgICAgIGNhY2hlOiBmYWxzZSwgLyogZm9yIElFICovXG4gICAgICB0eXBlOiAnUE9TVCcsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIHRpbWVvdXQ6ICgodGltZW91dCA9PSB1bmRlZmluZWQpIHx8ICh0aW1lb3V0ID09IG51bGwpIHx8ICghaXNJbnRlZ2VyKHRpbWVvdXQpKSkgPyA0ICogNjAgKiAxMDAwIDogdGltZW91dCwgLy8gZGVmYXVsdCB0aW1lb3V0ID0gNCBtaW5cbiAgICAgIGNvbnRlbnRUeXBlOiAndGV4dC9wbGFpbicsIC8vIHNob3VsZCBiZSAnYXBwbGljYXRpb24vanNvbicgYnV0IGRvIG5vdCB3b3JrIGF0IGFsbFxuICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGpzb25EYXRhKVxuICAgIH0pXG4gICAgICAuZG9uZShmdW5jdGlvbiAoZGF0YSwgdGV4dFN0YXR1cywganFYSFIpIHtcbiAgICAgICAgaWYgKGRhdGEuRXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgcG9zdEFqYXgoJHt0b2tlbn0pOiBlcnJvciwgdXJsPSR7dXJsfSBtZXNzYWdlPSR7ZGF0YS5FcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBlcnJvcih0b2tlbiwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBwb3N0QWpheCgke3Rva2VufSk6IHN1Y2Nlc3MsIHVybD0ke3VybH1gKTtcbiAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgc3VjY2Vzcyh0b2tlbiwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmZhaWwoZnVuY3Rpb24gKGpxWEhSLCB0ZXh0U3RhdHVzLCBlcnJvclRocm93bikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBwb3N0QWpheCgke3Rva2VufSk6IGZhaWx1cmUsIHVybD0ke3VybH0gdGV4dFN0YXR1cz0ke3RleHRTdGF0dXN9YCk7XG4gICAgICAgIGlmIChmYWlsKSB7XG4gICAgICAgICAgaWYgKHRleHRTdGF0dXMgPT0gJ3RpbWVvdXQnKSB7XG4gICAgICAgICAgICBmYWlsKHRva2VuLCB1cmwsIHRydWUsIGpxWEhSLnN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmFpbCh0b2tlbiwgdXJsLCBmYWxzZSwganFYSFIuc3RhdHVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG59XG5cbiIsIi8vIENvcHlyaWdodCAoQykgMjAwOS0yMDIzIExlbW9pbmUgQXV0b21hdGlvbiBUZWNobm9sb2dpZXNcbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuXG52YXIgcHVsc2VVdGlsaXR5ID0gcmVxdWlyZSgncHVsc2VVdGlsaXR5Jyk7XG52YXIgX3N2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxuLyoqXG4gKiBSZXR1cm4gX3N2Z05TIGZvciB1bmlxdWUgZ2xvYmFsIGRlZmluaXRpb25cbiAqL1xuZXhwb3J0cy5nZXRfc3ZnTlMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfc3ZnTlM7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gcmFkaWFsIGdyYWRpZW50IGRlZlxuICogdG8gZGlzcGxheSBzdGFja2xpZ2h0XG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVN2Z1xuICogQGZ1bmN0aW9uIGNyZWF0ZVJhZGlhbEdyYWRpZW50RGVmXG4gKlxuICogQHJldHVybiBwYXR0ZXJuIGRlZlxuICovXG5leHBvcnRzLmNyZWF0ZVJhZGlhbEdyYWRpZW50RGVmID0gZnVuY3Rpb24gKGNvbG9yLCBuZXdJZCkge1xuICBsZXQgZGVmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKF9zdmdOUywgJ2RlZnMnKTtcblxuICBsZXQgc3RvcDAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoX3N2Z05TLCAnc3RvcCcpO1xuICBzdG9wMC5zZXRBdHRyaWJ1dGUoJ29mZnNldCcsICcwJScpO1xuICBzdG9wMC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3N0b3AtY29sb3I6I0RGREZERjtzdG9wLW9wYWNpdHk6MScpO1xuICBsZXQgc3RvcDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoX3N2Z05TLCAnc3RvcCcpO1xuICBzdG9wMS5zZXRBdHRyaWJ1dGUoJ29mZnNldCcsICcxMDAlJyk7XG4gIHN0b3AxLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnc3RvcC1jb2xvcjonICsgY29sb3IgKyAnO3N0b3Atb3BhY2l0eToxJyk7XG5cbiAgbGV0IGdyYWRpZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKF9zdmdOUywgJ3JhZGlhbEdyYWRpZW50Jyk7XG4gIGdyYWRpZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBuZXdJZCk7XG4gIGdyYWRpZW50LnNldEF0dHJpYnV0ZSgnY3gnLCAnNDAlJyk7XG4gIGdyYWRpZW50LnNldEF0dHJpYnV0ZSgnY3knLCAnNDAlJyk7XG4gIGdyYWRpZW50LnNldEF0dHJpYnV0ZSgncicsICczMCUnKTsgLy8gZGVmYXV0IDUwID9cbiAgZ3JhZGllbnQuc2V0QXR0cmlidXRlKCdmeCcsICc1MCUnKTtcbiAgZ3JhZGllbnQuc2V0QXR0cmlidXRlKCdmeScsICc0MCUnKTsgLy81MFxuICBncmFkaWVudC5hcHBlbmRDaGlsZChzdG9wMCk7XG4gIGdyYWRpZW50LmFwcGVuZENoaWxkKHN0b3AxKTtcblxuICBkZWYuYXBwZW5kQ2hpbGQoZ3JhZGllbnQpO1xuICByZXR1cm4gZGVmO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIHBhdHRlcm4gZGVmXG4gKiB0byBkaXNwbGF5IHBhdHRlcm5zIGZvciBNT1MgYW5kIG90aGVyIGJhcnNcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlU3ZnXG4gKiBAZnVuY3Rpb24gY3JlYXRlUGF0dGVybkRlZlxuICpcbiAqIEByZXR1cm4gcGF0dGVybiBkZWZcbiAqL1xuZXhwb3J0cy5jcmVhdGVQYXR0ZXJuRGVmID0gZnVuY3Rpb24gKHBhdHRlcm5OYW1lLCBjb2xvciwgbmV3TmFtZSkge1xuICBsZXQgZGVmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKF9zdmdOUywgJ2RlZnMnKTtcbiAgbGV0IHBhdHRlcm4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoX3N2Z05TLCAncGF0dGVybicpO1xuICBwYXR0ZXJuLnNldEF0dHJpYnV0ZSgnaWQnLCBuZXdOYW1lKTtcbiAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoJ3gnLCA2KTtcbiAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoJ3knLCA2KTtcbiAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMTApO1xuICBwYXR0ZXJuLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMTApO1xuICBwYXR0ZXJuLnNldEF0dHJpYnV0ZSgncGF0dGVyblVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XG4gIGlmIChwYXR0ZXJuTmFtZS5zdWJzdHJpbmcoMCwgNykgPT0gJ2NpcmNsZXMnKSB7XG4gICAgLy9pZiAoIHBhdHRlcm5OYW1lLnN0YXJ0c1dpdGgoJ2NpcmNsZXMnKSApIHsgUmVtb3ZlZCBiZWNhdXNlIElFIGZhaWxzXG4gICAgbGV0IHNpemUgPSBwYXR0ZXJuTmFtZS5zdWJzdHIoOCk7XG4gICAgbGV0IGNpcmNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhfc3ZnTlMsICdjaXJjbGUnKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdjeCcsIHNpemUgLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdjeScsIHNpemUgLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdyJywgc2l6ZSAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3N0cm9rZTogbm9uZTsgZmlsbDogJyArIGNvbG9yKTtcbiAgICBwYXR0ZXJuLmFwcGVuZENoaWxkKGNpcmNsZSk7XG4gIH1cbiAgaWYgKHBhdHRlcm5OYW1lLnN1YnN0cmluZygwLCA0KSA9PSAnZG90cycpIHtcbiAgICAvL2lmICggcGF0dGVybk5hbWUuc3RhcnRzV2l0aCgnZG90cycpICkgeyBSZW1vdmVkIGJlY2F1c2UgSUUgZmFpbHNcbiAgICBsZXQgc2l6ZSA9IHBhdHRlcm5OYW1lLnN1YnN0cig1KTtcbiAgICBsZXQgcmVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhfc3ZnTlMsICdyZWN0Jyk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgneScsIDApO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzaXplKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnc3Ryb2tlOiBub25lOyBmaWxsOiAnICsgY29sb3IpO1xuICAgIHBhdHRlcm4uYXBwZW5kQ2hpbGQocmVjdCk7XG4gIH1cbiAgaWYgKHBhdHRlcm5OYW1lLnN1YnN0cmluZygwLCAxNykgPT0gJ2hvcml6b250YWwtc3RyaXBlJykge1xuICAgIC8vaWYgKCBwYXR0ZXJuTmFtZS5zdGFydHNXaXRoKCdob3Jpem9udGFsLXN0cmlwZScpICkgeyBSZW1vdmVkIGJlY2F1c2UgSUUgZmFpbHNcbiAgICBsZXQgc2l6ZSA9IHBhdHRlcm5OYW1lLnN1YnN0cigxOCk7XG4gICAgbGV0IHJlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoX3N2Z05TLCAncmVjdCcpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlKCd4JywgMCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3knLCAwKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAxMCk7IC8vIEZ1bGwgd2lkdGhcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZSk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3N0cm9rZTogbm9uZTsgZmlsbDogJyArIGNvbG9yKTtcbiAgICBwYXR0ZXJuLmFwcGVuZENoaWxkKHJlY3QpO1xuICB9XG4gIGlmIChwYXR0ZXJuTmFtZS5zdWJzdHJpbmcoMCwgMTUpID09ICd2ZXJ0aWNhbC1zdHJpcGUnKSB7XG4gICAgLy9pZiAoIHBhdHRlcm5OYW1lLnN0YXJ0c1dpdGgoJ3ZlcnRpY2FsLXN0cmlwZScpICkgeyBSZW1vdmVkIGJlY2F1c2UgSUUgZmFpbHNcbiAgICBsZXQgc2l6ZSA9IHBhdHRlcm5OYW1lLnN1YnN0cigxNik7XG4gICAgbGV0IHJlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoX3N2Z05TLCAncmVjdCcpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlKCd4JywgMCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3knLCAwKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMTApOyAvLyBGdWxsIHdpZHRoXG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3N0cm9rZTogbm9uZTsgZmlsbDogJyArIGNvbG9yKTtcbiAgICBwYXR0ZXJuLmFwcGVuZENoaWxkKHJlY3QpO1xuICB9XG4gIGlmIChwYXR0ZXJuTmFtZS5zdWJzdHJpbmcoMCwgMTQpID09ICdkaWFnb25hbC1zdHJpcCcpIHtcbiAgICAvL2lmICggcGF0dGVybk5hbWUuc3RhcnRzV2l0aCgnZGlhZ29uYWwtc3RyaXBlJykgKSB7IFJlbW92ZWQgYmVjYXVzZSBJRSBmYWlsc1xuICAgIGxldCBzaXplID0gcGF0dGVybk5hbWUuc3Vic3RyKDE2KTtcbiAgICBsZXQgbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhfc3ZnTlMsICdsaW5lJyk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3gxJywgMCk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3kxJywgMTApO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKCd4MicsIDEwKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZSgneTInLCAwKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnc3Ryb2tlOicgKyBjb2xvciArICc7c3Ryb2tlLXdpZHRoOicgKyBzaXplKTtcbiAgICBwYXR0ZXJuLmFwcGVuZENoaWxkKGxpbmUpO1xuICAgIGxldCBsaW5lMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhfc3ZnTlMsICdsaW5lJyk7XG4gICAgbGluZTIuc2V0QXR0cmlidXRlKCd4MScsIC0xMCk7XG4gICAgbGluZTIuc2V0QXR0cmlidXRlKCd5MScsIDEwKTtcbiAgICBsaW5lMi5zZXRBdHRyaWJ1dGUoJ3gyJywgMTApO1xuICAgIGxpbmUyLnNldEF0dHJpYnV0ZSgneTInLCAtMTApO1xuICAgIGxpbmUyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnc3Ryb2tlOicgKyBjb2xvciArICc7c3Ryb2tlLXdpZHRoOicgKyBzaXplKTtcbiAgICBwYXR0ZXJuLmFwcGVuZENoaWxkKGxpbmUyKTtcbiAgICBsZXQgbGluZTMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoX3N2Z05TLCAnbGluZScpO1xuICAgIGxpbmUzLnNldEF0dHJpYnV0ZSgneDEnLCAwKTtcbiAgICBsaW5lMy5zZXRBdHRyaWJ1dGUoJ3kxJywgMjApO1xuICAgIGxpbmUzLnNldEF0dHJpYnV0ZSgneDInLCAyMCk7XG4gICAgbGluZTMuc2V0QXR0cmlidXRlKCd5MicsIDApO1xuICAgIGxpbmUzLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnc3Ryb2tlOicgKyBjb2xvciArICc7c3Ryb2tlLXdpZHRoOicgKyBzaXplKTtcbiAgICBwYXR0ZXJuLmFwcGVuZENoaWxkKGxpbmUzKTtcbiAgfVxuXG4gIGRlZi5hcHBlbmRDaGlsZChwYXR0ZXJuKTtcbiAgcmV0dXJuIGRlZjtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBTVkcgc2ltcGxlIHJlY3RcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlU3ZnXG4gKiBAZnVuY3Rpb24gY3JlYXRlUmVjdFxuICpcbiAqIEByZXR1cm4gU1ZHIHJlY3RcbiAqL1xudmFyIGNyZWF0ZVJlY3QgPSBleHBvcnRzLmNyZWF0ZVJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IsIG1haW5DbGFzcykge1xuICBsZXQgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKF9zdmdOUywgJ3N2ZycpO1xuICBzdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcblxuICAvLyBDUkVBVEUgU1ZHIHJlY3RcbiAgbGV0IHJlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoX3N2Z05TLCAncmVjdCcpO1xuICBzdmcuYXBwZW5kQ2hpbGQocmVjdCk7XG4gIGlmICh4ID09IG51bGwpXG4gICAgeCA9IDA7XG4gIGlmICh5ID09IG51bGwpXG4gICAgeSA9IDA7XG4gIHJlY3Quc2V0QXR0cmlidXRlKCd4JywgeCk7XG4gIHJlY3Quc2V0QXR0cmlidXRlKCd5JywgeSk7XG4gIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoKTtcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG4gIGlmIChjb2xvciAhPSBudWxsKVxuICAgIHJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgY29sb3IpO1xuICBpZiAobWFpbkNsYXNzICE9IG51bGwpXG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgbWFpbkNsYXNzKTtcblxuICByZXR1cm4gc3ZnO1xufVxuXG4vKipcbiAqIENyZWF0ZSBiYXNlIFNWRyB0byBpbnNlcnQgb3RoZXJzIFNWRyBlbGVtZW50c1xuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VTdmdcbiAqXG4gKiBAZnVuY3Rpb24gY3JlYXRlQmFzZVxuICogXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHdpZHRoICBcbiAqIEBwYXJhbSB7SW50ZWdlcn0gaGVpZ2h0ICBcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYWluQ2xhc3MgIGNsYXNzIHRvIHNldFxuICogQHBhcmFtIHtJbnRlZ2VyfSB2aWV3Qm94V2lkdGggIG9wdGlvbmFsXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHZpZXdCb3hIZWlnaHQgIG9wdGlvbmFsXG4gKiBAcmV0dXJuIHtPYmplY3R9IFNWR1xuICovXG52YXIgY3JlYXRlQmFzZSA9IGV4cG9ydHMuY3JlYXRlQmFzZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0LCBtYWluQ2xhc3MsIHZpZXdCb3hXaWR0aCwgdmlld0JveEhlaWdodCkge1xuICBsZXQgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKF9zdmdOUywgJ3N2ZycpO1xuICBzdmcuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgc3ZnLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBtYWluQ2xhc3MpO1xuICBpZiAoKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKHZpZXdCb3hXaWR0aCkpICYmXG4gICAgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKHZpZXdCb3hIZWlnaHQpKSkge1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAnMCAwICdcbiAgICAgICsgdmlld0JveFdpZHRoICsgJyAnXG4gICAgICArIHZpZXdCb3hIZWlnaHQpO1xuICB9XG4gIHJldHVybiBzdmc7XG59XG5cbi8qKlxuICpcbiAqIENyZWF0ZSBTVkcgZWxsaXBzZVxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VTdmdcbiAqXG4gKiBAZnVuY3Rpb24gY3JlYXRlRWxsaXBzZVxuICogXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHhNaWRkbGVcbiAqIEBwYXJhbSB7SW50ZWdlcn0geU1pZGRsZVxuICogQHBhcmFtIHtJbnRlZ2VyfSB4UmFkaXVzXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHlSYWRpdXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBtYWluQ2xhc3MgIGNsYXNzIHRvIHNldFxuIFxuICogQHJldHVybnMge09iamVjdH0gU1ZHXG4gKi9cbmV4cG9ydHMuY3JlYXRlRWxsaXBzZSA9IGZ1bmN0aW9uICh4TWlkZGxlLCB5TWlkZGxlLCB4UmFkaXVzLCB5UmFkaXVzLCBtYWluQ2xhc3MpIHtcbiAgbGV0IGVsbGlwc2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoX3N2Z05TLCAnZWxsaXBzZScpO1xuICBlbGxpcHNlLnNldEF0dHJpYnV0ZSgnY3gnLCB4TWlkZGxlKTtcbiAgZWxsaXBzZS5zZXRBdHRyaWJ1dGUoJ2N5JywgeU1pZGRsZSk7XG4gIGVsbGlwc2Uuc2V0QXR0cmlidXRlKCdyeCcsIHhSYWRpdXMpO1xuICBlbGxpcHNlLnNldEF0dHJpYnV0ZSgncnknLCB5UmFkaXVzKTtcbiAgZWxsaXBzZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgbWFpbkNsYXNzKTtcbiAgcmV0dXJuIGVsbGlwc2U7XG59XG5cbi8qKlxuICogQ3JlYXRlIFNWRyBjaXJjbGVcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlU3ZnXG4gKlxuICogQGZ1bmN0aW9uIGNyZWF0ZUNpcmNsZVxuICogXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHhNaWRkbGVcbiAqIEBwYXJhbSB7SW50ZWdlcn0geU1pZGRsZVxuICogQHBhcmFtIHtJbnRlZ2VyfSByYWRpdXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxsQ29sb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYWluQ2xhc3MgIGNsYXNzIHRvIHNldFxuICogQHBhcmFtIHtzdHJpbmd9IHN0cm9rZUNvbG9yXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHN0cm9rZVdpZHRoXG4gXG4gKiBAcmV0dXJuIHtPYmplY3R9IFNWR1xuICovXG5leHBvcnRzLmNyZWF0ZUNpcmNsZSA9IGZ1bmN0aW9uICh4TWlkZGxlLCB5TWlkZGxlLCByYWRpdXMsIGZpbGxDb2xvciwgbWFpbkNsYXNzLCBzdHJva2VDb2xvciwgc3Ryb2tlV2lkdGgpIHtcbiAgbGV0IGNpcmNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhfc3ZnTlMsICdjaXJjbGUnKTtcbiAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnY3gnLCB4TWlkZGxlKTtcbiAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnY3knLCB5TWlkZGxlKTtcbiAgY2lyY2xlLnNldEF0dHJpYnV0ZSgncicsIHJhZGl1cyk7XG4gIGlmICghcHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChmaWxsQ29sb3IpKSB7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnZmlsbCcsIGZpbGxDb2xvcik7XG4gIH1cbiAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBtYWluQ2xhc3MpO1xuICBpZiAoIXB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQoc3Ryb2tlV2lkdGgpKSB7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgc3Ryb2tlV2lkdGgpO1xuICB9XG4gIGlmICghcHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChzdHJva2VDb2xvcikpIHtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCBzdHJva2VDb2xvcik7XG4gIH1cbiAgcmV0dXJuIGNpcmNsZTtcbn1cbi8qKlxuICogQ3JlYXRlIFNWRyBzZWdtZW50IG9uIGRvbnV0XG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVN2Z1xuICpcbiAqIEBmdW5jdGlvbiBjaGFuZ2VTZWdtZW50T25Eb251dEVuZFxuICogdG8gYmUgY2FsbGVkIGFmdGVyIGNyZWF0ZVNlZ21lbnRPbkRvbnV0IHRvIG9ubHkgY2hhbmdlIGVuZCBwb3NpdGlvblxuICogXG4gKiBAcGFyYW0ge0RPTX0gY2lyY2xlUHJvZ3Jlc3NcbiAqIEBwYXJhbSB7SW50ZWdlcn0gcmFkaXVzXG4gKiBAcGFyYW0ge0RvdWJsZX0gd2lkdGhQZXJjZW50IHBlcmNlbnQgZm9yIHRoZSBzZWdtZW50IGxlbmd0aFxuICogQHBhcmFtIHtzdHJpbmd9IG1haW5DbGFzcyAgY2xhc3MgdG8gc2V0IChvcHRpb25hbClcbiBcbiAqIEByZXR1cm4ge09iamVjdH0gU1ZHXG4gKi9cbmV4cG9ydHMuXG4gIGNoYW5nZVNlZ21lbnRPbkRvbnV0RW5kID0gZnVuY3Rpb24gKGNpcmNsZVByb2dyZXNzLCByYWRpdXMsIHdpZHRoUGVyY2VudCwgbWFpbkNsYXNzKSB7XG4gICAgbGV0IGNpcmN1bWZlcmVuY2UgPSAyLjAgKiBNYXRoLlBJICogcmFkaXVzO1xuICAgIGlmICh3aWR0aFBlcmNlbnQgPj0gMC4wKSB7IC8vIEtlZXAgJzw9JyBhbmQgbm90ICc8JyBvbmx5IHRvIGFsbG93IHByb2dyZXNzXG4gICAgICBjaXJjbGVQcm9ncmVzcy5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLFxuICAgICAgICAoY2lyY3VtZmVyZW5jZSAqIHdpZHRoUGVyY2VudCkudG9GaXhlZCgwKSArICcgJyArXG4gICAgICAgIChjaXJjdW1mZXJlbmNlICogKDEuMCAtIHdpZHRoUGVyY2VudCkpLnRvRml4ZWQoMCkpOyAvLyc4NSAxNScpO1xuICAgIH1cblxuICAgIGlmIChtYWluQ2xhc3MpXG4gICAgICBjaXJjbGVQcm9ncmVzcy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgbWFpbkNsYXNzKTtcblxuICAgIHJldHVybiBjaXJjbGVQcm9ncmVzcztcbiAgfVxuXG4vKipcbiAqIENyZWF0ZSBTVkcgc2VnbWVudCBvbiBkb251dFxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VTdmdcbiAqXG4gKiBAZnVuY3Rpb24gY3JlYXRlU2VnbWVudE9uRG9udXRcbiAqIFxuICogQHBhcmFtIHtJbnRlZ2VyfSB4TWlkZGxlXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHlNaWRkbGVcbiAqIEBwYXJhbSB7SW50ZWdlcn0gcmFkaXVzXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsbENvbG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFpbkNsYXNzICBjbGFzcyB0byBzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJva2VDb2xvclxuICogQHBhcmFtIHtJbnRlZ2VyfSBzdHJva2VXaWR0aCBpbiAlXG4gKiBAcGFyYW0ge0RvdWJsZX0gYmVnaW5QZXJjZW50IHBlcmNlbnQgZm9yIHRoZSBiZWdpbiBvZiB0aGUgc2VnbWVudFxuICogQHBhcmFtIHtEb3VibGV9IHdpZHRoUGVyY2VudCBwZXJjZW50IGZvciB0aGUgc2VnbWVudCBsZW5ndGhcbiBcbiAqIEByZXR1cm4ge09iamVjdH0gU1ZHXG4gKi9cbmV4cG9ydHMuY3JlYXRlU2VnbWVudE9uRG9udXQgPSBmdW5jdGlvbiAoeE1pZGRsZSwgeU1pZGRsZSwgcmFkaXVzLCBmaWxsQ29sb3IsIG1haW5DbGFzcyxcbiAgc3Ryb2tlQ29sb3IsIHN0cm9rZVdpZHRoLCBiZWdpblBlcmNlbnQsIHdpZHRoUGVyY2VudCkge1xuICBpZiAod2lkdGhQZXJjZW50IDwgMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vbGV0IG1hZ2ljQ2lyY2xlUmFkaXVzID0gMTUuOTE1NDk0MzA5MTg5NTQ7XG4gIGxldCBjaXJjdW1mZXJlbmNlID0gMi4wICogTWF0aC5QSSAqIHJhZGl1czsgLy8gPT0gMTAwIGlmIG1hZ2ljQ2lyY2xlUmFkaXVzIGlzIHVzZWRcblxuICBsZXQgY2lyY2xlUHJvZ3Jlc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoX3N2Z05TLCAnY2lyY2xlJyk7XG4gIGNpcmNsZVByb2dyZXNzLnNldEF0dHJpYnV0ZSgnY3gnLCB4TWlkZGxlKTtcbiAgY2lyY2xlUHJvZ3Jlc3Muc2V0QXR0cmlidXRlKCdjeScsIHlNaWRkbGUpO1xuICBjaXJjbGVQcm9ncmVzcy5zZXRBdHRyaWJ1dGUoJ3InLCByYWRpdXMpO1xuICBpZiAoIXB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQoZmlsbENvbG9yKSkge1xuICAgIGNpcmNsZVByb2dyZXNzLnNldEF0dHJpYnV0ZSgnZmlsbCcsIGZpbGxDb2xvcik7XG4gIH1cbiAgY2lyY2xlUHJvZ3Jlc3Muc2V0QXR0cmlidXRlKCdjbGFzcycsIG1haW5DbGFzcyk7XG4gIGlmICghcHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChzdHJva2VDb2xvcikpIHtcbiAgICBjaXJjbGVQcm9ncmVzcy5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIHN0cm9rZUNvbG9yKTtcbiAgfVxuICBjaXJjbGVQcm9ncmVzcy5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIHN0cm9rZVdpZHRoKTtcbiAgLy8gMipwaSpSID0gMiozLjE0KnJhZGl1cyA9IDEwMFxuICBpZiAod2lkdGhQZXJjZW50ID49IDAuMCkgeyAvLyBLZWVwICc8PScgYW5kIG5vdCAnPCcgb25seSB0byBhbGxvdyBwcm9ncmVzc1xuICAgIGNpcmNsZVByb2dyZXNzLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsXG4gICAgICAoY2lyY3VtZmVyZW5jZSAqIHdpZHRoUGVyY2VudCkudG9GaXhlZCgwKSArICcgJyArXG4gICAgICAoY2lyY3VtZmVyZW5jZSAqICgxLjAgLSB3aWR0aFBlcmNlbnQpKS50b0ZpeGVkKDApKTsgLy8nODUgMTUnKTtcbiAgICBjaXJjbGVQcm9ncmVzcy5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0JyxcbiAgICAgIChjaXJjdW1mZXJlbmNlICogKDEuMCAtIGJlZ2luUGVyY2VudCkpLnRvRml4ZWQoMCkpO1xuICAgIC8vIHdhcyAyNSA9IG9uIHRvcCAoKzEwMCB0byBhdm9pZCA8MClcbiAgICAvLyBub3cgPSAwID0gb24gdGhlIHJpZ2h0IC0gbmVlZCByb3RhdGUgKCsxMDAgdG8gYXZvaWQgPDApXG4gIH1cblxuICByZXR1cm4gY2lyY2xlUHJvZ3Jlc3M7XG59XG5cbi8qKlxuICogQ3JlYXRlIFNWRyBsaW5lIG9uIGEgZG9udXRcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlU3ZnXG4gKlxuICogQGZ1bmN0aW9uIGNyZWF0ZUxpbmVPbkRvbnV0XG4gKiBcbiAqIEBwYXJhbSB7SW50ZWdlcn0geE1pZGRsZVxuICogQHBhcmFtIHtJbnRlZ2VyfSB5TWlkZGxlXG4gKiBAcGFyYW0ge0ludGVnZXJ9IG1pZGRsZVJhZGl1c1xuICogQHBhcmFtIHtJbnRlZ2VyfSBleHRlcm5SYWRpdXNcbiAqIEBwYXJhbSB7RG91YmxlfSBwZXJjZW50UG9zaXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cm9rZVdpZHRoXG4gXG4gKiBAcmV0dXJuIHtPYmplY3R9IFNWR1xuICovXG5leHBvcnRzLmNyZWF0ZUxpbmVPbkRvbnV0ID0gZnVuY3Rpb24gKHhNaWRkbGUsIHlNaWRkbGUsIG1pZGRsZVJhZGl1cywgZXh0ZXJuUmFkaXVzLFxuICBwZXJjZW50UG9zaXRpb24sIGNvbG9yLCB3aWR0aCwgZGFzaGFycmF5KSB7XG4gIGxldCBhbmdsZSA9IChwZXJjZW50UG9zaXRpb24gLSAwLjI1KSAqIDIgKiBNYXRoLlBJO1xuICBsZXQgYUxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoX3N2Z05TLCAnbGluZScpO1xuICBhTGluZS5zZXRBdHRyaWJ1dGUoJ3gxJywgeE1pZGRsZSArIG1pZGRsZVJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSk7XG4gIGFMaW5lLnNldEF0dHJpYnV0ZSgneTEnLCB5TWlkZGxlICsgbWlkZGxlUmFkaXVzICogTWF0aC5zaW4oYW5nbGUpKTtcbiAgYUxpbmUuc2V0QXR0cmlidXRlKCd4MicsIHhNaWRkbGUgKyBleHRlcm5SYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSkpO1xuICBhTGluZS5zZXRBdHRyaWJ1dGUoJ3kyJywgeU1pZGRsZSArIGV4dGVyblJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKSk7XG4gIGFMaW5lLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgd2lkdGgpO1xuICBpZiAoIXB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQoY29sb3IpKSB7XG4gICAgYUxpbmUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCBjb2xvcik7XG4gIH1cbiAgaWYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKGRhc2hhcnJheSkpIHtcbiAgICBhTGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBkYXNoYXJyYXkudG9GaXhlZCgwKSk7XG4gIH1cbiAgcmV0dXJuIGFMaW5lO1xufVxuXG4vKipcbiAqIENyZWF0ZSBTVkcgc3R5bGUgdG8gcm90YXRlIGEgZGFzaCBjaXJjbGUuXG4gKiBSb3RhdGlvbiBmcm9tIGJlZ2luU2Vjb25kcyB1bnRpbCA2MHNlYyAoaWYgaW5jcmVhc2UpIGVsc2UgdW50aWwgMCBzZWNcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlU3ZnXG4gKlxuICogQGZ1bmN0aW9uIGNyZWF0ZVN0eWxlRGFzaENpcmNsZVJvdGF0aW9uXG4gKiBcbiAqIEBwYXJhbSB7alF1ZXJ5fSBjYWxsZXIgeC10YWcgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gY2lyY2xlUmFkaXVzIHJhZGl1c1xuICogQHBhcmFtIHtOdW1iZXJ9IGJlZ2luU2Vjb25kcyBiZXR3ZWVuIDAgYW5kIDYwXG4gKi9cbmV4cG9ydHMuaW5pdEZpeGVkRGFzaENpcmNsZURhc2hhcnJheSA9XG4gIGZ1bmN0aW9uIChjYWxsZXIsIGNpcmNsZVJhZGl1cywgYmVnaW5TZWNvbmRzKSB7XG4gICAgbGV0IGZ1bGxQYXRoTGVuZ3RoID0gMiAqIE1hdGguUEkgKiBjaXJjbGVSYWRpdXM7IC8vIGNpcmN1bWZlcmVuY2VcbiAgICBjYWxsZXIuc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5JyxcbiAgICAgIChmdWxsUGF0aExlbmd0aCAqIGJlZ2luU2Vjb25kcyAvIDYwKS50b0ZpeGVkKDApICsgJyAnXG4gICAgICArIChmdWxsUGF0aExlbmd0aCAqICg2MCAtIGJlZ2luU2Vjb25kcykgLyA2MCkudG9GaXhlZCgwKSk7XG4gIH1cblxuLyoqXG4gKiBDcmVhdGUgU1ZHIHN0eWxlIHRvIHJvdGF0ZSBhIGRhc2ggY2lyY2xlLlxuICogUm90YXRpb24gZnJvbSBiZWdpblNlY29uZHMgdW50aWwgNjBzZWMgKGlmIGluY3JlYXNlKSBlbHNlIHVudGlsIDAgc2VjXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVN2Z1xuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVTdHlsZURhc2hDaXJjbGVSb3RhdGlvblxuICogXG4gKiBAcGFyYW0ge2pRdWVyeX0gY2FsbGVyIHgtdGFnIGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleUZyYW1lTmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IGNpcmNsZVJhZGl1cyByYWRpdXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jcmVhc2Ugcm90YXRpb24gZGlyZWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYmVnaW5TZWNvbmRzIGJldHdlZW4gMCBhbmQgNjBcbiAqL1xuZXhwb3J0cy5jcmVhdGVTdHlsZURhc2hDaXJjbGVSb3RhdGlvbiA9XG4gIGZ1bmN0aW9uIChjYWxsZXIsIGtleUZyYW1lTmFtZSwgYmVnaW5TZWNvbmRzLCBjaXJjbGVSYWRpdXMsIGluY3JlYXNlKSB7XG4gICAgbGV0IGZ1bGxQYXRoTGVuZ3RoID0gMiAqIE1hdGguUEkgKiBjaXJjbGVSYWRpdXM7IC8vIGNpcmN1bWZlcmVuY2VcbiAgICBsZXQgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgIC8qIFJSIC0gaWYgb25lIGRheSB3ZSBuZWVkIGRvdHMgdG8gdGhlIGxlZnQgZm9yIG5lZ2F0aXZlIHZhbHVlc1xuICAgIGxldCBrZXlGcmFtZXMgPSAnXFxcbiAgICBAa2V5ZnJhbWVzICcrIGtleUZyYW1lTmFtZSArJyB7XFxcbiAgICAgIGZyb20ge1xcXG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6ICcrZnVsbFBhdGhMZW5ndGgqYmVnaW5TZWNvbmRzLzYwKycgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgK2Z1bGxQYXRoTGVuZ3RoKig2MC1iZWdpblNlY29uZHMpLzYwKyc7XFxcbiAgICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ6ICcrZnVsbFBhdGhMZW5ndGgqKDEuMjUtKDYwLWJlZ2luU2Vjb25kcykvNjApKyc7XFxcbiAgICAgIH1cXFxuICAgICAgdG8ge1xcXG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6ICcrZnVsbFBhdGhMZW5ndGgrJyAwO1xcXG4gICAgICAgIHN0cm9rZS1kYXNob2Zmc2V0OiAnK2Z1bGxQYXRoTGVuZ3RoKjEuMjUrJztcXFxuICAgICAgfVxcXG4gICAgfSc7Ki9cbiAgICBsZXQga2V5RnJhbWVzO1xuICAgIGlmIChpbmNyZWFzZSkge1xuICAgICAga2V5RnJhbWVzID0gJ1xcXG4gICAgQGtleWZyYW1lcyAnKyBrZXlGcmFtZU5hbWUgKyAnIHtcXFxuICAgICAgZnJvbSB7XFxcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogJysgKGZ1bGxQYXRoTGVuZ3RoICogYmVnaW5TZWNvbmRzIC8gNjApLnRvRml4ZWQoMCkgKyAnICdcbiAgICAgICAgKyAoZnVsbFBhdGhMZW5ndGggKiAoNjAgLSBiZWdpblNlY29uZHMpIC8gNjApLnRvRml4ZWQoMCkgKyAnO1xcXG4gICAgICB9XFxcbiAgICAgIHRvIHtcXFxuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiAnKyBmdWxsUGF0aExlbmd0aC50b0ZpeGVkKDApICsgJyAwO1xcXG4gICAgICB9XFxcbiAgICB9JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBrZXlGcmFtZXMgPSAnXFxcbiAgICBAa2V5ZnJhbWVzICcrIGtleUZyYW1lTmFtZSArICcge1xcXG4gICAgICBmcm9tIHtcXFxuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiAnKyAoZnVsbFBhdGhMZW5ndGggKiBiZWdpblNlY29uZHMgLyA2MCkudG9GaXhlZCgwKSArICcgJ1xuICAgICAgICArIChmdWxsUGF0aExlbmd0aCAqICg2MCAtIGJlZ2luU2Vjb25kcykgLyA2MCkudG9GaXhlZCgwKSArICc7XFxcbiAgICAgIH1cXFxuICAgICAgdG8ge1xcXG4gICAgICAgIHN0cm9rZS1kYXNoYXJyYXk6IDAgJyArIGZ1bGxQYXRoTGVuZ3RoLnRvRml4ZWQoMCkgKyAnO1xcXG4gICAgICB9XFxcbiAgICB9JztcbiAgICB9XG4gICAgc3R5bGUuaW5uZXJIVE1MID0ga2V5RnJhbWVzOyAvLy5yZXBsYWNlKC9BX0RZTkFNSUNfVkFMVUUvZywgXCIxODBkZWdcIik7XG4gICAgY2FsbGVyLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4vKipcbiAqIENyZWF0ZSBTVkcgc3R5bGUgdG8gYW5pbWF0ZSBhIHNlZ21lbnQuXG4gKiBSb3RhdGlvbiBmcm9tIGZyb21XaWR0aCB0byB0b1dpZHRoXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVN2Z1xuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVTdHlsZUZvclNlZ21lbnRPbkRvbnV0XG4gKiBcbiAqIEBwYXJhbSB7alF1ZXJ5fSBjYWxsZXIgeC10YWcgY29tcG9uZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5RnJhbWVOYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gY2lyY2xlUmFkaXVzIHJhZGl1cyBpbiAlXG4gKiBAcGFyYW0ge051bWJlcn0gZnJvbVdpZHRoIHNlZ21lbnQgd2lkdGggaW4gJVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvV2lkdGggc2VnbWVudCB3aWR0aCBhZnRlciBhbmltYXRpb25cbiAqIFxuICogQHJldHVybiB7T2JqZWN0fSBTVkcgc3R5bGVcbiAqL1xuZXhwb3J0cy5jcmVhdGVTdHlsZUZvclNlZ21lbnRPbkRvbnV0ID1cbiAgZnVuY3Rpb24gKGNhbGxlciwga2V5RnJhbWVOYW1lLCBjaXJjbGVSYWRpdXMsIGZyb21XaWR0aCwgdG9XaWR0aCkge1xuICAgIGxldCBjaXJjdW1mZXJlbmNlID0gMiAqIE1hdGguUEkgKiBjaXJjbGVSYWRpdXM7IC8vID0gZnVsbCBwYXRoIGxlbmd0aFxuICAgIGxldCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cbiAgICBsZXQga2V5RnJhbWVzID0gJ1xcXG4gIEBrZXlmcmFtZXMgJysga2V5RnJhbWVOYW1lICsgJyB7XFxcbiAgICBmcm9tIHtcXFxuICAgICAgc3Ryb2tlLWRhc2hhcnJheTogJysgKGNpcmN1bWZlcmVuY2UgKiBmcm9tV2lkdGgpLnRvRml4ZWQoMCkgKyAnICdcbiAgICAgICsgKGNpcmN1bWZlcmVuY2UgKiAoMS4wIC0gZnJvbVdpZHRoKSkudG9GaXhlZCgwKSArICc7XFxcbiAgICB9XFxcbiAgICB0byB7XFxcbiAgICAgIHN0cm9rZS1kYXNoYXJyYXk6ICcrIChjaXJjdW1mZXJlbmNlICogdG9XaWR0aCkudG9GaXhlZCgwKSArICcgJ1xuICAgICAgKyAoY2lyY3VtZmVyZW5jZSAqICgxLjAgLSB0b1dpZHRoKSkudG9GaXhlZCgwKSArICc7XFxcbiAgICB9XFxcbiAgfSc7XG4gICAgc3R5bGUuaW5uZXJIVE1MID0ga2V5RnJhbWVzO1xuICAgIGNhbGxlci5hcHBlbmRDaGlsZChzdHlsZSk7XG5cbiAgICAvL2NvbnNvbGUubG9nKCdDeWNsZVByb2dyZXNzUGllKCcgKyB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtYWNoaW5lLWlkJylcbiAgICAvLyArICcpOiBhcHBlbmQgc3R5bGUgLSBrZXlGcmFtZXMgPSAnICsga2V5RnJhbWVzKTtcblxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuXG4vKipcbiAqIENyZWF0ZSBTVkcgc3R5bGUgdG8gYW5pbWF0ZSBhIHNlZ21lbnQuXG4gKiBSb3RhdGlvbiB1bnRpbCB0byB0b1dpZHRoIChmcm9tIG11c3QgYmUgZGVmaW5lZCBpbiBtYWluIHN2ZylcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlU3ZnXG4gKlxuICogQGZ1bmN0aW9uIGNyZWF0ZVN0eWxlRm9yRW5kQW5pbWF0aW9uT25Eb251dFxuICogXG4gKiBAcGFyYW0ge2pRdWVyeX0gY2FsbGVyIHgtdGFnIGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleUZyYW1lTmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IGNpcmNsZVJhZGl1cyByYWRpdXMgaW4gJVxuICogQHBhcmFtIHtOdW1iZXJ9IHRvV2lkdGggc2VnbWVudCB3aWR0aCBhZnRlciBhbmltYXRpb24gaW4gJVxuICovXG4vKmV4cG9ydHMuY3JlYXRlU3R5bGVGb3JFbmRBbmltYXRpb25PbkRvbnV0ID1cbmZ1bmN0aW9uIChjYWxsZXIsIGtleUZyYW1lTmFtZSwgY2lyY2xlUmFkaXVzLCB0b1dpZHRoKSB7XG4gIGxldCBjaXJjdW1mZXJlbmNlID0gMiAqIE1hdGguUEkgKiBjaXJjbGVSYWRpdXM7IC8vID0gZnVsbCBwYXRoIGxlbmd0aFxuICBsZXQgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICBsZXQga2V5RnJhbWVzID0gJ1xcXG5Aa2V5ZnJhbWVzICcrIGtleUZyYW1lTmFtZSArICcge1xcXG4gIHRvIHtcXFxuICAgIHN0cm9rZS1kYXNoYXJyYXk6ICcrIChjaXJjdW1mZXJlbmNlICogdG9XaWR0aCkudG9GaXhlZCgwKSArICcgJ1xuICAgICsgKGNpcmN1bWZlcmVuY2UgKiAoMS4wIC0gdG9XaWR0aCkpLnRvRml4ZWQoMCkgKyAnO1xcXG4gIH1cXFxufSc7XG4gIHN0eWxlLmlubmVySFRNTCA9IGtleUZyYW1lcztcbiAgY2FsbGVyLmFwcGVuZENoaWxkKHN0eWxlKTtcbn0qL1xuXG4vKipcbiAqIENyZWF0ZSBTVkcgc3R5bGUgdG8gYW5pbWF0ZSBhIHNlZ21lbnQuXG4gKiBSb3RhdGlvbiBvZiBCRUdJTiBmcm9tIGZyb21XaWR0aCB0byB0b1dpZHRoXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVN2Z1xuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVTdHlsZUZvclNlZ21lbnRPbkRvbnV0TW92aW5nQmVnaW5cbiAqIFxuICogQHBhcmFtIHtqUXVlcnl9IGNhbGxlciB4LXRhZyBjb21wb25lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlGcmFtZU5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBjaXJjbGVSYWRpdXMgcmFkaXVzXG4gKiBAcGFyYW0ge051bWJlcn0gZnJvbUJlZ2luIHNlZ21lbnQgYmVnaW5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b0JlZ2luIHNlZ21lbnQgYmVnaW4gYWZ0ZXIgYW5pbWF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gZnJvbVdpZHRoIHNlZ21lbnQgd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b1dpZHRoIHNlZ21lbnQgd2lkdGggYWZ0ZXIgYW5pbWF0aW9uXG4gKi9cbmV4cG9ydHMuY3JlYXRlU3R5bGVGb3JTZWdtZW50T25Eb251dE1vdmluZ0JlZ2luID1cbiAgZnVuY3Rpb24gKGNhbGxlciwga2V5RnJhbWVOYW1lLCBjaXJjbGVSYWRpdXMsIGZyb21CZWdpbiwgdG9CZWdpbiwgZnJvbVdpZHRoLCB0b1dpZHRoKSB7XG4gICAgbGV0IGNpcmN1bWZlcmVuY2UgPSAyICogTWF0aC5QSSAqIGNpcmNsZVJhZGl1czsgLy8gPSBmdWxsIHBhdGggbGVuZ3RoXG4gICAgbGV0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICAgIGxldCBrZXlGcmFtZXMgPSAnXFxcbiAgQGtleWZyYW1lcyAnKyBrZXlGcmFtZU5hbWUgKyAnIHtcXFxuICAgIGZyb20ge1xcXG4gICAgICBzdHJva2UtZGFzaGFycmF5OiAnKyAoY2lyY3VtZmVyZW5jZSAqIGZyb21XaWR0aCkudG9GaXhlZCgwKSArICcgJ1xuICAgICAgKyAoY2lyY3VtZmVyZW5jZSAqICgxLjAgLSBmcm9tV2lkdGgpKS50b0ZpeGVkKDApICsgJztcXFxuICAgICAgc3Ryb2tlLWRhc2hvZmZzZXQ6ICcrIChjaXJjdW1mZXJlbmNlICogKDEuMCAtIGZyb21CZWdpbikpLnRvRml4ZWQoMCkgKyAnO1xcXG4gICAgfVxcXG4gICAgdG8ge1xcXG4gICAgICBzdHJva2UtZGFzaGFycmF5OiAnKyAoY2lyY3VtZmVyZW5jZSAqIHRvV2lkdGgpLnRvRml4ZWQoMCkgKyAnICdcbiAgICAgICsgKGNpcmN1bWZlcmVuY2UgKiAoMS4wIC0gdG9XaWR0aCkpLnRvRml4ZWQoMCkgKyAnO1xcXG4gICAgICBzdHJva2UtZGFzaG9mZnNldDogJysgKGNpcmN1bWZlcmVuY2UgKiAoMS4wIC0gdG9CZWdpbikpLnRvRml4ZWQoMCkgKyAnO1xcXG4gICAgfVxcXG4gIH0nO1xuICAgIHN0eWxlLmlubmVySFRNTCA9IGtleUZyYW1lcztcbiAgICBjYWxsZXIuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbi8qKlxuICogQ3JlYXRlIFNWRyBzZWdtZW50IG9uIGdhdWdlXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVN2Z1xuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVTZWdtZW50T25HYXVnZVxuICogXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHhNaWRkbGVcbiAqIEBwYXJhbSB7SW50ZWdlcn0geU1pZGRsZVxuICogQHBhcmFtIHtJbnRlZ2VyfSByYWRpdXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxsQ29sb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYWluQ2xhc3MgIGNsYXNzIHRvIHNldFxuICogQHBhcmFtIHtzdHJpbmd9IHN0cm9rZUNvbG9yXG4gKiBAcGFyYW0ge0ludGVnZXJ9IHN0cm9rZVdpZHRoXG4gKiBAcGFyYW0ge0RvdWJsZX0gYmVnaW5QZXJjZW50IHBlcmNlbnQgZm9yIHRoZSBiZWdpbiBvZiB0aGUgc2VnbWVudFxuICogQHBhcmFtIHtEb3VibGV9IHdpZHRoUGVyY2VudCBwZXJjZW50IGZvciB0aGUgc2VnbWVudCBsZW5ndGhcbiBcbiAqIEByZXR1cm4ge09iamVjdH0gU1ZHXG4gKi9cbmV4cG9ydHMuY3JlYXRlU2VnbWVudE9uR2F1Z2UgPSBmdW5jdGlvbiAoeE1pZGRsZSwgeU1pZGRsZSwgcmFkaXVzLCBmaWxsQ29sb3IsIG1haW5DbGFzcyxcbiAgc3Ryb2tlQ29sb3IsIHN0cm9rZVdpZHRoLCBiZWdpblBlcmNlbnQsIHdpZHRoUGVyY2VudCkge1xuICAvL2xldCBtYWdpY0NpcmNsZVJhZGl1cyA9IDE1LjkxNTQ5NDMwOTE4OTU0O1xuICBsZXQgY2lyY3VtZmVyZW5jZSA9IDIgKiBNYXRoLlBJICogcmFkaXVzOyAvLyA9PSAxMDAgaWYgbWFnaWNDaXJjbGVSYWRpdXMgaXMgdXNlZFxuXG4gIGxldCBjaXJjbGVQcm9ncmVzcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhfc3ZnTlMsICdjaXJjbGUnKTtcbiAgY2lyY2xlUHJvZ3Jlc3Muc2V0QXR0cmlidXRlKCdjeCcsIHhNaWRkbGUpO1xuICBjaXJjbGVQcm9ncmVzcy5zZXRBdHRyaWJ1dGUoJ2N5JywgeU1pZGRsZSk7XG4gIGNpcmNsZVByb2dyZXNzLnNldEF0dHJpYnV0ZSgncicsIHJhZGl1cyk7XG4gIGlmICghcHVsc2VVdGlsaXR5LmlzTm90RGVmaW5lZChmaWxsQ29sb3IpKSB7XG4gICAgY2lyY2xlUHJvZ3Jlc3Muc2V0QXR0cmlidXRlKCdmaWxsJywgZmlsbENvbG9yKTtcbiAgfVxuICBjaXJjbGVQcm9ncmVzcy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgbWFpbkNsYXNzKTtcbiAgaWYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKHN0cm9rZUNvbG9yKSkge1xuICAgIGNpcmNsZVByb2dyZXNzLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgc3Ryb2tlQ29sb3IpO1xuICB9XG4gIGNpcmNsZVByb2dyZXNzLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgc3Ryb2tlV2lkdGgpO1xuICAvLyAyKnBpKlIgPSAyKjMuMTQqcmFkaXVzID0gMTAwXG4gICQoY2lyY2xlUHJvZ3Jlc3MpLmNzcygnc3Ryb2tlLWRhc2hhcnJheScsXG4gICAgKGNpcmN1bWZlcmVuY2UgKiAod2lkdGhQZXJjZW50IC8gMi4wKSkudG9GaXhlZCgwKSArICcgJyArXG4gICAgKGNpcmN1bWZlcmVuY2UgKiAoMS4wIC0gKHdpZHRoUGVyY2VudCAvIDIuMCkpKS50b0ZpeGVkKDApKTsgLy8nODUgMTUnKTtcbiAgJChjaXJjbGVQcm9ncmVzcykuY3NzKCdzdHJva2UtZGFzaG9mZnNldCcsXG4gICAgKGNpcmN1bWZlcmVuY2UgKiAoMS4yNSAtIChiZWdpblBlcmNlbnQgLyAyLjAgKyAwLjc1KSkpLnRvRml4ZWQoMCkpO1xuICByZXR1cm4gY2lyY2xlUHJvZ3Jlc3M7XG59XG5cbi8qKlxuICogQ3JlYXRlIFNWRyBsaW5lIG9uIGEgZ2F1Z2VcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlU3ZnXG4gKlxuICogQGZ1bmN0aW9uIGNyZWF0ZUxpbmVPbkdhdWdlXG4gKiBcbiAqIEBwYXJhbSB7SW50ZWdlcn0geE1pZGRsZVxuICogQHBhcmFtIHtJbnRlZ2VyfSB5TWlkZGxlXG4gKiBAcGFyYW0ge0ludGVnZXJ9IG1pZGRsZVJhZGl1c1xuICogQHBhcmFtIHtJbnRlZ2VyfSBleHRlcm5SYWRpdXNcbiAqIEBwYXJhbSB7RG91YmxlfSBwZXJjZW50UG9zaXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJva2VDb2xvclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cm9rZVdpZHRoXG4gXG4gKiBAcmV0dXJuIHtPYmplY3R9IFNWR1xuICovXG5leHBvcnRzLmNyZWF0ZUxpbmVPbkdhdWdlID0gZnVuY3Rpb24gKHhNaWRkbGUsIHlNaWRkbGUsIG1pZGRsZVJhZGl1cywgZXh0ZXJuUmFkaXVzLFxuICBwZXJjZW50UG9zaXRpb24sIHN0cm9rZUNvbG9yLCB3aWR0aCwgZGFzaGFycmF5KSB7XG4gIGxldCBhbmdsZSA9IChwZXJjZW50UG9zaXRpb24gLyAyICsgMC41KSAqIDIgKiBNYXRoLlBJO1xuICBsZXQgYUxpbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoX3N2Z05TLCAnbGluZScpO1xuICBhTGluZS5zZXRBdHRyaWJ1dGUoJ3gxJywgeE1pZGRsZSArIG1pZGRsZVJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKSk7XG4gIGFMaW5lLnNldEF0dHJpYnV0ZSgneTEnLCB5TWlkZGxlICsgbWlkZGxlUmFkaXVzICogTWF0aC5zaW4oYW5nbGUpKTtcbiAgYUxpbmUuc2V0QXR0cmlidXRlKCd4MicsIHhNaWRkbGUgKyBleHRlcm5SYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSkpO1xuICBhTGluZS5zZXRBdHRyaWJ1dGUoJ3kyJywgeU1pZGRsZSArIGV4dGVyblJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKSk7XG4gIGFMaW5lLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgd2lkdGgpO1xuICBpZiAoIXB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQoc3Ryb2tlQ29sb3IpKSB7XG4gICAgYUxpbmUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCBzdHJva2VDb2xvcik7XG4gIH1cbiAgaWYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKGRhc2hhcnJheSkpIHtcbiAgICBhTGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBkYXNoYXJyYXkudG9GaXhlZCgwKSk7XG4gIH1cbiAgcmV0dXJuIGFMaW5lO1xufVxuXG4vKipcbiAqIElubGluZSB0aGUgc3ZnIHNwZWNpZmllZCBhcyBiYWNrZ3JvdW5kLWltYWdlIG9mIGEgZGl2XG4gKiBUaGUgb3JpZ2luYWwgYmFja2dyb3VuZC1pbWFnZSBpcyByZW1vdmVkIGFuZCB0aGUgaW5saW5lIHN2ZyBpcyBpbnNlcnRlZCBpbiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tBZnRlcklubGluZSAoY2FuIGJlIHVuZGVmaW5lZClcbiAqL1xudmFyIGlubGluZUJhY2tncm91bmRTdmcgPSBleHBvcnRzLmlubGluZUJhY2tncm91bmRTdmcgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGNhbGxiYWNrQWZ0ZXJJbmxpbmUpIHtcbiAgLy8gQ2hlY2sgaWYgU1ZHIGlzIHN1cHBvcnRlZCBhbmQgc2VsZWN0b3IgaXMgdmFsaWRcbiAgaWYgKHR5cGVvZiBTVkdSZWN0ID09ICd1bmRlZmluZWQnIHx8ICQoc2VsZWN0b3IpID09IG51bGwpXG4gICAgcmV0dXJuO1xuXG4gIC8vIFRyeSB0byBjaGFuZ2UgdGhlIGltYWdlIGFzIGxvbmcgYXMgdGhlIGNzcyBpcyBub3QgbG9hZGVkIHlldFxuICBmdW5jdGlvbiBjaGVja0JhY2tncm91bmRJbWFnZSAoc2VsZWN0b3IpIHtcbiAgICBsZXQgYmFja2dyb3VuZEltYWdlID0gJChzZWxlY3RvcikuY3NzKCdiYWNrZ3JvdW5kLWltYWdlJyk7XG4gICAgaWYgKGJhY2tncm91bmRJbWFnZSA9PSBudWxsIHx8ICFiYWNrZ3JvdW5kSW1hZ2UuaW5jbHVkZXMoJ3VybCcpKSB7XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChjaGVja0JhY2tncm91bmRJbWFnZSwgMTAwLCBzZWxlY3Rvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gUmVxdWVzdCB0aGUgU1ZHIGZpbGVcbiAgICAgIGxldCBzcmMgPSBiYWNrZ3JvdW5kSW1hZ2UucmVwbGFjZSgndXJsKCcsICcnKS5yZXBsYWNlKCcpJywgJycpLnJlcGxhY2UoL1xcXCIvZ2ksICcnKTtcblxuICAgICAgLy8gQXBwZW5kIHRoZSBTVkcgdG8gdGhlIHRhcmdldFxuICAgICAgdmFyIGFqYXhSZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIGFqYXhSZXEub25sb2FkID0gZnVuY3Rpb24gKGUsIGQpIHtcbiAgICAgICAgLy9pZiAoYWpheFJlcS5zdGF0dXNUZXh0ID09ICdPSycpIHsgc3RhdHVzVGV4dCA9PSAnJyB1c2luZyBodHRwcyAvIEZvcmRcbiAgICAgICAgaWYgKGFqYXhSZXEuc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgICQoc2VsZWN0b3IpLmNzcygnYmFja2dyb3VuZC1pbWFnZScsICdub25lJyk7XG4gICAgICAgICAgJChzZWxlY3RvcikuYXBwZW5kKGFqYXhSZXEucmVzcG9uc2VUZXh0KTtcblxuICAgICAgICAgIC8vIENhbGxiYWNrXG4gICAgICAgICAgaWYgKHB1bHNlVXRpbGl0eS5pc0Z1bmN0aW9uKGNhbGxiYWNrQWZ0ZXJJbmxpbmUpKSB7XG4gICAgICAgICAgICBjYWxsYmFja0FmdGVySW5saW5lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYWpheFJlcS5vcGVuKCdHRVQnLCBzcmMsIHRydWUpO1xuICAgICAgYWpheFJlcS5zZW5kKCk7XG4gICAgfVxuICB9XG4gIGNoZWNrQmFja2dyb3VuZEltYWdlKHNlbGVjdG9yKTtcbn07XG5cbi8qIEdldCBhIGNsYXNzIHRvIGtub3cgdGhlIGljb24gRk9SIG1hY2hpbmUgbW9kZXNcbiovXG5leHBvcnRzLmdldE1hY2hpbmVNb2RlQ2xhc3MgPSBmdW5jdGlvbiAobWFjaGluZU1vZGVDYXRlZ29yeSkge1xuICBsZXQgY2xhc3NCZWdpbiA9ICdwdWxzZS1tb2RlLWNhdGVnb3J5LSc7XG4gIHN3aXRjaCAobWFjaGluZU1vZGVDYXRlZ29yeSkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBjbGFzc0JlZ2luICsgJ2luYWN0aXZlJztcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gY2xhc3NCZWdpbiArICdhY3RpdmUnO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBjbGFzc0JlZ2luICsgJ2Vycm9yJztcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gY2xhc3NCZWdpbiArICd1bmtub3duJztcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gY2xhc3NCZWdpbiArICdlY28nO1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBjbGFzc0JlZ2luICsgJ3N0b3BwaW5nJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyogQ3JlYXRlIGFuIGljb24gZm9yIGNvbG9yZWQgbGVnZW5kLiBcbiAqIFRoZSBjb2xvciBjYW4gYmUgZGVmaW5lZCBieSBhIGNvbG9yIE9SIGNsYXNzLlxuKi9cbmV4cG9ydHMuY3JlYXRlQ29sb3JlZExlZ2VuZCA9IGZ1bmN0aW9uIChjb2xvciwgbWFpbkNsYXNzKSB7XG4gIHJldHVybiBjcmVhdGVSZWN0KDAsIDAsIDE1LCAxNSwgY29sb3IsIG1haW5DbGFzcyk7XG59XG5cbi8qKlxuICogRGlzcGxheSBtYWludGVuYW5jZSBzY3JlZW5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlU3ZnXG4gKlxuICogQGZ1bmN0aW9uIHNob3dQdWxzZU1haW50ZW5hbmNlXG4gKiBcbiAqL1xuZXhwb3J0cy5zaG93UHVsc2VNYWludGVuYW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gaWYgYWxyZWFkeSBleGlzdHMsIGRvIG5vdGhpbmdcbiAge1xuICAgIGxldCBwdWxzZU1haW50ZW5hbmNlID0gJCgnYm9keScpLmZpbmQoJy5wdWxzZS1tYWludGVuYW5jZScpO1xuICAgIGlmIChwdWxzZU1haW50ZW5hbmNlLmxlbmd0aCAhPSAwKSB7XG4gICAgICAkKHB1bHNlTWFpbnRlbmFuY2VbMF0pLnNob3coKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvLyBlbHNlIENSRUFURVxuICBsZXQgdGV4dCA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3B1bHNlLW1haW50ZW5hbmNlLXRleHQnKVxuICAgIC5odG1sKCdUaGUgc3lzdGVtIGlzIGN1cnJlbnRseSB1bmRlciBtYWludGVuYW5jZScpO1xuICBsZXQgc3ZnID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygncHVsc2UtbWFpbnRlbmFuY2Utc3ZnJyk7XG4gIGxldCBjZW50ZXJlZERpdiA9ICQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3B1bHNlLW1haW50ZW5hbmNlLWNlbnRlcmVkLWRpdicpXG4gICAgLmFwcGVuZChzdmcpLmFwcGVuZCh0ZXh0KTtcblxuICBsZXQgc2hhZG93ID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcygncHVsc2UtbWFpbnRlbmFuY2Utc2hhZG93Jyk7XG4gIGxldCBib3ggPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdwdWxzZS1tYWludGVuYW5jZS1kaXNwbGF5LWJveCcpXG4gICAgLmFwcGVuZChjZW50ZXJlZERpdik7XG5cbiAgbGV0IHB1bHNlTWFpbnRlbmFuY2UgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdwdWxzZS1tYWludGVuYW5jZScpXG4gICAgLmFwcGVuZChzaGFkb3cpLmFwcGVuZChib3gpO1xuXG4gIC8vcHVsc2VTdmcuXG4gIGlubGluZUJhY2tncm91bmRTdmcoc3ZnKTtcblxuICAvLyBDcmVhdGUgYSBkaXYgTWFpbnRlbmFuY2VcbiAgJCgnYm9keScpLmFwcGVuZChwdWxzZU1haW50ZW5hbmNlKTtcbn1cbi8qXG4ucHVsc2UtbWFpbnRlbmFuY2Utc3Zne1xuLmNyZWF0ZV9zdmcoJ3B1bHNlLW1haW50ZW5hbmNlJywgQGNvbG9yX3RleHQsIEBjb2xvcl90ZXh0KVxufVxuICovXG4vKipcbiAqIEhJREUgbWFpbnRlbmFuY2Ugc2NyZWVuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVN2Z1xuICpcbiAqIEBmdW5jdGlvbiBoaWRlUHVsc2VNYWludGVuYW5jZVxuICogXG4gKi9cbmV4cG9ydHMuaGlkZVB1bHNlTWFpbnRlbmFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gIC8vJCgnYm9keScpLmZpbmQoJy5wdWxzZS1tYWludGVuYW5jZScpLnJlbW92ZSgpO1xuICAkKCdib2R5JykuZmluZCgnLnB1bHNlLW1haW50ZW5hbmNlJykuaGlkZSgpO1xufVxuXG5cbi8qKlxuICogcmVtb3ZlIEJBUiBjaGFydCBjcmVhdGVkIHVzaW5nIG5leHQgbWV0aG9kXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVN2Z1xuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVCYXJDaGFydFxuICogQHBhcmFtIHtET019IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHN2Z0NsYXNzXG4gKi9cbnZhciByZW1vdmVCYXJDaGFydCA9IGV4cG9ydHMucmVtb3ZlQmFyQ2hhcnQgPSBmdW5jdGlvbiAocGFyZW50LCBzdmdDbGFzcykge1xuICBpZiAocGFyZW50ID09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBjbGVhciBzdmdcbiAgbGV0IHN2ZyA9ICQocGFyZW50KS5maW5kKCcuJyArIHN2Z0NsYXNzKTtcbiAgZDMuc2VsZWN0QWxsKHN2Zy50b0FycmF5KCkpLnJlbW92ZSgpO1xuICAkKHBhcmVudCkucmVtb3ZlKCcuJyArIHN2Z0NsYXNzKTtcbn1cblxuLyoqXG4gKiBjcmVhdGUgQkFSIGNoYXJ0XG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVN2Z1xuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVCYXJDaGFydFxuICogQHBhcmFtIHtET019IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHN2Z0NsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gY2hhcnREYXRhXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogXG4gKiAgY2hhcnREYXRhID0gW1xuICogICAge1xuICogICAgICB4RGlzcGxheTogJ1J1c3QnLFxuICogICAgICAgdmFsdWU6IDc4LjkgLT4gdmFsdWUgdG8gZGlzcGxheVxuICogICAgICAgYm91bmRlZFZhbHVlIC0+IHZhbHVlIHRvIGRyYXcgaW4gY2FzZSBvZiBmaXhlZCBoZWlnaHRcbiAqICAgIH0seyAuLi59XTtcbiAqXG4gKiAgb3B0aW9ucyA9IHsgLy8gRWFjaCBjYW4gYmUgdW5kZWZpbmVkXG4gKiAgICBtaW5WYWx1ZSA6IG51bWJlclxuICogICAgbWF4VmFsdWUgOiBudW1iZXJcbiAqICAgIG1haW5UaXRsZSA6IHN0cmluZ1xuICogICAgbGVmdFRpdGxlIDogc3RyaW5nXG4gKiAgICBib3R0b21UaXRsZSA6IHN0cmluZ1xuICogICAgc291cmNlVGV4dCA6IHN0cmluZ1xuICogICAgZHJhd0hvcml6b250YWxHcmlkIDogYm9vbCwgZGVmYXVsdCBmYWxzZVxuICogICAgZHJhd1ZlcnRpY2FsR3JpZCA6IGJvb2wsIGRlZmF1bHQgZmFsc2VcbiAqICB9XG4gKi9cbmV4cG9ydHMuY3JlYXRlQmFyQ2hhcnQgPSBmdW5jdGlvbiAocGFyZW50LCBzdmdDbGFzcywgY2hhcnREYXRhLCBvcHRpb25zKSB7XG4gIGlmIChwYXJlbnQgPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlbW92ZUJhckNoYXJ0KHBhcmVudCwgc3ZnQ2xhc3MpO1xuXG4gIGxldCBtaW5WYWx1ZSA9IDA7XG4gIGxldCBtYXhWYWx1ZSA9IDA7XG5cbiAgLy8gQXV0b21hdGljIGJvdW5kc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJ0RGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGxldCB2YWx1ZSA9IGNoYXJ0RGF0YVtpXS52YWx1ZTtcbiAgICAvLyBNaW4gLyBNYXhcbiAgICBpZiAobWluVmFsdWUgPiB2YWx1ZSkge1xuICAgICAgbWluVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKG1heFZhbHVlIDwgdmFsdWUpIHtcbiAgICAgIG1heFZhbHVlID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIC8vIEN1dCBkaXNwbGF5IGlmIG5lZWRlZFxuICBpZiAoIXB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQob3B0aW9ucy5taW5WYWx1ZSlcbiAgICAmJiAnJyAhPSBvcHRpb25zLm1pblZhbHVlKSB7XG4gICAgaWYgKG1pblZhbHVlIDwgb3B0aW9ucy5taW5WYWx1ZSkge1xuICAgICAgbWluVmFsdWUgPSBvcHRpb25zLm1pblZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAoIXB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQob3B0aW9ucy5tYXhWYWx1ZSlcbiAgICAmJiAnJyAhPSBvcHRpb25zLm1heFZhbHVlKSB7XG4gICAgaWYgKG1heFZhbHVlID4gb3B0aW9ucy5tYXhWYWx1ZSkge1xuICAgICAgbWF4VmFsdWUgPSBvcHRpb25zLm1heFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1pbmltdW0gKHdhcyBEZWZhdWx0KSBzaXplXG4gIHZhciBjaGFydE1hcmdpbiA9IDYwO1xuICB2YXIgY2hhcnRXaWR0aCA9IDMwMDsgIC8vMTAwMDtcbiAgdmFyIGNoYXJ0SGVpZ2h0ID0gMjQwOyAvLzYwMDtcblxuICAvLyBBZGFwdCBzaXplIHRvIHBhcmVudCdzXG4gIGxldCBwV2lkdGggPSBwYXJlbnQud2lkdGgoKTtcbiAgbGV0IHBIZWlnaHQgPSBwYXJlbnQuaGVpZ2h0KCk7XG4gIGlmIChjaGFydFdpZHRoIDwgcFdpZHRoKSB7XG4gICAgY2hhcnRXaWR0aCA9IHBXaWR0aDtcbiAgfVxuICBpZiAoY2hhcnRIZWlnaHQgPCBwSGVpZ2h0KSB7XG4gICAgY2hhcnRIZWlnaHQgPSBwSGVpZ2h0O1xuICB9XG5cbiAgLy8gUmVtb3ZlIG1hcmdpblxuICBjaGFydFdpZHRoIC09IDIgKiBjaGFydE1hcmdpbjtcbiAgY2hhcnRIZWlnaHQgLT0gMiAqIGNoYXJ0TWFyZ2luO1xuXG4gIC8vIENyZWF0ZSBCQVIgY2hhcnRcbiAgbGV0IHN2ZyA9IGQzLnNlbGVjdEFsbChwYXJlbnQudG9BcnJheSgpKS5hcHBlbmQoJ3N2ZycpXG4gICAgLmF0dHIoJ2NsYXNzJywgc3ZnQ2xhc3MpO1xuICBzdmcuYXR0cigndmlld0JveCcsICcwIDAgJ1xuICAgICsgKGNoYXJ0V2lkdGggKyAyICogY2hhcnRNYXJnaW4pIC8vIHZpZXdCb3hXaWR0aCBcbiAgICArICcgJ1xuICAgICsgKGNoYXJ0SGVpZ2h0ICsgMiAqIGNoYXJ0TWFyZ2luKSk7IC8vICsgdmlld0JveEhlaWdodFxuXG4gIC8vIE1vdmUgdG8gbWFuYWdlIG1hcmdpblxuICBsZXQgY2hhcnQgPSBzdmcuYXBwZW5kKCdnJylcbiAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke2NoYXJ0TWFyZ2lufSwgJHtjaGFydE1hcmdpbn0pYCk7XG5cbiAgLy8gWSBTY2FsZSBhY2NvcmRpbmcgdG8gZGlzcGxheWVkIHZhbHVlcyAobGluZWFyIHNjYWxlKVxuICAvLyBYIGFuZCBZIFNjYWxlIC0gc2NhbGVCYW5kIGlzIGluIGQzLXNjYWxlLCBpdCBzcGxpdHMgcmFuZ2UgaW50byBiYW5kc1xuICBsZXQgeFNjYWxlID0gZDMuc2NhbGVCYW5kKClcbiAgICAucmFuZ2UoWzAsIGNoYXJ0V2lkdGhdKVxuICAgIC5kb21haW4oY2hhcnREYXRhLm1hcCgocykgPT4gcy54RGlzcGxheSkpXG4gICAgLnBhZGRpbmcoMC4yKTsgLy8gb3IgMC40XG4gIGxldCB5U2NhbGUgPSBkMy5zY2FsZUxpbmVhcigpXG4gICAgLnJhbmdlKFtjaGFydEhlaWdodCwgMF0pXG4gICAgLmRvbWFpbihbbWluVmFsdWUsIG1heFZhbHVlXSk7XG5cbiAgLy8gRHJhdyBYIGF4aXNcbiAgLy8gVGlja3MgYXQgYm90dG9tXG4gIGNoYXJ0LmFwcGVuZCgnZycpXG4gICAgLmF0dHIoJ2NsYXNzJywgJ3gtYm90dG9tLWF4aXMnKVxuICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKDAsICR7Y2hhcnRIZWlnaHR9KWApXG4gICAgLmNhbGwoZDMuYXhpc0JvdHRvbSh4U2NhbGUpKTtcblxuICAvLyBEcmF3IFggYXhpcyAvLyBMaW5lIGF0IDAgKGNhbiBiZSBib3R0b20sIGJ1dCBub3QgYWx3YXlzKVxuICBzdmcuYXBwZW5kKCdnJylcbiAgICAuYXR0cignY2xhc3MnLCAneC0wLWF4aXMnKVxuICAgIC5hcHBlbmQoJ2xpbmUnKVxuICAgIC5hdHRyKCd5MScsIGNoYXJ0TWFyZ2luICsgeVNjYWxlKDApKVxuICAgIC5hdHRyKCd5MicsIGNoYXJ0TWFyZ2luICsgeVNjYWxlKDApKVxuICAgIC5hdHRyKCd4MScsIGNoYXJ0TWFyZ2luKVxuICAgIC5hdHRyKCd4MicsIGNoYXJ0TWFyZ2luICsgY2hhcnRXaWR0aCk7XG5cbiAgLy8gTGVmdCBZIGF4aXNcbiAgY2hhcnQuYXBwZW5kKCdnJylcbiAgICAuY2FsbChkMy5heGlzTGVmdCh5U2NhbGUpKTtcblxuICBpZiAob3B0aW9ucy5kcmF3VmVydGljYWxHcmlkKSB7XG4gICAgLy8gdmVydGljYWwgZ3JpZCBsaW5lc1xuICAgIGxldCBtYWtlWExpbmVzID0gKCkgPT4gZDMuYXhpc0JvdHRvbSgpXG4gICAgICAuc2NhbGUoeFNjYWxlKVxuXG4gICAgLy8gdmVydGljYWwgZ3JpZCBsaW5lc1xuICAgIGNoYXJ0LmFwcGVuZCgnZycpXG4gICAgICAuYXR0cignY2xhc3MnLCAnZ3JpZCcpXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAke2NoYXJ0SGVpZ2h0fSlgKVxuICAgICAgLmNhbGwobWFrZVhMaW5lcygpXG4gICAgICAgIC50aWNrU2l6ZSgtY2hhcnRIZWlnaHQsIDAsIDApXG4gICAgICAgIC50aWNrRm9ybWF0KCcnKVxuICAgICAgKVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuZHJhd0hvcml6b250YWxHcmlkKSB7XG4gICAgLy8gSG9yaXpvbnRhbCBncmlkIGxpbmVzXG4gICAgbGV0IG1ha2VZTGluZXMgPSAoKSA9PiBkMy5heGlzTGVmdCgpXG4gICAgICAuc2NhbGUoeVNjYWxlKTtcblxuICAgIGNoYXJ0LmFwcGVuZCgnZycpXG4gICAgICAuYXR0cignY2xhc3MnLCAnZ3JpZCcpXG4gICAgICAuY2FsbChtYWtlWUxpbmVzKClcbiAgICAgICAgLnRpY2tTaXplKC1jaGFydFdpZHRoLCAwLCAwKVxuICAgICAgICAudGlja0Zvcm1hdCgnJylcbiAgICAgICk7XG4gIH1cblxuICAvLyBEcmF3IGRhdGFcbiAgbGV0IGJhckdyb3VwcyA9IGNoYXJ0LnNlbGVjdEFsbCgpXG4gICAgLmRhdGEoY2hhcnREYXRhKVxuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZCgnZycpO1xuXG5cbiAgLy8gZy52YWx1ZSByZXBsYWNlZCB3aXRoIGJvdW5kZWRWYWx1ZVxuICBiYXJHcm91cHNcbiAgICAuYXBwZW5kKCdyZWN0JylcbiAgICAvLy5hdHRyKCdjbGFzcycsICdiYXInKVxuICAgIC5hdHRyKCdjbGFzcycsIChnKSA9PiAoZy5ib3VuZGVkVmFsdWUgPiAwKSA/ICdiYXIgcG9zaXRpdmUnIDogJ2JhciBuZWdhdGl2ZScpXG4gICAgLmF0dHIoJ3gnLCAoZykgPT4geFNjYWxlKGcueERpc3BsYXkpKVxuICAgIC8vIGNhbiBiZSAuYXR0cijigJl44oCZLCAoYWN0dWFsLCBpbmRleCwgYXJyYXkpID0+IHhTY2FsZShhY3R1YWwudmFsdWUpKVxuICAgIC5hdHRyKCd5JywgKGcpID0+IChnLmJvdW5kZWRWYWx1ZSA+IDApID8geVNjYWxlKGcuYm91bmRlZFZhbHVlKSA6IHlTY2FsZSgwKSlcbiAgICAuYXR0cignaGVpZ2h0JywgKGcpID0+IE1hdGguYWJzKHlTY2FsZShnLmJvdW5kZWRWYWx1ZSkgLSB5U2NhbGUoMCkpKVxuICAgIC5hdHRyKCd3aWR0aCcsIHhTY2FsZS5iYW5kd2lkdGgoKSk7XG4gIC8qLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKGFjdHVhbCwgaSkge1xufSlcbi5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcbn0pICovXG5cbiAgLy8gQWRkIHRleHQgd2l0aCB2YWx1ZSBpbiBiYXIgLSBOb3QgcmVhZHkgeWV0IC0gQ291bGQgYmUgYWRkZWRcbiAgLypiYXJHcm91cHNcbiAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAuYXR0cignY2xhc3MnLCAndmFsdWUnKVxuICAgIC5hdHRyKCd4JywgKGEpID0+IHhTY2FsZShhLnhEaXNwbGF5KSArIHhTY2FsZS5iYW5kd2lkdGgoKSAvIDIpXG4gICAgLmF0dHIoJ3knLCAoYSkgPT4geVNjYWxlKGEudmFsdWUpICsgMzApXG4gICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgLnRleHQoKGEpID0+IGAke2EudmFsdWV9JWApOyovXG5cbiAgaWYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKG9wdGlvbnMubGVmdFRpdGxlKSkge1xuICAgIC8vIEFkZCBsZWZ0IGxlZ2VuZFxuICAgIHN2Z1xuICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAuYXR0cignY2xhc3MnLCAnbGFiZWwnKVxuICAgICAgLmF0dHIoJ3gnLCAtKGNoYXJ0SGVpZ2h0IC8gMikgLSBjaGFydE1hcmdpbilcbiAgICAgIC5hdHRyKCd5JywgY2hhcnRNYXJnaW4gLyAyLjQpXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3JvdGF0ZSgtOTApJylcbiAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgLnRleHQoJ0xlZnQgbGVnZW5kJyk7XG4gIH1cbiAgaWYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKG9wdGlvbnMuYm90dG9tVGl0bGUpKSB7XG4gICAgLy8gQWRkIGJvdHRvbSBsZWdlbmRcbiAgICBzdmcuYXBwZW5kKCd0ZXh0JylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdsYWJlbCcpXG4gICAgICAuYXR0cigneCcsIGNoYXJ0V2lkdGggLyAyICsgY2hhcnRNYXJnaW4pXG4gICAgICAuYXR0cigneScsIGNoYXJ0SGVpZ2h0ICsgY2hhcnRNYXJnaW4gKiAxLjcpXG4gICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcbiAgICAgIC50ZXh0KCdCb3R0b20gbGVnZW5kJyk7XG4gIH1cbiAgaWYgKCFwdWxzZVV0aWxpdHkuaXNOb3REZWZpbmVkKG9wdGlvbnMubWFpblRpdGxlKSkge1xuICAgIC8vIEFkZCBtYWluIHRpdGxlXG4gICAgc3ZnLmFwcGVuZCgndGV4dCcpXG4gICAgICAuYXR0cignY2xhc3MnLCAndGl0bGUnKVxuICAgICAgLmF0dHIoJ3gnLCBjaGFydFdpZHRoIC8gMiArIGNoYXJ0TWFyZ2luKVxuICAgICAgLmF0dHIoJ3knLCA0MClcbiAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuICAgICAgLnRleHQoJ01haW4gdGl0bGUnKTtcbiAgfVxuICBpZiAoIXB1bHNlVXRpbGl0eS5pc05vdERlZmluZWQob3B0aW9ucy5zb3VyY2VUZXh0KSkge1xuICAgIC8vIEFkZCBib3R0b20gc291cmNlIHRleHRcbiAgICBzdmcuYXBwZW5kKCd0ZXh0JylcbiAgICAgIC5hdHRyKCdjbGFzcycsICdzb3VyY2UnKVxuICAgICAgLmF0dHIoJ3gnLCBjaGFydFdpZHRoIC0gY2hhcnRNYXJnaW4gLyAyKVxuICAgICAgLmF0dHIoJ3knLCBjaGFydEhlaWdodCArIGNoYXJ0TWFyZ2luICogMS43KVxuICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0JylcbiAgICAgIC50ZXh0KCdTb3VyY2U6ICcgKyBvcHRpb25zLnNvdXJjZVRleHQpO1xuICB9XG4gIC8vIE1ha2UgaXQgaW50ZXJhY3RpdmVcbiAgLypzdmdFbGVtZW50XG4gICAgLm9uKCdtb3VzZWVudGVyJywgZnVuY3Rpb24gKGFjdHVhbCwgaSkge1xuICAgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIo4oCYb3BhY2l0eeKAmSwgMC41KVxuICAgIH0pXG4gICAgLm9uKCdtb3VzZWxlYXZl4oCZLCBmdW5jdGlvbiAoYWN0dWFsLCBpKSB7XG4gICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIo4oCYb3BhY2l0eeKAmSwgMSlcbn0pO1xuZDMubW91c2UgLT4gdG8gZ2V0IGNvb3JkaW5hdGUsIHNob3cgdG9vbHRpcCAuLi5cbiovXG5cbn1cblxuLyoqXG4gKiBjcmVhdGUgbWlzc2luZyBkYXRhIChyZWQgZG90KVxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VTdmdcbiAqXG4gKiBAZnVuY3Rpb24gY3JlYXRlTWlzc2luZ2RhdGFcbiAqIEBwYXJhbSB7RE9NfSBwYXJlbnRcbiAqL1xuZXhwb3J0cy5jcmVhdGVNaXNzaW5nZGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgLy8gVG8gYWRkIGluIHZlcnNpb24gMTJcbiAgbGV0IHJhZGl1cyA9IDQ7XG5cbiAgLy9jcmVhdGVCYXNlXG4gIGxldCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoX3N2Z05TLCAnc3ZnJyk7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMiAqIHJhZGl1cyk7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDIgKiByYWRpdXMpO1xuICBzdmcuc2V0QXR0cmlidXRlKCdjbGFzcycsICdwdWxzZS1taXNzaW5nLWRhdGEnKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZSgndmlld0JveCcsICcwIDAgJyArIDIgKiByYWRpdXMgKyAnICcgKyAyICogcmFkaXVzKTtcbiAgLy8gQXBwZW5kXG4gICQocGFyZW50KS5hcHBlbmQoc3ZnKTtcblxuICAvLyBjcmVhdGVDaXJjbGUgLyBjb3VsZCBiZSBhbiBpbWFnZVxuICBsZXQgY2lyY2xlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKF9zdmdOUywgJ2NpcmNsZScpO1xuXG4gIC8vID0gZnVuY3Rpb24gKHhNaWRkbGUsIHlNaWRkbGUsIHJhZGl1cywgZmlsbENvbG9yLCBtYWluQ2xhc3MsIHN0cm9rZUNvbG9yLCBzdHJva2VXaWR0aCkge1xuICBjaXJjbGUuc2V0QXR0cmlidXRlKCdjeCcsIHJhZGl1cyk7XG4gIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ2N5JywgcmFkaXVzKTtcbiAgY2lyY2xlLnNldEF0dHJpYnV0ZSgncicsIHJhZGl1cyk7XG4gIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3B1bHNlLW1pc3NpbmctZGF0YS1jaXJjbGUnKTtcbiAgLy9jaXJjbGUuc2V0QXR0cmlidXRlKCdmaWxsJywgJ3JlZCcpO1xuICAvL2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsICcxcHgnKTsgICAgICBcbiAgLy9jaXJjbGUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCBzdHJva2VDb2xvcik7XG5cbiAgc3ZnLmFwcGVuZENoaWxkKGNpcmNsZSk7XG59IiwiLy8gQ29weXJpZ2h0IChDKSAyMDA5LTIwMjMgTGVtb2luZSBBdXRvbWF0aW9uIFRlY2hub2xvZ2llc1xuLy9cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5cbi8qKlxuICogQGZpbGUgVmFyaW91cyB0b29sIGZ1bmN0aW9ucy5cbiAqL1xuXG4vKipcbiogQG1vZHVsZSBwdWxzZVV0aWxpdHlcbiogQHJlcXVpcmVzIHB1bHNlUmFuZ2VcbiovXG52YXIgcHVsc2VSYW5nZSA9IHJlcXVpcmUoJ3B1bHNlUmFuZ2UnKTtcblxuLyoqIEdldCBpbnRlZ2VyIGZyb20gc3RyaW5nXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gc3RyaW5nMmludFxuICovXG5leHBvcnRzLnN0cmluZzJpbnQgPSBmdW5jdGlvbiBzdHJpbmcyaW50IChzdHIpIHtcbiAgcmV0dXJuIChzdHIgPT0gJ251bGwnIHx8IHN0ciA9PSBudWxsIHx8IHN0ciA9PSAnJykgPyAtMSA6IHBhcnNlSW50KHN0cik7XG59O1xuXG4vKiogR2V0IGNvbnRyYXRlZCBjb2xvciBmcm9tIHJnYiBPUiAjaGV4XG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gZ2V0Q29udHJhc3RDb2xvclxuICovXG5leHBvcnRzLmdldENvbnRyYXN0Q29sb3IgPSBmdW5jdGlvbiBnZXRDb250cmFzdENvbG9yIChoZXhjb2xvcikge1xuICBpZiAoaGV4Y29sb3IuaW5kZXhPZigncmdiJykgPj0gMCkgeyAvLyByZ2IgZm9ybWF0XG4gICAgbGV0IG51bXMgPSAvKC4qPylyZ2JcXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspXFwpL2kuZXhlYyhoZXhjb2xvcik7XG4gICAgbGV0IHIgPSBwYXJzZUludChudW1zWzJdLCAxMCkudG9TdHJpbmcoMTYpO1xuICAgIGxldCBnID0gcGFyc2VJbnQobnVtc1szXSwgMTApLnRvU3RyaW5nKDE2KTtcbiAgICBsZXQgYiA9IHBhcnNlSW50KG51bXNbNF0sIDEwKS50b1N0cmluZygxNik7XG5cbiAgICBsZXQgeWlxID0gKChyICogMjk5KSArIChnICogNTg3KSArIChiICogMTE0KSkgLyAxMDAwO1xuICAgIHJldHVybiAoeWlxID49IDEyOCkgPyAnIzEyMTIxMicgOiAnI2VkZWRlZCc7IC8vJ2JsYWNrJyA6ICd3aGl0ZSc7XG4gIH1cbiAgZWxzZSBpZiAoaGV4Y29sb3IuY2hhckF0KDApID09ICcjJykge1xuICAgIGxldCByID0gcGFyc2VJbnQoaGV4Y29sb3Iuc3Vic3RyKDEsIDIpLCAxNik7XG4gICAgbGV0IGcgPSBwYXJzZUludChoZXhjb2xvci5zdWJzdHIoMywgMiksIDE2KTtcbiAgICBsZXQgYiA9IHBhcnNlSW50KGhleGNvbG9yLnN1YnN0cig1LCAyKSwgMTYpO1xuXG4gICAgbGV0IHlpcSA9ICgociAqIDI5OSkgKyAoZyAqIDU4NykgKyAoYiAqIDExNCkpIC8gMTAwMDtcbiAgICByZXR1cm4gKHlpcSA+PSAxMjgpID8gJyMxMjEyMTInIDogJyNlZGVkZWQnOyAvLydibGFjaycgOiAnd2hpdGUnO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiAnIzdGN0Y3Ric7IC8vIEdyZXkuLi4gYmVzdCB0aGFuIG5vdGhpbmdcbiAgfVxufVxuXG4vKiogQ2hlY2sgd2hldGhlciBnaXZlbiBvYmplY3QgcmVwcmVzZW50cyBkZWNpbWFsIG9yIGZsb2F0IHZhbHVlLlxuICogUmVwbGFjZSBqcXVlcnkgb2Jzb2xldGUgbWV0aG9kLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gaXNOdW1lcmljXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzTnVtZXJpYyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAoKHBhcnNlRmxvYXQodmFsdWUpID09IHBhcnNlSW50KHZhbHVlKSkgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpID09PSB2YWx1ZSAmJiB2YWx1ZSAlIDEgIT09IDA7XG4gIH1cbn1cblxuLyoqIENoZWNrIHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IHJlcHJlc2VudHMgZGVjaW1hbCB2YWx1ZSBvciBub3RcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlVXRpbGl0eVxuICogQGZ1bmN0aW9uIGlzRmxvYXRcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlICBvYmplY3QgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNGbG9hdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gTnVtYmVyKHZhbHVlKSA9PT0gdmFsdWUgJiYgdmFsdWUgJSAxICE9PSAwO1xufVxuXG4vKiogQ2hlY2sgd2hldGhlciBnaXZlbiBvYmplY3QgcmVwcmVzZW50cyBpbnRlZ2VyIHZhbHVlIG9yIG5vdFxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gaXNJbnRlZ2VyXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNJbnRlZ2VyID0gZXhwb3J0cy5pc0ludGVnZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKChwYXJzZUZsb2F0KHZhbHVlKSA9PSBwYXJzZUludCh2YWx1ZSkpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqIENoZWNrIHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IHJlcHJlc2VudHMgYSBib29sZWFuIHZhbHVlIG9yIG5vdFxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gaXNCb29sZWFuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIGFuIG9iamVjdFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKCgodHlwZW9mIHZhbHVlKSA9PT0gJ2Jvb2xlYW4nKSB8fCAoKHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikgPT0gdHJ1ZSkgfHwgKHZhbHVlID09PSAndHJ1ZScpIHx8ICh2YWx1ZSA9PT0gJ2ZhbHNlJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuXG4vKiogQ2hlY2sgd2hldGhlciBnaXZlbiBvYmplY3QgcmVwcmVzZW50cyBmdW5jdGlvbiB2YWx1ZSBvciBub3RcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlVXRpbGl0eVxuICogQGZ1bmN0aW9uIGlzRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgYW4gb2JqZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSAmJiAodmFsdWUgIT09IG51bGwpICYmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IEZ1bmN0aW9uXScpO1xufVxuXG4vKipcbiAqIHJldHVybiBhIHN0cmluZyB3aXRoIGxlYWRpbmcgMCAtIGZvciBkYXRlIEZPUk1BVCBvbiAyIGRpZ2l0c1xuICoqL1xuZXhwb3J0cy5sZWFkaW5nWmVybyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodmFsdWUgPCAxMCkge1xuICAgIHJldHVybiAnMCcgKyB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIHJldHVybiBhbiBhcnJheSBvZiBzdHJpbmcgdXNlZCB0byBncmFkYXRlIHdpZGdldCB3aXRoIHRpbWUgbGFiZWxzXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqXG4gKiBAZnVuY3Rpb24gZ2V0VGltZU1hcmtlcnNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGF0ZXRpbWUgcmVwcmVzZW50cyBzZWNvbmRzIHNpbmNlIDEgSmFuIDE5NzAgaW4gVVRDIGZvcm1hdFxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCB0aW1lIGZvcm1hdCB1c2VkIHRvIGZvcm1hdCBsYWJlbCB0byBkaXNwbGF5XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZXhwb3J0cy5nZXRUaW1lTWFya2VycyA9IGZ1bmN0aW9uIChkYXRldGltZSwgZm9ybWF0KSB7XG4gIGxldCB1dGMgPSBtb21lbnQudXRjKGRhdGV0aW1lKTtcbiAgbGV0IG0wID0gdXRjLmxvY2FsKCk7XG4gIGxldCBtNCA9IG0wLmNsb25lKCkuYWRkKDEsICdkJyk7XG4gIGxldCBtMSA9IG0wLmNsb25lKCkuYWRkKDYsICdoJyk7XG4gIGxldCBtMiA9IG0wLmNsb25lKCkuYWRkKDEyLCAnaCcpO1xuICBsZXQgbTMgPSBtMC5jbG9uZSgpLmFkZCgxOCwgJ2gnKTtcbiAgbGV0IGFycmF5ID0gbmV3IEFycmF5KCk7XG4gIGFycmF5WzBdID0gbTAuZm9ybWF0KGZvcm1hdCk7XG4gIGFycmF5WzFdID0gbTEuZm9ybWF0KGZvcm1hdCk7XG4gIGFycmF5WzJdID0gbTIuZm9ybWF0KGZvcm1hdCk7XG4gIGFycmF5WzNdID0gbTMuZm9ybWF0KGZvcm1hdCk7XG4gIGFycmF5WzRdID0gbTQuZm9ybWF0KGZvcm1hdCk7XG4gIHJldHVybiBhcnJheTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgaW50ZWdlciB0aGF0IHJlcHJlc2VudHMgZGF0ZSB0byBhIG1vbWVudCBvYmplY3QgaW4gbG9jYWwgbW9kZS5cbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlVXRpbGl0eVxuICpcbiAqIEBmdW5jdGlvbiBnZXRNb21lbnRMb2NhbEZyb21VdGNEYXRlXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRhdGV0aW1lIEludGVnZXIgdGhhdCByZXByZXNlbnRzIGRhdGUgaW4gdXRjXG4gKiBAcmV0dXJuIHtNb21lbnR9XG4gKi9cbmV4cG9ydHMuZ2V0TW9tZW50TG9jYWxGcm9tVXRjRGF0ZSA9IGZ1bmN0aW9uIChkYXRldGltZSkge1xuICBsZXQgbW9tZW50X3V0YyA9IG1vbWVudChkYXRldGltZSkudXRjKCk7XG4gIGxldCBtID0gbW9tZW50X3V0Yy5jbG9uZSgpO1xuICByZXR1cm4gbS5sb2NhbCgpO1xufVxuXG4vKiogQ29udmVydCBhIGRhdGUgZm9yIHRoZSBSRVBPUlRcbiAqIFxuICogSXQganVzdCBjb252ZXJ0cyB0aGUgZGF0ZSB0byBhIExPQ0FMIHN0cmluZyBmb3IgY2FsbGluZyByZXBvcnRzXG4gKiAodXNlZCBpbiB0b29sbGlmZW1hY2hpbmUgYmFyKVxuICogXG4gKiBJZiBkYXRlIGlzIG5vdCBkZWZpbmVkIG9yIGlmIGl0IGlzIGFuIGVtcHR5IHN0cmluZywgYW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gY29udmVydERhdGVGb3JSZXBvcnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xEYXRlfSBkYXRlIC0gZGF0ZSB0byBzZW5kIHRvIHRoZSB3ZWIgc2VydmljZVxuICogQHJldHVybiB7c3RyaW5nfSBEYXRlIHN0cmluZyBmb3IgYW55IFJFUE9SVFxuICovXG4vL3ZhciBjb252ZXJ0RGF0ZUZvclJlcG9ydCA9XG5leHBvcnRzLmNvbnZlcnREYXRlRm9yUmVwb3J0ID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgaWYgKGlzTm90RGVmaW5lZChkYXRlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBsZXQgcGFkMiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICByZXR1cm4gKCcwJyArIG51bWJlcikuc2xpY2UoLTIpO1xuICB9XG4gIGxldCBwYWQzID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHJldHVybiAoJzAwJyArIG51bWJlcikuc2xpY2UoLTMpO1xuICB9XG5cbiAgbGV0IGQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgbGV0IGRhdGVTdHJpbmcgPVxuICAgIGQuZ2V0RnVsbFllYXIoKSArICctJyArXG4gICAgcGFkMihkLmdldE1vbnRoKCkpICsgJy0nICtcbiAgICBwYWQyKGQuZ2V0RGF0ZSgpKSArICcrJyArXG4gICAgcGFkMihkLmdldEhvdXJzKCkpICsgJyUzQScgK1xuICAgIHBhZDIoZC5nZXRNaW51dGVzKCkpICsgJyUzQScgK1xuICAgIHBhZDIoZC5nZXRTZWNvbmRzKCkpICsgJy4nICtcbiAgICBwYWQzKGQuZ2V0TWlsbGlzZWNvbmRzKCkpO1xuXG4gIHJldHVybiBkYXRlU3RyaW5nO1xufVxuXG4vKiogQ29udmVydCBhIGRhdGUgZm9yIHRoZSB3ZWIgc2VydmljZVxuICogXG4gKiBJdCBqdXN0IGNvbnZlcnRzIHRoZSBkYXRlIHRvIGFuIElTTyBzdHJpbmdcbiAqIFxuICogSWYgZGF0ZSBpcyBub3QgZGVmaW5lZCBvciBpZiBpdCBpcyBhbiBlbXB0eSBzdHJpbmcsIGFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZFxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlVXRpbGl0eVxuICogQGZ1bmN0aW9uIGNvbnZlcnREYXRlRm9yV2ViU2VydmljZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfERhdGV9IGRhdGUgLSBkYXRlIHRvIHNlbmQgdG8gdGhlIHdlYiBzZXJ2aWNlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERhdGUgc3RyaW5nIGZvciB0aGUgd2ViIHNlcnZpY2VcbiAqL1xudmFyIGNvbnZlcnREYXRlRm9yV2ViU2VydmljZSA9IGV4cG9ydHMuY29udmVydERhdGVGb3JXZWJTZXJ2aWNlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgaWYgKGlzTm90RGVmaW5lZChkYXRlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGxldCBkO1xuICBpZiAodHlwZW9mIGRhdGUgPT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZGF0ZS50cmltKCkgPT0gJycpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZCA9IG5ldyBEYXRlKGRhdGUpO1xuICB9XG4gIGVsc2Uge1xuICAgIGQgPSBkYXRlO1xuICB9XG4gIHJldHVybiBkLnRvSVNPU3RyaW5nKCk7XG59XG5cbi8qKiBDb252ZXJ0IGEgZGF5IGZvciB0aGUgd2ViIHNlcnZpY2VcbiAqIFxuICogSXQganVzdCBjb252ZXJ0cyB0aGUgZGF5IHRvIGFuIElTTyBzdHJpbmcgZGF5IChub3QgZGF0ZSAhIClcbiAqIFxuICogSWYgZGF5IGlzIG5vdCBkZWZpbmVkIG9yIGlmIGl0IGlzIGFuIGVtcHR5IHN0cmluZywgYW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gY29udmVydERhdGVGb3JXZWJTZXJ2aWNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8RGF0ZX0gZGF0ZSAtIGRhdGUgdG8gc2VuZCB0byB0aGUgd2ViIHNlcnZpY2Ugb3UgZGF5IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfSBEYXkgc3RyaW5nIGZvciB0aGUgd2ViIHNlcnZpY2UgPSBZWVlZLU1NLUREXG4gKi9cbi8vdmFyIGNvbnZlcnREYXlGb3JXZWJTZXJ2aWNlID0gXG5leHBvcnRzLmNvbnZlcnREYXlGb3JXZWJTZXJ2aWNlID0gZnVuY3Rpb24gKGRheSkge1xuICBpZiAoaXNOb3REZWZpbmVkKGRheSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBsZXQgZDtcbiAgaWYgKHR5cGVvZiBkYXkgPT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZGF5LnRyaW0oKSA9PSAnJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gZGF5O1xuICB9XG4gIGVsc2Uge1xuICAgIGQgPSBuZXcgRGF0ZShkYXkpO1xuICAgIHJldHVybiBkLnRvSVNPU3RyaW5nKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsYmFjayB0byBjb252ZXJ0IGFuIG9iamVjdCB0byBhIHN0cmluZ1xuICogXG4gKiBAY2FsbGJhY2sgdG9TdHJpbmdDYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IC0gT2JqZWN0IHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge3N0cmluZ30gUmVzdWx0XG4gKi9cblxuLyoqIENvbnZlcnQgYSByYW5nZSBmb3IgdGhlIHdlYiBzZXJ2aWNlXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gY29udmVydFJhbmdlRm9yV2ViU2VydmljZVxuICpcbiAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlIC0gUmFuZ2UgdG8gY29udmVydFxuICogQHBhcmFtIHt0b1N0cmluZ0NhbGxiYWNrfSBib3VuZFRvU3RyaW5nIC0gQ2FsbGJhY2sgdG8gY29udmVydCBhIGJvdW5kIHRvIGEgc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyBmb3IgdGhlIHdlYiBzZXJ2aWNlXG4gKi9cbnZhciBfY29udmVydFJhbmdlRm9yV2ViU2VydmljZSAvLz0gZXhwb3J0cy5jb252ZXJ0UmFuZ2VGb3JXZWJTZXJ2aWNlIFxuICA9IGZ1bmN0aW9uIChyYW5nZSwgYm91bmRUb1N0cmluZykge1xuICAgIHJldHVybiByYW5nZS50b1N0cmluZyhib3VuZFRvU3RyaW5nKTtcbiAgfVxuXG4vKiogQ29udmVydCBhIHJhbmdlIGZvciB0aGUgd2ViIHNlcnZpY2VcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqIEBmdW5jdGlvbiBjb252ZXJ0U3RyaW5nUmFuZ2VGb3JXZWJTZXJ2aWNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmdSYW5nZX0gc3RyaW5ncmFuZ2UgLSBSYW5nZSBvZiBzdHJpbmdzIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIGZvciB0aGUgd2ViIHNlcnZpY2VcbiAqL1xuZXhwb3J0cy5jb252ZXJ0U3RyaW5nUmFuZ2VGb3JXZWJTZXJ2aWNlID0gZnVuY3Rpb24gKHN0cmluZ3JhbmdlKSB7XG4gIHJldHVybiBfY29udmVydFJhbmdlRm9yV2ViU2VydmljZShzdHJpbmdyYW5nZSwgYSA9PiBhKTtcbn1cblxuLyoqIENvbnZlcnQgYSBkYXRlIHJhbmdlIGZvciB0aGUgd2ViIHNlcnZpY2VcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqIEBmdW5jdGlvbiBjb252ZXJ0RGF0ZVJhbmdlRm9yV2ViU2VydmljZVxuICpcbiAqIEBwYXJhbSB7RGF0ZVJhbmdlfSBkYXRlcmFuZ2UgLSBEYXRlIHJhbmdlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIGZvciB0aGUgd2ViIHNlcnZpY2VcbiAqL1xudmFyIGNvbnZlcnREYXRlUmFuZ2VGb3JXZWJTZXJ2aWNlID0gZXhwb3J0cy5jb252ZXJ0RGF0ZVJhbmdlRm9yV2ViU2VydmljZSA9IGZ1bmN0aW9uIChkYXRlcmFuZ2UpIHtcbiAgcmV0dXJuIF9jb252ZXJ0UmFuZ2VGb3JXZWJTZXJ2aWNlKGRhdGVyYW5nZSwgYSA9PiBjb252ZXJ0RGF0ZUZvcldlYlNlcnZpY2UoYSkpO1xufVxuXG4vKipcbiAqIENyZWF0ZSByYW5nZSBmb3Igd2Vic2VydmljZSBjb250YWluaW5nIG9ubHkgMSBzaW5nbGUgZGF0ZVxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gY3JlYXRlU2luZ2xlUmFuZ2VGb3JXZWJTZXJ2aWNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8RGF0ZX0gZGF0ZXRpbWUgU3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgZGF0ZXRpbWUgaW4gSVNPIDg2MDEgZm9ybWF0IG9yIERhdGVcbiAqIEByZXR1cm4ge3N0cmluZ30gcmFuZ2UgU3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgcmFuZ2UgaW4gSVNPIDg2MDEgZm9ybWF0OiBbMjAxNi0wNS0wMVQwMDowMzowMCwyMDE2LTA1LTAxVDAwOjAzOjAwXVxuICovXG5leHBvcnRzLmNyZWF0ZVNpbmdsZVJhbmdlRm9yV2ViU2VydmljZSA9IGZ1bmN0aW9uIChkYXRldGltZSkge1xuICBsZXQgciA9IHB1bHNlUmFuZ2UuY3JlYXRlRGF0ZVJhbmdlKGRhdGV0aW1lLCBkYXRldGltZSwgJ1tdJyk7XG4gIHJldHVybiBjb252ZXJ0RGF0ZVJhbmdlRm9yV2ViU2VydmljZShyKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcmFuZ2UgZm9yIHdlYnNlcnZpY2VcbiAqIFxuICogVGhlIGRlZmF1bHQgaW5jbHVzaXZpdHkgZm9yIGEgRGF0ZVJhbmdlIGlzOlxuICogWykgaWYgYmVnaW4gYW5kIGVuZCBhcmUgbm90IHRoZSBzYW1lXG4gKiBlbHNlIFtdXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqXG4gKiBAZnVuY3Rpb24gY3JlYXRlRGF0ZVJhbmdlRm9yV2ViU2VydmljZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfERhdGV9IGJlZ2luIC0gRGF0ZSBvciBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSByYW5nZSBpbiBJU08gODYwMSBmb3JtYXQuXG4gKiBAcGFyYW0ge3N0cmluZ3xEYXRlfSBlbmQgLSBEYXRlIG9yIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIHJhbmdlIGluIElTTyA4NjAxIGZvcm1hdC5cbiAqIEByZXR1cm4ge3N0cmluZ30gcmFuZ2UgU3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgcmFuZ2UgaW4gSVNPIDg2MDEgZm9ybWF0OiBbMjAxNi0wNS0wMVQwMDowMzowMCwpXG4gKi9cbmV4cG9ydHMuY3JlYXRlRGF0ZVJhbmdlRm9yV2ViU2VydmljZSA9IGZ1bmN0aW9uIChiZWdpbiwgZW5kKSB7XG4gIGxldCByID0gcHVsc2VSYW5nZS5jcmVhdGVEYXRlUmFuZ2VEZWZhdWx0SW5jbHVzaXZpdHkoYmVnaW4sIGVuZCk7XG4gIHJldHVybiBjb252ZXJ0RGF0ZVJhbmdlRm9yV2ViU2VydmljZShyKTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5IGEgZGF5XG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqXG4gKiBAZnVuY3Rpb24gZ2V0RGlzcGxheURheVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiZWdpbiBTdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBiZWdpbiBkYXkgaW4gSVNPIDg2MDEgZm9ybWF0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGRheVxuICovXG5leHBvcnRzLmdldERpc3BsYXlEYXkgPSBmdW5jdGlvbiAoZGF5KSB7XG4gIGlmICgoIWRheSkgfHwgKGRheSA9PSAnbnVsbCcpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmIChkYXkubGVuZ3RoID4gMTApIHsgLy8gVE1QIGNvZGUgdG8gbWFrZSBnZXRSYW5nZUFyb3VuZCA8IDIwMTYtMDMtMDcgd29yayAgICBcbiAgICBsZXQgX2RheSA9IGNvbnZlcnREYXRlVG9Nb21lbnQoZGF5KTsgLy8gZGF5ICsgbWlkbmlnaHRcbiAgICBfZGF5ID0gX2RheS5hZGQoMTIsICdob3VycycpOyAvLyBUbyBiZSBzdXJlIHRvIGRpc3BsYXkgdGhlIHJpZ2h0IGRheVxuICAgIHJldHVybiBfZGF5LmZvcm1hdCgnbGwnKTtcbiAgfVxuICBlbHNlIHtcbiAgICBsZXQgX2RheSA9IG1vbWVudChkYXksICdZWVlZLU1NLUREJyk7XG4gICAgcmV0dXJuIF9kYXkuZm9ybWF0KCdsbCcpO1xuICB9XG59XG5cbi8qKiBEaXNwbGF5IGEgc2luZ2xlIGRhdGVcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqXG4gKiBAZnVuY3Rpb24gZGlzcGxheURhdGVcbiAqXG4gKiBAcGFyYW0ge2RhdGV9IGRhdGUgLSBkYXRlLCB3aXRoIGJvdW5kcyBvZiB0eXBlIG5hdGl2ZSBqYXZhc2NyaXB0IERhdGUgb3IgSVNPIDg2MDEgZm9ybWF0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlY29uZHMgLSB0cnVlID09IHNob3cgc2Vjb25kc1xuICogQHJldHVybiB7c3RyaW5nfSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBkYXRlXG4gKi9cbnZhciBkaXNwbGF5RGF0ZSA9IGV4cG9ydHMuZGlzcGxheURhdGUgPSBmdW5jdGlvbiAoZGF0ZSwgc2Vjb25kcykge1xuICBsZXQgbSA9IGNvbnZlcnREYXRlVG9Nb21lbnQoZGF0ZSk7XG4gIGlmIChzZWNvbmRzKSB7XG4gICAgcmV0dXJuIChtLmZvcm1hdCgnbGwnKSAvLyBNb250aCBuYW1lLCBkYXkgb2YgbW9udGgsIHllYXIsIHRpbWVcbiAgICAgICsgJywgJyArIG0uZm9ybWF0KCdMVFMnKSk7ICAvLyBISDpNTTpTZWNcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gbS5mb3JtYXQoJ2xsbCcpOyAvLyBNb250aCBuYW1lLCBkYXkgb2YgbW9udGgsIHllYXIsIHRpbWVcbiAgfVxufVxuXG4vKiogRGlzcGxheSBhIGRhdGUgcmFuZ2VcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqXG4gKiBAZnVuY3Rpb24gZGlzcGxheURhdGVSYW5nZVxuICpcbiAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlIC0gZGF0ZSByYW5nZSwgd2l0aCBib3VuZHMgb2YgdHlwZSBuYXRpdmUgamF2YXNjcmlwdCBEYXRlIG9yIElTTyA4NjAxIGZvcm1hdFxuICogQHBhcmFtIHtib29sZWFufSBzZWNvbmRzIC0gdHJ1ZSA9PSBzaG93IHNlY29uZHNcbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgZGF0ZSByYW5nZVxuICovXG4vL3ZhciBkaXNwbGF5RGF0ZVJhbmdlID0gXG5leHBvcnRzLmRpc3BsYXlEYXRlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UsIHNlY29uZHMpIHtcbiAgbGV0IHIgPSBwdWxzZVJhbmdlLmNvbnZlcnRUb0RhdGVSYW5nZShyYW5nZSk7XG4gIGlmIChyLmlzRW1wdHkoKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBlbHNlIHsgLy8gbm90IGVtcHR5XG4gICAgaWYgKHIubG93ZXIgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKCdkaXNwbGF5RGF0ZVJhbmdlOiBsb3dlciBpcyBub3QgZGVmaW5lZCcpO1xuICAgICAgaWYgKHIudXBwZXIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJy1vbyAtICtvbyc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICctb28gLSAnICsgZGlzcGxheURhdGUoci51cHBlciwgc2Vjb25kcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgeyAvLyByYW5nZS5sb3dlciBub3QgbnVsbFxuICAgICAgaWYgKHIudXBwZXIgPT0gbnVsbCkge1xuICAgICAgICBsZXQgcmV0VmFsID0gZGlzcGxheURhdGUoci5sb3dlciwgc2Vjb25kcylcbiAgICAgICAgICArICcgLSAnXG4gICAgICAgICAgKyAnSW4gcHJvZ3Jlc3MnOyAvLyBUT0RPOiBpMThuXG4gICAgICAgIHJldHVybiByZXRWYWw7XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gbG93ZXIgYW5kIHVwcGVyIGFyZSBkZWZpbmVkXG4gICAgICAgIGlmIChyLmxvd2VyLmdldFRpbWUoKSA9PSByLnVwcGVyLmdldFRpbWUoKSkge1xuICAgICAgICAgIHJldHVybiBkaXNwbGF5RGF0ZShyLmxvd2VyLCBzZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsZXQgYmVnaW5fbG9jYWwgPSBjb252ZXJ0RGF0ZVRvTW9tZW50KHIubG93ZXIpO1xuICAgICAgICAgIGxldCBlbmRfbG9jYWwgPSBjb252ZXJ0RGF0ZVRvTW9tZW50KHIudXBwZXIpO1xuICAgICAgICAgIGlmIChiZWdpbl9sb2NhbC5pc1NhbWUoZW5kX2xvY2FsLCAnZGF5JykpIHtcbiAgICAgICAgICAgIGxldCByZXRWYWwgPSBiZWdpbl9sb2NhbC5mb3JtYXQoJ2xsJylcbiAgICAgICAgICAgICAgKyAnICAgJ1xuICAgICAgICAgICAgICArIChzZWNvbmRzID8gYmVnaW5fbG9jYWwuZm9ybWF0KCdMVFMnKSA6IGJlZ2luX2xvY2FsLmZvcm1hdCgnTFQnKSlcbiAgICAgICAgICAgICAgKyAnIC0gJ1xuICAgICAgICAgICAgICArIChzZWNvbmRzID8gZW5kX2xvY2FsLmZvcm1hdCgnTFRTJykgOiBlbmRfbG9jYWwuZm9ybWF0KCdMVCcpKTtcbiAgICAgICAgICAgIHJldHVybiByZXRWYWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJldFZhbCA9IGRpc3BsYXlEYXRlKHIubG93ZXIsIHNlY29uZHMpXG4gICAgICAgICAgICAgICsgJyAtICdcbiAgICAgICAgICAgICAgKyBkaXNwbGF5RGF0ZShyLnVwcGVyLCBzZWNvbmRzKTtcbiAgICAgICAgICAgIHJldHVybiByZXRWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKiBBcHBlbmQgYSBkYXRlIHJhbmdlIGRpc3BsYXkgd2l0aCBzZXBhcmF0ZWQgYmVnaW4gYW5kIGVuZFxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlVXRpbGl0eVxuICpcbiAqIEBmdW5jdGlvbiAgYXBwZW5kRGF0ZVJhbmdlRGlzcGxheVxuICogb3V0cHV0IGNsYXNzZXMgOiByYW5nZS1iZWdpbiAvIHJhbmdlLWVuZCAvIHJhbmdlLWJlZ2luLWVuZCAvIHJhbmdlLWJlZ2luLWVuZC1kYXRlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBwYXJlbnQgLSB3aGVyZSBzcGFuIHdpbGwgYmUgYWRkZWRcbiAqIEBwYXJhbSB7UmFuZ2V9IHJhbmdlIC0gZGF0ZSByYW5nZSwgd2l0aCBib3VuZHMgb2YgdHlwZSBuYXRpdmUgamF2YXNjcmlwdCBEYXRlIG9yIElTTyA4NjAxIGZvcm1hdFxuICogQHBhcmFtIHtib29sZWFufSBzZWNvbmRzIC0gdHJ1ZSA9PSBzaG93IHNlY29uZHNcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaW4gY2FzZSBvZiBzdWNjZXNzXG4gKi9cbi8vdmFyIGFwcGVuZERhdGVSYW5nZURpc3BsYXkgPSBcbmV4cG9ydHMuYXBwZW5kRGF0ZVJhbmdlRGlzcGxheSA9IGZ1bmN0aW9uIChwYXJlbnQsIHJhbmdlLCBzZWNvbmRzKSB7XG5cbiAgbGV0IGFwcGVuZFJhbmdlID0gZnVuY3Rpb24gKHBhcmVudCwgYmVnaW5TdHJpbmcsIGVuZFN0cmluZykge1xuICAgIGxldCBzcGFuQmVnaW4gPSAkKCc8c3Bhbj48L3NwYW4+JykuYWRkQ2xhc3MoJ3JhbmdlLWJlZ2luJykuaHRtbChiZWdpblN0cmluZyk7XG4gICAgbGV0IHNwYW5TZXAgPSAkKCc8c3Bhbj48L3NwYW4+JykuYWRkQ2xhc3MoJ3JhbmdlLXNlcGFyYXRvcicpLmh0bWwoJyAtICcpO1xuICAgIGxldCBzcGFuRW5kID0gJCgnPHNwYW4+PC9zcGFuPicpLmFkZENsYXNzKCdyYW5nZS1lbmQnKS5odG1sKGVuZFN0cmluZyk7XG4gICAgJChwYXJlbnQpLmFwcGVuZChzcGFuQmVnaW4pLmFwcGVuZChzcGFuU2VwKS5hcHBlbmQoc3BhbkVuZCk7XG4gIH1cblxuICBsZXQgciA9IHB1bHNlUmFuZ2UuY29udmVydFRvRGF0ZVJhbmdlKHJhbmdlKTtcbiAgaWYgKHIuaXNFbXB0eSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGVsc2UgeyAvLyBub3QgZW1wdHlcbiAgICBpZiAoci5sb3dlciA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2Rpc3BsYXlEYXRlUmFuZ2U6IGxvd2VyIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICBpZiAoci51cHBlciA9PSBudWxsKSB7XG4gICAgICAgIGFwcGVuZFJhbmdlKHBhcmVudCwgJy1vbycsICcrb28nKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYXBwZW5kUmFuZ2UocGFyZW50LCAnLW9vJywgZGlzcGxheURhdGUoci51cHBlciwgc2Vjb25kcykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7IC8vIHJhbmdlLmxvd2VyIG5vdCBudWxsXG4gICAgICBpZiAoci51cHBlciA9PSBudWxsKSB7XG4gICAgICAgIGFwcGVuZFJhbmdlKHBhcmVudCwgZGlzcGxheURhdGUoci5sb3dlciwgc2Vjb25kcyksICdJbiBwcm9ncmVzcycpOyAvLyBUT0RPOiBpMThuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgZWxzZSB7IC8vIGxvd2VyIGFuZCB1cHBlciBhcmUgZGVmaW5lZFxuICAgICAgICBpZiAoci5sb3dlci5nZXRUaW1lKCkgPT0gci51cHBlci5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAvLyBzZWUgYXBwZW5kUmFuZ2UgLSBidXQgdW5pcXVlICFcbiAgICAgICAgICBsZXQgc3BhblJhbmdlID0gJCgnPHNwYW4+PC9zcGFuPicpLmFkZENsYXNzKCdyYW5nZS1iZWdpbi1lbmQnKVxuICAgICAgICAgICAgLmh0bWwoZGlzcGxheURhdGUoci5sb3dlciwgc2Vjb25kcykpO1xuICAgICAgICAgICQocGFyZW50KS5hcHBlbmQoc3BhblJhbmdlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsZXQgYmVnaW5fbG9jYWwgPSBjb252ZXJ0RGF0ZVRvTW9tZW50KHIubG93ZXIpO1xuICAgICAgICAgIGxldCBlbmRfbG9jYWwgPSBjb252ZXJ0RGF0ZVRvTW9tZW50KHIudXBwZXIpO1xuICAgICAgICAgIGlmIChiZWdpbl9sb2NhbC5pc1NhbWUoZW5kX2xvY2FsLCAnZGF5JykpIHtcbiAgICAgICAgICAgIC8vIHNlZSBhcHBlbmRSYW5nZSAtIGJ1dCB1bmlxdWUgZGF0ZSAtIDIgdGltZXNcbiAgICAgICAgICAgIGxldCBzcGFuRGF0ZSA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5hZGRDbGFzcygncmFuZ2UtYmVnaW4tZW5kLWRhdGUnKVxuICAgICAgICAgICAgICAuaHRtbChiZWdpbl9sb2NhbC5mb3JtYXQoJ2xsJykpO1xuICAgICAgICAgICAgbGV0IHNwYW5TZXBEVCA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5hZGRDbGFzcygncmFuZ2Utc2VwYXJhdG9yLWRhdGUtdGltZScpLmh0bWwoJyAnKTtcbiAgICAgICAgICAgIGxldCBzcGFuQmVnaW4gPSAkKCc8c3Bhbj48L3NwYW4+JykuYWRkQ2xhc3MoJ3JhbmdlLWJlZ2luJylcbiAgICAgICAgICAgICAgLmh0bWwoKHNlY29uZHMgPyBiZWdpbl9sb2NhbC5mb3JtYXQoJ0xUUycpIDogYmVnaW5fbG9jYWwuZm9ybWF0KCdMVCcpKSk7XG4gICAgICAgICAgICBsZXQgc3BhblNlcCA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5hZGRDbGFzcygncmFuZ2Utc2VwYXJhdG9yJykuaHRtbCgnIC0gJyk7XG4gICAgICAgICAgICBsZXQgc3BhbkVuZCA9ICQoJzxzcGFuPjwvc3Bhbj4nKS5hZGRDbGFzcygncmFuZ2UtZW5kJylcbiAgICAgICAgICAgICAgLmh0bWwoKHNlY29uZHMgPyBlbmRfbG9jYWwuZm9ybWF0KCdMVFMnKSA6IGVuZF9sb2NhbC5mb3JtYXQoJ0xUJykpKTtcbiAgICAgICAgICAgICQocGFyZW50KS5hcHBlbmQoc3BhbkRhdGUpLmFwcGVuZChzcGFuU2VwRFQpXG4gICAgICAgICAgICAgIC5hcHBlbmQoc3BhbkJlZ2luKS5hcHBlbmQoc3BhblNlcCkuYXBwZW5kKHNwYW5FbmQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXBwZW5kUmFuZ2UocGFyZW50LCBkaXNwbGF5RGF0ZShyLmxvd2VyLCBzZWNvbmRzKSwgZGlzcGxheURhdGUoci51cHBlciwgc2Vjb25kcykpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBhIG51bWJlciBvZiBzZWNvbmRzIHRvIGEgc3RyaW5nXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqXG4gKiBAZnVuY3Rpb24gdG9ISE1NU1NcbiAqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG5iU2Vjb25kcyBudW1iZXIgb2Ygc2Vjb25kcyAoZHVyYXRpb24pXG4gKiBAcmV0dXJuIHN0cmluZyB2YWx1ZVxuICovXG5cbmV4cG9ydHMuc2Vjb25kc1RvSEhNTVNTID0gZnVuY3Rpb24gKG5iU2Vjb25kcykge1xuICBsZXQgc2VjX251bSA9IHBhcnNlSW50KG5iU2Vjb25kcywgMTApOyAvLyBkb24ndCBmb3JnZXQgdGhlIHNlY29uZCBwYXJhbVxuICBsZXQgaG91cnMgPSBNYXRoLmZsb29yKHNlY19udW0gLyAzNjAwKTtcbiAgbGV0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKChzZWNfbnVtIC0gKGhvdXJzICogMzYwMCkpIC8gNjApO1xuICBsZXQgc2Vjb25kcyA9IHNlY19udW0gLSAoaG91cnMgKiAzNjAwKSAtIChtaW51dGVzICogNjApO1xuXG4gIGlmIChob3VycyA+PSAyNCkgeyBob3VycyA9IGhvdXJzICUgMjQ7IH1cblxuICBpZiAoaG91cnMgPCAxMCkgeyBob3VycyA9ICcwJyArIGhvdXJzOyB9XG4gIGlmIChtaW51dGVzIDwgMTApIHsgbWludXRlcyA9ICcwJyArIG1pbnV0ZXM7IH1cbiAgaWYgKHNlY29uZHMgPCAxMCkgeyBzZWNvbmRzID0gJzAnICsgc2Vjb25kczsgfVxuICByZXR1cm4gaG91cnMgKyAnOicgKyBtaW51dGVzICsgJzonICsgc2Vjb25kcztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgZHVyYXRpb24gc3RyaW5nIHRvIGEgbnVtYmVyIG9mIHNlY29uZHNcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlVXRpbGl0eVxuICpcbiAqIEBmdW5jdGlvbiBISE1NU1N0b1NlY29uZHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gSEhITU1TUyBcbiAqIEByZXR1cm4ge2ludGVnZXJ9IG51bWJlciBvZiBzZWNvbmRzIChkdXJhdGlvbilcbiAqL1xuXG5leHBvcnRzLkhITU1TU3RvU2Vjb25kcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgbGV0IHJldFZhbCA9IDA7XG4gIGxldCBtdWx0aXBsaWVyID0gMTtcblxuICBsZXQgc3BsaXRlZFN0ciA9IHN0ci5zcGxpdCgnOicpO1xuICBmb3IgKGxldCBpID0gc3BsaXRlZFN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHJldFZhbCArPSBtdWx0aXBsaWVyICogcGFyc2VJbnQoc3BsaXRlZFN0cltpXSwgMTApO1xuICAgIG11bHRpcGxpZXIgKj0gNjA7XG4gIH1cbiAgcmV0dXJuIHJldFZhbDtcbn1cblxuLyoqXG4gKiBzZWFyY2ggYSBwYXJhbWV0ZXIgaW4gYW4gdXJsIGFuZCByZXR1cm4gaXRzIHZhbHVlXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqXG4gKiBAZnVuY3Rpb24gZ2V0VVJMUGFyYW1ldGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhZ2VVUkwgdXJsIGFkZHJlc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbSBwYXJhbWV0ZXIgbmFtZSB3aG9zZSBuYW1lIG11c3QgYmUgc2VhcmNoIGluIHVybFxuICogQHJldHVybiBwYXJhbWV0ZXIgdmFsdWUgb3IgbnVsbCBpZiBnaXZlbiB1cmwgZG8gbm90IGNvbnRhaW4gdGhpcyBwYXJhbWV0ZXIgbmFtZVxuICovXG4vL3ZhciBnZXRVUkxQYXJhbWV0ZXIgPSBcbmV4cG9ydHMuZ2V0VVJMUGFyYW1ldGVyID0gZnVuY3Rpb24gKHBhZ2VVUkwsIHBhcmFtKSB7XG4gIGxldCBzUXVlcnkgPSBwYWdlVVJMLnNwbGl0KCc/JylbMV07XG4gIGlmIChzUXVlcnkpIHtcbiAgICBsZXQgc1VSTFZhcmlhYmxlcyA9IHNRdWVyeS5zcGxpdCgnJicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc1VSTFZhcmlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHNQYXJhbWV0ZXJOYW1lID0gc1VSTFZhcmlhYmxlc1tpXS5zcGxpdCgnPScpO1xuICAgICAgaWYgKHNQYXJhbWV0ZXJOYW1lWzBdID09IHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBzUGFyYW1ldGVyTmFtZVsxXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogY2hhbmdlIG9yIGFkZCBhIHBhcmFtZXRlciBpbiBhbiB1cmwgYW5kIHJldHVybiBuZXcgdXJsXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqXG4gKiBAZnVuY3Rpb24gY2hhbmdlVVJMUGFyYW1ldGVyXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhZ2VVUkwgdXJsIGFkZHJlc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbSBwYXJhbWV0ZXIgbmFtZSB3aG9zZSBuYW1lIG11c3QgYmUgc2VhcmNoIGluIHVybFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIE5FVyBwYXJhbWV0ZXIgdmFsdWUgdG8gYWRkIGluIHVybFxuICogQHJldHVybiBuZXcgVVJMXG4gKi9cbmV4cG9ydHMuY2hhbmdlVVJMUGFyYW1ldGVyID0gZnVuY3Rpb24gKHBhZ2VVUkwsIHBhcmFtLCB2YWx1ZSkge1xuICBsZXQgc1F1ZXJ5ID0gcGFnZVVSTC5zcGxpdCgnPycpO1xuICBpZiAoKHNRdWVyeS5sZW5ndGggPiAxKSAmJiAoc1F1ZXJ5WzFdKSkge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIGxldCBzVVJMVmFyaWFibGVzID0gc1F1ZXJ5WzFdLnNwbGl0KCcmJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzVVJMVmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgc1BhcmFtZXRlck5hbWUgPSBzVVJMVmFyaWFibGVzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICBpZiAoc1BhcmFtZXRlck5hbWVbMF0gPT0gcGFyYW0pIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBzUGFyYW1ldGVyTmFtZVsxXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgc1VSTFZhcmlhYmxlc1tpXSA9IHNQYXJhbWV0ZXJOYW1lLmpvaW4oJz0nKTtcbiAgICB9XG4gICAgaWYgKCFmb3VuZCkge1xuICAgICAgc1VSTFZhcmlhYmxlc1tzVVJMVmFyaWFibGVzLmxlbmd0aF0gPSBwYXJhbSArICc9JyArIHZhbHVlO1xuICAgIH1cbiAgICBzUXVlcnlbMV0gPSBzVVJMVmFyaWFibGVzLmpvaW4oJyYnKTtcbiAgfVxuICBlbHNlIHtcbiAgICBzUXVlcnlbMV0gPSBwYXJhbSArICc9JyArIHZhbHVlO1xuICB9XG4gIHBhZ2VVUkwgPSBzUXVlcnkuam9pbignPycpO1xuICByZXR1cm4gcGFnZVVSTDtcbn1cblxuLyoqXG4gKiBzZWFyY2ggYSBwYXJhbWV0ZXIgaW4gYW4gdXJsIGFuZCByZXR1cm4gaXRzIHZhbHVlc1xuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKlxuICogQGZ1bmN0aW9uIGdldFVSTFBhcmFtZXRlclZhbHVlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYWdlVVJMIHVybCBhZGRyZXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0gcGFyYW1ldGVyIG5hbWUgd2hvc2UgbmFtZSBtdXN0IGJlIHNlYXJjaCBpbiB1cmxcbiAqIEByZXR1cm4gYW4gYXJyYXkgd2l0aCB2YWx1ZXMgb2YgZ2l2ZW4gcGFyYW1ldGVycy4gaWYgZ2l2ZW4gdXJsIGRvIG5vdCBjb250YWluIHRoaXMgcGFyYW1ldGVyIG5hbWUsIGl0IHJldHVybnMgYW4gZW1wdHkgYXJyYXkgXG4gKi9cbnZhciBnZXRVUkxQYXJhbWV0ZXJWYWx1ZXMgPSBleHBvcnRzLmdldFVSTFBhcmFtZXRlclZhbHVlcyA9IGZ1bmN0aW9uIChwYWdlVVJMLCBwYXJhbSkge1xuICBsZXQgc3BsaXR0ZWRTdHJpbmcgPSBwYWdlVVJMLnNwbGl0KCc/Jyk7XG4gIGxldCB2YWx1ZXMgPSBuZXcgQXJyYXkoKTtcbiAgaWYgKHNwbGl0dGVkU3RyaW5nLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIHZhbHVlczsgLy8gSWYgbm8gJz8nIGV4aXN0XG4gIH1cbiAgbGV0IHNRdWVyeSA9IHNwbGl0dGVkU3RyaW5nWzFdO1xuICBpZiAoc1F1ZXJ5KSB7XG4gICAgbGV0IHNVUkxWYXJpYWJsZXMgPSBzUXVlcnkuc3BsaXQoJyYnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNVUkxWYXJpYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzUGFyYW1ldGVyTmFtZSA9IHNVUkxWYXJpYWJsZXNbaV0uc3BsaXQoJz0nKTtcbiAgICAgIGlmIChzUGFyYW1ldGVyTmFtZVswXSA9PSBwYXJhbSkge1xuICAgICAgICB2YWx1ZXNbdmFsdWVzLmxlbmd0aF0gPSBzUGFyYW1ldGVyTmFtZVsxXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IGRpc3RpbmN0VmFsdWVzID0gbmV3IEFycmF5KCk7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgaWYgKGRpc3RpbmN0VmFsdWVzLmluZGV4T2YodmFsdWVzW2pdKSA8IDApIHtcbiAgICAgIGRpc3RpbmN0VmFsdWVzW2Rpc3RpbmN0VmFsdWVzLmxlbmd0aF0gPSB2YWx1ZXNbal07XG4gICAgfVxuICB9XG4gIHJldHVybiBkaXN0aW5jdFZhbHVlcztcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBwYXJhbWV0ZXIgaW4gYW4gdXJsIGFuZCByZXR1cm4gbmV3IHVybFxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKlxuICogQGZ1bmN0aW9uIHJlbW92ZVVSTFBhcmFtZXRlclxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYWdlVVJMIHVybCBhZGRyZXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW0gcGFyYW1ldGVyIG5hbWUgd2hvc2UgbmFtZSBtdXN0IGJlIHNlYXJjaCBhbmQgcmVtb3ZlZCBpbiB1cmxcbiAqIEByZXR1cm4ge3N0cmluZ30gYW4gdXJsXG4gKi9cbi8vdmFyIHJlbW92ZVVSTFBhcmFtZXRlciA9IFxuZXhwb3J0cy5yZW1vdmVVUkxQYXJhbWV0ZXIgPSBmdW5jdGlvbiAocGFnZVVSTCwgcGFyYW0pIHtcbiAgbGV0IHNwbGl0dGVkU3RyaW5nID0gcGFnZVVSTC5zcGxpdCgnPycpO1xuICBpZiAoc3BsaXR0ZWRTdHJpbmcubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgbGV0IG5ld1VSTCA9IHNwbGl0dGVkU3RyaW5nWzBdO1xuICBpZiAoc3BsaXR0ZWRTdHJpbmcubGVuZ3RoID4gMSkge1xuICAgIGxldCBzUXVlcnkgPSBzcGxpdHRlZFN0cmluZ1sxXTtcbiAgICBpZiAoc1F1ZXJ5KSB7XG4gICAgICBsZXQgc1VSTFZhcmlhYmxlcyA9IHNRdWVyeS5zcGxpdCgnJicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzVVJMVmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzVVJMVmFyaWFibGVzW2ldLmxlbmd0aCA+IDApIHsgLy8gVG8gYXZvaWQgJz8mJyBpZiBhbnlcbiAgICAgICAgICBsZXQgc1BhcmFtZXRlck5hbWUgPSBzVVJMVmFyaWFibGVzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgaWYgKHNQYXJhbWV0ZXJOYW1lWzBdICE9IHBhcmFtKSB7XG4gICAgICAgICAgICBpZiAobmV3VVJMLmluY2x1ZGVzKCc/JykpXG4gICAgICAgICAgICAgIG5ld1VSTCArPSAnJic7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG5ld1VSTCArPSAnPydcbiAgICAgICAgICAgIG5ld1VSTCArPSBzVVJMVmFyaWFibGVzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3VVJMO1xufVxuXG5cbi8qKlxuICogUmVtb3ZlIGEgcGFyYW1ldGVyIGluIGFuIHVybCBhbmQgcmV0dXJuIG5ldyB1cmxcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlVXRpbGl0eVxuICpcbiAqIEBmdW5jdGlvbiByZW1vdmVVUkxQYXJhbWV0ZXJDb250YWluaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhZ2VVUkwgdXJsIGFkZHJlc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbSBwYXJhbWV0ZXIgd2hvc2UgbmFtZSBtdXN0IGJlIHNlYXJjaCBhbmQgcmVtb3ZlZCBpbiB1cmwgKCpwYXJhbSopXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGFuIHVybFxuICovXG4vL3ZhciByZW1vdmVVUkxQYXJhbWV0ZXJDb250YWluaW5nID0gXG5leHBvcnRzLnJlbW92ZVVSTFBhcmFtZXRlckNvbnRhaW5pbmcgPSBmdW5jdGlvbiAocGFnZVVSTCwgcGFyYW0pIHtcbiAgbGV0IHNwbGl0dGVkU3RyaW5nID0gcGFnZVVSTC5zcGxpdCgnPycpO1xuICBpZiAoc3BsaXR0ZWRTdHJpbmcubGVuZ3RoID09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgbGV0IG5ld1VSTCA9IHNwbGl0dGVkU3RyaW5nWzBdO1xuICBpZiAoc3BsaXR0ZWRTdHJpbmcubGVuZ3RoID4gMSkge1xuICAgIGxldCBzUXVlcnkgPSBzcGxpdHRlZFN0cmluZ1sxXTtcbiAgICBpZiAoc1F1ZXJ5KSB7XG4gICAgICBsZXQgc1VSTFZhcmlhYmxlcyA9IHNRdWVyeS5zcGxpdCgnJicpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzVVJMVmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzUGFyYW1ldGVyTmFtZSA9IHNVUkxWYXJpYWJsZXNbaV0uc3BsaXQoJz0nKTtcbiAgICAgICAgaWYgKCFzUGFyYW1ldGVyTmFtZVswXS5pbmNsdWRlcyhwYXJhbSkpIHtcbiAgICAgICAgICBpZiAobmV3VVJMLmluY2x1ZGVzKCc/JykpXG4gICAgICAgICAgICBuZXdVUkwgKz0gJyYnO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5ld1VSTCArPSAnPydcbiAgICAgICAgICBuZXdVUkwgKz0gc1VSTFZhcmlhYmxlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3VVJMO1xufVxuXG4vKipcbiAqIHNlYXJjaCBtYWNoaW5lIGlkIHBhcmFtZXRlciBpbiBhbiB1cmwgYW5kIHJldHVybiBpdHMgdmFsdWVzLlxuICogVGhpcyBmdW5jdGlvbiBsb29rIGZvciBhbGwgcG9zc2libGUgaWRlbnRpZmllciBvZiBtYWNoaW5lIGlkIHBhcmFtZXRlciBpbiB1cmwuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqXG4gKiBAZnVuY3Rpb24gZ2V0TWFjaGluZUlkUGFyYW1ldGVyVmFsdWVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFnZVVSTCB1cmwgYWRkcmVzc1xuICogQHJldHVybiBhbiBhcnJheSB3aXRoIHZhbHVlcyBvZiBtYWNoaW5lIGlkIHBhcmFtZXRlciB2YWx1ZXMuIGlmIGdpdmVuIHVybCBkbyBub3QgY29udGFpbiB0aGlzIHBhcmFtZXRlciBuYW1lLCBpdCByZXR1cm5zIGFuIGVtcHR5IGFycmF5IFxuICovXG5leHBvcnRzLmdldE1hY2hpbmVJZFBhcmFtZXRlclZhbHVlID0gZnVuY3Rpb24gKHBhZ2VVUkwpIHtcbiAgbGV0IGlkZW50aWZpZXJzID0gWydtYWNoaW5lJywgJ21hY2hpbmUtaWRzJ107XG4gIGxldCB2YWx1ZXMgPSBuZXcgQXJyYXkoKTtcbiAgZm9yIChsZXQgaWQgPSAwOyBpZCA8IGlkZW50aWZpZXJzLmxlbmd0aDsgaWQrKykge1xuICAgIHZhbHVlcyA9IGdldFVSTFBhcmFtZXRlclZhbHVlcyhwYWdlVVJMLCBpZGVudGlmaWVyc1tpZF0pO1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLyoqXG4gKiBzZWFyY2ggbWFjaGluZSBpZCBwYXJhbWV0ZXIgaW4gYW4gdXJsIGFuZCByZXR1cm4gaXRzIHZhbHVlcy5cbiAqIFRoaXMgZnVuY3Rpb24gbG9vayBmb3IgYWxsIHBvc3NpYmxlIGlkZW50aWZpZXIgb2YgbWFjaGluZSBpZCBwYXJhbWV0ZXIgaW4gdXJsLlxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKlxuICogQGZ1bmN0aW9uIGdldEFMTE1hY2hpbmVJZFBhcmFtZXRlclZhbHVlIC0gVE9ETyA6IFJFTU9WRVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYWdlVVJMIHVybCBhZGRyZXNzXG4gKiBAcmV0dXJuIGFuIGFycmF5IHdpdGggdmFsdWVzIG9mIG1hY2hpbmUgaWQgcGFyYW1ldGVyIHZhbHVlcy4gaWYgZ2l2ZW4gdXJsIGRvIG5vdCBjb250YWluIHRoaXMgcGFyYW1ldGVyIG5hbWUsIGl0IHJldHVybnMgYW4gZW1wdHkgYXJyYXkgXG4gKi9cbmV4cG9ydHMuZ2V0QUxMTWFjaGluZUlkUGFyYW1ldGVyVmFsdWUgPSBmdW5jdGlvbiAocGFnZVVSTCkge1xuICBsZXQgaWRlbnRpZmllcnMgPSBbJ21hY2hpbmUnLCAnbWFjaGluZS1pZHMnLCAnc2VsZWN0ZWQtbWFjaGluZS1pZCcsICdtYWNoaW5ldG9wJ107XG4gIGxldCB2YWx1ZXMgPSBuZXcgQXJyYXkoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgIGxldCB0bXB2YWx1ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICB0bXB2YWx1ZXMgPSBnZXRVUkxQYXJhbWV0ZXJWYWx1ZXMocGFnZVVSTCwgaWRlbnRpZmllcnNbaV0pO1xuICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodG1wdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuXG4vKipcbiAqIHNlYXJjaCBBTEwgcGFyYW1ldGVycyBleGNsdWRpbmcgbWFjaGluZSBpZCBwYXJhbWV0ZXIgaW4gYW4gdXJsIGFuZCByZXR1cm4gYSBzdHJpbmcuXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqXG4gKiBAZnVuY3Rpb24gZ2V0UGFyYW1ldGVyc0V4Y2VwdGluZ01hY2hpbmVJZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYWdlVVJMIHVybCBhZGRyZXNzXG4gKiBAcmV0dXJuIGFuIGFycmF5IHdpdGggdmFsdWVzIG9mIG1hY2hpbmUgaWQgcGFyYW1ldGVyIHZhbHVlcy4gaWYgZ2l2ZW4gdXJsIGRvIG5vdCBjb250YWluIHRoaXMgcGFyYW1ldGVyIG5hbWUsIGl0IHJldHVybnMgYW4gZW1wdHkgYXJyYXkgXG4gKi9cbmV4cG9ydHMuZ2V0UGFyYW1ldGVyc0V4Y2VwdGluZ01hY2hpbmVJZCA9IGZ1bmN0aW9uIChwYWdlVVJMKSB7XG4gIGxldCByZXRTdHJpbmcgPSAnJztcbiAgbGV0IHNwbGl0dGVkU3RyaW5nID0gcGFnZVVSTC5zcGxpdCgnPycpO1xuICBpZiAoc3BsaXR0ZWRTdHJpbmcubGVuZ3RoID09IDApIHtcbiAgICBjb25zb2xlLmxvZygncHVsc2VVdGlsaXR5LmdldFBhcmFtZXRlcnNFeGNlcHRpbmdNYWNoaW5lSWQgOiBubyBVUkwgZm91bmQgIScpO1xuICB9XG4gIGlmIChzcGxpdHRlZFN0cmluZy5sZW5ndGggPiAxKSB7XG4gICAgbGV0IHNRdWVyeSA9IHNwbGl0dGVkU3RyaW5nWzFdO1xuICAgIGlmIChzUXVlcnkpIHtcbiAgICAgIGxldCBzVVJMVmFyaWFibGVzID0gc1F1ZXJ5LnNwbGl0KCcmJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNVUkxWYXJpYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNQYXJhbWV0ZXJOYW1lID0gc1VSTFZhcmlhYmxlc1tpXS5zcGxpdCgnPScpO1xuICAgICAgICBpZiAoKHNQYXJhbWV0ZXJOYW1lWzBdICE9ICdtYWNoaW5lJykgJiZcbiAgICAgICAgICAoc1BhcmFtZXRlck5hbWVbMF0gIT0gJ21hY2hpbmUtaWRzJykgJiZcbiAgICAgICAgICAoc1BhcmFtZXRlck5hbWVbMF0gIT0gJ3NlbGVjdGVkLW1hY2hpbmUtaWQnKSAmJlxuICAgICAgICAgIChzUGFyYW1ldGVyTmFtZVswXSAhPSAnbWFjaGluZXRvcCcpKSB7XG4gICAgICAgICAgcmV0U3RyaW5nICs9ICcmJyArIHNQYXJhbWV0ZXJOYW1lWzBdICsgJz0nICsgc1BhcmFtZXRlck5hbWVbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldFN0cmluZztcbn1cblxuLyoqXG4gKiBjaGVjayBpZiBhIHZhbHVlIGlzIG5vdCBkZWZpbmVkIG1lYW5zIHRoYXQgaXQgaXMgbnVsbCBvciB1bmRlZmluZWRcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlVXRpbGl0eVxuICpcbiAqIEBmdW5jdGlvbiBpc05vdERlZmluZWRcbiAqXG4gKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc05vdERlZmluZWQgPSBleHBvcnRzLmlzTm90RGVmaW5lZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAoKHZhbHVlID09PSBudWxsKSB8fCAodmFsdWUgPT0gJ251bGwnKSB8fFxuICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB8fCAodHlwZW9mIHZhbHVlID09ICd1bmRlZmluZWQnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqR2V0IGEgZHVyYXRpb24gaW4gc2Vjb25kcyBhbmQgcmV0dXJucyBhIHRleHQgdGhhdCByZXByZXNlbnRzXG4gKnRoaXMgZHVyYXRpb24gaW4gZGF5cywgaG91cnMsIG1pbnV0ZXMgYW5kIHNlY29uZHNcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlVXRpbGl0eVxuICpcbiAqIEBmdW5jdGlvbiBnZXRUZXh0RHVyYXRpb25cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb24gaW4gc2Vjb25kc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnRzLmdldFRleHREdXJhdGlvbiA9IGZ1bmN0aW9uIChkdXJhdGlvbikge1xuICBsZXQgc2Vjb25kcyA9IHBhcnNlSW50KGR1cmF0aW9uLCAxMCk7XG5cbiAgbGV0IGRheXMgPSBNYXRoLmZsb29yKHNlY29uZHMgLyAoMjQgKiA2MCAqIDYwKSk7XG4gIGxldCBob3VycyA9IE1hdGguZmxvb3IoKHNlY29uZHMgLSAoZGF5cyAqIDI0ICogNjAgKiA2MCkpIC8gKDYwICogNjApKTtcbiAgbGV0IG1pbnMgPSBNYXRoLmZsb29yKChzZWNvbmRzIC0gKGRheXMgKiAyNCAqIDYwICogNjApIC0gKGhvdXJzICogNjAgKiA2MCkpIC8gNjApO1xuICBsZXQgc2VjcyA9IHNlY29uZHMgLSAoZGF5cyAqIDI0ICogNjAgKiA2MCkgLSAoaG91cnMgKiA2MCAqIDYwKSAtIChtaW5zICogNjApO1xuXG4gIGxldCB0ZXh0ID0gJyc7XG5cbiAgaWYgKGRheXMgPiAwKSB7XG4gICAgdGV4dCArPSBkYXlzICsgJyBkICAnO1xuICB9XG5cbiAgaWYgKGhvdXJzID4gMCkge1xuICAgIHRleHQgKz0gaG91cnMgKyAnIGggJztcbiAgfVxuXG4gIGlmIChtaW5zID4gMCkge1xuICAgIHRleHQgKz0gbWlucyArICcgbWluICc7XG4gIH1cblxuICBpZiAoKGRheXMgPT0gMCkgJiYgKGhvdXJzID09IDApICYmIChtaW5zIDw9IDUpKSB7XG4gICAgaWYgKHNlY3MgPiAwKSB7XG4gICAgICB0ZXh0ICs9IHNlY3MgKyAnIHNlYyAnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dDtcbn1cblxuLyoqXG4gKiBHZXQgYSBkdXJhdGlvbiBpbiBzZWNvbmRzIGFuZCByZXR1cm5zIGEgdGV4dCB0aGF0IHJlcHJlc2VudHNcbiAqdGhpcyBkdXJhdGlvbiBpbiBob3VycywgbWludXRlc1xuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKlxuICogQGZ1bmN0aW9uIGdldEhvdXJzTWludXRlc0R1cmF0aW9uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uIGluIHNlY29uZHNcbiAqIEByZXR1cm4ge3N0cmluZ30gMDowMCBmb3JtYXR0ZWQgdGV4dFxuICovXG5leHBvcnRzLmdldEhvdXJzTWludXRlc0R1cmF0aW9uID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gIGxldCBzZWNvbmRzID0gcGFyc2VJbnQoZHVyYXRpb24sIDEwKTtcblxuICBsZXQgaG91cnMgPSBNYXRoLmZsb29yKHNlY29uZHMgLyAoNjAgKiA2MCkpO1xuICBsZXQgbWlucyA9IE1hdGguZmxvb3IoKHNlY29uZHMgLSAoaG91cnMgKiA2MCAqIDYwKSkgLyA2MCk7XG4gIC8vbGV0IHNlY3MgPSBzZWNvbmRzIC0gKGRheXMgKjI0ICogNjAgKiA2MCkgLSAoaG91cnMgKiA2MCAqIDYwKSAtIChtaW5zICogNjApO1xuXG4gIGxldCB0ZXh0ID0gaG91cnMgKyAnOicgKyAobWlucyA+IDkgPyAnJyArIG1pbnMgOiAnMCcgKyBtaW5zKTtcbiAgcmV0dXJuIHRleHQ7XG59XG5cbi8qKlxuICogR2V0IGEgZHVyYXRpb24gaW4gc2Vjb25kcyBhbmQgcmV0dXJucyByZW1haW5pbmcgc2Vjb25kcyBhZnRlclxuICogdGV4dCBkaXNwbGF5ZWQgd2l0aCBnZXRIb3Vyc01pbnV0ZXNEdXJhdGlvblxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKlxuICogQGZ1bmN0aW9uIGdldFJlbWFpbmluZ1NlY29uZHNEdXJhdGlvblxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBpbiBzZWNvbmRzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydHMuZ2V0UmVtYWluaW5nU2Vjb25kc0R1cmF0aW9uID0gZnVuY3Rpb24gKGR1cmF0aW9uKSB7XG4gIGxldCBzZWNvbmRzID0gcGFyc2VJbnQoZHVyYXRpb24sIDEwKTtcblxuICAvL2xldCBob3VycyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvICg2MCAqIDYwKSk7XG4gIGxldCBtaW5zID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjApO1xuICBsZXQgc2VjcyA9IHNlY29uZHMgLSAobWlucyAqIDYwKTtcblxuICByZXR1cm4gc2Vjcztcbn1cblxuXG4vKipcbiAqIENvbnZlcnQgZGF0ZXRpbWUgaW4gaXNvIHN0cmluZyBmb3JtYXQgdG8gYSBtb21lbnQgb2JqZWN0XG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqXG4gKiBAZnVuY3Rpb24gY29udmVydERhdGVUb01vbWVudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfERhdGV9IGRhdGUgRGF0ZSBvciBzdHJpbmcgdGhhdCByZXByZXNlbmRzIGEgZGF0ZS90aW1lXG4gKiBAcmV0dXJuIHtNb21lbnR9IGEgbW9tZW50IG9iamVjdCBpZiBwYXJhbWV0ZXIgaGFzIHJpZ2h0IGZvcm1hdCBvdGhlcndpc2UgbnVsbFxuICovXG52YXIgY29udmVydERhdGVUb01vbWVudCA9IGV4cG9ydHMuY29udmVydERhdGVUb01vbWVudCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gIGxldCBkO1xuICBpZiAodHlwZW9mIGxvd2VyID09ICdzdHJpbmcnKSB7XG4gICAgZCA9IG5ldyBEYXRlKGRhdGUpO1xuICB9XG4gIGVsc2Uge1xuICAgIGQgPSBkYXRlO1xuICB9XG4gIGxldCBtID0gbW9tZW50KGQpO1xuICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIG07XG4gIH1cbn1cblxuXG4vKipcbiAqIENvbnZlcnQgbW9tZW50IG9iamVjdCB0byBkYXRldGltZSBpbiBpc28gc3RyaW5nIGZvcm1hdCAnWVlZWS1NTS1ERFRISDptbTpzc1onXG4gKiBcbiAqXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlVXRpbGl0eVxuICpcbiAqIEBmdW5jdGlvbiBjb252ZXJ0TW9tZW50VG9EYXRlVGltZVN0cmluZ1xuICpcbiAqIEBwYXJhbSB7TW9tZW50fSBtIGRhdGVUaW1lU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGRhdGV0aW1lIHdpdGggZm9sbG93aW5nIGZvcm1hdDogJ1lZWVktTU0tRERUSEg6bW06c3NaJyAvICdZWVlZLU1NLUREVEhIOm1tOnNzLlNTU1onXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBhIHN0cmluZyBvYmplY3QgXG4gKi9cbmV4cG9ydHMuY29udmVydE1vbWVudFRvRGF0ZVRpbWVTdHJpbmcgPSBmdW5jdGlvbiBjb252ZXJ0TW9tZW50VG9EYXRlVGltZVN0cmluZyAobSkge1xuICBpZiAobS5pc1ZhbGlkKCkpIHtcbiAgICByZXR1cm4gbS50b0lTT1N0cmluZygpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG4vKiogRGVmYXVsdCBkYXRlIGZvcm1hdCAqL1xuZXhwb3J0cy5kZWZhdWx0RGF0ZUZvcm1hdCA9ICdMJztcbi8qKiBEZWZhdWx0IHRpbWUgZm9ybWF0Ki9cbmV4cG9ydHMuZGVmYXVsdFRpbWVGb3JtYXQgPSAnTFQnO1xuLyoqIERlZmF1bHQgdGltZSBmb3JtYXQgd2l0aCBzZWNvbmQqL1xuZXhwb3J0cy5kZWZhdWx0VGltZUZvcm1hdFdpdGhTZWNvbmQgPSAnTFRTJztcblxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gZ2V0IGRlZmF1bHQgbG9jYXRlIGZyb20gbmF2aWdhdG9yXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gZ2V0RGVmYXVsdExvY2FsZVxuICogXG4gKiBAcmV0dXJuIERlZmF1bHQgbG9jYWxlXG4gKi9cbmV4cG9ydHMuZ2V0RGVmYXVsdExvY2FsZSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGxvY2FsZSA9IHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2VzIHx8IFt3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlIHx8IHdpbmRvdy5uYXZpZ2F0b3IudXNlckxhbmd1YWdlXTtcbiAgcmV0dXJuIGxvY2FsZVswXTtcbn1cblxuLyoqXG4gKiByZXR1cm4gdHJ1ZSBpZiB0aW1lIGZvcm1hdCBmb3IgZGVmYXVsdCBsb2NhbGUgdXNlIG1lcmlkaWFuKEFNL1BNKVxuICogIG90aGVyd2lzZSBmYWxzZVxuICogXG4gKiBAbWVtYmVyb2YgbW9kdWxlOnB1bHNlVXRpbGl0eVxuICogQGZ1bmN0aW9uIGlzMjRIb3Vyc0Zvcm1hdFxuICpcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgaW4gMjQgaG91cnMgZm9ybWF0XG4gKi9cbmV4cG9ydHMuaXMyNEhvdXJzRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICBsZXQgbG9uZ0RhdGVGb3JtYXQgPSBtb21lbnQubG9jYWxlRGF0YSgpLmxvbmdEYXRlRm9ybWF0KCdMVFMnKS50b1VwcGVyQ2FzZSgpO1xuICBpZiAoKGxvbmdEYXRlRm9ybWF0LmluZGV4T2YoJ0EnKSA+PSAwKSB8fCAobG9uZ0RhdGVGb3JtYXQuaW5kZXhPZignUCcpID49IDApKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5cbi8qKlxuICogRnVuY3Rpb24gdXNlZCB0byByZXR1cm4galF1ZXJ5IGVsZW1lbnQgd2l0aCBnaXZlbiB0YWcgbmFtZSBhbmQgYXR0cmlidXRlXG4gKlxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqIEBmdW5jdGlvbiBjcmVhdGVqUXVlcnlFbGVtZW50V2l0aEF0dHJpYnV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIHRhZyBuYW1lXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFuIG9iamVjdCBpbiBrZXktdmFsdWUgZm9ybSB3aGljaCByZXByZXNlbnRzIGF0dHJpYnV0ZSBvZiBlbGVtZW50IHRvIGNyZWF0ZVxuICpcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IGEgalF1ZXJ5IGVsZW1lbnQgXG4gKi9cbnZhciBjcmVhdGVqUXVlcnlFbGVtZW50V2l0aEF0dHJpYnV0ZSA9IGV4cG9ydHMuY3JlYXRlalF1ZXJ5RWxlbWVudFdpdGhBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodGFnTmFtZSwgYXR0cmlidXRlcykge1xuICBsZXQgZWx0ID0gbnVsbDtcblxuICBpZiAod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoJ0Nocm9tZScpKSB7XG4gICAgbGV0IHN0ciA9ICc8JyArIHRhZ05hbWUgKyAnICc7XG4gICAgZm9yIChsZXQga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGxldCB2YWx1ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBzdHIgPSBzdHIgKyBrZXkgKyBcIj0nXCIgKyB2YWx1ZSArIFwiJyBcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RyID0gc3RyICsgJz48LycgKyB0YWdOYW1lICsgJz4nO1xuICAgIGVsdCA9ICQoc3RyKTtcbiAgfVxuICBlbHNlIHtcbiAgICBsZXQgZG9tRWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICBmb3IgKGxldCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgbGV0IHZhbHVlID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRvbUVsdC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsdCA9ICQoZG9tRWx0KTtcbiAgfVxuXG4gIC8qZWxzZSBcbiAgICBsZXQgc3RyID0gJzwnICsgdGFnTmFtZSArICcgJztcbiAgICBmb3IgKGxldCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgbGV0IHZhbHVlID0gYXR0cmlidXRlc1trZXldO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHN0ciA9IHN0ciArIGtleSArIFwiPSdcIiArIHZhbHVlICsgXCInIFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBzdHIgPSBzdHIgKyAnPjwvJyArIHRhZ05hbWUgKyAnPic7XG4gICAgZWx0ID0gJChzdHIpO1xuICAqL1xuXG4gIC8qaWYoICEoZWx0LmdldCgwKSBpbnN0YW5jZW9mIFB1bHNlQ29tcG9uZW50KSApe1xuICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRlZCBlbGVtZW50IGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBQdWxzZUNvbXBvbmVudFwiKTtcbiAgfSovXG5cbiAgcmV0dXJuIGVsdDtcblxuICAvKlxuICBsZXQgZG9tRWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgZm9yIChsZXQga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgdmFsdWUgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgaWYodmFsdWUpe1xuICAgICAgZG9tRWx0LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICQoZG9tRWx0KTsqL1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHhUYWdOYW1lIGV4aXN0cyBpbiBib2R5LiBJZiBub3QsIGNyZWF0ZSBpdCAtIHVzZWZ1bCB0byBjYWxsIGFkZE1vZGlmaWNhdGlvblxuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gZ2V0T3JDcmVhdGVTaW5nbGV0b25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30geFRhZ05hbWVcbiAqIEBwYXJhbSB7anNvbn0gYXR0cmlidXRlcyAoY2FuIGJlIHVuZGVmaW5lZClcbiAqIEByZXR1cm4ge3hUYWd9IHRydWUgc2VhcmNoZWQgZWxlbWVudFxuICovXG5leHBvcnRzLmdldE9yQ3JlYXRlU2luZ2xldG9uID0gZnVuY3Rpb24gKHhUYWdOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gIGxldCBhdHRyID0gKG51bGwgPT0gYXR0cmlidXRlcykgPyB7fSA6IGF0dHJpYnV0ZXM7XG4gIGxldCB0YWcgPSAkKCdib2R5JykuZmluZCh4VGFnTmFtZSk7XG4gIGlmICh0YWcubGVuZ3RoID09IDApIHtcbiAgICB0YWcgPSBjcmVhdGVqUXVlcnlFbGVtZW50V2l0aEF0dHJpYnV0ZSh4VGFnTmFtZSwgYXR0cik7XG4gICAgJCgnYm9keScpLmFwcGVuZCh0YWcpO1xuICB9XG4gIGlmICh0YWcubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB0YWdbMF07XG4gIH1cbiAgcmV0dXJuIG51bGw7IC8vIEhvcGUgbmV2ZXIgIVxufVxuXG4vKipcbiAqIENoZWNrIGlmIERPTSBlbGVtZW50IGhhcyBjbGFzc1xuICpcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gaGFzQ2xhc3NcbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgZ2l2ZW4gZWxlbWVudCBoYXMgY2xhc3MgbmFtZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydHMuaGFzQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIHJldHVybiBlbGVtZW50LmNsYXNzTmFtZSAmJiBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgY2xhc3NOYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoZWxlbWVudC5jbGFzc05hbWUpO1xufVxuXG4vKiogQ3JlYXRlIGEgY29va2llXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gY3JlYXRlQ29va2llXG4gKlxuICovXG52YXIgY3JlYXRlQ29va2llID0gZXhwb3J0cy5jcmVhdGVDb29raWUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGRheXMpIHtcbiAgbGV0IGV4cGlyZXM7XG4gIGlmIChkYXlzICYmIGRheXMgPiAwKSB7XG4gICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvR01UU3RyaW5nKCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgZXhwaXJlcyA9ICcnOyAvLyA9PSBFeHBpcmUgPSBlbmQgb2Ygc2Vzc2lvblxuICB9XG4gIGRvY3VtZW50LmNvb2tpZSA9IG5hbWUgKyAnPScgKyB2YWx1ZSArIGV4cGlyZXMgKyAnOyBwYXRoPS8nO1xuICAvLyAnO3BhdGg9LycgPT0gZ2xvYmFsIHBhdGggdG8gc2hhcmUgd2l0aCByZXBvcnRpbmdcbn1cblxuLyoqIFJlYWQgYSBjb29raWVcbiAqIFxuICogQG1lbWJlcm9mIG1vZHVsZTpwdWxzZVV0aWxpdHlcbiAqIEBmdW5jdGlvbiByZWFkQ29va2llXG4gKi9cbnZhciByZWFkQ29va2llID1cbiAgZXhwb3J0cy5yZWFkQ29va2llID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBsZXQgbmFtZUVRID0gbmFtZSArICc9JztcbiAgICBsZXQgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYyA9IGNhW2ldO1xuICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09ICcgJykgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbiAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PSAwKSByZXR1cm4gYy5zdWJzdHJpbmcobmFtZUVRLmxlbmd0aCwgYy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG52YXIgZXJhc2VDb29raWUgPVxuICBleHBvcnRzLmVyYXNlQ29va2llID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyBlcmFzZSBjb29raWUgaXMgZG9uZSBpbiB4LWNoZWNrY3VycmVudHRpbWUuanNcbiAgICBjcmVhdGVDb29raWUobmFtZSwgJycsIC0xKTtcbiAgfVxuXG4vKiogY2hhbmdlIHBhZ2UgaW4gdXJsXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gY2hhbmdlUGFnZU5hbWVcbiAqL1xuZXhwb3J0cy5jaGFuZ2VQYWdlTmFtZSA9IGZ1bmN0aW9uIChocmVmLCBuZXdQYWdlTmFtZSkge1xuICAvL2xldCBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7IC8vIFwiLi4uL3BhZ2VuYW1lLmh0bWw/eHh4XCJcbiAgbGV0IHNwbGl0VXJsID0gaHJlZi5zcGxpdCgnPycpO1xuICBpZiAoc3BsaXRVcmwubGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiBocmVmOyAvLyBObyBjaGFuZ2VcbiAgfVxuICBsZXQgcG9zUHQgPSBzcGxpdFVybFswXS5sYXN0SW5kZXhPZignLicpO1xuICBsZXQgcG9zU2xhc2ggPSBzcGxpdFVybFswXS5sYXN0SW5kZXhPZignLycpO1xuICBpZiAoKHBvc1B0ICE9IC0xKSAmJiAocG9zU2xhc2ggIT0gLTEpKSB7IC8vIEZvdW5kIGJvdGhcbiAgICBsZXQgY3J0UGFnZSA9IChzcGxpdFVybFswXS5zbGljZShwb3NTbGFzaCArIDEsIHBvc1B0KSk7XG4gICAgc3BsaXRVcmxbMF0gPSBzcGxpdFVybFswXS5yZXBsYWNlKGNydFBhZ2UsIG5ld1BhZ2VOYW1lKTtcblxuICAgIHJldHVybiBzcGxpdFVybC5qb2luKCc/Jyk7XG4gIH1cbiAgcmV0dXJuIGhyZWY7XG59XG5cbi8qKiBnZXQgY3VycmVudCBwYWdlXG4gKiBcbiAqIEBtZW1iZXJvZiBtb2R1bGU6cHVsc2VVdGlsaXR5XG4gKiBAZnVuY3Rpb24gZ2V0Q3VycmVudFBhZ2VOYW1lXG4gKi9cbmV4cG9ydHMuZ2V0Q3VycmVudFBhZ2VOYW1lID0gZnVuY3Rpb24gKCkge1xuICBsZXQgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmOyAvLyBcIi4uLi9wYWdlbmFtZS5odG1sP3h4eFwiXG4gIGxldCBzcGxpdFVybCA9IGhyZWYuc3BsaXQoJz8nKTtcbiAgaWYgKHNwbGl0VXJsLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgbGV0IHBvc1B0ID0gc3BsaXRVcmxbMF0ubGFzdEluZGV4T2YoJy4nKTtcbiAgbGV0IHBvc1NsYXNoID0gc3BsaXRVcmxbMF0ubGFzdEluZGV4T2YoJy8nKTtcbiAgaWYgKChwb3NQdCAhPSAtMSkgJiYgKHBvc1NsYXNoICE9IC0xKSkgeyAvLyBGb3VuZCBib3RoXG4gICAgcmV0dXJuIChzcGxpdFVybFswXS5zbGljZShwb3NTbGFzaCArIDEsIHBvc1B0KSk7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNvbnZlbmllbnQgb2JqZWN0IHRoYXQgY2FuIHN0b3JlIGFuZCByZXRyaWV2ZSBkYXRhIGF0dGFjaGVkIHRvIGRpdmlzaW9ucyBoYXZpbmcgc3BlY2lmaWMgaWRzXG4gKiBVc2VkIChhdCBsZWFzdCkgYnkgY3VzdG9tZGlhbG9nIGFuZCBtYWNoaW5lIHNlbGVjdGlvblxuICovXG5leHBvcnRzLmNyZWF0ZURhdGFNYW5hZ2VyID0gZnVuY3Rpb24gKGlkTmFtZSkge1xuICByZXR1cm4ge1xuICAgIF9pZE5hbWU6IGlkTmFtZSxcbiAgICBfaWQ6IDAsXG4gICAgX2RhdGE6IFtdLFxuICAgIGNyZWF0ZU5ld0lkOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9kYXRhW3RoaXMuX2lkXSA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuX2lkKys7XG4gICAgfSxcbiAgICBpbml0aWFsaXplSWRBdHRyaWJ1dGU6IGZ1bmN0aW9uIChzZWxlY3RvciwgaWQpIHtcbiAgICAgICQoc2VsZWN0b3IpLmF0dHIodGhpcy5faWROYW1lLCBpZCk7XG4gICAgfSxcbiAgICBnZXRJZDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoJChzZWxlY3RvcikubGVuZ3RoKSB7XG4gICAgICAgIGxldCBhdHRyaWJ1dGUgPSAkKHNlbGVjdG9yKS5hdHRyKHRoaXMuX2lkTmFtZSk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUgPT0gdW5kZWZpbmVkIHx8IGF0dHJpYnV0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyBTZWFyY2ggaW4gcGFyZW50c1xuICAgICAgICAgIGxldCBwYXJlbnQgPSAkKHNlbGVjdG9yKVswXS5jbG9zZXN0KCdbJyArIHRoaXMuX2lkTmFtZSArICddJyk7XG4gICAgICAgICAgaWYgKCQocGFyZW50KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgPSAkKHBhcmVudCkuYXR0cih0aGlzLl9pZE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXR0cmlidXRlID09IHVuZGVmaW5lZCB8fCBhdHRyaWJ1dGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlNlbGVjdG9yICdcIiArIHNlbGVjdG9yICsgXCInIGhhcyBubyBhdHRyaWJ1dGUgJ1wiICsgdGhpcy5faWROYW1lICsgXCInXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpZCA9IHBhcnNlSW50KGF0dHJpYnV0ZSk7XG4gICAgICAgIGlmIChpZCA8IDAgfHwgaWQgPj0gdGhpcy5faWQpIHtcbiAgICAgICAgICB0aHJvdyAnQmFkICcgKyB0aGlzLl9pZE5hbWUgKyBcIiAnXCIgKyBpZCArIFwiJyBmb3Igc2VsZWN0b3IgJ1wiICsgc2VsZWN0b3IgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJTZWxlY3RvciAnXCIgKyBzZWxlY3RvciArIFwiJ2RvZXNuJ3QgZXhpc3RcIjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGF0YVtpZF07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIChpZCwgZmllbGQsIGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGFbaWRdW2ZpZWxkXSA9IGRhdGE7XG4gICAgfSxcbiAgICByZXNldDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICB0aGlzLl9kYXRhW2lkXSA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnRzLmFkZFRvb2xUaXAgPSBmdW5jdGlvbiAoZWxlbWVudCwgdGV4dCkge1xuICAvLyBTZXQgdGhlIHRvb2x0aXAgdGV4dFxuICAvLyBSZXBsYWNlICQoZWxlbWVudCkuYXR0cigndGl0bGUnLCB0ZXh0KTsgRVZFTiBpbiBhIHBhcnQgb2Ygc3ZnXG5cbiAgJChlbGVtZW50KS5hdHRyKCd0b29sdGlwJywgdGV4dCk7XG5cbiAgLy8gVHJpZ2dlciB0aGUgZGlzcGxheVxuICAkKGVsZW1lbnQpLmhvdmVyKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBIb3ZlciBvdmVyIGNvZGVcbiAgICBsZXQgdG9vbHRpcCA9ICQodGhpcykuYXR0cigndG9vbHRpcCcpO1xuICAgIGlmICh0b29sdGlwICE9IG51bGwgJiYgdG9vbHRpcC5sZW5ndGggPiAwKSB7XG4gICAgICAkKHRoaXMpLnJlbW92ZUF0dHIoJ3RpdGxlJyk7IC8vIEluIGNhc2UgaXQgaXMgZGVmaW5lZCBieSBlcnJvciB0byBhdm9pZCAyIHRvb2x0aXBzXG4gICAgICBpZiAoJCgnLm1hc3RlcnRvb2x0aXAnKS5sZW5ndGggPT0gMCAmJiAhJCh0aGlzKS5oYXNDbGFzcygndG9vbHRpcF9kaXNhYmxlZCcpKSB7XG4gICAgICAgICQoJzxwIGNsYXNzPVwibWFzdGVydG9vbHRpcFwiPjwvcD4nKVxuICAgICAgICAgIC50ZXh0KHRvb2x0aXApXG4gICAgICAgICAgLmFwcGVuZFRvKCdib2R5JylcbiAgICAgICAgICAuZmFkZUluKDQwMCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gSG92ZXIgb3V0IGNvZGVcbiAgICAkKCcubWFzdGVydG9vbHRpcCcpLnJlbW92ZSgpO1xuICB9KS5tb3VzZW1vdmUoZnVuY3Rpb24gKGUpIHtcbiAgICAvLyBYXG4gICAgaWYgKGUucGFnZVggPD0gJCh3aW5kb3cpLndpZHRoKCkgLyAyKSB7XG4gICAgICBsZXQgbW91c2V4ID0gZS5wYWdlWCArIDIwOyAvLyBHZXQgWCBjb29yZGluYXRlc1xuICAgICAgJCgnLm1hc3RlcnRvb2x0aXAnKS5jc3MoeyBsZWZ0OiBtb3VzZXggfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgbGV0IG1vdXNleCA9IGUucGFnZVggLSAyMFxuICAgICAgICAtICQoJy5tYXN0ZXJ0b29sdGlwJykud2lkdGgoKTsgLy8gR2V0IFggY29vcmRpbmF0ZXNcbiAgICAgICQoJy5tYXN0ZXJ0b29sdGlwJykuY3NzKHsgbGVmdDogbW91c2V4IH0pO1xuICAgIH1cblxuICAgIC8vIFlcbiAgICBpZiAoZS5wYWdlWSArICQoJy5tYXN0ZXJ0b29sdGlwJykuaGVpZ2h0KCkgKyAxMFxuICAgICAgPD0gJCh3aW5kb3cpLmhlaWdodCgpKSB7XG4gICAgICBsZXQgbW91c2V5ID0gZS5wYWdlWSArIDEwOyAvLyBHZXQgWSBjb29yZGluYXRlc1xuICAgICAgJCgnLm1hc3RlcnRvb2x0aXAnKS5jc3MoeyB0b3A6IG1vdXNleSB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBUbyBiZSB0ZXN0ZWQgISEhXG4gICAgICBsZXQgbW91c2V5ID0gZS5wYWdlWSAtIDEwIC0gJCgnLm1hc3RlcnRvb2x0aXAnKS5oZWlnaHQoKTsgLy8gR2V0IFkgY29vcmRpbmF0ZXNcbiAgICAgICQoJy5tYXN0ZXJ0b29sdGlwJykuY3NzKHsgdG9wOiBtb3VzZXkgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5yZW1vdmVUb29sVGlwID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgJChlbGVtZW50KS5yZW1vdmVBdHRyKCd0aXRsZScpO1xuICAkKCcubWFzdGVydG9vbHRpcCcpLnJlbW92ZSgpO1xufVxuXG5leHBvcnRzLmNsb25lV2l0aE5ld01hY2hpbmVJZCA9IGZ1bmN0aW9uIChib3h0b2Nsb25laWQsIG5ld01hY2hpbmVpZCkge1xuICAvLyBDb3B5XG4gIGxldCBjb3B5ID0gJCgnIycgKyBib3h0b2Nsb25laWQpLmNsb25lKHRydWUpO1xuICAvLyByZW1vdmUgYm94dG9jbG9uZWlkXG4gICQoY29weSkucmVtb3ZlQXR0cignaWQnKTtcbiAgLy8gUmVtb3ZlIGFsbCBjbGFzc2VzIGxpbmtlZCB0byBjbG9uZWQgY29tcG9uZW50IGlzIGRvbmUgaW4gY2xlYXJEeW5hbWljU3RhdGVDb250ZW50XG4gIC8vID09IChpbml0IHN0YXRlKVxuXG4gIC8vIFNldCBtYWNoaW5laWQgKGFmdGVyIGFsbCAncmVtb3ZlJyB0byBiZSByZWFkeSB0byBkaXNwbGF5KVxuICAkKGNvcHkpLmF0dHIoJ21hY2hpbmUtaWQnLCBuZXdNYWNoaW5laWQpO1xuICAkKGNvcHkpLmZpbmQoJyonKS5hdHRyKCdtYWNoaW5lLWlkJywgbmV3TWFjaGluZWlkKTtcblxuICByZXR1cm4gY29weTtcbn1cblxuZXhwb3J0cy5jbG9uZVdpdGhOZXdHcm91cElkID0gZnVuY3Rpb24gKGJveHRvY2xvbmVpZCwgbmV3R3JvdXBpZCwgaXNNYWNoaW5lKSB7XG4gIC8vIENvcHlcbiAgbGV0IGNvcHkgPSAkKCcjJyArIGJveHRvY2xvbmVpZCkuY2xvbmUodHJ1ZSk7XG4gIC8vIHJlbW92ZSBib3h0b2Nsb25laWRcbiAgJChjb3B5KS5yZW1vdmVBdHRyKCdpZCcpO1xuICAvLyBSZW1vdmUgYWxsIGNsYXNzZXMgbGlua2VkIHRvIGNsb25lZCBjb21wb25lbnQgaXMgZG9uZSBpbiBjbGVhckR5bmFtaWNTdGF0ZUNvbnRlbnRcbiAgLy8gPT0gKGluaXQgc3RhdGUpXG5cbiAgLy8gU2V0IGdyb3VwLWlkIChhZnRlciBhbGwgJ3JlbW92ZScgdG8gYmUgcmVhZHkgdG8gZGlzcGxheSlcbiAgJChjb3B5KS5hdHRyKCdncm91cCcsIG5ld0dyb3VwaWQpOyAvLyBub3QgZ3JvdXAtaWQgdG8gYmUgYWJsZSB0byB1c2UgZ2V0Q29uZmlnT3JBdHRyaWJ1dGVcbiAgJChjb3B5KS5maW5kKCcqJykuYXR0cignZ3JvdXAnLCBuZXdHcm91cGlkKTtcbiAgaWYgKGlzTWFjaGluZSA9PSB0cnVlKSB7XG4gICAgJChjb3B5KS5maW5kKCcqJykuYXR0cignbWFjaGluZS1pZCcsIG5ld0dyb3VwaWQpO1xuICB9XG4gIHJldHVybiBjb3B5O1xufVxuXG5leHBvcnRzLmdldFRleHRDaGFuZ2VDb250ZXh0ID0gZnVuY3Rpb24gKHNlbGYpIHtcbiAgbGV0IHRleHRjaGFuZ2Vjb250ZXh0ID0gJyc7XG4gIGlmIChzZWxmLmVsZW1lbnQuaGFzQXR0cmlidXRlKCd0ZXh0Y2hhbmdlLWNvbnRleHQnKSkge1xuICAgIHRleHRjaGFuZ2Vjb250ZXh0ID0gc2VsZi5lbGVtZW50LmdldEF0dHJpYnV0ZSgndGV4dGNoYW5nZS1jb250ZXh0Jyk7XG4gICAgaWYgKHRleHRjaGFuZ2Vjb250ZXh0LnNlYXJjaCgnbWFjaGluZS1pZCcpICE9IC0xKSB7XG4gICAgICB0ZXh0Y2hhbmdlY29udGV4dCArPSAnXycgKyBzZWxmLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtYWNoaW5lLWlkJyk7XG4gICAgfVxuICAgIGlmICh0ZXh0Y2hhbmdlY29udGV4dC5zZWFyY2goJ2dyb3VwJykgIT0gLTEpIHtcbiAgICAgIHRleHRjaGFuZ2Vjb250ZXh0ICs9ICdfJyArIHNlbGYuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2dyb3VwJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0Y2hhbmdlY29udGV4dDtcbn1cbiJdfQ==
